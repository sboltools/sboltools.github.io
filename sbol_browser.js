(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_shim();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      init_shim();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      init_shim();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer3;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
      }
      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          var proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer3.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer3.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        var buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function Buffer3(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError('The "string" argument must be of type string. Received type number');
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer3.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        }
        var valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer3.from(valueOf, encodingOrOffset, length);
        }
        var b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      Buffer3.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer3, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding2) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding2 === "string" ? createBuffer(size).fill(fill, encoding2) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer3.alloc = function(size, fill, encoding2) {
        return alloc(size, fill, encoding2);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer3.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer3.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding2) {
        if (typeof encoding2 !== "string" || encoding2 === "") {
          encoding2 = "utf8";
        }
        if (!Buffer3.isEncoding(encoding2)) {
          throw new TypeError("Unknown encoding: " + encoding2);
        }
        var length = byteLength(string, encoding2) | 0;
        var buf = createBuffer(length);
        var actual = buf.write(string, encoding2);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        var buf = createBuffer(length);
        for (var i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          var copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        var buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer3.isBuffer(obj)) {
          var len = checked(obj.length) | 0;
          var buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer3.alloc(+length);
      }
      Buffer3.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer3.prototype;
      };
      Buffer3.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer3.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer3.from(b, b.offset, b.byteLength);
        if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        }
        if (a === b)
          return 0;
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer3.isEncoding = function isEncoding(encoding2) {
        switch (String(encoding2).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer3.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer3.alloc(0);
        }
        var i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        var buffer = Buffer3.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              Buffer3.from(buf).copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(buffer, buf, pos);
            }
          } else if (!Buffer3.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding2) {
        if (Buffer3.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
        }
        var len = string.length;
        var mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding2) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding2 = ("" + encoding2).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.byteLength = byteLength;
      function slowToString(encoding2, start, end) {
        var loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding2)
          encoding2 = "utf8";
        while (true) {
          switch (encoding2) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding2);
              encoding2 = (encoding2 + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.prototype._isBuffer = true;
      function swap(b, n, m) {
        var i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer3.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer3.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer3.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer3.prototype.toString = function toString() {
        var length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
      Buffer3.prototype.equals = function equals(b) {
        if (!Buffer3.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer3.compare(this, b) === 0;
      };
      Buffer3.prototype.inspect = function inspect() {
        var str = "";
        var max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
      }
      Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer3.from(target, target.offset, target.byteLength);
        }
        if (!Buffer3.isBuffer(target)) {
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding2, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding2 = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer3.from(val, encoding2);
        }
        if (Buffer3.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding2, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding2, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding2, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (encoding2 !== void 0) {
          encoding2 = String(encoding2).toLowerCase();
          if (encoding2 === "ucs2" || encoding2 === "ucs-2" || encoding2 === "utf16le" || encoding2 === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        var i;
        if (dir) {
          var foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            var found = true;
            for (var j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer3.prototype.includes = function includes(val, byteOffset, encoding2) {
        return this.indexOf(val, byteOffset, encoding2) !== -1;
      };
      Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding2) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding2, true);
      };
      Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding2) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding2, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer3.prototype.write = function write(string, offset, length, encoding2) {
        if (offset === void 0) {
          encoding2 = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding2 = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding2 === void 0)
              encoding2 = "utf8";
          } else {
            encoding2 = length;
            length = void 0;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding2)
          encoding2 = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding2) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding2);
              encoding2 = ("" + encoding2).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer3.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;
        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = "";
        var i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        var out = "";
        for (var i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer3.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer3.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        var val = this[offset + --byteLength2];
        var mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var i = byteLength2;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer3.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer3.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
        }
        return len;
      };
      Buffer3.prototype.fill = function fill(val, start, end, encoding2) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding2 = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding2 = end;
            end = this.length;
          }
          if (encoding2 !== void 0 && typeof encoding2 !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding2 === "string" && !Buffer3.isEncoding(encoding2)) {
            throw new TypeError("Unknown encoding: " + encoding2);
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding2 === "utf8" && code < 128 || encoding2 === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding2);
          var len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        var c, hi, lo;
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        for (var i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        var alphabet = "0123456789abcdef";
        var table = new Array(256);
        for (var i = 0; i < 16; ++i) {
          var i16 = i * 16;
          for (var j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
    }
  });

  // node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/process/browser.js"(exports, module) {
      init_shim();
      var process2 = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process2.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process2.title = "browser";
      process2.browser = true;
      process2.env = {};
      process2.argv = [];
      process2.version = "";
      process2.versions = {};
      function noop() {
      }
      process2.on = noop;
      process2.addListener = noop;
      process2.once = noop;
      process2.off = noop;
      process2.removeListener = noop;
      process2.removeAllListeners = noop;
      process2.emit = noop;
      process2.prependListener = noop;
      process2.prependOnceListener = noop;
      process2.listeners = function(name) {
        return [];
      };
      process2.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process2.cwd = function() {
        return "/";
      };
      process2.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process2.umask = function() {
        return 0;
      };
    }
  });

  // node_modules/node-stdlib-browser/helpers/esbuild/shim.js
  var import_buffer, import_process, _globalThis, _global;
  var init_shim = __esm({
    "node_modules/node-stdlib-browser/helpers/esbuild/shim.js"() {
      import_buffer = __toESM(require_buffer());
      import_process = __toESM(require_browser());
      _globalThis = function(Object2) {
        function get() {
          var _global3 = this || self;
          delete Object2.prototype.__magic__;
          return _global3;
        }
        if (typeof globalThis === "object") {
          return globalThis;
        }
        if (this) {
          return get();
        } else {
          Object2.defineProperty(Object2.prototype, "__magic__", {
            configurable: true,
            get
          });
          var _global2 = __magic__;
          return _global2;
        }
      }(Object);
      _global = _globalThis;
    }
  });

  // node_modules/@rdfjs/environment/Environment.js
  var Environment, Environment_default;
  var init_Environment = __esm({
    "node_modules/@rdfjs/environment/Environment.js"() {
      init_shim();
      Environment = class {
        constructor(factories, { bind = false } = {}) {
          this._factories = factories.slice();
          for (const factory3 of this._factories) {
            if (typeof factory3.prototype.init === "function") {
              factory3.prototype.init.call(this);
            }
            for (const method of factory3.exports || []) {
              if (bind) {
                this[method] = factory3.prototype[method].bind(this);
              } else {
                this[method] = factory3.prototype[method];
              }
            }
          }
        }
        clone() {
          const env = new Environment(this._factories);
          for (const factory3 of env._factories) {
            if (typeof factory3.prototype.clone === "function") {
              factory3.prototype.clone.call(env, this);
            }
          }
          return env;
        }
      };
      Environment_default = Environment;
    }
  });

  // node_modules/@rdfjs/sink-map/index.js
  var require_sink_map = __commonJS({
    "node_modules/@rdfjs/sink-map/index.js"(exports, module) {
      init_shim();
      var SinkMap2 = class extends Map {
        import(key, input, options) {
          const parser = this.get(key);
          if (!parser) {
            return null;
          }
          return parser.import(input, options);
        }
      };
      module.exports = SinkMap2;
    }
  });

  // node_modules/@rdfjs/environment/lib/Formats.js
  var import_sink_map, Formats, Formats_default;
  var init_Formats = __esm({
    "node_modules/@rdfjs/environment/lib/Formats.js"() {
      init_shim();
      import_sink_map = __toESM(require_sink_map(), 1);
      Formats = class {
        constructor({ factory: factory3 }) {
          this.factory = factory3;
          this.parsers = new import_sink_map.default();
          this.serializers = new import_sink_map.default();
        }
        import(other) {
          if (other.parsers) {
            for (const [mediaType, parser] of other.parsers) {
              this.parsers.set(mediaType, new parser.constructor({ factory: this.factory }));
            }
          }
          if (other.serializers) {
            for (const [mediaType, serializer] of other.serializers) {
              this.serializers.set(mediaType, new serializer.constructor({ factory: this.factory }));
            }
          }
        }
      };
      Formats_default = Formats;
    }
  });

  // node_modules/@rdfjs/environment/FormatsFactory.js
  var FormatsFactory, FormatsFactory_default;
  var init_FormatsFactory = __esm({
    "node_modules/@rdfjs/environment/FormatsFactory.js"() {
      init_shim();
      init_Formats();
      FormatsFactory = class {
        init() {
          this.formats = new Formats_default({ factory: this });
        }
        clone(original) {
          this.formats.import(original.formats);
        }
      };
      FormatsFactory_default = FormatsFactory;
    }
  });

  // node_modules/nodeify-fetch/lib/getStream.js
  async function getStream(stream) {
    const chunks = [];
    stream.on("data", (chunk) => chunks.push(chunk));
    return new Promise((resolve, reject) => {
      stream.on("end", () => resolve(chunks));
      stream.on("error", (err) => reject(err));
    });
  }
  var getStream_default;
  var init_getStream = __esm({
    "node_modules/nodeify-fetch/lib/getStream.js"() {
      init_shim();
      getStream_default = getStream;
    }
  });

  // node_modules/nodeify-fetch/lib/patchRequest.js
  async function patch(options = {}) {
    if (!options.body || !options.body.readable) {
      return options;
    }
    const content = await getStream_default(options.body);
    if (content.length > 0) {
      if (import_buffer.Buffer.isBuffer(content[0])) {
        options.body = import_buffer.Buffer.concat(content);
      } else {
        options.body = content.join("");
      }
    } else {
      options.body = "";
    }
    return options;
  }
  var patchRequest_default;
  var init_patchRequest = __esm({
    "node_modules/nodeify-fetch/lib/patchRequest.js"() {
      init_shim();
      init_getStream();
      patchRequest_default = patch;
    }
  });

  // node_modules/process-nextick-args/index.js
  var require_process_nextick_args = __commonJS({
    "node_modules/process-nextick-args/index.js"(exports, module) {
      "use strict";
      init_shim();
      if (typeof import_process.default === "undefined" || !import_process.default.version || import_process.default.version.indexOf("v0.") === 0 || import_process.default.version.indexOf("v1.") === 0 && import_process.default.version.indexOf("v1.8.") !== 0) {
        module.exports = { nextTick };
      } else {
        module.exports = import_process.default;
      }
      function nextTick(fn, arg1, arg2, arg3) {
        if (typeof fn !== "function") {
          throw new TypeError('"callback" argument must be a function');
        }
        var len = arguments.length;
        var args, i;
        switch (len) {
          case 0:
          case 1:
            return import_process.default.nextTick(fn);
          case 2:
            return import_process.default.nextTick(function afterTickOne() {
              fn.call(null, arg1);
            });
          case 3:
            return import_process.default.nextTick(function afterTickTwo() {
              fn.call(null, arg1, arg2);
            });
          case 4:
            return import_process.default.nextTick(function afterTickThree() {
              fn.call(null, arg1, arg2, arg3);
            });
          default:
            args = new Array(len - 1);
            i = 0;
            while (i < args.length) {
              args[i++] = arguments[i];
            }
            return import_process.default.nextTick(function afterTick() {
              fn.apply(null, args);
            });
        }
      }
    }
  });

  // node_modules/isarray/index.js
  var require_isarray = __commonJS({
    "node_modules/isarray/index.js"(exports, module) {
      init_shim();
      var toString = {}.toString;
      module.exports = Array.isArray || function(arr) {
        return toString.call(arr) == "[object Array]";
      };
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module) {
      "use strict";
      init_shim();
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn)
          console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once2;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++)
          args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler2 = events[type];
        if (handler2 === void 0)
          return false;
        if (typeof handler2 === "function") {
          ReflectApply(handler2, this, args);
        } else {
          var len = handler2.length;
          var listeners = arrayClone(handler2, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once3(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once2(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler2, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler2, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/readable-stream/node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/readable-stream/node_modules/safe-buffer/index.js"(exports, module) {
      init_shim();
      var buffer = require_buffer();
      var Buffer3 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer3(arg, encodingOrOffset, length);
      }
      copyProps(Buffer3, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer3(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding2) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer3(size);
        if (fill !== void 0) {
          if (typeof encoding2 === "string") {
            buf.fill(fill, encoding2);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer3(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node_modules/core-util-is/lib/util.js
  var require_util = __commonJS({
    "node_modules/core-util-is/lib/util.js"(exports) {
      init_shim();
      function isArray(arg) {
        if (Array.isArray) {
          return Array.isArray(arg);
        }
        return objectToString(arg) === "[object Array]";
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString2(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString2;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;
      function isError(e) {
        return objectToString(e) === "[object Error]" || e instanceof Error;
      }
      exports.isError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require_buffer().Buffer.isBuffer;
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports, module) {
      init_shim();
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports, module) {
      "use strict";
      init_shim();
      var hasSymbols = require_shams();
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      init_shim();
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      init_shim();
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(that, args.concat(slice.call(arguments)));
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push("$" + i);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      init_shim();
      var implementation = require_implementation();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/has/src/index.js
  var require_src = __commonJS({
    "node_modules/has/src/index.js"(exports, module) {
      "use strict";
      init_shim();
      var bind = require_function_bind();
      module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports, module) {
      "use strict";
      init_shim();
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = Object.getPrototypeOf || function(x) {
        return x.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports, module) {
      "use strict";
      init_shim();
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports, module) {
      "use strict";
      init_shim();
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports, module) {
      "use strict";
      init_shim();
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "node_modules/is-generator-function/index.js"(exports, module) {
      "use strict";
      init_shim();
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = require_shams2()();
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e) {
        }
      };
      var GeneratorFunction;
      module.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === "[object GeneratorFunction]";
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn) === GeneratorFunction;
      };
    }
  });

  // node_modules/is-callable/index.js
  var require_is_callable = __commonJS({
    "node_modules/is-callable/index.js"(exports, module) {
      "use strict";
      init_shim();
      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_) {
          if (_ !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
      var documentDotAll = typeof document === "object" && typeof document.all === "undefined" && document.all !== void 0 ? document.all : {};
      module.exports = reflectApply ? function isCallable(value) {
        if (value === documentDotAll) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (typeof value === "function" && !value.prototype) {
          return true;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e) {
          if (e !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value);
      } : function isCallable(value) {
        if (value === documentDotAll) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (typeof value === "function" && !value.prototype) {
          return true;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        return strClass === fnClass || strClass === genClass;
      };
    }
  });

  // node_modules/for-each/index.js
  var require_for_each = __commonJS({
    "node_modules/for-each/index.js"(exports, module) {
      "use strict";
      init_shim();
      var isCallable = require_is_callable();
      var toStr = Object.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array, iterator, receiver) {
        for (var i = 0, len = array.length; i < len; i++) {
          if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
              iterator(array[i], i, array);
            } else {
              iterator.call(receiver, array[i], i, array);
            }
          }
        }
      };
      var forEachString = function forEachString2(string, iterator, receiver) {
        for (var i = 0, len = string.length; i < len; i++) {
          if (receiver == null) {
            iterator(string.charAt(i), i, string);
          } else {
            iterator.call(receiver, string.charAt(i), i, string);
          }
        }
      };
      var forEachObject = function forEachObject2(object, iterator, receiver) {
        for (var k in object) {
          if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
              iterator(object[k], k, object);
            } else {
              iterator.call(receiver, object[k], k, object);
            }
          }
        }
      };
      var forEach2 = function forEach3(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr.call(list) === "[object Array]") {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      module.exports = forEach2;
    }
  });

  // node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "node_modules/available-typed-arrays/index.js"(exports, module) {
      "use strict";
      init_shim();
      var possibleNames = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
      ];
      var g = typeof globalThis === "undefined" ? _global : globalThis;
      module.exports = function availableTypedArrays() {
        var out = [];
        for (var i = 0; i < possibleNames.length; i++) {
          if (typeof g[possibleNames[i]] === "function") {
            out[out.length] = possibleNames[i];
          }
        }
        return out;
      };
    }
  });

  // node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js
  var require_getOwnPropertyDescriptor = __commonJS({
    "node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js"(exports, module) {
      "use strict";
      init_shim();
      var GetIntrinsic = require_get_intrinsic();
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e) {
          $gOPD = null;
        }
      }
      module.exports = $gOPD;
    }
  });

  // node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "node_modules/is-typed-array/index.js"(exports, module) {
      "use strict";
      init_shim();
      var forEach2 = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g = typeof globalThis === "undefined" ? _global : globalThis;
      var typedArrays = availableTypedArrays();
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var gOPD = require_getOwnPropertyDescriptor();
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach2(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var anyTrue = false;
        forEach2(toStrTags, function(getter, typedArray) {
          if (!anyTrue) {
            try {
              anyTrue = getter.call(value) === typedArray;
            } catch (e) {
            }
          }
        });
        return anyTrue;
      };
      module.exports = function isTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          var tag = $slice($toString(value), 8, -1);
          return $indexOf(typedArrays, tag) > -1;
        }
        if (!gOPD) {
          return false;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "node_modules/which-typed-array/index.js"(exports, module) {
      "use strict";
      init_shim();
      var forEach2 = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g = typeof globalThis === "undefined" ? _global : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var gOPD = require_getOwnPropertyDescriptor();
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach2(typedArrays, function(typedArray) {
          if (typeof g[typedArray] === "function") {
            var arr = new g[typedArray]();
            if (Symbol.toStringTag in arr) {
              var proto = getPrototypeOf(arr);
              var descriptor = gOPD(proto, Symbol.toStringTag);
              if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
              }
              toStrTags[typedArray] = descriptor.get;
            }
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var foundName = false;
        forEach2(toStrTags, function(getter, typedArray) {
          if (!foundName) {
            try {
              var name = getter.call(value);
              if (name === typedArray) {
                foundName = name;
              }
            } catch (e) {
            }
          }
        });
        return foundName;
      };
      var isTypedArray = require_is_typed_array();
      module.exports = function whichTypedArray(value) {
        if (!isTypedArray(value)) {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          return $slice($toString(value), 8, -1);
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/util/support/types.js
  var require_types = __commonJS({
    "node_modules/util/support/types.js"(exports) {
      "use strict";
      init_shim();
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports.isArgumentsObject = isArgumentsObject;
      exports.isGeneratorFunction = isGeneratorFunction;
      exports.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/util/support/isBufferBrowser.js"(exports, module) {
      init_shim();
      module.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // node_modules/util/util.js
  var require_util2 = __commonJS({
    "node_modules/util/util.js"(exports) {
      init_shim();
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f) {
        if (!isString2(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (typeof import_process.default !== "undefined" && import_process.default.noDeprecation === true) {
          return fn;
        }
        if (typeof import_process.default === "undefined") {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (import_process.default.throwDeprecation) {
              throw new Error(msg);
            } else if (import_process.default.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (import_process.default.env.NODE_DEBUG) {
        debugEnv = import_process.default.env.NODE_DEBUG;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = import_process.default.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString2(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString2(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").substr(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0)
            numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      exports.types = require_types();
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString2(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString2;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      exports.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;
      exports.types.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      exports.isError = isError;
      exports.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require_isBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports.log = function() {
        console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require_inherits_browser();
      exports._extend = function(origin, add) {
        if (!add || !isObject(add))
          return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol)
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
        return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
      };
      exports.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(function(ret) {
            import_process.default.nextTick(cb.bind(null, null, ret));
          }, function(rej) {
            import_process.default.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          });
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
        return callbackified;
      }
      exports.callbackify = callbackify;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/BufferList.js
  var require_BufferList = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports, module) {
      "use strict";
      init_shim();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var Buffer3 = require_safe_buffer().Buffer;
      var util = require_util2();
      function copyBuffer(src, target, offset) {
        src.copy(target, offset);
      }
      module.exports = function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        BufferList.prototype.push = function push(v) {
          var entry = { data: v, next: null };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        };
        BufferList.prototype.unshift = function unshift(v) {
          var entry = { data: v, next: this.head };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        };
        BufferList.prototype.shift = function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        };
        BufferList.prototype.clear = function clear() {
          this.head = this.tail = null;
          this.length = 0;
        };
        BufferList.prototype.join = function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        };
        BufferList.prototype.concat = function concat(n) {
          if (this.length === 0)
            return Buffer3.alloc(0);
          if (this.length === 1)
            return this.head.data;
          var ret = Buffer3.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        };
        return BufferList;
      }();
      if (util && util.inspect && util.inspect.custom) {
        module.exports.prototype[util.inspect.custom] = function() {
          var obj = util.inspect({ length: this.length });
          return this.constructor.name + " " + obj;
        };
      }
    }
  });

  // node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      var pna = require_process_nextick_args();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
            pna.nextTick(emitErrorNT, this, err);
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            pna.nextTick(emitErrorNT, _this, err2);
            if (_this._writableState) {
              _this._writableState.errorEmitted = true;
            }
          } else if (cb) {
            cb(err2);
          }
        });
        return this;
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy
      };
    }
  });

  // node_modules/util-deprecate/browser.js
  var require_browser2 = __commonJS({
    "node_modules/util-deprecate/browser.js"(exports, module) {
      init_shim();
      module.exports = deprecate;
      function deprecate(fn, msg) {
        if (config("noDeprecation")) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config("throwDeprecation")) {
              throw new Error(msg);
            } else if (config("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      function config(name) {
        try {
          if (!_global.localStorage)
            return false;
        } catch (_) {
          return false;
        }
        var val = _global.localStorage[name];
        if (val == null)
          return false;
        return String(val).toLowerCase() === "true";
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable = __commonJS({
    "node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      var pna = require_process_nextick_args();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var asyncWrite = !import_process.default.browser && ["v0.10", "v0.9."].indexOf(import_process.default.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
      var Duplex;
      Writable.WritableState = WritableState;
      var util = Object.create(require_util());
      util.inherits = require_inherits_browser();
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser();
      var Buffer3 = require_safe_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy();
      util.inherits(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        var isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        var hwm = options.highWaterMark;
        var writableHwm = options.writableHighWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        if (hwm || hwm === 0)
          this.highWaterMark = hwm;
        else if (isDuplex && (writableHwm || writableHwm === 0))
          this.highWaterMark = writableHwm;
        else
          this.highWaterMark = defaultHwm;
        this.highWaterMark = Math.floor(this.highWaterMark);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex();
        if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
          return new Writable(options);
        }
        this._writableState = new WritableState(options, this);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
      };
      function writeAfterEnd(stream, cb) {
        var er = new Error("write after end");
        stream.emit("error", er);
        pna.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var valid = true;
        var er = false;
        if (chunk === null) {
          er = new TypeError("May not write null values to stream");
        } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        if (er) {
          stream.emit("error", er);
          pna.nextTick(cb, er);
          valid = false;
        }
        return valid;
      }
      Writable.prototype.write = function(chunk, encoding2, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer3.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (isBuf)
          encoding2 = "buffer";
        else if (!encoding2)
          encoding2 = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ended)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding2, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        var state = this._writableState;
        state.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
        if (typeof encoding2 === "string")
          encoding2 = encoding2.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
          throw new TypeError("Unknown encoding: " + encoding2);
        this._writableState.defaultEncoding = encoding2;
        return this;
      };
      function decodeChunk(state, chunk, encoding2) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer3.from(chunk, encoding2);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding2, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding2);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding2 = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding: encoding2,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding2, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding2, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          pna.nextTick(cb, er);
          pna.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          stream.emit("error", er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          stream.emit("error", er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished4 = needFinish(state);
          if (!finished4 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            asyncWrite(afterWrite, stream, state, finished4, cb);
          } else {
            afterWrite(stream, state, finished4, cb);
          }
        }
      }
      function afterWrite(stream, state, finished4, cb) {
        if (!finished4)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding2 = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding2, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding2, cb) {
        cb(new Error("_write() is not implemented"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding2, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding2 = null;
        } else if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding2);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending && !state.finished)
          endWritable(this, state, cb);
      };
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            stream.emit("error", err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function") {
            state.pendingcb++;
            state.finalCalled = true;
            pna.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            pna.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        if (state.corkedRequestsFree) {
          state.corkedRequestsFree.next = corkReq;
        } else {
          state.corkedRequestsFree = corkReq;
        }
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        get: function() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        this.end();
        cb(err);
      };
    }
  });

  // node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex = __commonJS({
    "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var pna = require_process_nextick_args();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var util = Object.create(require_util());
      util.inherits = require_inherits_browser();
      var Readable5 = require_stream_readable();
      var Writable = require_stream_writable();
      util.inherits(Duplex, Readable5);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable5.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false)
          this.readable = false;
        if (options && options.writable === false)
          this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false)
          this.allowHalfOpen = false;
        this.once("end", onend);
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function() {
          return this._writableState.highWaterMark;
        }
      });
      function onend() {
        if (this.allowHalfOpen || this._writableState.ended)
          return;
        pna.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        get: function() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
      Duplex.prototype._destroy = function(err, cb) {
        this.push(null);
        this.end();
        pna.nextTick(cb, err);
      };
    }
  });

  // node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js
  var require_string_decoder = __commonJS({
    "node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js"(exports) {
      "use strict";
      init_shim();
      var Buffer3 = require_safe_buffer().Buffer;
      var isEncoding = Buffer3.isEncoding || function(encoding2) {
        encoding2 = "" + encoding2;
        switch (encoding2 && encoding2.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc)
          return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried)
                return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc)))
          throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports.StringDecoder = StringDecoder;
      function StringDecoder(encoding2) {
        this.encoding = normalizeEncoding(encoding2);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer3.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0)
          return "";
        var r;
        var i;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === void 0)
            return "";
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }
        if (i < buf.length)
          return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127)
          return 0;
        else if (byte >> 5 === 6)
          return 2;
        else if (byte >> 4 === 14)
          return 3;
        else if (byte >> 3 === 30)
          return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i) {
        var j = buf.length - 1;
        if (j < i)
          return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2)
              nb = 0;
            else
              self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "\uFFFD";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "\uFFFD";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf, p);
        if (r !== void 0)
          return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed)
          return buf.toString("utf8", i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i, end);
      }
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + "\uFFFD";
        return r;
      }
      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString("utf16le", i);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i, buf.length - 1);
      }
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
      }
      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0)
          return buf.toString("base64", i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable = __commonJS({
    "node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      var pna = require_process_nextick_args();
      module.exports = Readable5;
      var isArray = require_isarray();
      var Duplex;
      Readable5.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser();
      var Buffer3 = require_safe_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var util = Object.create(require_util());
      util.inherits = require_inherits_browser();
      var debugUtil = require_util2();
      var debug = void 0;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function() {
        };
      }
      var BufferList = require_BufferList();
      var destroyImpl = require_destroy();
      var StringDecoder;
      util.inherits(Readable5, Stream);
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        var isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        var hwm = options.highWaterMark;
        var readableHwm = options.readableHighWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        if (hwm || hwm === 0)
          this.highWaterMark = hwm;
        else if (isDuplex && (readableHwm || readableHwm === 0))
          this.highWaterMark = readableHwm;
        else
          this.highWaterMark = defaultHwm;
        this.highWaterMark = Math.floor(this.highWaterMark);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable5(options) {
        Duplex = Duplex || require_stream_duplex();
        if (!(this instanceof Readable5))
          return new Readable5(options);
        this._readableState = new ReadableState(options, this);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable5.prototype, "destroyed", {
        get: function() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable5.prototype.destroy = destroyImpl.destroy;
      Readable5.prototype._undestroy = destroyImpl.undestroy;
      Readable5.prototype._destroy = function(err, cb) {
        this.push(null);
        cb(err);
      };
      Readable5.prototype.push = function(chunk, encoding2) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding2 = encoding2 || state.defaultEncoding;
            if (encoding2 !== state.encoding) {
              chunk = Buffer3.from(chunk, encoding2);
              encoding2 = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
      };
      Readable5.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            stream.emit("error", er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                stream.emit("error", new Error("stream.unshift() after end event"));
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              stream.emit("error", new Error("stream.push() after EOF"));
            } else {
              state.reading = false;
              if (state.decoder && !encoding2) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
          }
        }
        return needMoreData(state);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        return er;
      }
      function needMoreData(state) {
        return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
      }
      Readable5.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable5.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this._readableState.decoder = new StringDecoder(enc);
        this._readableState.encoding = enc;
        return this;
      };
      var MAX_HWM = 8388608;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable5.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = true;
          n = 0;
        } else {
          state.length -= n;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        emitReadable(stream);
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          if (state.sync)
            pna.nextTick(emitReadable_, stream);
          else
            emitReadable_(stream);
        }
      }
      function emitReadable_(stream) {
        debug("emit readable");
        stream.emit("readable");
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          pna.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        var len = state.length;
        while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
          else
            len = state.length;
        }
        state.readingMore = false;
      }
      Readable5.prototype._read = function(n) {
        this.emit("error", new Error("_read() is not implemented"));
      };
      Readable5.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          pna.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        var increasedAwaitDrain = false;
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          increasedAwaitDrain = false;
          var ret = dest.write(chunk);
          if (ret === false && !increasedAwaitDrain) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", src._readableState.awaitDrain);
              src._readableState.awaitDrain++;
              increasedAwaitDrain = true;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            dest.emit("error", er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable5.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = { hasUnpiped: false };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, unpipeInfo);
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable5.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        if (ev === "data") {
          if (this._readableState.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          var state = this._readableState;
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
              pna.nextTick(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this);
            }
          }
        }
        return res;
      };
      Readable5.prototype.addListener = Readable5.prototype.on;
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable5.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          pna.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        if (!state.reading) {
          debug("resume read 0");
          stream.read(0);
        }
        state.resumeScheduled = false;
        state.awaitDrain = 0;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable5.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
        }
      }
      Readable5.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function(method) {
              return function() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      Object.defineProperty(Readable5.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      });
      Readable5._fromList = fromList;
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.head.data;
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = fromListPartial(n, state.buffer, state.decoder);
        }
        return ret;
      }
      function fromListPartial(n, list, hasStrings) {
        var ret;
        if (n < list.head.data.length) {
          ret = list.head.data.slice(0, n);
          list.head.data = list.head.data.slice(n);
        } else if (n === list.head.data.length) {
          ret = list.shift();
        } else {
          ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
        }
        return ret;
      }
      function copyFromBufferString(n, list) {
        var p = list.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                list.head = p.next;
              else
                list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }
      function copyFromBuffer(n, list) {
        var ret = Buffer3.allocUnsafe(n);
        var p = list.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                list.head = p.next;
              else
                list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        if (state.length > 0)
          throw new Error('"endReadable()" called on non-empty stream');
        if (!state.endEmitted) {
          state.ended = true;
          pna.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
        }
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform = __commonJS({
    "node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform;
      var Duplex = require_stream_duplex();
      var util = Object.create(require_util());
      util.inherits = require_inherits_browser();
      util.inherits(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (!cb) {
          return this.emit("error", new Error("write callback called multiple times"));
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function") {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding2) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding2);
      };
      Transform.prototype._transform = function(chunk, encoding2, cb) {
        throw new Error("_transform() is not implemented");
      };
      Transform.prototype._write = function(chunk, encoding2, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding2;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        var _this2 = this;
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
          _this2.emit("close");
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (stream._transformState.transforming)
          throw new Error("Calling transform done when still transforming");
        return stream.push(null);
      }
    }
  });

  // node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough = __commonJS({
    "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough;
      var Transform = require_stream_transform();
      var util = Object.create(require_util());
      util.inherits = require_inherits_browser();
      util.inherits(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding2, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/readable-stream/readable-browser.js
  var require_readable_browser = __commonJS({
    "node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_shim();
      exports = module.exports = require_stream_readable();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
    }
  });

  // node_modules/readable-error/index.js
  var require_readable_error = __commonJS({
    "node_modules/readable-error/index.js"(exports, module) {
      init_shim();
      var Readable5 = require_readable_browser();
      var ReadableError2 = class extends Readable5 {
        constructor(err) {
          super({
            read: () => {
              this.emit("error", err);
            }
          });
        }
      };
      module.exports = ReadableError2;
    }
  });

  // node_modules/lodash/_trimmedEndIndex.js
  var require_trimmedEndIndex = __commonJS({
    "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
      init_shim();
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      module.exports = trimmedEndIndex;
    }
  });

  // node_modules/lodash/_baseTrim.js
  var require_baseTrim = __commonJS({
    "node_modules/lodash/_baseTrim.js"(exports, module) {
      init_shim();
      var trimmedEndIndex = require_trimmedEndIndex();
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      module.exports = baseTrim;
    }
  });

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js"(exports, module) {
      init_shim();
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      module.exports = isObject;
    }
  });

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js"(exports, module) {
      init_shim();
      var freeGlobal = typeof _global == "object" && _global && _global.Object === Object && _global;
      module.exports = freeGlobal;
    }
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/lodash/_root.js"(exports, module) {
      init_shim();
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module.exports = root;
    }
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js"(exports, module) {
      init_shim();
      var root = require_root();
      var Symbol2 = root.Symbol;
      module.exports = Symbol2;
    }
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js"(exports, module) {
      init_shim();
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module.exports = getRawTag;
    }
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js"(exports, module) {
      init_shim();
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module.exports = objectToString;
    }
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js"(exports, module) {
      init_shim();
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module.exports = baseGetTag;
    }
  });

  // node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/lodash/isObjectLike.js"(exports, module) {
      init_shim();
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module.exports = isObjectLike;
    }
  });

  // node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "node_modules/lodash/isSymbol.js"(exports, module) {
      init_shim();
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      module.exports = isSymbol;
    }
  });

  // node_modules/lodash/toNumber.js
  var require_toNumber = __commonJS({
    "node_modules/lodash/toNumber.js"(exports, module) {
      init_shim();
      var baseTrim = require_baseTrim();
      var isObject = require_isObject();
      var isSymbol = require_isSymbol();
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = toNumber;
    }
  });

  // node_modules/lodash/toFinite.js
  var require_toFinite = __commonJS({
    "node_modules/lodash/toFinite.js"(exports, module) {
      init_shim();
      var toNumber = require_toNumber();
      var INFINITY = 1 / 0;
      var MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      module.exports = toFinite;
    }
  });

  // node_modules/lodash/toInteger.js
  var require_toInteger = __commonJS({
    "node_modules/lodash/toInteger.js"(exports, module) {
      init_shim();
      var toFinite = require_toFinite();
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      module.exports = toInteger;
    }
  });

  // node_modules/lodash/before.js
  var require_before = __commonJS({
    "node_modules/lodash/before.js"(exports, module) {
      init_shim();
      var toInteger = require_toInteger();
      var FUNC_ERROR_TEXT = "Expected a function";
      function before(n, func) {
        var result;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = void 0;
          }
          return result;
        };
      }
      module.exports = before;
    }
  });

  // node_modules/lodash/once.js
  var require_once = __commonJS({
    "node_modules/lodash/once.js"(exports, module) {
      init_shim();
      var before = require_before();
      function once2(func) {
        return before(2, func);
      }
      module.exports = once2;
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser2 = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_shim();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer3 = _require.Buffer;
      var _require2 = require_util2();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer3.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer3.alloc(0);
            var ret = Buffer3.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer3.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy2 = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              import_process.default.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              import_process.default.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            import_process.default.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/errors-browser.js
  var require_errors_browser = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_shim();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable2 = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser2();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy2();
      var _require = require_state();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex2();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex2();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          import_process.default.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding2, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer3.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (isBuf)
          encoding2 = "buffer";
        else if (!encoding2)
          encoding2 = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ending)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding2, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
        if (typeof encoding2 === "string")
          encoding2 = encoding2.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding2);
        this._writableState.defaultEncoding = encoding2;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding2) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer3.from(chunk, encoding2);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding2, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding2);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding2 = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding: encoding2,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding2, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding2, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          import_process.default.nextTick(cb, er);
          import_process.default.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished4 = needFinish(state) || stream.destroyed;
          if (!finished4 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            import_process.default.nextTick(afterWrite, stream, state, finished4, cb);
          } else {
            afterWrite(stream, state, finished4, cb);
          }
        }
      }
      function afterWrite(stream, state, finished4, cb) {
        if (!finished4)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding2 = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding2, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding2, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding2 = null;
        } else if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding2);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            import_process.default.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            import_process.default.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex2 = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var Readable5 = require_stream_readable2();
      var Writable = require_stream_writable2();
      require_inherits_browser()(Duplex, Readable5);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable5.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended)
          return;
        import_process.default.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer2 = __commonJS({
    "node_modules/safe-buffer/index.js"(exports, module) {
      init_shim();
      var buffer = require_buffer();
      var Buffer3 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer3(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer3.prototype);
      copyProps(Buffer3, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer3(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding2) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer3(size);
        if (fill !== void 0) {
          if (typeof encoding2 === "string") {
            buf.fill(fill, encoding2);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer3(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node_modules/string_decoder/lib/string_decoder.js
  var require_string_decoder2 = __commonJS({
    "node_modules/string_decoder/lib/string_decoder.js"(exports) {
      "use strict";
      init_shim();
      var Buffer3 = require_safe_buffer2().Buffer;
      var isEncoding = Buffer3.isEncoding || function(encoding2) {
        encoding2 = "" + encoding2;
        switch (encoding2 && encoding2.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc)
          return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried)
                return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc)))
          throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports.StringDecoder = StringDecoder;
      function StringDecoder(encoding2) {
        this.encoding = normalizeEncoding(encoding2);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer3.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0)
          return "";
        var r;
        var i;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === void 0)
            return "";
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }
        if (i < buf.length)
          return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127)
          return 0;
        else if (byte >> 5 === 6)
          return 2;
        else if (byte >> 4 === 14)
          return 3;
        else if (byte >> 3 === 30)
          return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i) {
        var j = buf.length - 1;
        if (j < i)
          return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2)
              nb = 0;
            else
              self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "\uFFFD";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "\uFFFD";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf, p);
        if (r !== void 0)
          return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed)
          return buf.toString("utf8", i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i, end);
      }
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + "\uFFFD";
        return r;
      }
      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString("utf16le", i);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i, buf.length - 1);
      }
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
      }
      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0)
          return buf.toString("base64", i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once2(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_shim();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished4 = require_end_of_stream();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        import_process.default.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              import_process.default.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished4(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_shim();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable2 = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Readable5;
      var Duplex;
      Readable5.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser2();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list();
      var destroyImpl = require_destroy2();
      var _require = require_state();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable5, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex2();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder2().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable5(options) {
        Duplex = Duplex || require_stream_duplex2();
        if (!(this instanceof Readable5))
          return new Readable5(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable5.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable5.prototype.destroy = destroyImpl.destroy;
      Readable5.prototype._undestroy = destroyImpl.undestroy;
      Readable5.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable5.prototype.push = function(chunk, encoding2) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding2 = encoding2 || state.defaultEncoding;
            if (encoding2 !== state.encoding) {
              chunk = Buffer3.from(chunk, encoding2);
              encoding2 = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
      };
      Readable5.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding2) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable5.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable5.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable5.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          import_process.default.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          import_process.default.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable5.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable5.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          import_process.default.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable5.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable5.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              import_process.default.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable5.prototype.addListener = Readable5.prototype.on;
      Readable5.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable5.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable5.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          import_process.default.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable5.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable5.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable5.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable5.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableBuffer", {
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableFlowing", {
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable5._fromList = fromList;
      Object.defineProperty(Readable5.prototype, "readableLength", {
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          import_process.default.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable5.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser();
          }
          return from(Readable5, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform2 = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform;
      var _require$codes = require_errors_browser().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex2();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding2) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding2);
      };
      Transform.prototype._transform = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding2, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding2;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough2 = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough;
      var Transform = require_stream_transform2();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding2, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_shim();
      var eos;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once2(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/nodeify-fetch/node_modules/readable-stream/readable-browser.js
  var require_readable_browser2 = __commonJS({
    "node_modules/nodeify-fetch/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_shim();
      exports = module.exports = require_stream_readable2();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable2();
      exports.Duplex = require_stream_duplex2();
      exports.Transform = require_stream_transform2();
      exports.PassThrough = require_stream_passthrough2();
      exports.finished = require_end_of_stream();
      exports.pipeline = require_pipeline();
    }
  });

  // node_modules/nodeify-fetch/lib/arrayBufferToReadable.js
  function arrayBufferToReadable(callback) {
    return new import_readable_stream.Readable({
      read: (0, import_once.default)(async function() {
        try {
          this.push(import_buffer.Buffer.from(await callback()));
          this.push(null);
        } catch (err) {
          this.destroy(err);
        }
      })
    });
  }
  var import_once, import_readable_stream, arrayBufferToReadable_default;
  var init_arrayBufferToReadable = __esm({
    "node_modules/nodeify-fetch/lib/arrayBufferToReadable.js"() {
      init_shim();
      import_once = __toESM(require_once(), 1);
      import_readable_stream = __toESM(require_readable_browser2(), 1);
      arrayBufferToReadable_default = arrayBufferToReadable;
    }
  });

  // node_modules/nodeify-fetch/lib/Patchable.js
  var Patchable, Patchable_default;
  var init_Patchable = __esm({
    "node_modules/nodeify-fetch/lib/Patchable.js"() {
      init_shim();
      Patchable = class {
        constructor(obj, patch3) {
          this.obj = obj;
          for (const [key, value] of Object.entries(patch3)) {
            this[key] = value;
          }
          for (const key of Patchable.properties(obj)) {
            if (key in this) {
              continue;
            }
            if (typeof this.obj[key] === "function") {
              this[key] = (...args) => this.obj[key].call(obj, args);
            } else {
              Object.defineProperty(this, key, {
                get: () => {
                  return this.obj[key];
                },
                set: (value) => {
                  this.obj[key] = value;
                },
                enumerable: true,
                configurable: true
              });
            }
          }
        }
        static properties(obj) {
          return Object.getOwnPropertyNames(Object.getPrototypeOf(obj));
        }
      };
      Patchable_default = Patchable;
    }
  });

  // node_modules/nodeify-fetch/lib/whatwgToReadable.js
  function whatwgToReadable(whatwg) {
    return new import_readable_stream2.Readable({
      read: async function() {
        try {
          let chunk, full;
          do {
            chunk = await whatwg.read();
            if (chunk.done) {
              this.push(null);
            } else {
              full = !this.push(import_buffer.Buffer.from(chunk.value));
            }
          } while (!chunk.done && !full);
        } catch (err) {
          this.destroy(err);
        }
      }
    });
  }
  var import_readable_stream2, whatwgToReadable_default;
  var init_whatwgToReadable = __esm({
    "node_modules/nodeify-fetch/lib/whatwgToReadable.js"() {
      init_shim();
      import_readable_stream2 = __toESM(require_readable_browser2(), 1);
      whatwgToReadable_default = whatwgToReadable;
    }
  });

  // node_modules/nodeify-fetch/lib/patchResponse.js
  function patch2(res) {
    if (res.bodyUsed) {
      res.body = new import_readable_error.default(new Error("body already in use"));
      return res;
    }
    if (res.body && res.body.readable) {
      return res;
    }
    if (res.body && typeof res.body.getReader === "function") {
      return new Patchable_default(res, {
        body: whatwgToReadable_default(res.body.getReader())
      });
    }
    res.body = arrayBufferToReadable_default(() => res.arrayBuffer());
    return res;
  }
  var import_readable_error, patchResponse_default;
  var init_patchResponse = __esm({
    "node_modules/nodeify-fetch/lib/patchResponse.js"() {
      init_shim();
      import_readable_error = __toESM(require_readable_error(), 1);
      init_arrayBufferToReadable();
      init_Patchable();
      init_whatwgToReadable();
      patchResponse_default = patch2;
    }
  });

  // node_modules/nodeify-fetch/browser.js
  function nodeifyFetch(url, options) {
    return patchRequest_default(options).then((options2) => {
      return fetch(url, options2).then((res) => {
        return patchResponse_default(res);
      });
    });
  }
  var Headers2;
  var init_browser = __esm({
    "node_modules/nodeify-fetch/browser.js"() {
      init_shim();
      init_patchRequest();
      init_patchResponse();
      Headers2 = window.Headers;
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser3 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list2 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_shim();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer3 = _require.Buffer;
      var _require2 = require_util2();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer3.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer3.alloc(0);
            var ret = Buffer3.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer3.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy3 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              import_process.default.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              import_process.default.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            import_process.default.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js
  var require_errors_browser2 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_shim();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state2 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_INVALID_OPT_VALUE = require_errors_browser2().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable3 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser3();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy3();
      var _require = require_state2();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser2().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex3();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex3();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          import_process.default.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding2, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer3.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (isBuf)
          encoding2 = "buffer";
        else if (!encoding2)
          encoding2 = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ending)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding2, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
        if (typeof encoding2 === "string")
          encoding2 = encoding2.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding2);
        this._writableState.defaultEncoding = encoding2;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding2) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer3.from(chunk, encoding2);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding2, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding2);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding2 = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding: encoding2,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding2, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding2, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          import_process.default.nextTick(cb, er);
          import_process.default.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished4 = needFinish(state) || stream.destroyed;
          if (!finished4 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            import_process.default.nextTick(afterWrite, stream, state, finished4, cb);
          } else {
            afterWrite(stream, state, finished4, cb);
          }
        }
      }
      function afterWrite(stream, state, finished4, cb) {
        if (!finished4)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding2 = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding2, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding2, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding2 = null;
        } else if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding2);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            import_process.default.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            import_process.default.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex3 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var Readable5 = require_stream_readable3();
      var Writable = require_stream_writable3();
      require_inherits_browser()(Duplex, Readable5);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable5.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended)
          return;
        import_process.default.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream2 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser2().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once2(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator2 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_shim();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished4 = require_end_of_stream2();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        import_process.default.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              import_process.default.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished4(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser2 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_shim();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable3 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Readable5;
      var Duplex;
      Readable5.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser3();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list2();
      var destroyImpl = require_destroy3();
      var _require = require_state2();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser2().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable5, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex3();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder2().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable5(options) {
        Duplex = Duplex || require_stream_duplex3();
        if (!(this instanceof Readable5))
          return new Readable5(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable5.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable5.prototype.destroy = destroyImpl.destroy;
      Readable5.prototype._undestroy = destroyImpl.undestroy;
      Readable5.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable5.prototype.push = function(chunk, encoding2) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding2 = encoding2 || state.defaultEncoding;
            if (encoding2 !== state.encoding) {
              chunk = Buffer3.from(chunk, encoding2);
              encoding2 = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
      };
      Readable5.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding2) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable5.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable5.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable5.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          import_process.default.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          import_process.default.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable5.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable5.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          import_process.default.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable5.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable5.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              import_process.default.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable5.prototype.addListener = Readable5.prototype.on;
      Readable5.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable5.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable5.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          import_process.default.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable5.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable5.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable5.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator2();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable5.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableBuffer", {
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableFlowing", {
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable5._fromList = fromList;
      Object.defineProperty(Readable5.prototype, "readableLength", {
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          import_process.default.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable5.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser2();
          }
          return from(Readable5, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform3 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform;
      var _require$codes = require_errors_browser2().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex3();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding2) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding2);
      };
      Transform.prototype._transform = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding2, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding2;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough3 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough;
      var Transform = require_stream_transform3();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding2, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline2 = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_shim();
      var eos;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser2().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once2(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream2();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/stream-browserify/index.js
  var require_stream_browserify = __commonJS({
    "node_modules/stream-browserify/index.js"(exports, module) {
      init_shim();
      module.exports = Stream;
      var EE = require_events().EventEmitter;
      var inherits = require_inherits_browser();
      inherits(Stream, EE);
      Stream.Readable = require_stream_readable3();
      Stream.Writable = require_stream_writable3();
      Stream.Duplex = require_stream_duplex3();
      Stream.Transform = require_stream_transform3();
      Stream.PassThrough = require_stream_passthrough3();
      Stream.finished = require_end_of_stream2();
      Stream.pipeline = require_pipeline2();
      Stream.Stream = Stream;
      function Stream() {
        EE.call(this);
      }
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (dest.write(chunk) === false && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EE.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
    }
  });

  // node_modules/isstream/isstream.js
  var require_isstream = __commonJS({
    "node_modules/isstream/isstream.js"(exports, module) {
      init_shim();
      var stream = require_stream_browserify();
      function isStream(obj) {
        return obj instanceof stream.Stream;
      }
      function isReadable2(obj) {
        return isStream(obj) && typeof obj._read == "function" && typeof obj._readableState == "object";
      }
      function isWritable(obj) {
        return isStream(obj) && typeof obj._write == "function" && typeof obj._writableState == "object";
      }
      function isDuplex(obj) {
        return isReadable2(obj) && isWritable(obj);
      }
      module.exports = isStream;
      module.exports.isReadable = isReadable2;
      module.exports.isWritable = isWritable;
      module.exports.isDuplex = isDuplex;
    }
  });

  // node_modules/@rdfjs/fetch-lite/lib/headersToLowerCase.js
  function headersToLowerCase(headers) {
    const headersLowerCase = {};
    Object.entries(headers).forEach(([key, value]) => {
      headersLowerCase[key.toLowerCase()] = value;
    });
    return headersLowerCase;
  }
  var headersToLowerCase_default;
  var init_headersToLowerCase = __esm({
    "node_modules/@rdfjs/fetch-lite/lib/headersToLowerCase.js"() {
      init_shim();
      headersToLowerCase_default = headersToLowerCase;
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser4 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list3 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_shim();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer3 = _require.Buffer;
      var _require2 = require_util2();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer3.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer3.alloc(0);
            var ret = Buffer3.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer3.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy4 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              import_process.default.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              import_process.default.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            import_process.default.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/errors-browser.js
  var require_errors_browser3 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_shim();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state3 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_INVALID_OPT_VALUE = require_errors_browser3().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable4 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser4();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy4();
      var _require = require_state3();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser3().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex4();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex4();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          import_process.default.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding2, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer3.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (isBuf)
          encoding2 = "buffer";
        else if (!encoding2)
          encoding2 = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ending)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding2, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
        if (typeof encoding2 === "string")
          encoding2 = encoding2.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding2);
        this._writableState.defaultEncoding = encoding2;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding2) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer3.from(chunk, encoding2);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding2, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding2);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding2 = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding: encoding2,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding2, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding2, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          import_process.default.nextTick(cb, er);
          import_process.default.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished4 = needFinish(state) || stream.destroyed;
          if (!finished4 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            import_process.default.nextTick(afterWrite, stream, state, finished4, cb);
          } else {
            afterWrite(stream, state, finished4, cb);
          }
        }
      }
      function afterWrite(stream, state, finished4, cb) {
        if (!finished4)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding2 = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding2, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding2, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding2 = null;
        } else if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding2);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            import_process.default.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            import_process.default.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex4 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var Readable5 = require_stream_readable4();
      var Writable = require_stream_writable4();
      require_inherits_browser()(Duplex, Readable5);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable5.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended)
          return;
        import_process.default.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream3 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser3().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once2(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator3 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_shim();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished4 = require_end_of_stream3();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        import_process.default.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              import_process.default.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished4(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser3 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_shim();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable4 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Readable5;
      var Duplex;
      Readable5.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser4();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list3();
      var destroyImpl = require_destroy4();
      var _require = require_state3();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser3().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable5, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex4();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder2().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable5(options) {
        Duplex = Duplex || require_stream_duplex4();
        if (!(this instanceof Readable5))
          return new Readable5(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable5.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable5.prototype.destroy = destroyImpl.destroy;
      Readable5.prototype._undestroy = destroyImpl.undestroy;
      Readable5.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable5.prototype.push = function(chunk, encoding2) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding2 = encoding2 || state.defaultEncoding;
            if (encoding2 !== state.encoding) {
              chunk = Buffer3.from(chunk, encoding2);
              encoding2 = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
      };
      Readable5.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding2) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable5.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable5.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable5.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          import_process.default.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          import_process.default.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable5.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable5.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          import_process.default.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable5.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable5.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              import_process.default.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable5.prototype.addListener = Readable5.prototype.on;
      Readable5.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable5.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable5.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          import_process.default.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable5.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable5.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable5.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator3();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable5.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableBuffer", {
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableFlowing", {
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable5._fromList = fromList;
      Object.defineProperty(Readable5.prototype, "readableLength", {
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          import_process.default.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable5.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser3();
          }
          return from(Readable5, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform4 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform;
      var _require$codes = require_errors_browser3().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex4();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding2) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding2);
      };
      Transform.prototype._transform = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding2, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding2;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough4 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough;
      var Transform = require_stream_transform4();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding2, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline3 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_shim();
      var eos;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser3().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once2(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream3();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/readable-browser.js
  var require_readable_browser3 = __commonJS({
    "node_modules/@rdfjs/fetch-lite/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_shim();
      exports = module.exports = require_stream_readable4();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable4();
      exports.Duplex = require_stream_duplex4();
      exports.Transform = require_stream_transform4();
      exports.PassThrough = require_stream_passthrough4();
      exports.finished = require_end_of_stream3();
      exports.pipeline = require_pipeline3();
    }
  });

  // node_modules/@rdfjs/fetch-lite/lib/toStream.js
  function toStream(quads) {
    const stream = new import_readable_stream3.Readable({ objectMode: true, read: () => {
    } });
    for (const quad of quads) {
      stream.push(quad);
    }
    stream.push(null);
    return stream;
  }
  var import_readable_stream3, toStream_default;
  var init_toStream = __esm({
    "node_modules/@rdfjs/fetch-lite/lib/toStream.js"() {
      init_shim();
      import_readable_stream3 = __toESM(require_readable_browser3(), 1);
      toStream_default = toStream;
    }
  });

  // node_modules/@rdfjs/fetch-lite/lib/patchRequest.js
  function patchRequest(options, formats) {
    options.headers = headersToLowerCase_default(options.headers || {});
    options.headers.accept = options.headers.accept || [...formats.parsers.keys()].join(", ");
    if (!options.body) {
      return options;
    }
    if (typeof options.body === "string") {
      return options;
    }
    if (options.headers["content-type"] && !formats.serializers.has(options.headers["content-type"])) {
      throw new Error(`no serializer found for media type: ${options.headers["content-type"]}`);
    }
    options.headers["content-type"] = options.headers["content-type"] || formats.serializers.keys().next().value;
    if (!(0, import_isstream.isReadable)(options.body) && options.body[Symbol.iterator]) {
      options.body = toStream_default(options.body);
    }
    options.body = formats.serializers.import(options.headers["content-type"], options.body);
    return options;
  }
  var import_isstream, patchRequest_default2;
  var init_patchRequest2 = __esm({
    "node_modules/@rdfjs/fetch-lite/lib/patchRequest.js"() {
      init_shim();
      import_isstream = __toESM(require_isstream(), 1);
      init_headersToLowerCase();
      init_toStream();
      patchRequest_default2 = patchRequest;
    }
  });

  // node_modules/@rdfjs/fetch-lite/lib/waitFor.js
  function waitFor(stream) {
    return new Promise((resolve, reject) => {
      (0, import_readable_stream4.finished)(stream, (err) => {
        if (err) {
          return reject(err);
        }
        resolve();
      });
    });
  }
  var import_readable_stream4, waitFor_default;
  var init_waitFor = __esm({
    "node_modules/@rdfjs/fetch-lite/lib/waitFor.js"() {
      init_shim();
      import_readable_stream4 = __toESM(require_readable_browser3(), 1);
      waitFor_default = waitFor;
    }
  });

  // node_modules/@rdfjs/fetch-lite/lib/fromStream.js
  async function fromStream(dataset, stream) {
    stream.on("data", (quad) => dataset.add(quad));
    await waitFor_default(stream);
    return dataset;
  }
  var fromStream_default;
  var init_fromStream = __esm({
    "node_modules/@rdfjs/fetch-lite/lib/fromStream.js"() {
      init_shim();
      init_waitFor();
      fromStream_default = fromStream;
    }
  });

  // node_modules/@rdfjs/fetch-lite/lib/attachDataset.js
  function attachDataset(res, factory3) {
    res.dataset = async () => {
      const stream = await res.quadStream();
      return fromStream_default(factory3.dataset(), stream);
    };
  }
  var attachDataset_default;
  var init_attachDataset = __esm({
    "node_modules/@rdfjs/fetch-lite/lib/attachDataset.js"() {
      init_shim();
      init_fromStream();
      attachDataset_default = attachDataset;
    }
  });

  // node_modules/@rdfjs/fetch-lite/lib/jsonldContextLinkUrl.js
  function jsonldContextLinkUrl(res, contentType) {
    if (contentType !== "application/json") {
      return null;
    }
    if (!res.headers.has("link")) {
      return null;
    }
    const links = res.headers.get("link").split(",").map((link) => link.trim());
    const contextLink = links.find((link) => link.includes('rel="http://www.w3.org/ns/json-ld#context"'));
    if (!contextLink) {
      return null;
    }
    const contextUrl = (linkRegExp.exec(contextLink) || []).slice(-1)[0];
    if (!contextUrl) {
      return null;
    }
    return new URL(contextUrl, res.url).toString();
  }
  var linkRegExp, jsonldContextLinkUrl_default;
  var init_jsonldContextLinkUrl = __esm({
    "node_modules/@rdfjs/fetch-lite/lib/jsonldContextLinkUrl.js"() {
      init_shim();
      linkRegExp = /<(.*)>/;
      jsonldContextLinkUrl_default = jsonldContextLinkUrl;
    }
  });

  // node_modules/@rdfjs/fetch-lite/lib/attachQuadStream.js
  function attachQuadStream(res, fetch6, parsers) {
    res.quadStream = async () => {
      if (!res.headers.get("content-type")) {
        throw new Error("Content-Type header missing: couldn't determine parser");
      }
      let contentType = res.headers.get("content-type").split(";")[0];
      const contextLinkUrl = jsonldContextLinkUrl_default(res, contentType);
      if (contextLinkUrl) {
        contentType = "application/ld+json";
      }
      if (!parsers.has(contentType)) {
        return Promise.reject(new Error(`unknown content type: ${contentType}`));
      }
      let jsonldContext;
      if (contextLinkUrl) {
        jsonldContext = await fetch6(contextLinkUrl).then((res2) => res2.json());
      }
      return parsers.import(contentType, res.body, {
        baseIRI: res.url,
        context: jsonldContext
      });
    };
  }
  var attachQuadStream_default;
  var init_attachQuadStream = __esm({
    "node_modules/@rdfjs/fetch-lite/lib/attachQuadStream.js"() {
      init_shim();
      init_jsonldContextLinkUrl();
      attachQuadStream_default = attachQuadStream;
    }
  });

  // node_modules/@rdfjs/fetch-lite/lib/patchResponse.js
  function patchResponse(res, factory3, fetch6, parsers) {
    const contentHeader = [...res.headers.keys()].some((header23) => header23.startsWith("content-"));
    const chunkedEncoding = res.headers.get("transfer-encoding") === "chunked";
    const hasBody = contentHeader || chunkedEncoding;
    if (hasBody) {
      attachQuadStream_default(res, fetch6, parsers);
      if (factory3) {
        attachDataset_default(res, factory3);
      }
    }
    return res;
  }
  var patchResponse_default2;
  var init_patchResponse2 = __esm({
    "node_modules/@rdfjs/fetch-lite/lib/patchResponse.js"() {
      init_shim();
      init_attachDataset();
      init_attachQuadStream();
      patchResponse_default2 = patchResponse;
    }
  });

  // node_modules/@rdfjs/fetch-lite/index.js
  async function rdfFetch(url, options = {}) {
    const factory3 = options.factory;
    const fetch6 = options.fetch || nodeifyFetch;
    const formats = options.formats;
    if (!formats) {
      throw new Error("no formats given");
    }
    options = patchRequest_default2(options, formats);
    const res = await fetch6(url, options);
    return patchResponse_default2(res, factory3, fetch6, formats.parsers);
  }
  var init_fetch_lite = __esm({
    "node_modules/@rdfjs/fetch-lite/index.js"() {
      init_shim();
      init_browser();
      init_patchRequest2();
      init_patchResponse2();
    }
  });

  // node_modules/@rdfjs/fetch-lite/Factory.js
  function createFetch(context) {
    const result = function(url, options = {}) {
      const factory3 = typeof context.dataset === "function" ? context : null;
      return rdfFetch(url, {
        ...options,
        factory: factory3,
        fetch: context._fetch.fetch,
        formats: context.formats
      });
    };
    result.config = function(key, value) {
      context._fetch[key] = value;
    };
    result.Headers = Headers2;
    return result;
  }
  var FetchFactory, Factory_default;
  var init_Factory = __esm({
    "node_modules/@rdfjs/fetch-lite/Factory.js"() {
      init_shim();
      init_fetch_lite();
      FetchFactory = class {
        init() {
          this._fetch = {
            fetch: null
          };
          this.fetch = createFetch(this);
        }
        clone(original) {
          for (const [key, value] of Object.entries(original._fetch)) {
            this._fetch[key] = value;
          }
        }
      };
      Factory_default = FetchFactory;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/BlankNode.js
  var BlankNode, BlankNode_default;
  var init_BlankNode = __esm({
    "node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/BlankNode.js"() {
      init_shim();
      BlankNode = class {
        constructor(id) {
          this.value = id;
        }
        equals(other) {
          return !!other && other.termType === this.termType && other.value === this.value;
        }
      };
      BlankNode.prototype.termType = "BlankNode";
      BlankNode_default = BlankNode;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/DefaultGraph.js
  var DefaultGraph, DefaultGraph_default;
  var init_DefaultGraph = __esm({
    "node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/DefaultGraph.js"() {
      init_shim();
      DefaultGraph = class {
        equals(other) {
          return !!other && other.termType === this.termType;
        }
      };
      DefaultGraph.prototype.termType = "DefaultGraph";
      DefaultGraph.prototype.value = "";
      DefaultGraph_default = DefaultGraph;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/fromTerm.js
  function fromTerm(factory3, original) {
    if (!original) {
      return null;
    }
    if (original.termType === "BlankNode") {
      return factory3.blankNode(original.value);
    }
    if (original.termType === "DefaultGraph") {
      return factory3.defaultGraph();
    }
    if (original.termType === "Literal") {
      return factory3.literal(original.value, original.language || factory3.namedNode(original.datatype.value));
    }
    if (original.termType === "NamedNode") {
      return factory3.namedNode(original.value);
    }
    if (original.termType === "Quad") {
      const subject = factory3.fromTerm(original.subject);
      const predicate = factory3.fromTerm(original.predicate);
      const object = factory3.fromTerm(original.object);
      const graph2 = factory3.fromTerm(original.graph);
      return factory3.quad(subject, predicate, object, graph2);
    }
    if (original.termType === "Variable") {
      return factory3.variable(original.value);
    }
    throw new Error(`unknown termType ${original.termType}`);
  }
  var fromTerm_default;
  var init_fromTerm = __esm({
    "node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/fromTerm.js"() {
      init_shim();
      fromTerm_default = fromTerm;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/Literal.js
  var Literal, Literal_default;
  var init_Literal = __esm({
    "node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/Literal.js"() {
      init_shim();
      Literal = class {
        constructor(value, language, datatype) {
          this.value = value;
          this.language = language;
          this.datatype = datatype;
        }
        equals(other) {
          return !!other && other.termType === this.termType && other.value === this.value && other.language === this.language && other.datatype.equals(this.datatype);
        }
      };
      Literal.prototype.termType = "Literal";
      Literal_default = Literal;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/NamedNode.js
  var NamedNode, NamedNode_default;
  var init_NamedNode = __esm({
    "node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/NamedNode.js"() {
      init_shim();
      NamedNode = class {
        constructor(iri) {
          this.value = iri;
        }
        equals(other) {
          return !!other && other.termType === this.termType && other.value === this.value;
        }
      };
      NamedNode.prototype.termType = "NamedNode";
      NamedNode_default = NamedNode;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/Quad.js
  var Quad, Quad_default;
  var init_Quad = __esm({
    "node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/Quad.js"() {
      init_shim();
      Quad = class {
        constructor(subject, predicate, object, graph2) {
          this.subject = subject;
          this.predicate = predicate;
          this.object = object;
          this.graph = graph2;
        }
        equals(other) {
          return !!other && (other.termType === "Quad" || !other.termType) && other.subject.equals(this.subject) && other.predicate.equals(this.predicate) && other.object.equals(this.object) && other.graph.equals(this.graph);
        }
      };
      Quad.prototype.termType = "Quad";
      Quad.prototype.value = "";
      Quad_default = Quad;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/Variable.js
  var Variable, Variable_default;
  var init_Variable = __esm({
    "node_modules/rdf-ext/node_modules/@rdfjs/data-model/lib/Variable.js"() {
      init_shim();
      Variable = class {
        constructor(name) {
          this.value = name;
        }
        equals(other) {
          return !!other && other.termType === this.termType && other.value === this.value;
        }
      };
      Variable.prototype.termType = "Variable";
      Variable_default = Variable;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/data-model/Factory.js
  var langStringDatatype, stringDatatype, DataFactory, Factory_default2;
  var init_Factory2 = __esm({
    "node_modules/rdf-ext/node_modules/@rdfjs/data-model/Factory.js"() {
      init_shim();
      init_BlankNode();
      init_DefaultGraph();
      init_fromTerm();
      init_Literal();
      init_NamedNode();
      init_Quad();
      init_Variable();
      langStringDatatype = new NamedNode_default("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString");
      stringDatatype = new NamedNode_default("http://www.w3.org/2001/XMLSchema#string");
      DataFactory = class {
        constructor() {
          this.init();
        }
        init() {
          this._data = {
            blankNodeCounter: 0,
            defaultGraph: new DefaultGraph_default()
          };
        }
        namedNode(value) {
          return new NamedNode_default(value);
        }
        blankNode(value) {
          value = value || "b" + ++this._data.blankNodeCounter;
          return new BlankNode_default(value);
        }
        literal(value, languageOrDatatype) {
          if (typeof languageOrDatatype === "string") {
            return new Literal_default(value, languageOrDatatype, langStringDatatype);
          } else {
            return new Literal_default(value, "", languageOrDatatype || stringDatatype);
          }
        }
        variable(value) {
          return new Variable_default(value);
        }
        defaultGraph() {
          return this._data.defaultGraph;
        }
        quad(subject, predicate, object, graph2 = this.defaultGraph()) {
          return new Quad_default(subject, predicate, object, graph2);
        }
        fromTerm(original) {
          return fromTerm_default(this, original);
        }
        fromQuad(original) {
          return fromTerm_default(this, original);
        }
      };
      DataFactory.exports = [
        "blankNode",
        "defaultGraph",
        "fromQuad",
        "fromTerm",
        "literal",
        "namedNode",
        "quad",
        "variable"
      ];
      Factory_default2 = DataFactory;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/data-model/index.js
  var factory, data_model_default;
  var init_data_model = __esm({
    "node_modules/rdf-ext/node_modules/@rdfjs/data-model/index.js"() {
      init_shim();
      init_Factory2();
      factory = new Factory_default2();
      data_model_default = factory;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/namespace/index.js
  function namespace(baseIRI, { factory: factory3 = data_model_default } = {}) {
    const builder = (term = "") => factory3.namedNode(`${baseIRI}${term.raw || term}`);
    return typeof Proxy === "undefined" ? builder : new Proxy(builder, handler);
  }
  var handler, namespace_default;
  var init_namespace = __esm({
    "node_modules/rdf-ext/node_modules/@rdfjs/namespace/index.js"() {
      init_shim();
      init_data_model();
      handler = {
        apply: (target, thisArg, args) => target(args[0]),
        get: (target, property) => target(property)
      };
      namespace_default = namespace;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/namespace/Factory.js
  var Factory, Factory_default3;
  var init_Factory3 = __esm({
    "node_modules/rdf-ext/node_modules/@rdfjs/namespace/Factory.js"() {
      init_shim();
      init_namespace();
      Factory = class {
        namespace(baseIRI) {
          return namespace_default(baseIRI, { factory: this });
        }
      };
      Factory.exports = ["namespace"];
      Factory_default3 = Factory;
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser5 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list4 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_shim();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer3 = _require.Buffer;
      var _require2 = require_util2();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer3.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer3.alloc(0);
            var ret = Buffer3.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer3.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy5 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              import_process.default.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              import_process.default.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            import_process.default.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/errors-browser.js
  var require_errors_browser4 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_shim();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state4 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_INVALID_OPT_VALUE = require_errors_browser4().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable5 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser5();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy5();
      var _require = require_state4();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser4().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex5();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex5();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          import_process.default.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding2, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer3.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (isBuf)
          encoding2 = "buffer";
        else if (!encoding2)
          encoding2 = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ending)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding2, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
        if (typeof encoding2 === "string")
          encoding2 = encoding2.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding2);
        this._writableState.defaultEncoding = encoding2;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding2) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer3.from(chunk, encoding2);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding2, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding2);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding2 = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding: encoding2,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding2, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding2, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          import_process.default.nextTick(cb, er);
          import_process.default.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished4 = needFinish(state) || stream.destroyed;
          if (!finished4 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            import_process.default.nextTick(afterWrite, stream, state, finished4, cb);
          } else {
            afterWrite(stream, state, finished4, cb);
          }
        }
      }
      function afterWrite(stream, state, finished4, cb) {
        if (!finished4)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding2 = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding2, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding2, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding2 = null;
        } else if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding2);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            import_process.default.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            import_process.default.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex5 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var Readable5 = require_stream_readable5();
      var Writable = require_stream_writable5();
      require_inherits_browser()(Duplex, Readable5);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable5.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended)
          return;
        import_process.default.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream4 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser4().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once2(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator4 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_shim();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished4 = require_end_of_stream4();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        import_process.default.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              import_process.default.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished4(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser4 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_shim();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable5 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Readable5;
      var Duplex;
      Readable5.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser5();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list4();
      var destroyImpl = require_destroy5();
      var _require = require_state4();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser4().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable5, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex5();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder2().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable5(options) {
        Duplex = Duplex || require_stream_duplex5();
        if (!(this instanceof Readable5))
          return new Readable5(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable5.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable5.prototype.destroy = destroyImpl.destroy;
      Readable5.prototype._undestroy = destroyImpl.undestroy;
      Readable5.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable5.prototype.push = function(chunk, encoding2) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding2 = encoding2 || state.defaultEncoding;
            if (encoding2 !== state.encoding) {
              chunk = Buffer3.from(chunk, encoding2);
              encoding2 = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
      };
      Readable5.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding2) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable5.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable5.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable5.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          import_process.default.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          import_process.default.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable5.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable5.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          import_process.default.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable5.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable5.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              import_process.default.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable5.prototype.addListener = Readable5.prototype.on;
      Readable5.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable5.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable5.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          import_process.default.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable5.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable5.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable5.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator4();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable5.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableBuffer", {
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableFlowing", {
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable5._fromList = fromList;
      Object.defineProperty(Readable5.prototype, "readableLength", {
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          import_process.default.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable5.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser4();
          }
          return from(Readable5, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform5 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform;
      var _require$codes = require_errors_browser4().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex5();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding2) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding2);
      };
      Transform.prototype._transform = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding2, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding2;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough5 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough;
      var Transform = require_stream_transform5();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding2, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline4 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_shim();
      var eos;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser4().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once2(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream4();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/@rdfjs/prefix-map/node_modules/readable-stream/readable-browser.js
  var require_readable_browser4 = __commonJS({
    "node_modules/@rdfjs/prefix-map/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_shim();
      exports = module.exports = require_stream_readable5();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable5();
      exports.Duplex = require_stream_duplex5();
      exports.Transform = require_stream_transform5();
      exports.PassThrough = require_stream_passthrough5();
      exports.finished = require_end_of_stream4();
      exports.pipeline = require_pipeline4();
    }
  });

  // node_modules/@rdfjs/prefix-map/PrefixMap.js
  var import_readable_stream5, PrefixMap, PrefixMap_default;
  var init_PrefixMap = __esm({
    "node_modules/@rdfjs/prefix-map/PrefixMap.js"() {
      init_shim();
      import_readable_stream5 = __toESM(require_readable_browser4(), 1);
      PrefixMap = class extends Map {
        constructor(prefixes = [], { factory: factory3 }) {
          super(prefixes);
          this.factory = factory3;
        }
        resolve(term) {
          if (term.value.includes("://")) {
            return null;
          }
          const [prefix, path] = term.value.split(":", 2);
          if (path === void 0) {
            return null;
          }
          if (!this.has(prefix)) {
            return null;
          }
          return this.factory.namedNode(`${this.get(prefix).value}${path}`);
        }
        shrink(term) {
          if (!term) {
            return null;
          }
          const [pair] = [...this].filter(([, namespace3]) => term.value.startsWith(namespace3.value)).sort((a, b) => b[1].value.length - a[1].value.length);
          if (pair === void 0) {
            return null;
          }
          return this.factory.namedNode(`${pair[0]}:${term.value.slice(pair[1].value.length)}`);
        }
        import(stream) {
          stream.on("prefix", (prefix, namespace3) => {
            this.set(prefix, namespace3);
          });
          return new Promise((resolve, reject) => {
            (0, import_readable_stream5.finished)(stream, (err) => {
              if (err) {
                reject(err);
              } else {
                resolve(this);
              }
            });
          });
        }
        export(stream) {
          for (const [prefix, namespace3] of this) {
            stream.emit("prefix", prefix, namespace3);
          }
          return this;
        }
      };
      PrefixMap_default = PrefixMap;
    }
  });

  // node_modules/@rdfjs/prefix-map/Factory.js
  var Factory2, Factory_default4;
  var init_Factory4 = __esm({
    "node_modules/@rdfjs/prefix-map/Factory.js"() {
      init_shim();
      init_PrefixMap();
      Factory2 = class {
        init() {
          this.prefixes = new PrefixMap_default([], { factory: this });
        }
        clone(original) {
          if (original.prefixes) {
            for (const [prefix, term] of original.prefixes) {
              this.prefixes.set(prefix, term);
            }
          }
        }
        prefixMap(prefixes) {
          return new PrefixMap_default(prefixes, { factory: this });
        }
      };
      Factory2.exports = ["prefixMap"];
      Factory_default4 = Factory2;
    }
  });

  // node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/blankNode.js
  var require_blankNode = __commonJS({
    "node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/blankNode.js"(exports, module) {
      init_shim();
      function blankNode(blankNode2) {
        return "_:" + blankNode2.value;
      }
      module.exports = blankNode;
    }
  });

  // node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/dataset.js
  var require_dataset = __commonJS({
    "node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/dataset.js"(exports, module) {
      init_shim();
      function dataset(dataset2, toNT10) {
        return [...dataset2].map((quad) => toNT10(quad)).join("\n") + "\n";
      }
      module.exports = dataset;
    }
  });

  // node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/defaultGraph.js
  var require_defaultGraph = __commonJS({
    "node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/defaultGraph.js"(exports, module) {
      init_shim();
      function defaultGraph() {
        return "";
      }
      module.exports = defaultGraph;
    }
  });

  // node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/namedNode.js
  var require_namedNode = __commonJS({
    "node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/namedNode.js"(exports, module) {
      init_shim();
      function namedNode(namedNode2) {
        return "<" + namedNode2.value + ">";
      }
      module.exports = namedNode;
    }
  });

  // node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/literal.js
  var require_literal = __commonJS({
    "node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/literal.js"(exports, module) {
      init_shim();
      var namedNode = require_namedNode();
      var echarRegEx = /["\\\\\n\r]/;
      var echarRegExAll = /["\\\\\n\r]/g;
      var echarReplacement = {
        '"': '\\"',
        "\\": "\\\\",
        "\n": "\\n",
        "\r": "\\r"
      };
      function echarReplacer(char) {
        return echarReplacement[char];
      }
      function escapeValue(value) {
        if (echarRegEx.test(value)) {
          return value.replace(echarRegExAll, echarReplacer);
        }
        return value;
      }
      function literal(literal2) {
        const escapedValue = escapeValue(literal2.value);
        if (literal2.datatype.value === "http://www.w3.org/2001/XMLSchema#string") {
          return '"' + escapedValue + '"';
        }
        if (literal2.datatype.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString") {
          return '"' + escapedValue + '"@' + literal2.language;
        }
        return '"' + escapedValue + '"^^' + namedNode(literal2.datatype);
      }
      module.exports = literal;
    }
  });

  // node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/quad.js
  var require_quad = __commonJS({
    "node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/quad.js"(exports, module) {
      init_shim();
      function quad(quad2, toNT10) {
        const subjectString = toNT10(quad2.subject);
        const predicateString = toNT10(quad2.predicate);
        const objectString = toNT10(quad2.object);
        const graphString = toNT10(quad2.graph);
        return `${subjectString} ${predicateString} ${objectString} ${graphString ? graphString + " " : ""}.`;
      }
      module.exports = quad;
    }
  });

  // node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/variable.js
  var require_variable = __commonJS({
    "node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/lib/variable.js"(exports, module) {
      init_shim();
      function variable(variable2) {
        return "?" + variable2.value;
      }
      module.exports = variable;
    }
  });

  // node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/index.js
  var require_to_ntriples = __commonJS({
    "node_modules/@rdfjs/term-map/node_modules/@rdfjs/to-ntriples/index.js"(exports, module) {
      init_shim();
      var blankNode = require_blankNode();
      var dataset = require_dataset();
      var defaultGraph = require_defaultGraph();
      var literal = require_literal();
      var namedNode = require_namedNode();
      var quad = require_quad();
      var variable = require_variable();
      function toNT10(term) {
        if (!term) {
          return null;
        }
        if (term.termType === "BlankNode") {
          return blankNode(term);
        }
        if (term.termType === "DefaultGraph") {
          return defaultGraph();
        }
        if (term.termType === "Literal") {
          return literal(term);
        }
        if (term.termType === "NamedNode") {
          return namedNode(term);
        }
        if (term.termType === "Quad" || term.subject && term.predicate && term.object && term.graph) {
          return quad(term, toNT10);
        }
        if (term.termType === "Variable") {
          return variable(term);
        }
        if (term[Symbol.iterator]) {
          return dataset(term, toNT10);
        }
        throw new Error(`unknown termType ${term.termType}`);
      }
      module.exports = toNT10;
    }
  });

  // node_modules/@rdfjs/term-map/TermMap.js
  var import_to_ntriples, TermMap, TermMap_default;
  var init_TermMap = __esm({
    "node_modules/@rdfjs/term-map/TermMap.js"() {
      init_shim();
      import_to_ntriples = __toESM(require_to_ntriples(), 1);
      TermMap = class {
        constructor(entries) {
          this.index = /* @__PURE__ */ new Map();
          if (entries) {
            for (const [term, value] of entries) {
              this.set(term, value);
            }
          }
        }
        get size() {
          return this.index.size;
        }
        clear() {
          this.index.clear();
        }
        delete(term) {
          return this.index.delete((0, import_to_ntriples.default)(term));
        }
        *entries() {
          for (const [, { term, value }] of this.index) {
            yield [term, value];
          }
        }
        forEach(callback, thisArg) {
          for (const entry of this.entries()) {
            callback.call(thisArg, entry[1], entry[0], this);
          }
        }
        get(term) {
          const item = this.index.get((0, import_to_ntriples.default)(term));
          return item && item.value;
        }
        has(term) {
          return this.index.has((0, import_to_ntriples.default)(term));
        }
        *keys() {
          for (const [, { term }] of this.index) {
            yield term;
          }
        }
        set(term, value) {
          const key = (0, import_to_ntriples.default)(term);
          this.index.set(key, { term, value });
          return this;
        }
        *values() {
          for (const [, { value }] of this.index) {
            yield value;
          }
        }
        [Symbol.iterator]() {
          return this.entries()[Symbol.iterator]();
        }
      };
      TermMap_default = TermMap;
    }
  });

  // node_modules/@rdfjs/term-map/Factory.js
  var Factory3, Factory_default5;
  var init_Factory5 = __esm({
    "node_modules/@rdfjs/term-map/Factory.js"() {
      init_shim();
      init_TermMap();
      Factory3 = class {
        termMap(entries) {
          return new TermMap_default(entries);
        }
      };
      Factory3.exports = ["termMap"];
      Factory_default5 = Factory3;
    }
  });

  // node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/blankNode.js
  var require_blankNode2 = __commonJS({
    "node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/blankNode.js"(exports, module) {
      init_shim();
      function blankNode(blankNode2) {
        return "_:" + blankNode2.value;
      }
      module.exports = blankNode;
    }
  });

  // node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/dataset.js
  var require_dataset2 = __commonJS({
    "node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/dataset.js"(exports, module) {
      init_shim();
      function dataset(dataset2, toNT10) {
        return [...dataset2].map((quad) => toNT10(quad)).join("\n") + "\n";
      }
      module.exports = dataset;
    }
  });

  // node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/defaultGraph.js
  var require_defaultGraph2 = __commonJS({
    "node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/defaultGraph.js"(exports, module) {
      init_shim();
      function defaultGraph() {
        return "";
      }
      module.exports = defaultGraph;
    }
  });

  // node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/namedNode.js
  var require_namedNode2 = __commonJS({
    "node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/namedNode.js"(exports, module) {
      init_shim();
      function namedNode(namedNode2) {
        return "<" + namedNode2.value + ">";
      }
      module.exports = namedNode;
    }
  });

  // node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/literal.js
  var require_literal2 = __commonJS({
    "node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/literal.js"(exports, module) {
      init_shim();
      var namedNode = require_namedNode2();
      var echarRegEx = /["\\\\\n\r]/;
      var echarRegExAll = /["\\\\\n\r]/g;
      var echarReplacement = {
        '"': '\\"',
        "\\": "\\\\",
        "\n": "\\n",
        "\r": "\\r"
      };
      function echarReplacer(char) {
        return echarReplacement[char];
      }
      function escapeValue(value) {
        if (echarRegEx.test(value)) {
          return value.replace(echarRegExAll, echarReplacer);
        }
        return value;
      }
      function literal(literal2) {
        const escapedValue = escapeValue(literal2.value);
        if (literal2.datatype.value === "http://www.w3.org/2001/XMLSchema#string") {
          return '"' + escapedValue + '"';
        }
        if (literal2.datatype.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString") {
          return '"' + escapedValue + '"@' + literal2.language;
        }
        return '"' + escapedValue + '"^^' + namedNode(literal2.datatype);
      }
      module.exports = literal;
    }
  });

  // node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/quad.js
  var require_quad2 = __commonJS({
    "node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/quad.js"(exports, module) {
      init_shim();
      function quad(quad2, toNT10) {
        const subjectString = toNT10(quad2.subject);
        const predicateString = toNT10(quad2.predicate);
        const objectString = toNT10(quad2.object);
        const graphString = toNT10(quad2.graph);
        return `${subjectString} ${predicateString} ${objectString} ${graphString ? graphString + " " : ""}.`;
      }
      module.exports = quad;
    }
  });

  // node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/variable.js
  var require_variable2 = __commonJS({
    "node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/lib/variable.js"(exports, module) {
      init_shim();
      function variable(variable2) {
        return "?" + variable2.value;
      }
      module.exports = variable;
    }
  });

  // node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/index.js
  var require_to_ntriples2 = __commonJS({
    "node_modules/@rdfjs/term-set/node_modules/@rdfjs/to-ntriples/index.js"(exports, module) {
      init_shim();
      var blankNode = require_blankNode2();
      var dataset = require_dataset2();
      var defaultGraph = require_defaultGraph2();
      var literal = require_literal2();
      var namedNode = require_namedNode2();
      var quad = require_quad2();
      var variable = require_variable2();
      function toNT10(term) {
        if (!term) {
          return null;
        }
        if (term.termType === "BlankNode") {
          return blankNode(term);
        }
        if (term.termType === "DefaultGraph") {
          return defaultGraph();
        }
        if (term.termType === "Literal") {
          return literal(term);
        }
        if (term.termType === "NamedNode") {
          return namedNode(term);
        }
        if (term.termType === "Quad" || term.subject && term.predicate && term.object && term.graph) {
          return quad(term, toNT10);
        }
        if (term.termType === "Variable") {
          return variable(term);
        }
        if (term[Symbol.iterator]) {
          return dataset(term, toNT10);
        }
        throw new Error(`unknown termType ${term.termType}`);
      }
      module.exports = toNT10;
    }
  });

  // node_modules/@rdfjs/term-set/TermSet.js
  function quietToNT(term) {
    try {
      return (0, import_to_ntriples2.default)(term);
    } catch (err) {
      return null;
    }
  }
  var import_to_ntriples2, TermSet, TermSet_default;
  var init_TermSet = __esm({
    "node_modules/@rdfjs/term-set/TermSet.js"() {
      init_shim();
      import_to_ntriples2 = __toESM(require_to_ntriples2(), 1);
      TermSet = class {
        constructor(terms) {
          this.index = /* @__PURE__ */ new Map();
          if (terms) {
            for (const term of terms) {
              this.add(term);
            }
          }
        }
        get size() {
          return this.index.size;
        }
        add(term) {
          const key = (0, import_to_ntriples2.default)(term);
          if (!this.index.has(key)) {
            this.index.set(key, term);
          }
          return this;
        }
        clear() {
          this.index.clear();
        }
        delete(term) {
          if (!term) {
            return false;
          }
          return this.index.delete(quietToNT(term));
        }
        entries() {
          return this.values().entries();
        }
        forEach(callbackfn, thisArg) {
          return this.values().forEach(callbackfn, thisArg);
        }
        has(term) {
          if (!term) {
            return false;
          }
          return this.index.has(quietToNT(term));
        }
        values() {
          return new Set(this.index.values());
        }
        keys() {
          return this.values();
        }
        [Symbol.iterator]() {
          return this.values()[Symbol.iterator]();
        }
      };
      TermSet_default = TermSet;
    }
  });

  // node_modules/@rdfjs/term-set/Factory.js
  var Factory4, Factory_default6;
  var init_Factory6 = __esm({
    "node_modules/@rdfjs/term-set/Factory.js"() {
      init_shim();
      init_TermSet();
      Factory4 = class {
        termSet(terms) {
          return new TermSet_default(terms);
        }
      };
      Factory4.exports = ["termSet"];
      Factory_default6 = Factory4;
    }
  });

  // node_modules/@rdfjs/traverser/Traverser.js
  function forEach({ backward, callback, dataset, filter, forward, term, visited }) {
    const next = (term2, level) => {
      const checkMatches = (matches) => {
        for (const quad of matches) {
          if (visited.has(quad)) {
            continue;
          }
          visited.add(quad);
          const args = { dataset, level, quad };
          if (filter(args)) {
            callback(args);
            if (forward) {
              next(quad.object, level + 1);
            }
            if (backward) {
              next(quad.subject, level + 1);
            }
          }
        }
      };
      if (forward) {
        checkMatches(dataset.match(term2));
      }
      if (backward) {
        checkMatches(dataset.match(null, null, term2));
      }
    };
    next(term, 0);
  }
  var Traverser, Traverser_default;
  var init_Traverser = __esm({
    "node_modules/@rdfjs/traverser/Traverser.js"() {
      init_shim();
      Traverser = class {
        constructor(filter, { backward = false, factory: factory3, forward = true }) {
          this.backward = backward;
          this.factory = factory3;
          this.filter = filter;
          this.forward = forward;
        }
        forEach({ term, dataset }, callback) {
          forEach({
            backward: this.backward,
            callback,
            dataset,
            filter: this.filter,
            forward: this.forward,
            term,
            visited: this.factory.dataset()
          });
        }
        match({ term, dataset }) {
          const result = this.factory.dataset();
          forEach({
            backward: this.backward,
            callback: ({ quad }) => result.add(quad),
            dataset,
            filter: this.filter,
            forward: this.forward,
            term,
            visited: this.factory.dataset()
          });
          return result;
        }
        reduce({ term, dataset }, callback, initialValue) {
          let result = initialValue;
          forEach({
            backward: this.backward,
            callback: (args) => {
              result = callback(args, result);
            },
            dataset,
            filter: this.filter,
            forward: this.forward,
            term,
            visited: this.factory.dataset()
          });
          return result;
        }
      };
      Traverser_default = Traverser;
    }
  });

  // node_modules/@rdfjs/traverser/Factory.js
  var Factory5, Factory_default7;
  var init_Factory7 = __esm({
    "node_modules/@rdfjs/traverser/Factory.js"() {
      init_shim();
      init_Traverser();
      Factory5 = class {
        traverser(filter, { backward = false, forward = true } = {}) {
          return new Traverser_default(filter, { backward, factory: this, forward });
        }
      };
      Factory5.exports = ["traverser"];
      Factory_default7 = Factory5;
    }
  });

  // node_modules/@rdfjs/data-model/lib/BlankNode.js
  var require_BlankNode = __commonJS({
    "node_modules/@rdfjs/data-model/lib/BlankNode.js"(exports, module) {
      init_shim();
      var BlankNode3 = class {
        constructor(id) {
          this.value = id || "b" + ++BlankNode3.nextId;
        }
        equals(other) {
          return !!other && other.termType === this.termType && other.value === this.value;
        }
      };
      BlankNode3.prototype.termType = "BlankNode";
      BlankNode3.nextId = 0;
      module.exports = BlankNode3;
    }
  });

  // node_modules/@rdfjs/data-model/lib/DefaultGraph.js
  var require_DefaultGraph = __commonJS({
    "node_modules/@rdfjs/data-model/lib/DefaultGraph.js"(exports, module) {
      init_shim();
      var DefaultGraph3 = class {
        equals(other) {
          return !!other && other.termType === this.termType;
        }
      };
      DefaultGraph3.prototype.termType = "DefaultGraph";
      DefaultGraph3.prototype.value = "";
      module.exports = DefaultGraph3;
    }
  });

  // node_modules/@rdfjs/data-model/lib/fromTerm.js
  var require_fromTerm = __commonJS({
    "node_modules/@rdfjs/data-model/lib/fromTerm.js"(exports, module) {
      init_shim();
      function fromTerm2(original) {
        if (!original) {
          return null;
        }
        if (original.termType === "BlankNode") {
          return this.blankNode(original.value);
        }
        if (original.termType === "DefaultGraph") {
          return this.defaultGraph();
        }
        if (original.termType === "Literal") {
          return this.literal(original.value, original.language || this.namedNode(original.datatype.value));
        }
        if (original.termType === "NamedNode") {
          return this.namedNode(original.value);
        }
        if (original.termType === "Quad") {
          const subject = this.fromTerm(original.subject);
          const predicate = this.fromTerm(original.predicate);
          const object = this.fromTerm(original.object);
          const graph2 = this.fromTerm(original.graph);
          return this.quad(subject, predicate, object, graph2);
        }
        if (original.termType === "Variable") {
          return this.variable(original.value);
        }
        throw new Error(`unknown termType ${original.termType}`);
      }
      module.exports = fromTerm2;
    }
  });

  // node_modules/@rdfjs/data-model/lib/NamedNode.js
  var require_NamedNode = __commonJS({
    "node_modules/@rdfjs/data-model/lib/NamedNode.js"(exports, module) {
      init_shim();
      var NamedNode3 = class {
        constructor(iri) {
          this.value = iri;
        }
        equals(other) {
          return !!other && other.termType === this.termType && other.value === this.value;
        }
      };
      NamedNode3.prototype.termType = "NamedNode";
      module.exports = NamedNode3;
    }
  });

  // node_modules/@rdfjs/data-model/lib/Literal.js
  var require_Literal = __commonJS({
    "node_modules/@rdfjs/data-model/lib/Literal.js"(exports, module) {
      init_shim();
      var NamedNode3 = require_NamedNode();
      var Literal3 = class {
        constructor(value, language, datatype) {
          this.value = value;
          this.datatype = Literal3.stringDatatype;
          this.language = "";
          if (language) {
            this.language = language;
            this.datatype = Literal3.langStringDatatype;
          } else if (datatype) {
            this.datatype = datatype;
          }
        }
        equals(other) {
          return !!other && other.termType === this.termType && other.value === this.value && other.language === this.language && other.datatype.equals(this.datatype);
        }
      };
      Literal3.prototype.termType = "Literal";
      Literal3.langStringDatatype = new NamedNode3("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString");
      Literal3.stringDatatype = new NamedNode3("http://www.w3.org/2001/XMLSchema#string");
      module.exports = Literal3;
    }
  });

  // node_modules/@rdfjs/data-model/lib/Quad.js
  var require_Quad = __commonJS({
    "node_modules/@rdfjs/data-model/lib/Quad.js"(exports, module) {
      init_shim();
      var DefaultGraph3 = require_DefaultGraph();
      var Quad3 = class {
        constructor(subject, predicate, object, graph2) {
          this.subject = subject;
          this.predicate = predicate;
          this.object = object;
          if (graph2) {
            this.graph = graph2;
          } else {
            this.graph = new DefaultGraph3();
          }
        }
        equals(other) {
          return !!other && (other.termType === "Quad" || !other.termType) && other.subject.equals(this.subject) && other.predicate.equals(this.predicate) && other.object.equals(this.object) && other.graph.equals(this.graph);
        }
      };
      Quad3.prototype.termType = "Quad";
      Quad3.prototype.value = "";
      module.exports = Quad3;
    }
  });

  // node_modules/@rdfjs/data-model/lib/Variable.js
  var require_Variable = __commonJS({
    "node_modules/@rdfjs/data-model/lib/Variable.js"(exports, module) {
      init_shim();
      var Variable3 = class {
        constructor(name) {
          this.value = name;
        }
        equals(other) {
          return !!other && other.termType === this.termType && other.value === this.value;
        }
      };
      Variable3.prototype.termType = "Variable";
      module.exports = Variable3;
    }
  });

  // node_modules/@rdfjs/data-model/lib/DataFactory.js
  var require_DataFactory = __commonJS({
    "node_modules/@rdfjs/data-model/lib/DataFactory.js"(exports, module) {
      init_shim();
      var BlankNode3 = require_BlankNode();
      var DefaultGraph3 = require_DefaultGraph();
      var fromTermRaw = require_fromTerm();
      var Literal3 = require_Literal();
      var NamedNode3 = require_NamedNode();
      var Quad3 = require_Quad();
      var Variable3 = require_Variable();
      function namedNode(value) {
        return new NamedNode3(value);
      }
      function blankNode(value) {
        return new BlankNode3(value);
      }
      function literal(value, languageOrDatatype) {
        if (typeof languageOrDatatype === "string") {
          if (languageOrDatatype.indexOf(":") === -1) {
            return new Literal3(value, languageOrDatatype);
          }
          return new Literal3(value, null, DataFactory3.namedNode(languageOrDatatype));
        }
        return new Literal3(value, null, languageOrDatatype);
      }
      function variable(value) {
        return new Variable3(value);
      }
      function defaultGraph() {
        return DataFactory3.defaultGraphInstance;
      }
      function triple6(subject, predicate, object) {
        return DataFactory3.quad(subject, predicate, object);
      }
      function quad(subject, predicate, object, graph2) {
        return new Quad3(subject, predicate, object, graph2 || DataFactory3.defaultGraphInstance);
      }
      function fromTerm2(original) {
        return fromTermRaw.call(DataFactory3, original);
      }
      function fromQuad(original) {
        return fromTermRaw.call(DataFactory3, original);
      }
      var DataFactory3 = {
        namedNode,
        blankNode,
        literal,
        variable,
        defaultGraph,
        triple: triple6,
        quad,
        fromTerm: fromTerm2,
        fromQuad,
        defaultGraphInstance: new DefaultGraph3()
      };
      module.exports = DataFactory3;
    }
  });

  // node_modules/@rdfjs/data-model/index.js
  var require_data_model = __commonJS({
    "node_modules/@rdfjs/data-model/index.js"(exports, module) {
      init_shim();
      var DataFactory3 = require_DataFactory();
      module.exports = DataFactory3;
    }
  });

  // node_modules/@rdfjs/namespace/index.js
  var require_namespace = __commonJS({
    "node_modules/@rdfjs/namespace/index.js"(exports, module) {
      init_shim();
      var rdf = require_data_model();
      var handler2 = {
        apply: (target, thisArg, args) => target(args[0]),
        get: (target, property) => target(property)
      };
      function namespace3(baseIRI, { factory: factory3 = rdf } = {}) {
        const builder = (term = "") => factory3.namedNode(`${baseIRI}${term.raw || term}`);
        return typeof Proxy === "undefined" ? builder : new Proxy(builder, handler2);
      }
      module.exports = namespace3;
    }
  });

  // node_modules/clownface/lib/namespace.js
  var require_namespace2 = __commonJS({
    "node_modules/clownface/lib/namespace.js"(exports, module) {
      init_shim();
      var namespace3 = require_namespace();
      var ns = (factory3) => {
        const xsd = namespace3("http://www.w3.org/2001/XMLSchema#", { factory: factory3 });
        const rdf = namespace3("http://www.w3.org/1999/02/22-rdf-syntax-ns#", { factory: factory3 });
        return {
          first: rdf.first,
          nil: rdf.nil,
          rest: rdf.rest,
          langString: rdf.langString,
          xsd
        };
      };
      module.exports = ns;
    }
  });

  // node_modules/clownface/lib/toArray.js
  var require_toArray = __commonJS({
    "node_modules/clownface/lib/toArray.js"(exports, module) {
      init_shim();
      function toArray(value, defaultValue) {
        if (typeof value === "undefined" || value === null) {
          return defaultValue;
        }
        if (Array.isArray(value)) {
          return value;
        }
        if (typeof value !== "string" && value[Symbol.iterator]) {
          return [...value];
        }
        return [value];
      }
      module.exports = toArray;
    }
  });

  // node_modules/clownface/lib/fromPrimitive.js
  var require_fromPrimitive = __commonJS({
    "node_modules/clownface/lib/fromPrimitive.js"(exports, module) {
      init_shim();
      var rdf = require_data_model();
      var namespace3 = require_namespace2();
      var { xsd } = namespace3(rdf);
      function booleanToLiteral(value, factory3 = rdf) {
        if (typeof value !== "boolean") {
          return null;
        }
        return factory3.literal(value.toString(), xsd("boolean"));
      }
      function numberToLiteral(value, factory3 = rdf) {
        if (typeof value !== "number") {
          return null;
        }
        if (Number.isInteger(value)) {
          return factory3.literal(value.toString(10), xsd("integer"));
        }
        return factory3.literal(value.toString(10), xsd("double"));
      }
      function stringToLiteral(value, factory3 = rdf) {
        if (typeof value !== "string") {
          return null;
        }
        return factory3.literal(value);
      }
      function toLiteral(value, factory3 = rdf) {
        return booleanToLiteral(value, factory3) || numberToLiteral(value, factory3) || stringToLiteral(value, factory3);
      }
      module.exports = {
        booleanToLiteral,
        numberToLiteral,
        stringToLiteral,
        toLiteral
      };
    }
  });

  // node_modules/clownface/lib/term.js
  var require_term = __commonJS({
    "node_modules/clownface/lib/term.js"(exports, module) {
      init_shim();
      var { toLiteral } = require_fromPrimitive();
      function blankNode(value, factory3) {
        if (value && typeof value !== "string") {
          throw new Error("Blank node identifier must be a string");
        }
        return factory3.blankNode(value);
      }
      function literal(value, languageOrDatatype, factory3) {
        if (typeof value === "string") {
          languageOrDatatype = languageOrDatatype && (languageOrDatatype.value || languageOrDatatype.toString());
          if (languageOrDatatype && languageOrDatatype.indexOf(":") !== -1) {
            languageOrDatatype = factory3.namedNode(languageOrDatatype);
          }
          return factory3.literal(value.toString(), languageOrDatatype);
        }
        const term2 = toLiteral(value, factory3);
        if (!term2) {
          throw new Error("The value cannot be converted to a literal node");
        }
        return term2;
      }
      function namedNode(value, factory3) {
        if (typeof value !== "string") {
          throw new Error("Named node must be an IRI string");
        }
        return factory3.namedNode(value);
      }
      function term(value, type = "Literal", languageOrDatatype, factory3) {
        if (value && typeof value === "object" && value.termType) {
          return value;
        }
        if (value && value.constructor.name === "URL") {
          return namedNode(value.toString(), factory3);
        }
        if (type === "BlankNode") {
          return blankNode(value, factory3);
        }
        if (value === null || typeof value === "undefined") {
          return void 0;
        }
        if (type === "Literal") {
          return literal(value, languageOrDatatype, factory3);
        }
        if (type === "NamedNode") {
          return namedNode(value, factory3);
        }
        throw new Error("unknown type");
      }
      module.exports = term;
    }
  });

  // node_modules/clownface/lib/toTermArray.js
  var require_toTermArray = __commonJS({
    "node_modules/clownface/lib/toTermArray.js"(exports, module) {
      init_shim();
      var term = require_term();
      var toArray = require_toArray();
      function toTermArray(items, type, languageOrDatatype, factory3) {
        if ((typeof items === "undefined" || items === null) && !type) {
          return items;
        }
        return (toArray(items) || [void 0]).reduce((all, item) => {
          if (typeof item === "object" && item.terms) {
            return all.concat(item.terms);
          }
          all.push(term(item, type, languageOrDatatype, factory3));
          return all;
        }, []);
      }
      module.exports = toTermArray;
    }
  });

  // node_modules/clownface/lib/languageTag.js
  var require_languageTag = __commonJS({
    "node_modules/clownface/lib/languageTag.js"(exports, module) {
      init_shim();
      var RDF = require_data_model();
      var namespace3 = require_namespace2();
      var ns = namespace3(RDF);
      function mapLiteralsByLanguage(map, current) {
        const notLiteral = current.termType !== "Literal";
        const notStringLiteral = ns.langString.equals(current.datatype) || ns.xsd.string.equals(current.datatype);
        if (notLiteral || !notStringLiteral)
          return map;
        const language = current.language.toLowerCase();
        if (map.has(language)) {
          map.get(language).push(current);
        } else {
          map.set(language, [current]);
        }
        return map;
      }
      function createLanguageMapper(objects) {
        const literalsByLanguage = objects.reduce(mapLiteralsByLanguage, /* @__PURE__ */ new Map());
        const langMapEntries = [...literalsByLanguage.entries()];
        return (language) => {
          const languageLowerCase = language.toLowerCase();
          if (languageLowerCase === "*") {
            return langMapEntries[0] && langMapEntries[0][1];
          }
          const exactMatch = literalsByLanguage.get(languageLowerCase);
          if (exactMatch) {
            return exactMatch;
          }
          const secondaryMatches = langMapEntries.find(([entryLanguage]) => entryLanguage.startsWith(languageLowerCase));
          return secondaryMatches && secondaryMatches[1];
        };
      }
      function filterTaggedLiterals(terms, { language }) {
        const languages = typeof language === "string" ? [language] : language;
        const getLiteralsForLanguage = createLanguageMapper(terms);
        return languages.map(getLiteralsForLanguage).find(Boolean) || [];
      }
      module.exports = {
        filterTaggedLiterals
      };
    }
  });

  // node_modules/clownface/lib/Context.js
  var require_Context = __commonJS({
    "node_modules/clownface/lib/Context.js"(exports, module) {
      init_shim();
      var term = require_term();
      var toArray = require_toArray();
      var { filterTaggedLiterals } = require_languageTag();
      var Context2 = class {
        constructor({ dataset, graph: graph2, value, factory: factory3, namespace: namespace3 }) {
          this.dataset = dataset;
          this.graph = graph2;
          this.factory = factory3;
          this.namespace = namespace3;
          this.term = term(value, void 0, void 0, factory3);
        }
        clone({ dataset = this.dataset, graph: graph2 = this.graph, value, factory: factory3 = this.factory, namespace: namespace3 = this.namespace }) {
          return new Context2({ dataset, graph: graph2, value, factory: factory3, namespace: namespace3 });
        }
        has(predicate, object) {
          return this.matchProperty(toArray(this.term), predicate, object, toArray(this.graph), "subject").map((subject) => {
            return this.clone({ value: subject });
          });
        }
        in(predicate) {
          return this.matchProperty(null, predicate, toArray(this.term), toArray(this.graph), "subject").map((subject) => {
            return this.clone({ value: subject });
          });
        }
        out(predicate, { language } = {}) {
          let objects = this.matchProperty(toArray(this.term), predicate, null, toArray(this.graph), "object");
          if (typeof language !== "undefined") {
            objects = filterTaggedLiterals(objects, { language });
          }
          return objects.map((object) => {
            return this.clone({ value: object });
          });
        }
        addIn(predicates, subjects) {
          const context = [];
          if (this.term) {
            subjects.forEach((subject) => {
              predicates.forEach((predicate) => {
                this.dataset.add(this.factory.quad(subject, predicate, this.term, this.graph));
              });
              context.push(this.clone({ value: subject }));
            });
          }
          return context;
        }
        addOut(predicates, objects) {
          const context = [];
          if (this.term) {
            objects.forEach((object) => {
              predicates.forEach((predicate) => {
                this.dataset.add(this.factory.quad(this.term, predicate, object, this.graph));
              });
              context.push(this.clone({ value: object }));
            });
          }
          return context;
        }
        addList(predicates, items) {
          if (!this.term) {
            return;
          }
          predicates.forEach((predicate) => {
            const nodes = items.map(() => this.factory.blankNode());
            this.dataset.add(this.factory.quad(this.term, predicate, nodes[0] || this.namespace.nil, this.graph));
            for (let index = 0; index < nodes.length; index++) {
              this.dataset.add(this.factory.quad(nodes[index], this.namespace.first, items[index], this.graph));
              this.dataset.add(this.factory.quad(nodes[index], this.namespace.rest, nodes[index + 1] || this.namespace.nil, this.graph));
            }
          });
        }
        deleteIn(predicate, subject) {
          this.deleteMatch(subject, predicate, toArray(this.term), toArray(this.graph));
        }
        deleteOut(predicate, objects) {
          this.deleteMatch(toArray(this.term), predicate, objects, toArray(this.graph));
        }
        deleteList(predicates) {
          predicates.forEach((predicate) => {
            for (const quad of this.dataset.match(this.term, predicate)) {
              this.deleteItems(quad);
            }
          });
        }
        deleteItems(start) {
          let quads = [start];
          while (!quads[quads.length - 1].object.equals(this.namespace.nil)) {
            const node19 = quads[quads.length - 1].object;
            quads = quads.concat([...this.dataset.match(node19)]);
          }
          quads.forEach((quad) => {
            this.dataset.delete(quad);
          });
        }
        match(subject, predicate, object, graph2) {
          if (!subject && !predicate && !object && !graph2) {
            return [...this.dataset];
          }
          subject = subject || [null];
          predicate = predicate || [null];
          object = object || [null];
          graph2 = graph2 || [null];
          const matches = [];
          for (const g of graph2) {
            for (const s of subject) {
              for (const p of predicate) {
                for (const o of object) {
                  for (const quad of this.dataset.match(s, p, o, g)) {
                    matches.push(quad);
                  }
                }
              }
            }
          }
          return matches;
        }
        matchProperty(subject, predicate, object, graph2, property) {
          return this.match(subject, predicate, object, graph2).map((quad) => quad[property]);
        }
        deleteMatch(subject, predicate, object, graph2) {
          this.match(subject, predicate, object, graph2).forEach((quad) => {
            this.dataset.delete(quad);
          });
        }
      };
      module.exports = Context2;
    }
  });

  // node_modules/clownface/lib/Clownface.js
  var require_Clownface = __commonJS({
    "node_modules/clownface/lib/Clownface.js"(exports, module) {
      init_shim();
      var rdf = require_data_model();
      var ns = require_namespace2();
      var toArray = require_toArray();
      var toTermArray = require_toTermArray();
      var Context2 = require_Context();
      var Clownface = class {
        constructor({ dataset, graph: graph2, term, value, factory: factory3 = rdf, _context }) {
          this.factory = factory3;
          this.namespace = ns(factory3);
          if (_context) {
            this._context = _context;
            return;
          }
          const terms = term && toArray(term) || value && toArray(value) || [null];
          this._context = terms.map((term2) => {
            return new Context2({ dataset, graph: graph2, value: term2, factory: this.factory, namespace: this.namespace });
          });
        }
        get term() {
          const terms = this.terms;
          if (terms.length !== 1) {
            return void 0;
          }
          return terms[0];
        }
        get terms() {
          return this._context.map((node19) => node19.term).filter(Boolean);
        }
        get value() {
          const term = this.term;
          return term && term.value;
        }
        get values() {
          return this.terms.map((term) => term.value);
        }
        get dataset() {
          const datasets = this.datasets;
          if (datasets.length !== 1) {
            return void 0;
          }
          return datasets[0];
        }
        get datasets() {
          return this._context.map((node19) => node19.dataset).filter(Boolean);
        }
        any() {
          return Clownface.fromContext(this._context.map((current) => current.clone({})));
        }
        isList() {
          if (!this.term) {
            return false;
          }
          if (this.term.equals(this.namespace.nil)) {
            return true;
          }
          if (this.out(this.namespace.first).term) {
            return true;
          }
          return false;
        }
        list() {
          if (this.terms.length > 1) {
            throw new Error("iterator over multiple terms is not supported");
          }
          if (this.term) {
            if (this.term.termType !== "NamedNode" && this.term.termType !== "BlankNode") {
              return null;
            }
            if (!this.term.equals(this.namespace.nil) && !this.out(this.namespace.first).term) {
              return null;
            }
          }
          let item = this;
          return {
            [Symbol.iterator]: () => {
              return {
                next: () => {
                  if (!item.term || item.term.equals(this.namespace.nil)) {
                    return { done: true };
                  }
                  const value = item.out(this.namespace.first);
                  if (value.terms.length > 1) {
                    throw new Error(`Invalid list: multiple values for rdf:first on ${item.value}`);
                  }
                  const rest = item.out(this.namespace.rest);
                  if (rest.terms.length > 1) {
                    throw new Error(`Invalid list: multiple values for rdf:rest on ${item.value}`);
                  }
                  item = rest;
                  return { done: false, value };
                }
              };
            }
          };
        }
        toArray() {
          return this._context.map((context) => Clownface.fromContext(context)).filter((context) => context.terms.some(Boolean));
        }
        filter(callback) {
          const pointers = this._context.map((context) => Clownface.fromContext(context));
          return Clownface.fromContext(this._context.filter((context, index) => callback(Clownface.fromContext(context), index, pointers)));
        }
        forEach(callback) {
          this.toArray().forEach(callback);
          return this;
        }
        map(callback) {
          return this.toArray().map(callback);
        }
        toString() {
          return this.values.join();
        }
        node(values, { type, datatype, language } = {}) {
          values = this._toTermArray(values, type, datatype || language) || [null];
          const context = values.reduce((context2, value) => {
            return context2.concat(this._context.reduce((all, current) => {
              return all.concat([current.clone({ value })]);
            }, []));
          }, []);
          return Clownface.fromContext(context);
        }
        blankNode(values) {
          return this.node(values, { type: "BlankNode" });
        }
        literal(values, languageOrDatatype) {
          return this.node(values, { type: "Literal", datatype: languageOrDatatype });
        }
        namedNode(values) {
          return this.node(values, { type: "NamedNode" });
        }
        in(predicates) {
          predicates = this._toTermArray(predicates);
          const context = this._context.reduce((all, current) => all.concat(current.in(predicates)), []);
          return Clownface.fromContext(context);
        }
        out(predicates, options = {}) {
          predicates = this._toTermArray(predicates);
          const context = this._context.reduce((all, current) => all.concat(current.out(predicates, options)), []);
          return Clownface.fromContext(context);
        }
        has(predicates, objects) {
          predicates = this._toTermArray(predicates);
          objects = this._toTermArray(objects);
          const context = this._context.reduce((all, current) => all.concat(current.has(predicates, objects)), []);
          return Clownface.fromContext(context);
        }
        addIn(predicates, subjects, callback) {
          if (!predicates) {
            throw new Error("predicate parameter is required");
          }
          if (typeof subjects === "function") {
            callback = subjects;
            subjects = null;
          }
          predicates = this._toTermArray(predicates);
          subjects = this._toTermArray(subjects) || [this.factory.blankNode()];
          const context = this._context.map((context2) => context2.addIn(predicates, subjects));
          if (callback) {
            Clownface.fromContext(context).forEach(callback);
          }
          return this;
        }
        addOut(predicates, objects, callback) {
          if (!predicates) {
            throw new Error("predicate parameter is required");
          }
          if (typeof objects === "function") {
            callback = objects;
            objects = null;
          }
          predicates = this._toTermArray(predicates);
          objects = this._toTermArray(objects) || [this.factory.blankNode()];
          const context = this._context.map((context2) => context2.addOut(predicates, objects));
          if (callback) {
            Clownface.fromContext(context).forEach(callback);
          }
          return this;
        }
        addList(predicates, items) {
          if (!predicates || !items) {
            throw new Error("predicate and items parameter is required");
          }
          predicates = this._toTermArray(predicates);
          items = this._toTermArray(items);
          this._context.forEach((context) => context.addList(predicates, items));
          return this;
        }
        deleteIn(predicates, subjects) {
          predicates = this._toTermArray(predicates);
          subjects = this._toTermArray(subjects);
          this._context.forEach((context) => context.deleteIn(predicates, subjects));
          return this;
        }
        deleteOut(predicates, objects) {
          predicates = this._toTermArray(predicates);
          objects = this._toTermArray(objects);
          this._context.forEach((context) => context.deleteOut(predicates, objects));
          return this;
        }
        deleteList(predicates) {
          if (!predicates) {
            throw new Error("predicate parameter is required");
          }
          predicates = this._toTermArray(predicates);
          this._context.forEach((context) => context.deleteList(predicates));
          return this;
        }
        _toTermArray(predicates, type, languageOrDatatype) {
          return toTermArray(predicates, type, languageOrDatatype, this.factory);
        }
        static fromContext(context) {
          return new Clownface({ _context: toArray(context), factory: context.factory });
        }
      };
      module.exports = Clownface;
    }
  });

  // node_modules/clownface/index.js
  var require_clownface = __commonJS({
    "node_modules/clownface/index.js"(exports, module) {
      init_shim();
      var Clownface = require_Clownface();
      function factory3({ dataset, graph: graph2, term, value, factory: factory4, _context }) {
        return new Clownface({ dataset, graph: graph2, term, value, factory: factory4, _context });
      }
      module.exports = factory3;
    }
  });

  // node_modules/rdf-ext/ClownfaceFactory.js
  var import_clownface, ClownfaceFactory, ClownfaceFactory_default;
  var init_ClownfaceFactory = __esm({
    "node_modules/rdf-ext/ClownfaceFactory.js"() {
      init_shim();
      import_clownface = __toESM(require_clownface(), 1);
      ClownfaceFactory = class {
        clownface({ ...args } = {}) {
          if (!args.dataset && typeof this.dataset === "function") {
            args.dataset = this.dataset();
          }
          return (0, import_clownface.default)({ ...args, factory: this });
        }
      };
      ClownfaceFactory.exports = ["clownface"];
      ClownfaceFactory_default = ClownfaceFactory;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/blankNode.js
  var require_blankNode3 = __commonJS({
    "node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/blankNode.js"(exports, module) {
      init_shim();
      function blankNode(blankNode2) {
        return "_:" + blankNode2.value;
      }
      module.exports = blankNode;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/dataset.js
  var require_dataset3 = __commonJS({
    "node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/dataset.js"(exports, module) {
      init_shim();
      function dataset(dataset2, toNT10) {
        return [...dataset2].map((quad) => toNT10(quad)).join("\n") + "\n";
      }
      module.exports = dataset;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/defaultGraph.js
  var require_defaultGraph3 = __commonJS({
    "node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/defaultGraph.js"(exports, module) {
      init_shim();
      function defaultGraph() {
        return "";
      }
      module.exports = defaultGraph;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/namedNode.js
  var require_namedNode3 = __commonJS({
    "node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/namedNode.js"(exports, module) {
      init_shim();
      function namedNode(namedNode2) {
        return "<" + namedNode2.value + ">";
      }
      module.exports = namedNode;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/literal.js
  var require_literal3 = __commonJS({
    "node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/literal.js"(exports, module) {
      init_shim();
      var namedNode = require_namedNode3();
      var echarRegEx = /["\\\\\n\r]/;
      var echarRegExAll = /["\\\\\n\r]/g;
      var echarReplacement = {
        '"': '\\"',
        "\\": "\\\\",
        "\n": "\\n",
        "\r": "\\r"
      };
      function echarReplacer(char) {
        return echarReplacement[char];
      }
      function escapeValue(value) {
        if (echarRegEx.test(value)) {
          return value.replace(echarRegExAll, echarReplacer);
        }
        return value;
      }
      function literal(literal2) {
        const escapedValue = escapeValue(literal2.value);
        if (literal2.datatype.value === "http://www.w3.org/2001/XMLSchema#string") {
          return '"' + escapedValue + '"';
        }
        if (literal2.datatype.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString") {
          return '"' + escapedValue + '"@' + literal2.language;
        }
        return '"' + escapedValue + '"^^' + namedNode(literal2.datatype);
      }
      module.exports = literal;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/quad.js
  var require_quad3 = __commonJS({
    "node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/quad.js"(exports, module) {
      init_shim();
      function quad(quad2, toNT10) {
        const subjectString = toNT10(quad2.subject);
        const predicateString = toNT10(quad2.predicate);
        const objectString = toNT10(quad2.object);
        const graphString = toNT10(quad2.graph);
        return `${subjectString} ${predicateString} ${objectString} ${graphString ? graphString + " " : ""}.`;
      }
      module.exports = quad;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/variable.js
  var require_variable3 = __commonJS({
    "node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/lib/variable.js"(exports, module) {
      init_shim();
      function variable(variable2) {
        return "?" + variable2.value;
      }
      module.exports = variable;
    }
  });

  // node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/index.js
  var require_to_ntriples3 = __commonJS({
    "node_modules/rdf-ext/node_modules/@rdfjs/to-ntriples/index.js"(exports, module) {
      init_shim();
      var blankNode = require_blankNode3();
      var dataset = require_dataset3();
      var defaultGraph = require_defaultGraph3();
      var literal = require_literal3();
      var namedNode = require_namedNode3();
      var quad = require_quad3();
      var variable = require_variable3();
      function toNT10(term) {
        if (!term) {
          return null;
        }
        if (term.termType === "BlankNode") {
          return blankNode(term);
        }
        if (term.termType === "DefaultGraph") {
          return defaultGraph();
        }
        if (term.termType === "Literal") {
          return literal(term);
        }
        if (term.termType === "NamedNode") {
          return namedNode(term);
        }
        if (term.termType === "Quad" || term.subject && term.predicate && term.object && term.graph) {
          return quad(term, toNT10);
        }
        if (term.termType === "Variable") {
          return variable(term);
        }
        if (term[Symbol.iterator]) {
          return dataset(term, toNT10);
        }
        throw new Error(`unknown termType ${term.termType}`);
      }
      module.exports = toNT10;
    }
  });

  // node_modules/rdf-ext/lib/BlankNode.js
  var import_to_ntriples3, BlankNode2, BlankNode_default2;
  var init_BlankNode2 = __esm({
    "node_modules/rdf-ext/lib/BlankNode.js"() {
      init_shim();
      init_BlankNode();
      import_to_ntriples3 = __toESM(require_to_ntriples3(), 1);
      BlankNode2 = class extends BlankNode_default {
        toCanonical() {
          return (0, import_to_ntriples3.default)(this);
        }
        toString() {
          return this.toCanonical();
        }
      };
      BlankNode_default2 = BlankNode2;
    }
  });

  // node_modules/rdf-ext/lib/DefaultGraph.js
  var import_to_ntriples4, DefaultGraph2, DefaultGraph_default2;
  var init_DefaultGraph2 = __esm({
    "node_modules/rdf-ext/lib/DefaultGraph.js"() {
      init_shim();
      init_DefaultGraph();
      import_to_ntriples4 = __toESM(require_to_ntriples3(), 1);
      DefaultGraph2 = class extends DefaultGraph_default {
        toCanonical() {
          return (0, import_to_ntriples4.default)(this);
        }
        toString() {
          return this.toCanonical();
        }
      };
      DefaultGraph_default2 = DefaultGraph2;
    }
  });

  // node_modules/rdf-ext/lib/Literal.js
  var import_to_ntriples5, Literal2, Literal_default2;
  var init_Literal2 = __esm({
    "node_modules/rdf-ext/lib/Literal.js"() {
      init_shim();
      init_Literal();
      import_to_ntriples5 = __toESM(require_to_ntriples3(), 1);
      Literal2 = class extends Literal_default {
        toCanonical() {
          return (0, import_to_ntriples5.default)(this);
        }
        toString() {
          return this.value;
        }
      };
      Literal_default2 = Literal2;
    }
  });

  // node_modules/rdf-ext/lib/NamedNode.js
  var import_to_ntriples6, NamedNode2, NamedNode_default2;
  var init_NamedNode2 = __esm({
    "node_modules/rdf-ext/lib/NamedNode.js"() {
      init_shim();
      init_NamedNode();
      import_to_ntriples6 = __toESM(require_to_ntriples3(), 1);
      NamedNode2 = class extends NamedNode_default {
        toCanonical() {
          return (0, import_to_ntriples6.default)(this);
        }
        toString() {
          return this.value;
        }
      };
      NamedNode_default2 = NamedNode2;
    }
  });

  // node_modules/rdf-ext/lib/Quad.js
  var import_to_ntriples7, Quad2, Quad_default2;
  var init_Quad2 = __esm({
    "node_modules/rdf-ext/lib/Quad.js"() {
      init_shim();
      init_Quad();
      import_to_ntriples7 = __toESM(require_to_ntriples3(), 1);
      Quad2 = class extends Quad_default {
        toCanonical() {
          return (0, import_to_ntriples7.default)(this);
        }
        toString() {
          return this.toCanonical();
        }
      };
      Quad_default2 = Quad2;
    }
  });

  // node_modules/rdf-ext/lib/Variable.js
  var import_to_ntriples8, Variable2, Variable_default2;
  var init_Variable2 = __esm({
    "node_modules/rdf-ext/lib/Variable.js"() {
      init_shim();
      init_Variable();
      import_to_ntriples8 = __toESM(require_to_ntriples3(), 1);
      Variable2 = class extends Variable_default {
        toCanonical() {
          return (0, import_to_ntriples8.default)(this);
        }
        toString() {
          return this.toCanonical();
        }
      };
      Variable_default2 = Variable2;
    }
  });

  // node_modules/rdf-ext/DataFactory.js
  var langStringDatatype2, stringDatatype2, DataFactory2, DataFactory_default;
  var init_DataFactory = __esm({
    "node_modules/rdf-ext/DataFactory.js"() {
      init_shim();
      init_fromTerm();
      init_BlankNode2();
      init_DefaultGraph2();
      init_Literal2();
      init_NamedNode2();
      init_Quad2();
      init_Variable2();
      langStringDatatype2 = new NamedNode_default2("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString");
      stringDatatype2 = new NamedNode_default2("http://www.w3.org/2001/XMLSchema#string");
      DataFactory2 = class {
        init() {
          this._data = {
            blankNodeCounter: 0,
            defaultGraph: new DefaultGraph_default2()
          };
        }
        namedNode(value) {
          return new NamedNode_default2(value);
        }
        blankNode(value) {
          value = value || "b" + ++this._data.blankNodeCounter;
          return new BlankNode_default2(value);
        }
        literal(value, languageOrDatatype) {
          if (typeof languageOrDatatype === "string") {
            return new Literal_default2(value, languageOrDatatype, langStringDatatype2);
          } else {
            return new Literal_default2(value, "", languageOrDatatype || stringDatatype2);
          }
        }
        variable(value) {
          return new Variable_default2(value);
        }
        defaultGraph() {
          return this._data.defaultGraph;
        }
        quad(subject, predicate, object, graph2 = this.defaultGraph()) {
          return new Quad_default2(subject, predicate, object, graph2);
        }
        fromTerm(original) {
          return fromTerm_default(this, original);
        }
        fromQuad(original) {
          return fromTerm_default(this, original);
        }
      };
      DataFactory2.exports = [
        "namedNode",
        "blankNode",
        "literal",
        "variable",
        "defaultGraph",
        "quad",
        "fromTerm",
        "fromQuad"
      ];
      DataFactory_default = DataFactory2;
    }
  });

  // node_modules/@rdfjs/dataset/DatasetCore.js
  function isString(s) {
    return typeof s === "string" || s instanceof String;
  }
  function termToId(term) {
    if (typeof term === "string") {
      return term;
    }
    if (!term) {
      return "";
    }
    if (typeof term.id !== "undefined" && term.termType !== "Quad") {
      return term.id;
    }
    let subject, predicate, object, graph2;
    switch (term.termType) {
      case "NamedNode":
        return term.value;
      case "BlankNode":
        return `_:${term.value}`;
      case "Variable":
        return `?${term.value}`;
      case "DefaultGraph":
        return "";
      case "Literal":
        if (term.language) {
          return `"${term.value}"@${term.language}`;
        }
        return `"${term.value}"${term.datatype && term.datatype.value !== xsdString ? `^^${term.datatype.value}` : ""}`;
      case "Quad":
        subject = escapeQuotes(termToId(term.subject));
        predicate = escapeQuotes(termToId(term.predicate));
        object = escapeQuotes(termToId(term.object));
        graph2 = term.graph.termType === "DefaultGraph" ? "" : ` ${termToId(term.graph)}`;
        return `<<${subject} ${predicate} ${object}${graph2}>>`;
      default:
        throw new Error(`Unexpected termType: ${term.termType}`);
    }
  }
  function escapeQuotes(id) {
    return id.replace(escapedLiteral, (_, quoted) => `"${quoted.replace(/"/g, '""')}`);
  }
  var xsdString, escapedLiteral, DatasetCore, DatasetCore_default;
  var init_DatasetCore = __esm({
    "node_modules/@rdfjs/dataset/DatasetCore.js"() {
      init_shim();
      xsdString = "http://www.w3.org/2001/XMLSchema#string";
      escapedLiteral = /^"(.*".*)(?="[^"]*$)/;
      DatasetCore = class {
        constructor(quads) {
          this._size = 0;
          this._graphs = /* @__PURE__ */ Object.create(null);
          this._id = 0;
          this._ids = /* @__PURE__ */ Object.create(null);
          this._ids["><"] = 0;
          this._entities = /* @__PURE__ */ Object.create(null);
          this._quads = /* @__PURE__ */ new Map();
          if (quads) {
            for (const quad of quads) {
              this.add(quad);
            }
          }
        }
        get size() {
          let size = this._size;
          if (size !== null) {
            return size;
          }
          size = 0;
          const graphs = this._graphs;
          let subjects, subject;
          for (const graphKey in graphs) {
            for (const subjectKey in subjects = graphs[graphKey].subjects) {
              for (const predicateKey in subject = subjects[subjectKey]) {
                size += Object.keys(subject[predicateKey]).length;
              }
            }
          }
          this._size = size;
          return this._size;
        }
        add(quad) {
          let subject = termToId(quad.subject);
          let predicate = termToId(quad.predicate);
          let object = termToId(quad.object);
          const graph2 = termToId(quad.graph);
          let graphItem = this._graphs[graph2];
          if (!graphItem) {
            graphItem = this._graphs[graph2] = { subjects: {}, predicates: {}, objects: {} };
            Object.freeze(graphItem);
          }
          const ids = this._ids;
          const entities = this._entities;
          subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);
          predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);
          object = ids[object] || (ids[entities[++this._id] = object] = this._id);
          this._addToIndex(graphItem.subjects, subject, predicate, object);
          this._addToIndex(graphItem.predicates, predicate, object, subject);
          this._addToIndex(graphItem.objects, object, subject, predicate);
          this._setQuad(subject, predicate, object, graph2, quad);
          this._size = null;
          return this;
        }
        delete(quad) {
          let subject = termToId(quad.subject);
          let predicate = termToId(quad.predicate);
          let object = termToId(quad.object);
          const graph2 = termToId(quad.graph);
          const ids = this._ids;
          const graphs = this._graphs;
          let graphItem, subjects, predicates;
          if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph2]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) {
            return this;
          }
          this._removeFromIndex(graphItem.subjects, subject, predicate, object);
          this._removeFromIndex(graphItem.predicates, predicate, object, subject);
          this._removeFromIndex(graphItem.objects, object, subject, predicate);
          if (this._size !== null) {
            this._size--;
          }
          this._deleteQuad(subject, predicate, object, graph2);
          for (subject in graphItem.subjects) {
            return this;
          }
          delete graphs[graph2];
          return this;
        }
        has(quad) {
          const subject = termToId(quad.subject);
          const predicate = termToId(quad.predicate);
          const object = termToId(quad.object);
          const graph2 = termToId(quad.graph);
          const graphItem = this._graphs[graph2];
          if (!graphItem) {
            return false;
          }
          const ids = this._ids;
          let subjectId, predicateId, objectId;
          if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) {
            return false;
          }
          return this._countInIndex(graphItem.objects, objectId, subjectId, predicateId) === 1;
        }
        match(subject, predicate, object, graph2) {
          return this._createDataset(this._match(subject, predicate, object, graph2));
        }
        [Symbol.iterator]() {
          return this._match()[Symbol.iterator]();
        }
        _addToIndex(index0, key0, key1, key2) {
          const index1 = index0[key0] || (index0[key0] = {});
          const index2 = index1[key1] || (index1[key1] = {});
          const existed = key2 in index2;
          if (!existed) {
            index2[key2] = null;
          }
          return !existed;
        }
        _removeFromIndex(index0, key0, key1, key2) {
          const index1 = index0[key0];
          const index2 = index1[key1];
          delete index2[key2];
          for (const key in index2) {
            return;
          }
          delete index1[key1];
          for (const key in index1) {
            return;
          }
          delete index0[key0];
        }
        _findInIndex(index0, key0, key1, key2, name0, name1, name2, graph2, callback, array) {
          let tmp, index1, index2;
          if (key0) {
            (tmp = index0, index0 = {})[key0] = tmp[key0];
          }
          for (const value0 in index0) {
            index1 = index0[value0];
            if (index1) {
              if (key1) {
                (tmp = index1, index1 = {})[key1] = tmp[key1];
              }
              for (const value1 in index1) {
                index2 = index1[value1];
                if (index2) {
                  const values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2);
                  for (let l = 0; l < values.length; l++) {
                    const parts = {
                      [name0]: value0,
                      [name1]: value1,
                      [name2]: values[l]
                    };
                    const quad = this._getQuad(parts.subject, parts.predicate, parts.object, graph2);
                    if (array) {
                      array.push(quad);
                    } else if (callback(quad)) {
                      return true;
                    }
                  }
                }
              }
            }
          }
          return array;
        }
        _countInIndex(index0, key0, key1, key2) {
          let count = 0;
          let tmp, index1, index2;
          if (key0) {
            (tmp = index0, index0 = {})[key0] = tmp[key0];
          }
          for (const value0 in index0) {
            index1 = index0[value0];
            if (index1) {
              if (key1) {
                (tmp = index1, index1 = {})[key1] = tmp[key1];
              }
              for (const value1 in index1) {
                index2 = index1[value1];
                if (index2) {
                  if (key2) {
                    key2 in index2 && count++;
                  } else {
                    count += Object.keys(index2).length;
                  }
                }
              }
            }
          }
          return count;
        }
        _getGraphs(graph2) {
          if (!isString(graph2)) {
            return this._graphs;
          }
          return {
            [graph2]: this._graphs[graph2]
          };
        }
        _match(subject, predicate, object, graph2) {
          subject = subject && termToId(subject);
          predicate = predicate && termToId(predicate);
          object = object && termToId(object);
          graph2 = graph2 && termToId(graph2);
          const quads = [];
          const graphs = this._getGraphs(graph2);
          const ids = this._ids;
          let content, subjectId, predicateId, objectId;
          if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) {
            return quads;
          }
          for (const graphId in graphs) {
            content = graphs[graphId];
            if (content) {
              if (subjectId) {
                if (objectId) {
                  this._findInIndex(content.objects, objectId, subjectId, predicateId, "object", "subject", "predicate", graphId, null, quads);
                } else {
                  this._findInIndex(content.subjects, subjectId, predicateId, null, "subject", "predicate", "object", graphId, null, quads);
                }
              } else if (predicateId) {
                this._findInIndex(content.predicates, predicateId, objectId, null, "predicate", "object", "subject", graphId, null, quads);
              } else if (objectId) {
                this._findInIndex(content.objects, objectId, null, null, "object", "subject", "predicate", graphId, null, quads);
              } else {
                this._findInIndex(content.subjects, null, null, null, "subject", "predicate", "object", graphId, null, quads);
              }
            }
          }
          return quads;
        }
        _getQuad(subjectId, predicateId, objectId, graphId) {
          return this._quads.get(this._toId(subjectId, predicateId, objectId, graphId));
        }
        _setQuad(subjectId, predicateId, objectId, graphId, quad) {
          this._quads.set(this._toId(subjectId, predicateId, objectId, graphId), quad);
        }
        _deleteQuad(subjectId, predicateId, objectId, graphId) {
          this._quads.delete(this._toId(subjectId, predicateId, objectId, graphId));
        }
        _createDataset(quads) {
          return new this.constructor(quads);
        }
        _toId(subjectId, predicateId, objectId, graphId) {
          return `${subjectId}:${predicateId}:${objectId}:${graphId}`;
        }
      };
      DatasetCore_default = DatasetCore;
    }
  });

  // node_modules/rdf-canonize/lib/IdentifierIssuer.js
  var require_IdentifierIssuer = __commonJS({
    "node_modules/rdf-canonize/lib/IdentifierIssuer.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = class IdentifierIssuer {
        constructor(prefix, existing = /* @__PURE__ */ new Map(), counter = 0) {
          this.prefix = prefix;
          this._existing = existing;
          this.counter = counter;
        }
        clone() {
          const { prefix, _existing, counter } = this;
          return new IdentifierIssuer(prefix, new Map(_existing), counter);
        }
        getId(old) {
          const existing = old && this._existing.get(old);
          if (existing) {
            return existing;
          }
          const identifier = this.prefix + this.counter;
          this.counter++;
          if (old) {
            this._existing.set(old, identifier);
          }
          return identifier;
        }
        hasId(old) {
          return this._existing.has(old);
        }
        getOldIds() {
          return [...this._existing.keys()];
        }
      };
    }
  });

  // node_modules/setimmediate/setImmediate.js
  var require_setImmediate = __commonJS({
    "node_modules/setimmediate/setImmediate.js"(exports) {
      init_shim();
      (function(global, undefined2) {
        "use strict";
        if (global.setImmediate) {
          return;
        }
        var nextHandle = 1;
        var tasksByHandle = {};
        var currentlyRunningATask = false;
        var doc = global.document;
        var registerImmediate;
        function setImmediate2(callback) {
          if (typeof callback !== "function") {
            callback = new Function("" + callback);
          }
          var args = new Array(arguments.length - 1);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
          }
          var task = { callback, args };
          tasksByHandle[nextHandle] = task;
          registerImmediate(nextHandle);
          return nextHandle++;
        }
        function clearImmediate(handle) {
          delete tasksByHandle[handle];
        }
        function run(task) {
          var callback = task.callback;
          var args = task.args;
          switch (args.length) {
            case 0:
              callback();
              break;
            case 1:
              callback(args[0]);
              break;
            case 2:
              callback(args[0], args[1]);
              break;
            case 3:
              callback(args[0], args[1], args[2]);
              break;
            default:
              callback.apply(undefined2, args);
              break;
          }
        }
        function runIfPresent(handle) {
          if (currentlyRunningATask) {
            setTimeout(runIfPresent, 0, handle);
          } else {
            var task = tasksByHandle[handle];
            if (task) {
              currentlyRunningATask = true;
              try {
                run(task);
              } finally {
                clearImmediate(handle);
                currentlyRunningATask = false;
              }
            }
          }
        }
        function installNextTickImplementation() {
          registerImmediate = function(handle) {
            import_process.default.nextTick(function() {
              runIfPresent(handle);
            });
          };
        }
        function canUsePostMessage() {
          if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
              postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
          }
        }
        function installPostMessageImplementation() {
          var messagePrefix = "setImmediate$" + Math.random() + "$";
          var onGlobalMessage = function(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
              runIfPresent(+event.data.slice(messagePrefix.length));
            }
          };
          if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
          } else {
            global.attachEvent("onmessage", onGlobalMessage);
          }
          registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
          };
        }
        function installMessageChannelImplementation() {
          var channel = new MessageChannel();
          channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
          };
          registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
          };
        }
        function installReadyStateChangeImplementation() {
          var html = doc.documentElement;
          registerImmediate = function(handle) {
            var script = doc.createElement("script");
            script.onreadystatechange = function() {
              runIfPresent(handle);
              script.onreadystatechange = null;
              html.removeChild(script);
              script = null;
            };
            html.appendChild(script);
          };
        }
        function installSetTimeoutImplementation() {
          registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
          };
        }
        var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
        attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
        if ({}.toString.call(global.process) === "[object process]") {
          installNextTickImplementation();
        } else if (canUsePostMessage()) {
          installPostMessageImplementation();
        } else if (global.MessageChannel) {
          installMessageChannelImplementation();
        } else if (doc && "onreadystatechange" in doc.createElement("script")) {
          installReadyStateChangeImplementation();
        } else {
          installSetTimeoutImplementation();
        }
        attachTo.setImmediate = setImmediate2;
        attachTo.clearImmediate = clearImmediate;
      })(typeof self === "undefined" ? typeof _global === "undefined" ? exports : _global : self);
    }
  });

  // node_modules/rdf-canonize/lib/MessageDigest-browser.js
  var require_MessageDigest_browser = __commonJS({
    "node_modules/rdf-canonize/lib/MessageDigest-browser.js"(exports, module) {
      "use strict";
      init_shim();
      require_setImmediate();
      var crypto = self.crypto || self.msCrypto;
      module.exports = class MessageDigest {
        constructor(algorithm) {
          if (!(crypto && crypto.subtle)) {
            throw new Error("crypto.subtle not found.");
          }
          if (algorithm === "sha256") {
            this.algorithm = { name: "SHA-256" };
          } else if (algorithm === "sha1") {
            this.algorithm = { name: "SHA-1" };
          } else {
            throw new Error(`Unsupport algorithm "${algorithm}".`);
          }
          this._content = "";
        }
        update(msg) {
          this._content += msg;
        }
        async digest() {
          const data = new TextEncoder().encode(this._content);
          const buffer = new Uint8Array(await crypto.subtle.digest(this.algorithm, data));
          let hex = "";
          for (let i = 0; i < buffer.length; ++i) {
            hex += buffer[i].toString(16).padStart(2, "0");
          }
          return hex;
        }
      };
    }
  });

  // node_modules/rdf-canonize/lib/Permuter.js
  var require_Permuter = __commonJS({
    "node_modules/rdf-canonize/lib/Permuter.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = class Permuter {
        constructor(list) {
          this.current = list.sort();
          this.done = false;
          this.dir = /* @__PURE__ */ new Map();
          for (let i = 0; i < list.length; ++i) {
            this.dir.set(list[i], true);
          }
        }
        hasNext() {
          return !this.done;
        }
        next() {
          const { current, dir } = this;
          const rval = current.slice();
          let k = null;
          let pos = 0;
          const length = current.length;
          for (let i = 0; i < length; ++i) {
            const element = current[i];
            const left = dir.get(element);
            if ((k === null || element > k) && (left && i > 0 && element > current[i - 1] || !left && i < length - 1 && element > current[i + 1])) {
              k = element;
              pos = i;
            }
          }
          if (k === null) {
            this.done = true;
          } else {
            const swap = dir.get(k) ? pos - 1 : pos + 1;
            current[pos] = current[swap];
            current[swap] = k;
            for (const element of current) {
              if (element > k) {
                dir.set(element, !dir.get(element));
              }
            }
          }
          return rval;
        }
      };
    }
  });

  // node_modules/rdf-canonize/lib/NQuads.js
  var require_NQuads = __commonJS({
    "node_modules/rdf-canonize/lib/NQuads.js"(exports, module) {
      "use strict";
      init_shim();
      var RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
      var RDF_LANGSTRING = RDF + "langString";
      var XSD_STRING = "http://www.w3.org/2001/XMLSchema#string";
      var TYPE_NAMED_NODE = "NamedNode";
      var TYPE_BLANK_NODE = "BlankNode";
      var TYPE_LITERAL = "Literal";
      var TYPE_DEFAULT_GRAPH = "DefaultGraph";
      var REGEX = {};
      (() => {
        const iri = "(?:<([^:]+:[^>]*)>)";
        const PN_CHARS_BASE = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
        const PN_CHARS_U = PN_CHARS_BASE + "_";
        const PN_CHARS = PN_CHARS_U + "0-9-\xB7\u0300-\u036F\u203F-\u2040";
        const BLANK_NODE_LABEL = "(_:(?:[" + PN_CHARS_U + "0-9])(?:(?:[" + PN_CHARS + ".])*(?:[" + PN_CHARS + "]))?)";
        const bnode = BLANK_NODE_LABEL;
        const plain = '"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"';
        const datatype = "(?:\\^\\^" + iri + ")";
        const language = "(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))";
        const literal = "(?:" + plain + "(?:" + datatype + "|" + language + ")?)";
        const ws = "[ \\t]+";
        const wso = "[ \\t]*";
        const subject = "(?:" + iri + "|" + bnode + ")" + ws;
        const property = iri + ws;
        const object = "(?:" + iri + "|" + bnode + "|" + literal + ")" + wso;
        const graphName = "(?:\\.|(?:(?:" + iri + "|" + bnode + ")" + wso + "\\.))";
        REGEX.eoln = /(?:\r\n)|(?:\n)|(?:\r)/g;
        REGEX.empty = new RegExp("^" + wso + "$");
        REGEX.quad = new RegExp("^" + wso + subject + property + object + graphName + wso + "$");
      })();
      module.exports = class NQuads {
        static parse(input) {
          const dataset = [];
          const graphs = {};
          const lines = input.split(REGEX.eoln);
          let lineNumber = 0;
          for (const line of lines) {
            lineNumber++;
            if (REGEX.empty.test(line)) {
              continue;
            }
            const match = line.match(REGEX.quad);
            if (match === null) {
              throw new Error("N-Quads parse error on line " + lineNumber + ".");
            }
            const quad = { subject: null, predicate: null, object: null, graph: null };
            if (match[1] !== void 0) {
              quad.subject = { termType: TYPE_NAMED_NODE, value: match[1] };
            } else {
              quad.subject = { termType: TYPE_BLANK_NODE, value: match[2] };
            }
            quad.predicate = { termType: TYPE_NAMED_NODE, value: match[3] };
            if (match[4] !== void 0) {
              quad.object = { termType: TYPE_NAMED_NODE, value: match[4] };
            } else if (match[5] !== void 0) {
              quad.object = { termType: TYPE_BLANK_NODE, value: match[5] };
            } else {
              quad.object = {
                termType: TYPE_LITERAL,
                value: void 0,
                datatype: {
                  termType: TYPE_NAMED_NODE
                }
              };
              if (match[7] !== void 0) {
                quad.object.datatype.value = match[7];
              } else if (match[8] !== void 0) {
                quad.object.datatype.value = RDF_LANGSTRING;
                quad.object.language = match[8];
              } else {
                quad.object.datatype.value = XSD_STRING;
              }
              quad.object.value = _unescape(match[6]);
            }
            if (match[9] !== void 0) {
              quad.graph = {
                termType: TYPE_NAMED_NODE,
                value: match[9]
              };
            } else if (match[10] !== void 0) {
              quad.graph = {
                termType: TYPE_BLANK_NODE,
                value: match[10]
              };
            } else {
              quad.graph = {
                termType: TYPE_DEFAULT_GRAPH,
                value: ""
              };
            }
            if (!(quad.graph.value in graphs)) {
              graphs[quad.graph.value] = [quad];
              dataset.push(quad);
            } else {
              let unique = true;
              const quads = graphs[quad.graph.value];
              for (const q of quads) {
                if (_compareTriples(q, quad)) {
                  unique = false;
                  break;
                }
              }
              if (unique) {
                quads.push(quad);
                dataset.push(quad);
              }
            }
          }
          return dataset;
        }
        static serialize(dataset) {
          if (!Array.isArray(dataset)) {
            dataset = NQuads.legacyDatasetToQuads(dataset);
          }
          const quads = [];
          for (const quad of dataset) {
            quads.push(NQuads.serializeQuad(quad));
          }
          return quads.sort().join("");
        }
        static serializeQuad(quad) {
          const s = quad.subject;
          const p = quad.predicate;
          const o = quad.object;
          const g = quad.graph;
          let nquad = "";
          if (s.termType === TYPE_NAMED_NODE) {
            nquad += `<${s.value}>`;
          } else {
            nquad += `${s.value}`;
          }
          nquad += ` <${p.value}> `;
          if (o.termType === TYPE_NAMED_NODE) {
            nquad += `<${o.value}>`;
          } else if (o.termType === TYPE_BLANK_NODE) {
            nquad += o.value;
          } else {
            nquad += `"${_escape(o.value)}"`;
            if (o.datatype.value === RDF_LANGSTRING) {
              if (o.language) {
                nquad += `@${o.language}`;
              }
            } else if (o.datatype.value !== XSD_STRING) {
              nquad += `^^<${o.datatype.value}>`;
            }
          }
          if (g.termType === TYPE_NAMED_NODE) {
            nquad += ` <${g.value}>`;
          } else if (g.termType === TYPE_BLANK_NODE) {
            nquad += ` ${g.value}`;
          }
          nquad += " .\n";
          return nquad;
        }
        static legacyDatasetToQuads(dataset) {
          const quads = [];
          const termTypeMap = {
            "blank node": TYPE_BLANK_NODE,
            IRI: TYPE_NAMED_NODE,
            literal: TYPE_LITERAL
          };
          for (const graphName in dataset) {
            const triples = dataset[graphName];
            triples.forEach((triple6) => {
              const quad = {};
              for (const componentName in triple6) {
                const oldComponent = triple6[componentName];
                const newComponent = {
                  termType: termTypeMap[oldComponent.type],
                  value: oldComponent.value
                };
                if (newComponent.termType === TYPE_LITERAL) {
                  newComponent.datatype = {
                    termType: TYPE_NAMED_NODE
                  };
                  if ("datatype" in oldComponent) {
                    newComponent.datatype.value = oldComponent.datatype;
                  }
                  if ("language" in oldComponent) {
                    if (!("datatype" in oldComponent)) {
                      newComponent.datatype.value = RDF_LANGSTRING;
                    }
                    newComponent.language = oldComponent.language;
                  } else if (!("datatype" in oldComponent)) {
                    newComponent.datatype.value = XSD_STRING;
                  }
                }
                quad[componentName] = newComponent;
              }
              if (graphName === "@default") {
                quad.graph = {
                  termType: TYPE_DEFAULT_GRAPH,
                  value: ""
                };
              } else {
                quad.graph = {
                  termType: graphName.startsWith("_:") ? TYPE_BLANK_NODE : TYPE_NAMED_NODE,
                  value: graphName
                };
              }
              quads.push(quad);
            });
          }
          return quads;
        }
      };
      function _compareTriples(t1, t2) {
        if (!(t1.subject.termType === t2.subject.termType && t1.object.termType === t2.object.termType)) {
          return false;
        }
        if (!(t1.subject.value === t2.subject.value && t1.predicate.value === t2.predicate.value && t1.object.value === t2.object.value)) {
          return false;
        }
        if (t1.object.termType !== TYPE_LITERAL) {
          return true;
        }
        return t1.object.datatype.termType === t2.object.datatype.termType && t1.object.language === t2.object.language && t1.object.datatype.value === t2.object.datatype.value;
      }
      var _escapeRegex = /["\\\n\r]/g;
      function _escape(s) {
        return s.replace(_escapeRegex, function(match) {
          switch (match) {
            case '"':
              return '\\"';
            case "\\":
              return "\\\\";
            case "\n":
              return "\\n";
            case "\r":
              return "\\r";
          }
        });
      }
      var _unescapeRegex = /(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;
      function _unescape(s) {
        return s.replace(_unescapeRegex, function(match, code, u, U) {
          if (code) {
            switch (code) {
              case "t":
                return "	";
              case "b":
                return "\b";
              case "n":
                return "\n";
              case "r":
                return "\r";
              case "f":
                return "\f";
              case '"':
                return '"';
              case "'":
                return "'";
              case "\\":
                return "\\";
            }
          }
          if (u) {
            return String.fromCharCode(parseInt(u, 16));
          }
          if (U) {
            throw new Error("Unsupported U escape");
          }
        });
      }
    }
  });

  // node_modules/rdf-canonize/lib/URDNA2015Sync.js
  var require_URDNA2015Sync = __commonJS({
    "node_modules/rdf-canonize/lib/URDNA2015Sync.js"(exports, module) {
      "use strict";
      init_shim();
      var IdentifierIssuer = require_IdentifierIssuer();
      var MessageDigest = require_MessageDigest_browser();
      var Permuter = require_Permuter();
      var NQuads = require_NQuads();
      module.exports = class URDNA2015Sync {
        constructor() {
          this.name = "URDNA2015";
          this.blankNodeInfo = /* @__PURE__ */ new Map();
          this.canonicalIssuer = new IdentifierIssuer("_:c14n");
          this.hashAlgorithm = "sha256";
          this.quads = null;
        }
        main(dataset) {
          this.quads = dataset;
          for (const quad of dataset) {
            this._addBlankNodeQuadInfo({ quad, component: quad.subject });
            this._addBlankNodeQuadInfo({ quad, component: quad.object });
            this._addBlankNodeQuadInfo({ quad, component: quad.graph });
          }
          const hashToBlankNodes = /* @__PURE__ */ new Map();
          const nonNormalized = [...this.blankNodeInfo.keys()];
          for (const id of nonNormalized) {
            this._hashAndTrackBlankNode({ id, hashToBlankNodes });
          }
          const hashes = [...hashToBlankNodes.keys()].sort();
          const nonUnique = [];
          for (const hash of hashes) {
            const idList = hashToBlankNodes.get(hash);
            if (idList.length > 1) {
              nonUnique.push(idList);
              continue;
            }
            const id = idList[0];
            this.canonicalIssuer.getId(id);
          }
          for (const idList of nonUnique) {
            const hashPathList = [];
            for (const id of idList) {
              if (this.canonicalIssuer.hasId(id)) {
                continue;
              }
              const issuer = new IdentifierIssuer("_:b");
              issuer.getId(id);
              const result = this.hashNDegreeQuads(id, issuer);
              hashPathList.push(result);
            }
            hashPathList.sort(_stringHashCompare);
            for (const result of hashPathList) {
              const oldIds = result.issuer.getOldIds();
              for (const id of oldIds) {
                this.canonicalIssuer.getId(id);
              }
            }
          }
          const normalized = [];
          for (const quad of this.quads) {
            const q = { ...quad };
            q.subject = this._useCanonicalId({ component: q.subject });
            q.object = this._useCanonicalId({ component: q.object });
            q.graph = this._useCanonicalId({ component: q.graph });
            normalized.push(NQuads.serializeQuad(q));
          }
          normalized.sort();
          return normalized.join("");
        }
        hashFirstDegreeQuads(id) {
          const nquads = [];
          const info = this.blankNodeInfo.get(id);
          const quads = info.quads;
          for (const quad of quads) {
            const copy = {
              subject: null,
              predicate: quad.predicate,
              object: null,
              graph: null
            };
            copy.subject = this.modifyFirstDegreeComponent(id, quad.subject, "subject");
            copy.object = this.modifyFirstDegreeComponent(id, quad.object, "object");
            copy.graph = this.modifyFirstDegreeComponent(id, quad.graph, "graph");
            nquads.push(NQuads.serializeQuad(copy));
          }
          nquads.sort();
          const md = new MessageDigest(this.hashAlgorithm);
          for (const nquad of nquads) {
            md.update(nquad);
          }
          info.hash = md.digest();
          return info.hash;
        }
        hashRelatedBlankNode(related, quad, issuer, position) {
          let id;
          if (this.canonicalIssuer.hasId(related)) {
            id = this.canonicalIssuer.getId(related);
          } else if (issuer.hasId(related)) {
            id = issuer.getId(related);
          } else {
            id = this.blankNodeInfo.get(related).hash;
          }
          const md = new MessageDigest(this.hashAlgorithm);
          md.update(position);
          if (position !== "g") {
            md.update(this.getRelatedPredicate(quad));
          }
          md.update(id);
          return md.digest();
        }
        hashNDegreeQuads(id, issuer) {
          const md = new MessageDigest(this.hashAlgorithm);
          const hashToRelated = this.createHashToRelated(id, issuer);
          const hashes = [...hashToRelated.keys()].sort();
          for (const hash of hashes) {
            md.update(hash);
            let chosenPath = "";
            let chosenIssuer;
            const permuter = new Permuter(hashToRelated.get(hash));
            while (permuter.hasNext()) {
              const permutation = permuter.next();
              let issuerCopy = issuer.clone();
              let path = "";
              const recursionList = [];
              let nextPermutation = false;
              for (const related of permutation) {
                if (this.canonicalIssuer.hasId(related)) {
                  path += this.canonicalIssuer.getId(related);
                } else {
                  if (!issuerCopy.hasId(related)) {
                    recursionList.push(related);
                  }
                  path += issuerCopy.getId(related);
                }
                if (chosenPath.length !== 0 && path > chosenPath) {
                  nextPermutation = true;
                  break;
                }
              }
              if (nextPermutation) {
                continue;
              }
              for (const related of recursionList) {
                const result = this.hashNDegreeQuads(related, issuerCopy);
                path += issuerCopy.getId(related);
                path += `<${result.hash}>`;
                issuerCopy = result.issuer;
                if (chosenPath.length !== 0 && path > chosenPath) {
                  nextPermutation = true;
                  break;
                }
              }
              if (nextPermutation) {
                continue;
              }
              if (chosenPath.length === 0 || path < chosenPath) {
                chosenPath = path;
                chosenIssuer = issuerCopy;
              }
            }
            md.update(chosenPath);
            issuer = chosenIssuer;
          }
          return { hash: md.digest(), issuer };
        }
        modifyFirstDegreeComponent(id, component) {
          if (component.termType !== "BlankNode") {
            return component;
          }
          return {
            termType: "BlankNode",
            value: component.value === id ? "_:a" : "_:z"
          };
        }
        getRelatedPredicate(quad) {
          return `<${quad.predicate.value}>`;
        }
        createHashToRelated(id, issuer) {
          const hashToRelated = /* @__PURE__ */ new Map();
          const quads = this.blankNodeInfo.get(id).quads;
          for (const quad of quads) {
            this._addRelatedBlankNodeHash({
              quad,
              component: quad.subject,
              position: "s",
              id,
              issuer,
              hashToRelated
            });
            this._addRelatedBlankNodeHash({
              quad,
              component: quad.object,
              position: "o",
              id,
              issuer,
              hashToRelated
            });
            this._addRelatedBlankNodeHash({
              quad,
              component: quad.graph,
              position: "g",
              id,
              issuer,
              hashToRelated
            });
          }
          return hashToRelated;
        }
        _hashAndTrackBlankNode({ id, hashToBlankNodes }) {
          const hash = this.hashFirstDegreeQuads(id);
          const idList = hashToBlankNodes.get(hash);
          if (!idList) {
            hashToBlankNodes.set(hash, [id]);
          } else {
            idList.push(id);
          }
        }
        _addBlankNodeQuadInfo({ quad, component }) {
          if (component.termType !== "BlankNode") {
            return;
          }
          const id = component.value;
          const info = this.blankNodeInfo.get(id);
          if (info) {
            info.quads.add(quad);
          } else {
            this.blankNodeInfo.set(id, { quads: /* @__PURE__ */ new Set([quad]), hash: null });
          }
        }
        _addRelatedBlankNodeHash({ quad, component, position, id, issuer, hashToRelated }) {
          if (!(component.termType === "BlankNode" && component.value !== id)) {
            return;
          }
          const related = component.value;
          const hash = this.hashRelatedBlankNode(related, quad, issuer, position);
          const entries = hashToRelated.get(hash);
          if (entries) {
            entries.push(related);
          } else {
            hashToRelated.set(hash, [related]);
          }
        }
        _useCanonicalId({ component }) {
          if (component.termType === "BlankNode" && !component.value.startsWith(this.canonicalIssuer.prefix)) {
            return {
              termType: "BlankNode",
              value: this.canonicalIssuer.getId(component.value)
            };
          }
          return component;
        }
      };
      function _stringHashCompare(a, b) {
        return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
      }
    }
  });

  // node_modules/@rdfjs/normalize/index.js
  function toJsonldQuad(quad) {
    return {
      subject: toJsonldTerm(quad.subject),
      predicate: toJsonldTerm(quad.predicate),
      object: toJsonldTerm(quad.object),
      graph: toJsonldTerm(quad.graph)
    };
  }
  function toJsonldTerm(term) {
    if (term.termType === "BlankNode") {
      return {
        termType: "BlankNode",
        value: `_:${term.value}`
      };
    }
    return term;
  }
  function toJsonldDataset(dataset) {
    return [...dataset].map((quad) => toJsonldQuad(quad));
  }
  function normalize(dataset) {
    const canonize = new import_URDNA2015Sync.default();
    return canonize.main(toJsonldDataset(dataset));
  }
  var import_URDNA2015Sync, normalize_default;
  var init_normalize = __esm({
    "node_modules/@rdfjs/normalize/index.js"() {
      init_shim();
      import_URDNA2015Sync = __toESM(require_URDNA2015Sync(), 1);
      normalize_default = normalize;
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser6 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list5 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_shim();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer3 = _require.Buffer;
      var _require2 = require_util2();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer3.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer3.alloc(0);
            var ret = Buffer3.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer3.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy6 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              import_process.default.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              import_process.default.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            import_process.default.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/errors-browser.js
  var require_errors_browser5 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_shim();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state5 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_INVALID_OPT_VALUE = require_errors_browser5().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable6 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser6();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy6();
      var _require = require_state5();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser5().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex6();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex6();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          import_process.default.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding2, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer3.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (isBuf)
          encoding2 = "buffer";
        else if (!encoding2)
          encoding2 = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ending)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding2, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
        if (typeof encoding2 === "string")
          encoding2 = encoding2.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding2);
        this._writableState.defaultEncoding = encoding2;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding2) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer3.from(chunk, encoding2);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding2, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding2);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding2 = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding: encoding2,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding2, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding2, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          import_process.default.nextTick(cb, er);
          import_process.default.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished4 = needFinish(state) || stream.destroyed;
          if (!finished4 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            import_process.default.nextTick(afterWrite, stream, state, finished4, cb);
          } else {
            afterWrite(stream, state, finished4, cb);
          }
        }
      }
      function afterWrite(stream, state, finished4, cb) {
        if (!finished4)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding2 = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding2, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding2, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding2 = null;
        } else if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding2);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            import_process.default.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            import_process.default.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex6 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var Readable5 = require_stream_readable6();
      var Writable = require_stream_writable6();
      require_inherits_browser()(Duplex, Readable5);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable5.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended)
          return;
        import_process.default.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream5 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser5().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once2(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator5 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_shim();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished4 = require_end_of_stream5();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        import_process.default.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              import_process.default.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished4(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser5 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_shim();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable6 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Readable5;
      var Duplex;
      Readable5.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser6();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list5();
      var destroyImpl = require_destroy6();
      var _require = require_state5();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser5().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable5, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex6();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder2().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable5(options) {
        Duplex = Duplex || require_stream_duplex6();
        if (!(this instanceof Readable5))
          return new Readable5(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable5.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable5.prototype.destroy = destroyImpl.destroy;
      Readable5.prototype._undestroy = destroyImpl.undestroy;
      Readable5.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable5.prototype.push = function(chunk, encoding2) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding2 = encoding2 || state.defaultEncoding;
            if (encoding2 !== state.encoding) {
              chunk = Buffer3.from(chunk, encoding2);
              encoding2 = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
      };
      Readable5.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding2) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable5.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable5.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable5.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          import_process.default.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          import_process.default.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable5.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable5.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          import_process.default.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable5.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable5.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              import_process.default.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable5.prototype.addListener = Readable5.prototype.on;
      Readable5.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable5.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable5.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          import_process.default.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable5.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable5.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable5.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator5();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable5.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableBuffer", {
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableFlowing", {
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable5._fromList = fromList;
      Object.defineProperty(Readable5.prototype, "readableLength", {
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          import_process.default.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable5.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser5();
          }
          return from(Readable5, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform6 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform;
      var _require$codes = require_errors_browser5().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex6();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding2) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding2);
      };
      Transform.prototype._transform = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding2, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding2;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough6 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough;
      var Transform = require_stream_transform6();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding2, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline5 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_shim();
      var eos;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser5().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once2(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream5();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/rdf-ext/node_modules/readable-stream/readable-browser.js
  var require_readable_browser5 = __commonJS({
    "node_modules/rdf-ext/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_shim();
      exports = module.exports = require_stream_readable6();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable6();
      exports.Duplex = require_stream_duplex6();
      exports.Transform = require_stream_transform6();
      exports.PassThrough = require_stream_passthrough6();
      exports.finished = require_end_of_stream5();
      exports.pipeline = require_pipeline5();
    }
  });

  // node_modules/rdf-ext/lib/readableFrom.js
  function readableFrom(iterable) {
    let reading = false;
    const iterator = iterable[Symbol.iterator]();
    const next = () => {
      try {
        const { value, done } = iterator.next();
        if (done) {
          readable.push(null);
        } else if (readable.push(value)) {
          next();
        } else {
          reading = false;
        }
      } catch (err) {
        readable.destroy(err);
      }
    };
    const readable = new import_readable_stream6.Readable({
      objectMode: true,
      read: () => {
        if (!reading) {
          reading = true;
          next();
        }
      }
    });
    return readable;
  }
  var import_readable_stream6, readableFrom_default;
  var init_readableFrom = __esm({
    "node_modules/rdf-ext/lib/readableFrom.js"() {
      init_shim();
      import_readable_stream6 = __toESM(require_readable_browser5(), 1);
      readableFrom_default = readableFrom;
    }
  });

  // node_modules/rdf-ext/lib/Dataset.js
  function createDataset(obj, quads) {
    return new obj.constructor(quads);
  }
  var import_to_ntriples9, import_readable_stream7, DatasetExt, Dataset_default;
  var init_Dataset = __esm({
    "node_modules/rdf-ext/lib/Dataset.js"() {
      init_shim();
      init_DatasetCore();
      init_normalize();
      import_to_ntriples9 = __toESM(require_to_ntriples3(), 1);
      import_readable_stream7 = __toESM(require_readable_browser5(), 1);
      init_readableFrom();
      DatasetExt = class extends DatasetCore_default {
        addAll(quads) {
          for (const quad of quads) {
            this.add(quad);
          }
          return this;
        }
        clone() {
          return createDataset(this, this);
        }
        deleteMatches(subject, predicate, object, graph2) {
          for (const quad of this.match(subject, predicate, object, graph2)) {
            this.delete(quad);
          }
          return this;
        }
        difference(other) {
          return this.filter((quad) => !other.has(quad));
        }
        equals(other) {
          return this.toCanonical() === other.toCanonical();
        }
        every(callback) {
          return Array.from(this).every((quad) => callback(quad, this));
        }
        filter(callback) {
          return createDataset(this, Array.from(this).filter((quad) => callback(quad, this)));
        }
        forEach(callback) {
          Array.from(this).forEach((quad) => callback(quad, this));
        }
        import(stream) {
          stream.on("data", (quad) => this.add(quad));
          return new Promise((resolve, reject) => {
            (0, import_readable_stream7.finished)(stream, (err) => {
              if (err) {
                reject(err);
              } else {
                resolve(this);
              }
            });
          });
        }
        intersection(other) {
          return this.filter((quad) => other.has(quad));
        }
        map(callback) {
          return createDataset(this, Array.from(this).map((quad) => callback(quad, this)));
        }
        merge(other) {
          return this.clone().addAll(other);
        }
        some(callback) {
          return Array.from(this).some((quad) => callback(quad, this));
        }
        toCanonical() {
          return normalize_default(this);
        }
        toStream() {
          return readableFrom_default(this);
        }
        toString() {
          return (0, import_to_ntriples9.default)(this);
        }
      };
      Dataset_default = DatasetExt;
    }
  });

  // node_modules/rdf-ext/DatasetFactory.js
  var DatasetFactory, DatasetFactory_default;
  var init_DatasetFactory = __esm({
    "node_modules/rdf-ext/DatasetFactory.js"() {
      init_shim();
      init_Dataset();
      DatasetFactory = class {
        dataset(quads, graph2) {
          const dataset = new Dataset_default();
          if (quads) {
            if (graph2) {
              for (const quad of quads) {
                dataset.add(this.quad(quad.subject, quad.predicate, quad.object, graph2));
              }
            } else {
              dataset.addAll(quads);
            }
          }
          return dataset;
        }
      };
      DatasetFactory.exports = ["dataset"];
      DatasetFactory_default = DatasetFactory;
    }
  });

  // node_modules/rdf-ext/index.js
  var rdf_ext_exports = {};
  __export(rdf_ext_exports, {
    ClownfaceFactory: () => ClownfaceFactory_default,
    DataFactory: () => DataFactory_default,
    DatasetFactory: () => DatasetFactory_default,
    Environment: () => Environment_default,
    FetchFactory: () => Factory_default,
    FormatsFactory: () => FormatsFactory_default,
    NamespaceFactory: () => Factory_default3,
    PrefixMapFactory: () => Factory_default4,
    TermMapFactory: () => Factory_default5,
    TermSetFactory: () => Factory_default6,
    TraverserFactory: () => Factory_default7,
    default: () => rdf_ext_default
  });
  var defaultEnv, rdf_ext_default;
  var init_rdf_ext = __esm({
    "node_modules/rdf-ext/index.js"() {
      init_shim();
      init_Environment();
      init_FormatsFactory();
      init_Factory();
      init_Factory3();
      init_Factory4();
      init_Factory5();
      init_Factory6();
      init_Factory7();
      init_ClownfaceFactory();
      init_DataFactory();
      init_DatasetFactory();
      defaultEnv = new Environment_default([
        ClownfaceFactory_default,
        DataFactory_default,
        DatasetFactory_default,
        Factory_default,
        FormatsFactory_default,
        Factory_default3,
        Factory_default4,
        Factory_default5,
        Factory_default6,
        Factory_default7
      ], { bind: true });
      rdf_ext_default = defaultEnv;
    }
  });

  // node_modules/rdfoo/dist/rdfoo/node.js
  var require_node = __commonJS({
    "node_modules/rdfoo/dist/rdfoo/node.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toBool = exports.createBoolNode = exports.toFloat = exports.isFloat = exports.createFloatNode = exports.toString = exports.createStringNode = exports.toInt = exports.createIntNode = exports.toUri = exports.isUri = exports.createUriNode = void 0;
      var rdf_ext_1 = (init_rdf_ext(), __toCommonJS(rdf_ext_exports));
      function createUriNode(uri) {
        if (!(typeof uri === "string")) {
          throw new Error("trying to create URI node for " + typeof uri + " " + uri);
        }
        return rdf_ext_1.default.namedNode(uri);
      }
      exports.createUriNode = createUriNode;
      function isUri(node19) {
        return node19.termType === "NamedNode";
      }
      exports.isUri = isUri;
      function toUri(node19) {
        if (node19 === void 0)
          return;
        if (node19.termType !== "NamedNode") {
        }
        return node19.value;
      }
      exports.toUri = toUri;
      function createIntNode(value) {
        return rdf_ext_1.default.literal("" + value);
      }
      exports.createIntNode = createIntNode;
      function toInt(node19) {
        if (node19 === void 0)
          return;
        if (node19.termType !== "Literal") {
          console.error(JSON.stringify(node19));
          throw new Error("Integer node must be a literal; instead got " + node19.termType);
        }
        const res = parseInt(node19.value);
        if (isNaN(res)) {
          console.warn("parseInt returned NaN for " + JSON.stringify(node19.value));
        }
        return res;
      }
      exports.toInt = toInt;
      function createStringNode(value) {
        return rdf_ext_1.default.literal("" + value);
      }
      exports.createStringNode = createStringNode;
      function toString(node19) {
        if (node19 === void 0)
          return;
        if (node19.termType !== "Literal") {
          console.error(JSON.stringify(node19));
          throw new Error("String node must be a literal; instead got " + node19.termType);
        }
        return node19.value;
      }
      exports.toString = toString;
      function createFloatNode(value) {
        return rdf_ext_1.default.literal("" + value);
      }
      exports.createFloatNode = createFloatNode;
      function isFloat(node19) {
        return node19.termType === "Literal";
      }
      exports.isFloat = isFloat;
      function toFloat(node19) {
        if (node19 === void 0)
          return;
        if (node19.termType !== "Literal") {
          console.error(JSON.stringify(node19));
          throw new Error("Floating point node must be a literal; instead got " + node19.termType);
        }
        return parseFloat(node19.value);
      }
      exports.toFloat = toFloat;
      function createBoolNode(value) {
        return rdf_ext_1.default.literal(value ? "true" : "false");
      }
      exports.createBoolNode = createBoolNode;
      function toBool(node19) {
        if (node19 === void 0)
          return;
        if (node19.termType !== "Literal") {
          console.error(JSON.stringify(node19));
          throw new Error("Boolean node must be a literal; instead got " + node19.termType);
        }
        return node19.value === "true" ? true : false;
      }
      exports.toBool = toBool;
    }
  });

  // node_modules/shortid/lib/random/random-from-seed.js
  var require_random_from_seed = __commonJS({
    "node_modules/shortid/lib/random/random-from-seed.js"(exports, module) {
      "use strict";
      init_shim();
      var seed = 1;
      function getNextValue() {
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280;
      }
      function setSeed(_seed_) {
        seed = _seed_;
      }
      module.exports = {
        nextValue: getNextValue,
        seed: setSeed
      };
    }
  });

  // node_modules/shortid/lib/alphabet.js
  var require_alphabet = __commonJS({
    "node_modules/shortid/lib/alphabet.js"(exports, module) {
      "use strict";
      init_shim();
      var randomFromSeed = require_random_from_seed();
      var ORIGINAL = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
      var alphabet;
      var previousSeed;
      var shuffled;
      function reset() {
        shuffled = false;
      }
      function setCharacters(_alphabet_) {
        if (!_alphabet_) {
          if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
          }
          return;
        }
        if (_alphabet_ === alphabet) {
          return;
        }
        if (_alphabet_.length !== ORIGINAL.length) {
          throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. You submitted " + _alphabet_.length + " characters: " + _alphabet_);
        }
        var unique = _alphabet_.split("").filter(function(item, ind, arr) {
          return ind !== arr.lastIndexOf(item);
        });
        if (unique.length) {
          throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. These characters were not unique: " + unique.join(", "));
        }
        alphabet = _alphabet_;
        reset();
      }
      function characters(_alphabet_) {
        setCharacters(_alphabet_);
        return alphabet;
      }
      function setSeed(seed) {
        randomFromSeed.seed(seed);
        if (previousSeed !== seed) {
          reset();
          previousSeed = seed;
        }
      }
      function shuffle() {
        if (!alphabet) {
          setCharacters(ORIGINAL);
        }
        var sourceArray = alphabet.split("");
        var targetArray = [];
        var r = randomFromSeed.nextValue();
        var characterIndex;
        while (sourceArray.length > 0) {
          r = randomFromSeed.nextValue();
          characterIndex = Math.floor(r * sourceArray.length);
          targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
        }
        return targetArray.join("");
      }
      function getShuffled() {
        if (shuffled) {
          return shuffled;
        }
        shuffled = shuffle();
        return shuffled;
      }
      function lookup(index) {
        var alphabetShuffled = getShuffled();
        return alphabetShuffled[index];
      }
      function get() {
        return alphabet || ORIGINAL;
      }
      module.exports = {
        get,
        characters,
        seed: setSeed,
        lookup,
        shuffled: getShuffled
      };
    }
  });

  // node_modules/shortid/lib/random/random-byte-browser.js
  var require_random_byte_browser = __commonJS({
    "node_modules/shortid/lib/random/random-byte-browser.js"(exports, module) {
      "use strict";
      init_shim();
      var crypto = typeof window === "object" && (window.crypto || window.msCrypto);
      var randomByte;
      if (!crypto || !crypto.getRandomValues) {
        randomByte = function(size) {
          var bytes = [];
          for (var i = 0; i < size; i++) {
            bytes.push(Math.floor(Math.random() * 256));
          }
          return bytes;
        };
      } else {
        randomByte = function(size) {
          return crypto.getRandomValues(new Uint8Array(size));
        };
      }
      module.exports = randomByte;
    }
  });

  // node_modules/nanoid/format.browser.js
  var require_format_browser = __commonJS({
    "node_modules/nanoid/format.browser.js"(exports, module) {
      init_shim();
      module.exports = function(random, alphabet, size) {
        var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
        var step = -~(1.6 * mask * size / alphabet.length);
        var id = "";
        while (true) {
          var bytes = random(step);
          var i = step;
          while (i--) {
            id += alphabet[bytes[i] & mask] || "";
            if (id.length === +size)
              return id;
          }
        }
      };
    }
  });

  // node_modules/shortid/lib/generate.js
  var require_generate = __commonJS({
    "node_modules/shortid/lib/generate.js"(exports, module) {
      "use strict";
      init_shim();
      var alphabet = require_alphabet();
      var random = require_random_byte_browser();
      var format = require_format_browser();
      function generate(number) {
        var loopCounter = 0;
        var done;
        var str = "";
        while (!done) {
          str = str + format(random, alphabet.get(), 1);
          done = number < Math.pow(16, loopCounter + 1);
          loopCounter++;
        }
        return str;
      }
      module.exports = generate;
    }
  });

  // node_modules/shortid/lib/build.js
  var require_build = __commonJS({
    "node_modules/shortid/lib/build.js"(exports, module) {
      "use strict";
      init_shim();
      var generate = require_generate();
      var alphabet = require_alphabet();
      var REDUCE_TIME = 1567752802062;
      var version = 7;
      var counter;
      var previousSeconds;
      function build(clusterWorkerId) {
        var str = "";
        var seconds = Math.floor((Date.now() - REDUCE_TIME) * 1e-3);
        if (seconds === previousSeconds) {
          counter++;
        } else {
          counter = 0;
          previousSeconds = seconds;
        }
        str = str + generate(version);
        str = str + generate(clusterWorkerId);
        if (counter > 0) {
          str = str + generate(counter);
        }
        str = str + generate(seconds);
        return str;
      }
      module.exports = build;
    }
  });

  // node_modules/shortid/lib/is-valid.js
  var require_is_valid = __commonJS({
    "node_modules/shortid/lib/is-valid.js"(exports, module) {
      "use strict";
      init_shim();
      var alphabet = require_alphabet();
      function isShortId(id) {
        if (!id || typeof id !== "string" || id.length < 6) {
          return false;
        }
        var nonAlphabetic = new RegExp("[^" + alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
        return !nonAlphabetic.test(id);
      }
      module.exports = isShortId;
    }
  });

  // node_modules/shortid/lib/util/cluster-worker-id-browser.js
  var require_cluster_worker_id_browser = __commonJS({
    "node_modules/shortid/lib/util/cluster-worker-id-browser.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = 0;
    }
  });

  // node_modules/shortid/lib/index.js
  var require_lib = __commonJS({
    "node_modules/shortid/lib/index.js"(exports, module) {
      "use strict";
      init_shim();
      var alphabet = require_alphabet();
      var build = require_build();
      var isValid = require_is_valid();
      var clusterWorkerId = require_cluster_worker_id_browser() || 0;
      function seed(seedValue) {
        alphabet.seed(seedValue);
        return module.exports;
      }
      function worker(workerId) {
        clusterWorkerId = workerId;
        return module.exports;
      }
      function characters(newCharacters) {
        if (newCharacters !== void 0) {
          alphabet.characters(newCharacters);
        }
        return alphabet.shuffled();
      }
      function generate() {
        return build(clusterWorkerId);
      }
      module.exports = generate;
      module.exports.generate = generate;
      module.exports.seed = seed;
      module.exports.worker = worker;
      module.exports.characters = characters;
      module.exports.isValid = isValid;
    }
  });

  // node_modules/shortid/index.js
  var require_shortid = __commonJS({
    "node_modules/shortid/index.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = require_lib();
    }
  });

  // node_modules/rdfoo/dist/rdfoo/identifyFiletype.js
  var require_identifyFiletype = __commonJS({
    "node_modules/rdfoo/dist/rdfoo/identifyFiletype.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Filetype = void 0;
      var Filetype2;
      (function(Filetype3) {
        Filetype3[Filetype3["FASTA"] = 0] = "FASTA";
        Filetype3[Filetype3["GenBank"] = 1] = "GenBank";
        Filetype3[Filetype3["RDFXML"] = 2] = "RDFXML";
        Filetype3[Filetype3["NTriples"] = 3] = "NTriples";
      })(Filetype2 = exports.Filetype || (exports.Filetype = {}));
      function identifyFiletype4(content, mimeType) {
        switch (mimeType) {
          case "application/rdf+xml":
          case "application/xml":
          case "text/xml":
            return Filetype2.RDFXML;
          case "text/turtle":
          case "text/n3":
          case "text/n-triples":
            return Filetype2.NTriples;
        }
        let n = 0;
        while (content[n].trim().length === 0)
          ++n;
        if (content[n] === ">") {
          return Filetype2.FASTA;
        }
        if (content[n] === "@") {
          return Filetype2.NTriples;
        }
        if (content[n] === "#") {
          return Filetype2.NTriples;
        }
        if (content.substr(n, 5) === "LOCUS") {
          return Filetype2.GenBank;
        }
        if (content.substr(n, 5) === "<?xml") {
          return Filetype2.RDFXML;
        }
        if (content.substr(n, 5) === "<rdf:") {
          return Filetype2.RDFXML;
        }
        let firstLineEnd = content.indexOf("\n", n);
        if (firstLineEnd !== -1) {
          if (content[n] === "<" && content[firstLineEnd - 1] === ".") {
            return Filetype2.NTriples;
          }
        }
        return null;
      }
      exports.default = identifyFiletype4;
    }
  });

  // node_modules/@rdfjs/sink/index.js
  var require_sink = __commonJS({
    "node_modules/@rdfjs/sink/index.js"(exports, module) {
      init_shim();
      var Sink = class {
        constructor(Impl, options) {
          this.Impl = Impl;
          this.options = options;
        }
        import(input, options) {
          const output = new this.Impl(input, Object.assign({}, this.options, options));
          input.on("end", () => {
            if (!output.readable) {
              output.emit("end");
            }
          });
          input.on("error", (err) => {
            output.emit("error", err);
          });
          return output;
        }
      };
      module.exports = Sink;
    }
  });

  // node_modules/jsonparse/jsonparse.js
  var require_jsonparse = __commonJS({
    "node_modules/jsonparse/jsonparse.js"(exports, module) {
      init_shim();
      var C = {};
      var LEFT_BRACE = C.LEFT_BRACE = 1;
      var RIGHT_BRACE = C.RIGHT_BRACE = 2;
      var LEFT_BRACKET = C.LEFT_BRACKET = 3;
      var RIGHT_BRACKET = C.RIGHT_BRACKET = 4;
      var COLON = C.COLON = 5;
      var COMMA = C.COMMA = 6;
      var TRUE = C.TRUE = 7;
      var FALSE = C.FALSE = 8;
      var NULL = C.NULL = 9;
      var STRING = C.STRING = 10;
      var NUMBER = C.NUMBER = 11;
      var START = C.START = 17;
      var STOP = C.STOP = 18;
      var TRUE1 = C.TRUE1 = 33;
      var TRUE2 = C.TRUE2 = 34;
      var TRUE3 = C.TRUE3 = 35;
      var FALSE1 = C.FALSE1 = 49;
      var FALSE2 = C.FALSE2 = 50;
      var FALSE3 = C.FALSE3 = 51;
      var FALSE4 = C.FALSE4 = 52;
      var NULL1 = C.NULL1 = 65;
      var NULL2 = C.NULL2 = 66;
      var NULL3 = C.NULL3 = 67;
      var NUMBER1 = C.NUMBER1 = 81;
      var NUMBER3 = C.NUMBER3 = 83;
      var STRING1 = C.STRING1 = 97;
      var STRING2 = C.STRING2 = 98;
      var STRING3 = C.STRING3 = 99;
      var STRING4 = C.STRING4 = 100;
      var STRING5 = C.STRING5 = 101;
      var STRING6 = C.STRING6 = 102;
      var VALUE = C.VALUE = 113;
      var KEY = C.KEY = 114;
      var OBJECT = C.OBJECT = 129;
      var ARRAY = C.ARRAY = 130;
      var BACK_SLASH = "\\".charCodeAt(0);
      var FORWARD_SLASH = "/".charCodeAt(0);
      var BACKSPACE = "\b".charCodeAt(0);
      var FORM_FEED = "\f".charCodeAt(0);
      var NEWLINE = "\n".charCodeAt(0);
      var CARRIAGE_RETURN = "\r".charCodeAt(0);
      var TAB = "	".charCodeAt(0);
      var STRING_BUFFER_SIZE = 64 * 1024;
      function Parser() {
        this.tState = START;
        this.value = void 0;
        this.string = void 0;
        this.stringBuffer = import_buffer.Buffer.alloc ? import_buffer.Buffer.alloc(STRING_BUFFER_SIZE) : new import_buffer.Buffer(STRING_BUFFER_SIZE);
        this.stringBufferOffset = 0;
        this.unicode = void 0;
        this.highSurrogate = void 0;
        this.key = void 0;
        this.mode = void 0;
        this.stack = [];
        this.state = VALUE;
        this.bytes_remaining = 0;
        this.bytes_in_sequence = 0;
        this.temp_buffs = { "2": new import_buffer.Buffer(2), "3": new import_buffer.Buffer(3), "4": new import_buffer.Buffer(4) };
        this.offset = -1;
      }
      Parser.toknam = function(code) {
        var keys = Object.keys(C);
        for (var i = 0, l = keys.length; i < l; i++) {
          var key = keys[i];
          if (C[key] === code) {
            return key;
          }
        }
        return code && "0x" + code.toString(16);
      };
      var proto = Parser.prototype;
      proto.onError = function(err) {
        throw err;
      };
      proto.charError = function(buffer, i) {
        this.tState = STOP;
        this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + Parser.toknam(this.tState)));
      };
      proto.appendStringChar = function(char) {
        if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString("utf8");
          this.stringBufferOffset = 0;
        }
        this.stringBuffer[this.stringBufferOffset++] = char;
      };
      proto.appendStringBuf = function(buf, start, end) {
        var size = buf.length;
        if (typeof start === "number") {
          if (typeof end === "number") {
            if (end < 0) {
              size = buf.length - start + end;
            } else {
              size = end - start;
            }
          } else {
            size = buf.length - start;
          }
        }
        if (size < 0) {
          size = 0;
        }
        if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
          this.stringBufferOffset = 0;
        }
        buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);
        this.stringBufferOffset += size;
      };
      proto.write = function(buffer) {
        if (typeof buffer === "string")
          buffer = new import_buffer.Buffer(buffer);
        var n;
        for (var i = 0, l = buffer.length; i < l; i++) {
          if (this.tState === START) {
            n = buffer[i];
            this.offset++;
            if (n === 123) {
              this.onToken(LEFT_BRACE, "{");
            } else if (n === 125) {
              this.onToken(RIGHT_BRACE, "}");
            } else if (n === 91) {
              this.onToken(LEFT_BRACKET, "[");
            } else if (n === 93) {
              this.onToken(RIGHT_BRACKET, "]");
            } else if (n === 58) {
              this.onToken(COLON, ":");
            } else if (n === 44) {
              this.onToken(COMMA, ",");
            } else if (n === 116) {
              this.tState = TRUE1;
            } else if (n === 102) {
              this.tState = FALSE1;
            } else if (n === 110) {
              this.tState = NULL1;
            } else if (n === 34) {
              this.string = "";
              this.stringBufferOffset = 0;
              this.tState = STRING1;
            } else if (n === 45) {
              this.string = "-";
              this.tState = NUMBER1;
            } else {
              if (n >= 48 && n < 64) {
                this.string = String.fromCharCode(n);
                this.tState = NUMBER3;
              } else if (n === 32 || n === 9 || n === 10 || n === 13) {
              } else {
                return this.charError(buffer, i);
              }
            }
          } else if (this.tState === STRING1) {
            n = buffer[i];
            if (this.bytes_remaining > 0) {
              for (var j = 0; j < this.bytes_remaining; j++) {
                this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
              }
              this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);
              this.bytes_in_sequence = this.bytes_remaining = 0;
              i = i + j - 1;
            } else if (this.bytes_remaining === 0 && n >= 128) {
              if (n <= 193 || n > 244) {
                return this.onError(new Error("Invalid UTF-8 character at position " + i + " in state " + Parser.toknam(this.tState)));
              }
              if (n >= 194 && n <= 223)
                this.bytes_in_sequence = 2;
              if (n >= 224 && n <= 239)
                this.bytes_in_sequence = 3;
              if (n >= 240 && n <= 244)
                this.bytes_in_sequence = 4;
              if (this.bytes_in_sequence + i > buffer.length) {
                for (var k = 0; k <= buffer.length - 1 - i; k++) {
                  this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k];
                }
                this.bytes_remaining = i + this.bytes_in_sequence - buffer.length;
                i = buffer.length - 1;
              } else {
                this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);
                i = i + this.bytes_in_sequence - 1;
              }
            } else if (n === 34) {
              this.tState = START;
              this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
              this.stringBufferOffset = 0;
              this.onToken(STRING, this.string);
              this.offset += import_buffer.Buffer.byteLength(this.string, "utf8") + 1;
              this.string = void 0;
            } else if (n === 92) {
              this.tState = STRING2;
            } else if (n >= 32) {
              this.appendStringChar(n);
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === STRING2) {
            n = buffer[i];
            if (n === 34) {
              this.appendStringChar(n);
              this.tState = STRING1;
            } else if (n === 92) {
              this.appendStringChar(BACK_SLASH);
              this.tState = STRING1;
            } else if (n === 47) {
              this.appendStringChar(FORWARD_SLASH);
              this.tState = STRING1;
            } else if (n === 98) {
              this.appendStringChar(BACKSPACE);
              this.tState = STRING1;
            } else if (n === 102) {
              this.appendStringChar(FORM_FEED);
              this.tState = STRING1;
            } else if (n === 110) {
              this.appendStringChar(NEWLINE);
              this.tState = STRING1;
            } else if (n === 114) {
              this.appendStringChar(CARRIAGE_RETURN);
              this.tState = STRING1;
            } else if (n === 116) {
              this.appendStringChar(TAB);
              this.tState = STRING1;
            } else if (n === 117) {
              this.unicode = "";
              this.tState = STRING3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6) {
            n = buffer[i];
            if (n >= 48 && n < 64 || n > 64 && n <= 70 || n > 96 && n <= 102) {
              this.unicode += String.fromCharCode(n);
              if (this.tState++ === STRING6) {
                var intVal = parseInt(this.unicode, 16);
                this.unicode = void 0;
                if (this.highSurrogate !== void 0 && intVal >= 56320 && intVal < 57343 + 1) {
                  this.appendStringBuf(new import_buffer.Buffer(String.fromCharCode(this.highSurrogate, intVal)));
                  this.highSurrogate = void 0;
                } else if (this.highSurrogate === void 0 && intVal >= 55296 && intVal < 56319 + 1) {
                  this.highSurrogate = intVal;
                } else {
                  if (this.highSurrogate !== void 0) {
                    this.appendStringBuf(new import_buffer.Buffer(String.fromCharCode(this.highSurrogate)));
                    this.highSurrogate = void 0;
                  }
                  this.appendStringBuf(new import_buffer.Buffer(String.fromCharCode(intVal)));
                }
                this.tState = STRING1;
              }
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {
            n = buffer[i];
            switch (n) {
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 46:
              case 101:
              case 69:
              case 43:
              case 45:
                this.string += String.fromCharCode(n);
                this.tState = NUMBER3;
                break;
              default:
                this.tState = START;
                var result = Number(this.string);
                if (isNaN(result)) {
                  return this.charError(buffer, i);
                }
                if (this.string.match(/[0-9]+/) == this.string && result.toString() != this.string) {
                  this.onToken(STRING, this.string);
                } else {
                  this.onToken(NUMBER, result);
                }
                this.offset += this.string.length - 1;
                this.string = void 0;
                i--;
                break;
            }
          } else if (this.tState === TRUE1) {
            if (buffer[i] === 114) {
              this.tState = TRUE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE2) {
            if (buffer[i] === 117) {
              this.tState = TRUE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE3) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(TRUE, true);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE1) {
            if (buffer[i] === 97) {
              this.tState = FALSE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE2) {
            if (buffer[i] === 108) {
              this.tState = FALSE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE3) {
            if (buffer[i] === 115) {
              this.tState = FALSE4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE4) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(FALSE, false);
              this.offset += 4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL1) {
            if (buffer[i] === 117) {
              this.tState = NULL2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL2) {
            if (buffer[i] === 108) {
              this.tState = NULL3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL3) {
            if (buffer[i] === 108) {
              this.tState = START;
              this.onToken(NULL, null);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          }
        }
      };
      proto.onToken = function(token, value) {
      };
      proto.parseError = function(token, value) {
        this.tState = STOP;
        this.onError(new Error("Unexpected " + Parser.toknam(token) + (value ? "(" + JSON.stringify(value) + ")" : "") + " in state " + Parser.toknam(this.state)));
      };
      proto.push = function() {
        this.stack.push({ value: this.value, key: this.key, mode: this.mode });
      };
      proto.pop = function() {
        var value = this.value;
        var parent = this.stack.pop();
        this.value = parent.value;
        this.key = parent.key;
        this.mode = parent.mode;
        this.emit(value);
        if (!this.mode) {
          this.state = VALUE;
        }
      };
      proto.emit = function(value) {
        if (this.mode) {
          this.state = COMMA;
        }
        this.onValue(value);
      };
      proto.onValue = function(value) {
      };
      proto.onToken = function(token, value) {
        if (this.state === VALUE) {
          if (token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL) {
            if (this.value) {
              this.value[this.key] = value;
            }
            this.emit(value);
          } else if (token === LEFT_BRACE) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = {};
            } else {
              this.value = {};
            }
            this.key = void 0;
            this.state = KEY;
            this.mode = OBJECT;
          } else if (token === LEFT_BRACKET) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = [];
            } else {
              this.value = [];
            }
            this.key = 0;
            this.mode = ARRAY;
            this.state = VALUE;
          } else if (token === RIGHT_BRACE) {
            if (this.mode === OBJECT) {
              this.pop();
            } else {
              return this.parseError(token, value);
            }
          } else if (token === RIGHT_BRACKET) {
            if (this.mode === ARRAY) {
              this.pop();
            } else {
              return this.parseError(token, value);
            }
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === KEY) {
          if (token === STRING) {
            this.key = value;
            this.state = COLON;
          } else if (token === RIGHT_BRACE) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === COLON) {
          if (token === COLON) {
            this.state = VALUE;
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === COMMA) {
          if (token === COMMA) {
            if (this.mode === ARRAY) {
              this.key++;
              this.state = VALUE;
            } else if (this.mode === OBJECT) {
              this.state = KEY;
            }
          } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else {
          return this.parseError(token, value);
        }
      };
      Parser.C = C;
      module.exports = Parser;
    }
  });

  // node_modules/cross-fetch/dist/browser-polyfill.js
  var require_browser_polyfill = __commonJS({
    "node_modules/cross-fetch/dist/browser-polyfill.js"(exports) {
      init_shim();
      (function(self2) {
        var irrelevant = function(exports2) {
          var support = {
            searchParams: "URLSearchParams" in self2,
            iterable: "Symbol" in self2 && "iterator" in Symbol,
            blob: "FileReader" in self2 && "Blob" in self2 && function() {
              try {
                new Blob();
                return true;
              } catch (e) {
                return false;
              }
            }(),
            formData: "FormData" in self2,
            arrayBuffer: "ArrayBuffer" in self2
          };
          function isDataView(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj);
          }
          if (support.arrayBuffer) {
            var viewClasses = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]"
            ];
            var isArrayBufferView = ArrayBuffer.isView || function(obj) {
              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
            };
          }
          function normalizeName(name) {
            if (typeof name !== "string") {
              name = String(name);
            }
            if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
              throw new TypeError("Invalid character in header field name");
            }
            return name.toLowerCase();
          }
          function normalizeValue(value) {
            if (typeof value !== "string") {
              value = String(value);
            }
            return value;
          }
          function iteratorFor(items) {
            var iterator = {
              next: function() {
                var value = items.shift();
                return { done: value === void 0, value };
              }
            };
            if (support.iterable) {
              iterator[Symbol.iterator] = function() {
                return iterator;
              };
            }
            return iterator;
          }
          function Headers3(headers) {
            this.map = {};
            if (headers instanceof Headers3) {
              headers.forEach(function(value, name) {
                this.append(name, value);
              }, this);
            } else if (Array.isArray(headers)) {
              headers.forEach(function(header23) {
                this.append(header23[0], header23[1]);
              }, this);
            } else if (headers) {
              Object.getOwnPropertyNames(headers).forEach(function(name) {
                this.append(name, headers[name]);
              }, this);
            }
          }
          Headers3.prototype.append = function(name, value) {
            name = normalizeName(name);
            value = normalizeValue(value);
            var oldValue = this.map[name];
            this.map[name] = oldValue ? oldValue + ", " + value : value;
          };
          Headers3.prototype["delete"] = function(name) {
            delete this.map[normalizeName(name)];
          };
          Headers3.prototype.get = function(name) {
            name = normalizeName(name);
            return this.has(name) ? this.map[name] : null;
          };
          Headers3.prototype.has = function(name) {
            return this.map.hasOwnProperty(normalizeName(name));
          };
          Headers3.prototype.set = function(name, value) {
            this.map[normalizeName(name)] = normalizeValue(value);
          };
          Headers3.prototype.forEach = function(callback, thisArg) {
            for (var name in this.map) {
              if (this.map.hasOwnProperty(name)) {
                callback.call(thisArg, this.map[name], name, this);
              }
            }
          };
          Headers3.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name) {
              items.push(name);
            });
            return iteratorFor(items);
          };
          Headers3.prototype.values = function() {
            var items = [];
            this.forEach(function(value) {
              items.push(value);
            });
            return iteratorFor(items);
          };
          Headers3.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name) {
              items.push([name, value]);
            });
            return iteratorFor(items);
          };
          if (support.iterable) {
            Headers3.prototype[Symbol.iterator] = Headers3.prototype.entries;
          }
          function consumed(body) {
            if (body.bodyUsed) {
              return Promise.reject(new TypeError("Already read"));
            }
            body.bodyUsed = true;
          }
          function fileReaderReady(reader) {
            return new Promise(function(resolve, reject) {
              reader.onload = function() {
                resolve(reader.result);
              };
              reader.onerror = function() {
                reject(reader.error);
              };
            });
          }
          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise;
          }
          function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsText(blob);
            return promise;
          }
          function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);
            for (var i = 0; i < view.length; i++) {
              chars[i] = String.fromCharCode(view[i]);
            }
            return chars.join("");
          }
          function bufferClone(buf) {
            if (buf.slice) {
              return buf.slice(0);
            } else {
              var view = new Uint8Array(buf.byteLength);
              view.set(new Uint8Array(buf));
              return view.buffer;
            }
          }
          function Body() {
            this.bodyUsed = false;
            this._initBody = function(body) {
              this._bodyInit = body;
              if (!body) {
                this._bodyText = "";
              } else if (typeof body === "string") {
                this._bodyText = body;
              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
              } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString();
              } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                this._bodyInit = new Blob([this._bodyArrayBuffer]);
              } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                this._bodyArrayBuffer = bufferClone(body);
              } else {
                this._bodyText = body = Object.prototype.toString.call(body);
              }
              if (!this.headers.get("content-type")) {
                if (typeof body === "string") {
                  this.headers.set("content-type", "text/plain;charset=UTF-8");
                } else if (this._bodyBlob && this._bodyBlob.type) {
                  this.headers.set("content-type", this._bodyBlob.type);
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                }
              }
            };
            if (support.blob) {
              this.blob = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                } else if (this._bodyFormData) {
                  throw new Error("could not read FormData body as blob");
                } else {
                  return Promise.resolve(new Blob([this._bodyText]));
                }
              };
              this.arrayBuffer = function() {
                if (this._bodyArrayBuffer) {
                  return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
                } else {
                  return this.blob().then(readBlobAsArrayBuffer);
                }
              };
            }
            this.text = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as text");
              } else {
                return Promise.resolve(this._bodyText);
              }
            };
            if (support.formData) {
              this.formData = function() {
                return this.text().then(decode);
              };
            }
            this.json = function() {
              return this.text().then(JSON.parse);
            };
            return this;
          }
          var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method;
          }
          function Request(input, options) {
            options = options || {};
            var body = options.body;
            if (input instanceof Request) {
              if (input.bodyUsed) {
                throw new TypeError("Already read");
              }
              this.url = input.url;
              this.credentials = input.credentials;
              if (!options.headers) {
                this.headers = new Headers3(input.headers);
              }
              this.method = input.method;
              this.mode = input.mode;
              this.signal = input.signal;
              if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
              }
            } else {
              this.url = String(input);
            }
            this.credentials = options.credentials || this.credentials || "same-origin";
            if (options.headers || !this.headers) {
              this.headers = new Headers3(options.headers);
            }
            this.method = normalizeMethod(options.method || this.method || "GET");
            this.mode = options.mode || this.mode || null;
            this.signal = options.signal || this.signal;
            this.referrer = null;
            if ((this.method === "GET" || this.method === "HEAD") && body) {
              throw new TypeError("Body not allowed for GET or HEAD requests");
            }
            this._initBody(body);
          }
          Request.prototype.clone = function() {
            return new Request(this, { body: this._bodyInit });
          };
          function decode(body) {
            var form = new FormData();
            body.trim().split("&").forEach(function(bytes) {
              if (bytes) {
                var split = bytes.split("=");
                var name = split.shift().replace(/\+/g, " ");
                var value = split.join("=").replace(/\+/g, " ");
                form.append(decodeURIComponent(name), decodeURIComponent(value));
              }
            });
            return form;
          }
          function parseHeaders(rawHeaders) {
            var headers = new Headers3();
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
            preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
              var parts = line.split(":");
              var key = parts.shift().trim();
              if (key) {
                var value = parts.join(":").trim();
                headers.append(key, value);
              }
            });
            return headers;
          }
          Body.call(Request.prototype);
          function Response(bodyInit, options) {
            if (!options) {
              options = {};
            }
            this.type = "default";
            this.status = options.status === void 0 ? 200 : options.status;
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = "statusText" in options ? options.statusText : "OK";
            this.headers = new Headers3(options.headers);
            this.url = options.url || "";
            this._initBody(bodyInit);
          }
          Body.call(Response.prototype);
          Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new Headers3(this.headers),
              url: this.url
            });
          };
          Response.error = function() {
            var response = new Response(null, { status: 0, statusText: "" });
            response.type = "error";
            return response;
          };
          var redirectStatuses = [301, 302, 303, 307, 308];
          Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
              throw new RangeError("Invalid status code");
            }
            return new Response(null, { status, headers: { location: url } });
          };
          exports2.DOMException = self2.DOMException;
          try {
            new exports2.DOMException();
          } catch (err) {
            exports2.DOMException = function(message, name) {
              this.message = message;
              this.name = name;
              var error = Error(message);
              this.stack = error.stack;
            };
            exports2.DOMException.prototype = Object.create(Error.prototype);
            exports2.DOMException.prototype.constructor = exports2.DOMException;
          }
          function fetch6(input, init) {
            return new Promise(function(resolve, reject) {
              var request = new Request(input, init);
              if (request.signal && request.signal.aborted) {
                return reject(new exports2.DOMException("Aborted", "AbortError"));
              }
              var xhr = new XMLHttpRequest();
              function abortXhr() {
                xhr.abort();
              }
              xhr.onload = function() {
                var options = {
                  status: xhr.status,
                  statusText: xhr.statusText,
                  headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                };
                options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
                var body = "response" in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(body, options));
              };
              xhr.onerror = function() {
                reject(new TypeError("Network request failed"));
              };
              xhr.ontimeout = function() {
                reject(new TypeError("Network request failed"));
              };
              xhr.onabort = function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              };
              xhr.open(request.method, request.url, true);
              if (request.credentials === "include") {
                xhr.withCredentials = true;
              } else if (request.credentials === "omit") {
                xhr.withCredentials = false;
              }
              if ("responseType" in xhr && support.blob) {
                xhr.responseType = "blob";
              }
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
              if (request.signal) {
                request.signal.addEventListener("abort", abortXhr);
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    request.signal.removeEventListener("abort", abortXhr);
                  }
                };
              }
              xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
            });
          }
          fetch6.polyfill = true;
          if (!self2.fetch) {
            self2.fetch = fetch6;
            self2.Headers = Headers3;
            self2.Request = Request;
            self2.Response = Response;
          }
          exports2.Headers = Headers3;
          exports2.Request = Request;
          exports2.Response = Response;
          exports2.fetch = fetch6;
          Object.defineProperty(exports2, "__esModule", { value: true });
          return exports2;
        }({});
      })(typeof self !== "undefined" ? self : exports);
    }
  });

  // node_modules/relative-to-absolute-iri/lib/Resolve.js
  var require_Resolve = __commonJS({
    "node_modules/relative-to-absolute-iri/lib/Resolve.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      function resolve(relativeIRI, baseIRI) {
        baseIRI = baseIRI || "";
        const baseFragmentPos = baseIRI.indexOf("#");
        if (baseFragmentPos > 0) {
          baseIRI = baseIRI.substr(0, baseFragmentPos);
        }
        if (!relativeIRI.length) {
          if (baseIRI.indexOf(":") < 0) {
            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);
          }
          return baseIRI;
        }
        if (relativeIRI.startsWith("?")) {
          const baseQueryPos = baseIRI.indexOf("?");
          if (baseQueryPos > 0) {
            baseIRI = baseIRI.substr(0, baseQueryPos);
          }
          return baseIRI + relativeIRI;
        }
        if (relativeIRI.startsWith("#")) {
          return baseIRI + relativeIRI;
        }
        if (!baseIRI.length) {
          const relativeColonPos = relativeIRI.indexOf(":");
          if (relativeColonPos < 0) {
            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);
          }
          return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);
        }
        const valueColonPos = relativeIRI.indexOf(":");
        if (valueColonPos >= 0) {
          return removeDotSegmentsOfPath(relativeIRI, valueColonPos);
        }
        const baseColonPos = baseIRI.indexOf(":");
        if (baseColonPos < 0) {
          throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);
        }
        const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);
        if (relativeIRI.indexOf("//") === 0) {
          return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
        }
        let baseSlashAfterColonPos;
        if (baseIRI.indexOf("//", baseColonPos) === baseColonPos + 1) {
          baseSlashAfterColonPos = baseIRI.indexOf("/", baseColonPos + 3);
          if (baseSlashAfterColonPos < 0) {
            if (baseIRI.length > baseColonPos + 3) {
              return baseIRI + "/" + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
            } else {
              return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
            }
          }
        } else {
          baseSlashAfterColonPos = baseIRI.indexOf("/", baseColonPos + 1);
          if (baseSlashAfterColonPos < 0) {
            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);
          }
        }
        if (relativeIRI.indexOf("/") === 0) {
          return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);
        }
        let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);
        const baseIRILastSlashPos = baseIRIPath.lastIndexOf("/");
        if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {
          baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);
          if (relativeIRI[0] === "." && relativeIRI[1] !== "." && relativeIRI[1] !== "/" && relativeIRI[2]) {
            relativeIRI = relativeIRI.substr(1);
          }
        }
        relativeIRI = baseIRIPath + relativeIRI;
        relativeIRI = removeDotSegments(relativeIRI);
        return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;
      }
      exports.resolve = resolve;
      function removeDotSegments(path) {
        const segmentBuffers = [];
        let i = 0;
        while (i < path.length) {
          switch (path[i]) {
            case "/":
              if (path[i + 1] === ".") {
                if (path[i + 2] === ".") {
                  if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {
                    segmentBuffers.push([]);
                    i++;
                    break;
                  }
                  segmentBuffers.pop();
                  if (!path[i + 3]) {
                    segmentBuffers.push([]);
                  }
                  i += 3;
                } else {
                  if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {
                    segmentBuffers.push([]);
                    i++;
                    break;
                  }
                  if (!path[i + 2]) {
                    segmentBuffers.push([]);
                  }
                  i += 2;
                }
              } else {
                segmentBuffers.push([]);
                i++;
              }
              break;
            case "#":
            case "?":
              if (!segmentBuffers.length) {
                segmentBuffers.push([]);
              }
              segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));
              i = path.length;
              break;
            default:
              if (!segmentBuffers.length) {
                segmentBuffers.push([]);
              }
              segmentBuffers[segmentBuffers.length - 1].push(path[i]);
              i++;
              break;
          }
        }
        return "/" + segmentBuffers.map((buffer) => buffer.join("")).join("/");
      }
      exports.removeDotSegments = removeDotSegments;
      function removeDotSegmentsOfPath(iri, colonPosition) {
        let searchOffset = colonPosition + 1;
        if (colonPosition >= 0) {
          if (iri[colonPosition + 1] === "/" && iri[colonPosition + 2] === "/") {
            searchOffset = colonPosition + 3;
          }
        } else {
          if (iri[0] === "/" && iri[1] === "/") {
            searchOffset = 2;
          }
        }
        const pathSeparator = iri.indexOf("/", searchOffset);
        if (pathSeparator < 0) {
          return iri;
        }
        const base = iri.substr(0, pathSeparator);
        const path = iri.substr(pathSeparator);
        return base + removeDotSegments(path);
      }
      exports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;
      function isCharacterAllowedAfterRelativePathSegment(character) {
        return !character || character === "#" || character === "?" || character === "/";
      }
    }
  });

  // node_modules/relative-to-absolute-iri/index.js
  var require_relative_to_absolute_iri = __commonJS({
    "node_modules/relative-to-absolute-iri/index.js"(exports) {
      "use strict";
      init_shim();
      function __export2(m) {
        for (var p in m)
          if (!exports.hasOwnProperty(p))
            exports[p] = m[p];
      }
      Object.defineProperty(exports, "__esModule", { value: true });
      __export2(require_Resolve());
    }
  });

  // node_modules/jsonld-context-parser/lib/ErrorCoded.js
  var require_ErrorCoded = __commonJS({
    "node_modules/jsonld-context-parser/lib/ErrorCoded.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ERROR_CODES = exports.ErrorCoded = void 0;
      var ErrorCoded = class extends Error {
        constructor(message, code) {
          super(message);
          this.code = code;
        }
      };
      exports.ErrorCoded = ErrorCoded;
      var ERROR_CODES;
      (function(ERROR_CODES2) {
        ERROR_CODES2["COLLIDING_KEYWORDS"] = "colliding keywords";
        ERROR_CODES2["CONFLICTING_INDEXES"] = "conflicting indexes";
        ERROR_CODES2["CYCLIC_IRI_MAPPING"] = "cyclic IRI mapping";
        ERROR_CODES2["INVALID_ID_VALUE"] = "invalid @id value";
        ERROR_CODES2["INVALID_INDEX_VALUE"] = "invalid @index value";
        ERROR_CODES2["INVALID_NEST_VALUE"] = "invalid @nest value";
        ERROR_CODES2["INVALID_PREFIX_VALUE"] = "invalid @prefix value";
        ERROR_CODES2["INVALID_PROPAGATE_VALUE"] = "invalid @propagate value";
        ERROR_CODES2["INVALID_REVERSE_VALUE"] = "invalid @reverse value";
        ERROR_CODES2["INVALID_IMPORT_VALUE"] = "invalid @import value";
        ERROR_CODES2["INVALID_VERSION_VALUE"] = "invalid @version value";
        ERROR_CODES2["INVALID_BASE_IRI"] = "invalid base IRI";
        ERROR_CODES2["INVALID_CONTAINER_MAPPING"] = "invalid container mapping";
        ERROR_CODES2["INVALID_CONTEXT_ENTRY"] = "invalid context entry";
        ERROR_CODES2["INVALID_CONTEXT_NULLIFICATION"] = "invalid context nullification";
        ERROR_CODES2["INVALID_DEFAULT_LANGUAGE"] = "invalid default language";
        ERROR_CODES2["INVALID_INCLUDED_VALUE"] = "invalid @included value";
        ERROR_CODES2["INVALID_IRI_MAPPING"] = "invalid IRI mapping";
        ERROR_CODES2["INVALID_JSON_LITERAL"] = "invalid JSON literal";
        ERROR_CODES2["INVALID_KEYWORD_ALIAS"] = "invalid keyword alias";
        ERROR_CODES2["INVALID_LANGUAGE_MAP_VALUE"] = "invalid language map value";
        ERROR_CODES2["INVALID_LANGUAGE_MAPPING"] = "invalid language mapping";
        ERROR_CODES2["INVALID_LANGUAGE_TAGGED_STRING"] = "invalid language-tagged string";
        ERROR_CODES2["INVALID_LANGUAGE_TAGGED_VALUE"] = "invalid language-tagged value";
        ERROR_CODES2["INVALID_LOCAL_CONTEXT"] = "invalid local context";
        ERROR_CODES2["INVALID_REMOTE_CONTEXT"] = "invalid remote context";
        ERROR_CODES2["INVALID_REVERSE_PROPERTY"] = "invalid reverse property";
        ERROR_CODES2["INVALID_REVERSE_PROPERTY_MAP"] = "invalid reverse property map";
        ERROR_CODES2["INVALID_REVERSE_PROPERTY_VALUE"] = "invalid reverse property value";
        ERROR_CODES2["INVALID_SCOPED_CONTEXT"] = "invalid scoped context";
        ERROR_CODES2["INVALID_SCRIPT_ELEMENT"] = "invalid script element";
        ERROR_CODES2["INVALID_SET_OR_LIST_OBJECT"] = "invalid set or list object";
        ERROR_CODES2["INVALID_TERM_DEFINITION"] = "invalid term definition";
        ERROR_CODES2["INVALID_TYPE_MAPPING"] = "invalid type mapping";
        ERROR_CODES2["INVALID_TYPE_VALUE"] = "invalid type value";
        ERROR_CODES2["INVALID_TYPED_VALUE"] = "invalid typed value";
        ERROR_CODES2["INVALID_VALUE_OBJECT"] = "invalid value object";
        ERROR_CODES2["INVALID_VALUE_OBJECT_VALUE"] = "invalid value object value";
        ERROR_CODES2["INVALID_VOCAB_MAPPING"] = "invalid vocab mapping";
        ERROR_CODES2["IRI_CONFUSED_WITH_PREFIX"] = "IRI confused with prefix";
        ERROR_CODES2["KEYWORD_REDEFINITION"] = "keyword redefinition";
        ERROR_CODES2["LOADING_DOCUMENT_FAILED"] = "loading document failed";
        ERROR_CODES2["LOADING_REMOTE_CONTEXT_FAILED"] = "loading remote context failed";
        ERROR_CODES2["MULTIPLE_CONTEXT_LINK_HEADERS"] = "multiple context link headers";
        ERROR_CODES2["PROCESSING_MODE_CONFLICT"] = "processing mode conflict";
        ERROR_CODES2["PROTECTED_TERM_REDEFINITION"] = "protected term redefinition";
        ERROR_CODES2["CONTEXT_OVERFLOW"] = "context overflow";
        ERROR_CODES2["INVALID_BASE_DIRECTION"] = "invalid base direction";
        ERROR_CODES2["RECURSIVE_CONTEXT_INCLUSION"] = "recursive context inclusion";
        ERROR_CODES2["INVALID_STREAMING_KEY_ORDER"] = "invalid streaming key order";
      })(ERROR_CODES = exports.ERROR_CODES || (exports.ERROR_CODES = {}));
    }
  });

  // node_modules/http-link-header/lib/link.js
  var require_link = __commonJS({
    "node_modules/http-link-header/lib/link.js"(exports, module) {
      "use strict";
      init_shim();
      var COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i;
      var WS_TRIM_PATTERN = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
      var WS_CHAR_PATTERN = /\s|\uFEFF|\xA0/;
      var WS_FOLD_PATTERN = /\r?\n[\x20\x09]+/g;
      var DELIMITER_PATTERN = /[;,"]/;
      var WS_DELIMITER_PATTERN = /[;,"]|\s/;
      var TOKEN_PATTERN = /^[!#$%&'*+\-\.^_`|~\da-zA-Z]+$/;
      var STATE = {
        IDLE: 1 << 0,
        URI: 1 << 1,
        ATTR: 1 << 2
      };
      function trim(value) {
        return value.replace(WS_TRIM_PATTERN, "");
      }
      function hasWhitespace(value) {
        return WS_CHAR_PATTERN.test(value);
      }
      function skipWhitespace(value, offset) {
        while (hasWhitespace(value[offset])) {
          offset++;
        }
        return offset;
      }
      function needsQuotes(value) {
        return WS_DELIMITER_PATTERN.test(value) || !TOKEN_PATTERN.test(value);
      }
      var Link = class {
        constructor(value) {
          this.refs = [];
          if (value) {
            this.parse(value);
          }
        }
        rel(value) {
          var links = [];
          var type = value.toLowerCase();
          for (var i = 0; i < this.refs.length; i++) {
            if (this.refs[i].rel.toLowerCase() === type) {
              links.push(this.refs[i]);
            }
          }
          return links;
        }
        get(attr, value) {
          attr = attr.toLowerCase();
          var links = [];
          for (var i = 0; i < this.refs.length; i++) {
            if (this.refs[i][attr] === value) {
              links.push(this.refs[i]);
            }
          }
          return links;
        }
        set(link) {
          this.refs.push(link);
          return this;
        }
        has(attr, value) {
          attr = attr.toLowerCase();
          for (var i = 0; i < this.refs.length; i++) {
            if (this.refs[i][attr] === value) {
              return true;
            }
          }
          return false;
        }
        parse(value, offset) {
          offset = offset || 0;
          value = offset ? value.slice(offset) : value;
          value = trim(value).replace(WS_FOLD_PATTERN, "");
          var state = STATE.IDLE;
          var length = value.length;
          var offset = 0;
          var ref = null;
          while (offset < length) {
            if (state === STATE.IDLE) {
              if (hasWhitespace(value[offset])) {
                offset++;
                continue;
              } else if (value[offset] === "<") {
                if (ref != null) {
                  ref.rel != null ? this.refs.push(...Link.expandRelations(ref)) : this.refs.push(ref);
                }
                var end = value.indexOf(">", offset);
                if (end === -1)
                  throw new Error("Expected end of URI delimiter at offset " + offset);
                ref = { uri: value.slice(offset + 1, end) };
                offset = end;
                state = STATE.URI;
              } else {
                throw new Error('Unexpected character "' + value[offset] + '" at offset ' + offset);
              }
              offset++;
            } else if (state === STATE.URI) {
              if (hasWhitespace(value[offset])) {
                offset++;
                continue;
              } else if (value[offset] === ";") {
                state = STATE.ATTR;
                offset++;
              } else if (value[offset] === ",") {
                state = STATE.IDLE;
                offset++;
              } else {
                throw new Error('Unexpected character "' + value[offset] + '" at offset ' + offset);
              }
            } else if (state === STATE.ATTR) {
              if (value[offset] === ";" || hasWhitespace(value[offset])) {
                offset++;
                continue;
              }
              var end = value.indexOf("=", offset);
              if (end === -1)
                throw new Error("Expected attribute delimiter at offset " + offset);
              var attr = trim(value.slice(offset, end)).toLowerCase();
              var attrValue = "";
              offset = end + 1;
              offset = skipWhitespace(value, offset);
              if (value[offset] === '"') {
                offset++;
                while (offset < length) {
                  if (value[offset] === '"') {
                    offset++;
                    break;
                  }
                  if (value[offset] === "\\") {
                    offset++;
                  }
                  attrValue += value[offset];
                  offset++;
                }
              } else {
                var end = offset + 1;
                while (!DELIMITER_PATTERN.test(value[end]) && end < length) {
                  end++;
                }
                attrValue = value.slice(offset, end);
                offset = end;
              }
              if (ref[attr] && Link.isSingleOccurenceAttr(attr)) {
              } else if (attr[attr.length - 1] === "*") {
                ref[attr] = Link.parseExtendedValue(attrValue);
              } else {
                attrValue = attr === "type" ? attrValue.toLowerCase() : attrValue;
                if (ref[attr] != null) {
                  if (Array.isArray(ref[attr])) {
                    ref[attr].push(attrValue);
                  } else {
                    ref[attr] = [ref[attr], attrValue];
                  }
                } else {
                  ref[attr] = attrValue;
                }
              }
              switch (value[offset]) {
                case ",":
                  state = STATE.IDLE;
                  break;
                case ";":
                  state = STATE.ATTR;
                  break;
              }
              offset++;
            } else {
              throw new Error('Unknown parser state "' + state + '"');
            }
          }
          if (ref != null) {
            ref.rel != null ? this.refs.push(...Link.expandRelations(ref)) : this.refs.push(ref);
          }
          ref = null;
          return this;
        }
        toString() {
          var refs = [];
          var link = "";
          var ref = null;
          for (var i = 0; i < this.refs.length; i++) {
            ref = this.refs[i];
            link = Object.keys(this.refs[i]).reduce(function(link2, attr) {
              if (attr === "uri")
                return link2;
              return link2 + "; " + Link.formatAttribute(attr, ref[attr]);
            }, "<" + ref.uri + ">");
            refs.push(link);
          }
          return refs.join(", ");
        }
      };
      Link.isCompatibleEncoding = function(value) {
        return COMPATIBLE_ENCODING_PATTERN.test(value);
      };
      Link.parse = function(value, offset) {
        return new Link().parse(value, offset);
      };
      Link.isSingleOccurenceAttr = function(attr) {
        return attr === "rel" || attr === "type" || attr === "media" || attr === "title" || attr === "title*";
      };
      Link.isTokenAttr = function(attr) {
        return attr === "rel" || attr === "type" || attr === "anchor";
      };
      Link.escapeQuotes = function(value) {
        return value.replace(/"/g, '\\"');
      };
      Link.expandRelations = function(ref) {
        var rels = ref.rel.split(" ");
        return rels.map(function(rel) {
          var value = Object.assign({}, ref);
          value.rel = rel;
          return value;
        });
      };
      Link.parseExtendedValue = function(value) {
        var parts = /([^']+)?(?:'([^']+)')?(.+)/.exec(value);
        return {
          language: parts[2].toLowerCase(),
          encoding: Link.isCompatibleEncoding(parts[1]) ? null : parts[1].toLowerCase(),
          value: Link.isCompatibleEncoding(parts[1]) ? decodeURIComponent(parts[3]) : parts[3]
        };
      };
      Link.formatExtendedAttribute = function(attr, data) {
        var encoding2 = (data.encoding || "utf-8").toUpperCase();
        var language = data.language || "en";
        var encodedValue = "";
        if (import_buffer.Buffer.isBuffer(data.value) && Link.isCompatibleEncoding(encoding2)) {
          encodedValue = data.value.toString(encoding2);
        } else if (import_buffer.Buffer.isBuffer(data.value)) {
          encodedValue = data.value.toString("hex").replace(/[0-9a-f]{2}/gi, "%$1");
        } else {
          encodedValue = encodeURIComponent(data.value);
        }
        return attr + "=" + encoding2 + "'" + language + "'" + encodedValue;
      };
      Link.formatAttribute = function(attr, value) {
        if (Array.isArray(value)) {
          return value.map((item) => {
            return Link.formatAttribute(attr, item);
          }).join("; ");
        }
        if (attr[attr.length - 1] === "*" || typeof value !== "string") {
          return Link.formatExtendedAttribute(attr, value);
        }
        if (Link.isTokenAttr(attr)) {
          value = needsQuotes(value) ? '"' + Link.escapeQuotes(value) + '"' : Link.escapeQuotes(value);
        } else if (needsQuotes(value)) {
          value = encodeURIComponent(value);
          value = value.replace(/%20/g, " ").replace(/%2C/g, ",").replace(/%3B/g, ";");
          value = '"' + value + '"';
        }
        return attr + "=" + value;
      };
      module.exports = Link;
    }
  });

  // node_modules/jsonld-context-parser/lib/FetchDocumentLoader.js
  var require_FetchDocumentLoader = __commonJS({
    "node_modules/jsonld-context-parser/lib/FetchDocumentLoader.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FetchDocumentLoader = void 0;
      require_browser_polyfill();
      var ErrorCoded_1 = require_ErrorCoded();
      var http_link_header_1 = require_link();
      var relative_to_absolute_iri_1 = require_relative_to_absolute_iri();
      var FetchDocumentLoader = class {
        constructor(fetcher) {
          this.fetcher = fetcher;
        }
        async load(url) {
          const response = await (this.fetcher || fetch)(url, { headers: new Headers({ accept: "application/ld+json" }) });
          if (response.ok && response.headers) {
            let mediaType = response.headers.get("Content-Type");
            if (mediaType) {
              const colonPos = mediaType.indexOf(";");
              if (colonPos > 0) {
                mediaType = mediaType.substr(0, colonPos);
              }
            }
            if (mediaType === "application/ld+json") {
              return await response.json();
            } else {
              if (response.headers.has("Link")) {
                let alternateUrl;
                response.headers.forEach((value, key) => {
                  if (key === "link") {
                    const linkHeader = http_link_header_1.parse(value);
                    for (const link of linkHeader.get("type", "application/ld+json")) {
                      if (link.rel === "alternate") {
                        if (alternateUrl) {
                          throw new Error("Multiple JSON-LD alternate links were found on " + url);
                        }
                        alternateUrl = relative_to_absolute_iri_1.resolve(link.uri, url);
                      }
                    }
                  }
                });
                if (alternateUrl) {
                  return this.load(alternateUrl);
                }
              }
              throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD media type ${mediaType}`, ErrorCoded_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);
            }
          } else {
            throw new Error(response.statusText || `Status code: ${response.status}`);
          }
        }
      };
      exports.FetchDocumentLoader = FetchDocumentLoader;
    }
  });

  // node_modules/jsonld-context-parser/lib/Util.js
  var require_Util = __commonJS({
    "node_modules/jsonld-context-parser/lib/Util.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Util = void 0;
      var Util = class {
        static isCompactIri(term) {
          return term.indexOf(":") > 0 && !(term && term[0] === "#");
        }
        static getPrefix(term, context) {
          if (term && term[0] === "#") {
            return null;
          }
          const separatorPos = term.indexOf(":");
          if (separatorPos >= 0) {
            if (term.length > separatorPos + 1 && term.charAt(separatorPos + 1) === "/" && term.charAt(separatorPos + 2) === "/") {
              return null;
            }
            const prefix = term.substr(0, separatorPos);
            if (prefix === "_") {
              return null;
            }
            if (context[prefix]) {
              return prefix;
            }
          }
          return null;
        }
        static getContextValueId(contextValue) {
          if (contextValue === null || typeof contextValue === "string") {
            return contextValue;
          }
          const id = contextValue["@id"];
          return id ? id : null;
        }
        static isSimpleTermDefinitionPrefix(value, options) {
          return !Util.isPotentialKeyword(value) && (value[0] === "_" || options.allowPrefixNonGenDelims || Util.isPrefixIriEndingWithGenDelim(value));
        }
        static isPotentialKeyword(keyword) {
          return typeof keyword === "string" && Util.KEYWORD_REGEX.test(keyword);
        }
        static isPrefixIriEndingWithGenDelim(prefixIri) {
          return Util.ENDS_WITH_GEN_DELIM.test(prefixIri);
        }
        static isPrefixValue(value) {
          return value && (typeof value === "string" || value && typeof value === "object");
        }
        static isValidIri(iri) {
          return Boolean(iri && Util.IRI_REGEX.test(iri));
        }
        static isValidIriWeak(iri) {
          return !!iri && iri[0] !== ":" && Util.IRI_REGEX_WEAK.test(iri);
        }
        static isValidKeyword(keyword) {
          return Util.VALID_KEYWORDS[keyword];
        }
        static isTermProtected(context, key) {
          const value = context[key];
          return !(typeof value === "string") && value && value["@protected"];
        }
        static hasProtectedTerms(context) {
          for (const key of Object.keys(context)) {
            if (Util.isTermProtected(context, key)) {
              return true;
            }
          }
          return false;
        }
        static isReservedInternalKeyword(key) {
          return key.startsWith("@__");
        }
      };
      exports.Util = Util;
      Util.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ "<>{}|\\\[\]`#]*(#[^#]*)?$/;
      Util.IRI_REGEX_WEAK = /(?::[^:])|\//;
      Util.KEYWORD_REGEX = /^@[a-z]+$/i;
      Util.ENDS_WITH_GEN_DELIM = /[:/?#\[\]@]$/;
      Util.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;
      Util.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/;
      Util.VALID_KEYWORDS = {
        "@base": true,
        "@container": true,
        "@context": true,
        "@direction": true,
        "@graph": true,
        "@id": true,
        "@import": true,
        "@included": true,
        "@index": true,
        "@json": true,
        "@language": true,
        "@list": true,
        "@nest": true,
        "@none": true,
        "@prefix": true,
        "@propagate": true,
        "@protected": true,
        "@reverse": true,
        "@set": true,
        "@type": true,
        "@value": true,
        "@version": true,
        "@vocab": true
      };
      Util.EXPAND_KEYS_BLACKLIST = [
        "@base",
        "@vocab",
        "@language",
        "@version",
        "@direction"
      ];
      Util.ALIAS_DOMAIN_BLACKLIST = [
        "@container",
        "@graph",
        "@id",
        "@index",
        "@list",
        "@nest",
        "@none",
        "@prefix",
        "@reverse",
        "@set",
        "@type",
        "@value",
        "@version"
      ];
      Util.ALIAS_RANGE_BLACKLIST = [
        "@context",
        "@preserve"
      ];
      Util.CONTAINERS = [
        "@list",
        "@set",
        "@index",
        "@language",
        "@graph",
        "@id",
        "@type"
      ];
      Util.CONTAINERS_1_0 = [
        "@list",
        "@set",
        "@index"
      ];
    }
  });

  // node_modules/jsonld-context-parser/lib/JsonLdContextNormalized.js
  var require_JsonLdContextNormalized = __commonJS({
    "node_modules/jsonld-context-parser/lib/JsonLdContextNormalized.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JsonLdContextNormalized = void 0;
      var relative_to_absolute_iri_1 = require_relative_to_absolute_iri();
      var ContextParser_1 = require_ContextParser();
      var ErrorCoded_1 = require_ErrorCoded();
      var Util_1 = require_Util();
      var JsonLdContextNormalized = class {
        constructor(contextRaw) {
          this.contextRaw = contextRaw;
        }
        getContextRaw() {
          return this.contextRaw;
        }
        expandTerm(term, expandVocab, options = ContextParser_1.defaultExpandOptions) {
          const contextValue = this.contextRaw[term];
          if (contextValue === null || contextValue && contextValue["@id"] === null) {
            return null;
          }
          let validIriMapping = true;
          if (contextValue && expandVocab) {
            const value = Util_1.Util.getContextValueId(contextValue);
            if (value && value !== term) {
              if (typeof value !== "string" || !Util_1.Util.isValidIri(value) && !Util_1.Util.isValidKeyword(value)) {
                if (!Util_1.Util.isPotentialKeyword(value)) {
                  validIriMapping = false;
                }
              } else {
                return value;
              }
            }
          }
          const prefix = Util_1.Util.getPrefix(term, this.contextRaw);
          const vocab = this.contextRaw["@vocab"];
          const vocabRelative = (!!vocab || vocab === "") && vocab.indexOf(":") < 0;
          const base = this.contextRaw["@base"];
          const potentialKeyword = Util_1.Util.isPotentialKeyword(term);
          if (prefix) {
            const contextPrefixValue = this.contextRaw[prefix];
            const value = Util_1.Util.getContextValueId(contextPrefixValue);
            if (value) {
              if (typeof contextPrefixValue === "string" || !options.allowPrefixForcing) {
                if (!Util_1.Util.isSimpleTermDefinitionPrefix(value, options)) {
                  return term;
                }
              } else {
                if (value[0] !== "_" && !potentialKeyword && !contextPrefixValue["@prefix"] && !(term in this.contextRaw)) {
                  return term;
                }
              }
              return value + term.substr(prefix.length + 1);
            }
          } else if (expandVocab && (vocab || vocab === "" || options.allowVocabRelativeToBase && (base && vocabRelative)) && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {
            if (vocabRelative) {
              if (options.allowVocabRelativeToBase) {
                return (vocab || base ? relative_to_absolute_iri_1.resolve(vocab, base) : "") + term;
              } else {
                throw new ErrorCoded_1.ErrorCoded(`Relative vocab expansion for term '${term}' with vocab '${vocab}' is not allowed.`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);
              }
            } else {
              return vocab + term;
            }
          } else if (!expandVocab && base && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {
            return relative_to_absolute_iri_1.resolve(term, base);
          }
          if (validIriMapping) {
            return term;
          } else {
            throw new ErrorCoded_1.ErrorCoded(`Invalid IRI mapping found for context entry '${term}': '${JSON.stringify(contextValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
          }
        }
        compactIri(iri, vocab) {
          if (vocab && this.contextRaw["@vocab"] && iri.startsWith(this.contextRaw["@vocab"])) {
            return iri.substr(this.contextRaw["@vocab"].length);
          }
          if (!vocab && this.contextRaw["@base"] && iri.startsWith(this.contextRaw["@base"])) {
            return iri.substr(this.contextRaw["@base"].length);
          }
          const shortestPrefixing = { prefix: "", suffix: iri };
          for (const key in this.contextRaw) {
            const value = this.contextRaw[key];
            if (value && !Util_1.Util.isPotentialKeyword(key)) {
              const contextIri = Util_1.Util.getContextValueId(value);
              if (iri.startsWith(contextIri)) {
                const suffix = iri.substr(contextIri.length);
                if (!suffix) {
                  if (vocab) {
                    return key;
                  }
                } else if (suffix.length < shortestPrefixing.suffix.length) {
                  shortestPrefixing.prefix = key;
                  shortestPrefixing.suffix = suffix;
                }
              }
            }
          }
          if (shortestPrefixing.prefix) {
            return shortestPrefixing.prefix + ":" + shortestPrefixing.suffix;
          }
          return iri;
        }
      };
      exports.JsonLdContextNormalized = JsonLdContextNormalized;
    }
  });

  // node_modules/canonicalize/lib/canonicalize.js
  var require_canonicalize = __commonJS({
    "node_modules/canonicalize/lib/canonicalize.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = function serialize(object) {
        if (object === null || typeof object !== "object" || object.toJSON != null) {
          return JSON.stringify(object);
        }
        if (Array.isArray(object)) {
          return "[" + object.reduce((t, cv, ci) => {
            const comma = ci === 0 ? "" : ",";
            const value = cv === void 0 || typeof cv === "symbol" ? null : cv;
            return t + comma + serialize(value);
          }, "") + "]";
        }
        return "{" + Object.keys(object).sort().reduce((t, cv, ci) => {
          if (object[cv] === void 0 || typeof object[cv] === "symbol") {
            return t;
          }
          const comma = t.length === 0 ? "" : ",";
          return t + comma + serialize(cv) + ":" + serialize(object[cv]);
        }, "") + "}";
      };
    }
  });

  // node_modules/jsonld-context-parser/lib/ContextParser.js
  var require_ContextParser = __commonJS({
    "node_modules/jsonld-context-parser/lib/ContextParser.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultExpandOptions = exports.ContextParser = void 0;
      require_browser_polyfill();
      var relative_to_absolute_iri_1 = require_relative_to_absolute_iri();
      var ErrorCoded_1 = require_ErrorCoded();
      var FetchDocumentLoader_1 = require_FetchDocumentLoader();
      var JsonLdContextNormalized_1 = require_JsonLdContextNormalized();
      var Util_1 = require_Util();
      var canonicalizeJson = require_canonicalize();
      var ContextParser = class {
        constructor(options) {
          options = options || {};
          this.documentLoader = options.documentLoader || new FetchDocumentLoader_1.FetchDocumentLoader();
          this.documentCache = {};
          this.validateContext = !options.skipValidation;
          this.expandContentTypeToBase = !!options.expandContentTypeToBase;
          this.remoteContextsDepthLimit = options.remoteContextsDepthLimit || 32;
          this.redirectSchemaOrgHttps = "redirectSchemaOrgHttps" in options ? !!options.redirectSchemaOrgHttps : true;
        }
        static validateLanguage(value, strictRange, errorCode) {
          if (typeof value !== "string") {
            throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(value)}'`, errorCode);
          }
          if (!Util_1.Util.REGEX_LANGUAGE_TAG.test(value)) {
            if (strictRange) {
              throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(value)}'`, errorCode);
            } else {
              return false;
            }
          }
          return true;
        }
        static validateDirection(value, strictValues) {
          if (typeof value !== "string") {
            throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);
          }
          if (!Util_1.Util.REGEX_DIRECTION_TAG.test(value)) {
            if (strictValues) {
              throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);
            } else {
              return false;
            }
          }
          return true;
        }
        idifyReverseTerms(context) {
          for (const key of Object.keys(context)) {
            const value = context[key];
            if (value && typeof value === "object") {
              if (value["@reverse"] && !value["@id"]) {
                if (typeof value["@reverse"] !== "string" || Util_1.Util.isValidKeyword(value["@reverse"])) {
                  throw new ErrorCoded_1.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${value["@reverse"]}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                }
                value["@id"] = value["@reverse"];
                if (Util_1.Util.isPotentialKeyword(value["@reverse"])) {
                  delete value["@reverse"];
                } else {
                  value["@reverse"] = true;
                }
              }
            }
          }
          return context;
        }
        expandPrefixedTerms(context, expandContentTypeToBase) {
          const contextRaw = context.getContextRaw();
          for (const key of Object.keys(contextRaw)) {
            if (Util_1.Util.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0 && !Util_1.Util.isReservedInternalKeyword(key)) {
              const keyValue = contextRaw[key];
              if (Util_1.Util.isPotentialKeyword(key) && Util_1.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(key) >= 0) {
                if (key !== "@type" || typeof contextRaw[key] === "object" && !(contextRaw[key]["@protected"] || contextRaw[key]["@container"] === "@set")) {
                  throw new ErrorCoded_1.ErrorCoded(`Keywords can not be aliased to something else.
Tried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);
                }
              }
              if (Util_1.Util.ALIAS_RANGE_BLACKLIST.indexOf(Util_1.Util.getContextValueId(keyValue)) >= 0) {
                throw new ErrorCoded_1.ErrorCoded(`Aliasing to certain keywords is not allowed.
Tried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.INVALID_KEYWORD_ALIAS);
              }
              if (keyValue && Util_1.Util.isPotentialKeyword(Util_1.Util.getContextValueId(keyValue)) && keyValue["@prefix"] === true) {
                throw new ErrorCoded_1.ErrorCoded(`Tried to use keyword aliases as prefix: '${key}': '${JSON.stringify(keyValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);
              }
              while (Util_1.Util.isPrefixValue(contextRaw[key])) {
                const value = contextRaw[key];
                let changed = false;
                if (typeof value === "string") {
                  contextRaw[key] = context.expandTerm(value, true);
                  changed = changed || value !== contextRaw[key];
                } else {
                  const id = value["@id"];
                  const type = value["@type"];
                  const canAddIdEntry = !("@prefix" in value) || Util_1.Util.isValidIri(key);
                  if ("@id" in value) {
                    if (id !== void 0 && id !== null && typeof id === "string") {
                      contextRaw[key]["@id"] = context.expandTerm(id, true);
                      changed = changed || id !== contextRaw[key]["@id"];
                    }
                  } else if (!Util_1.Util.isPotentialKeyword(key) && canAddIdEntry) {
                    const newId = context.expandTerm(key, true);
                    if (newId !== key) {
                      contextRaw[key]["@id"] = newId;
                      changed = true;
                    }
                  }
                  if (type && typeof type === "string" && type !== "@vocab" && (!value["@container"] || !value["@container"]["@type"]) && canAddIdEntry) {
                    contextRaw[key]["@type"] = context.expandTerm(type, true);
                    if (expandContentTypeToBase && type === contextRaw[key]["@type"]) {
                      contextRaw[key]["@type"] = context.expandTerm(type, false);
                    }
                    changed = changed || type !== contextRaw[key]["@type"];
                  }
                }
                if (!changed) {
                  break;
                }
              }
            }
          }
        }
        normalize(context, { processingMode, normalizeLanguageTags }) {
          if (normalizeLanguageTags || processingMode === 1) {
            for (const key of Object.keys(context)) {
              if (key === "@language" && typeof context[key] === "string") {
                context[key] = context[key].toLowerCase();
              } else {
                const value = context[key];
                if (value && typeof value === "object") {
                  if (typeof value["@language"] === "string") {
                    value["@language"] = value["@language"].toLowerCase();
                  }
                }
              }
            }
          }
        }
        containersToHash(context) {
          for (const key of Object.keys(context)) {
            const value = context[key];
            if (value && typeof value === "object") {
              if (typeof value["@container"] === "string") {
                value["@container"] = { [value["@container"]]: true };
              } else if (Array.isArray(value["@container"])) {
                const newValue = {};
                for (const containerValue of value["@container"]) {
                  newValue[containerValue] = true;
                }
                value["@container"] = newValue;
              }
            }
          }
        }
        applyScopedProtected(context, { processingMode }) {
          if (processingMode && processingMode >= 1.1) {
            if (context["@protected"]) {
              for (const key of Object.keys(context)) {
                if (Util_1.Util.isReservedInternalKeyword(key)) {
                  continue;
                }
                if (!Util_1.Util.isPotentialKeyword(key) && !Util_1.Util.isTermProtected(context, key)) {
                  const value = context[key];
                  if (value && typeof value === "object") {
                    if (!("@protected" in context[key])) {
                      context[key]["@protected"] = true;
                    }
                  } else {
                    context[key] = {
                      "@id": value,
                      "@protected": true
                    };
                  }
                }
              }
              delete context["@protected"];
            }
          }
        }
        validateKeywordRedefinitions(contextBefore, contextAfter, expandOptions) {
          for (const key of Object.keys(contextAfter)) {
            if (Util_1.Util.isTermProtected(contextBefore, key)) {
              if (typeof contextAfter[key] === "string") {
                const isPrefix = Util_1.Util.isSimpleTermDefinitionPrefix(contextAfter[key], expandOptions);
                contextAfter[key] = { "@id": contextAfter[key] };
                if (isPrefix) {
                  contextAfter[key]["@prefix"] = true;
                  contextBefore[key]["@prefix"] = true;
                }
              }
              const valueBefore = canonicalizeJson(contextBefore[key]);
              contextAfter[key]["@protected"] = true;
              const valueAfter = canonicalizeJson(contextAfter[key]);
              if (valueBefore !== valueAfter) {
                throw new ErrorCoded_1.ErrorCoded(`Attempted to override the protected keyword ${key} from ${JSON.stringify(Util_1.Util.getContextValueId(contextBefore[key]))} to ${JSON.stringify(Util_1.Util.getContextValueId(contextAfter[key]))}`, ErrorCoded_1.ERROR_CODES.PROTECTED_TERM_REDEFINITION);
              }
            }
          }
        }
        validate(context, { processingMode }) {
          for (const key of Object.keys(context)) {
            if (Util_1.Util.isReservedInternalKeyword(key)) {
              continue;
            }
            if (key === "") {
              throw new ErrorCoded_1.ErrorCoded(`The empty term is not allowed, got: '${key}': '${JSON.stringify(context[key])}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);
            }
            const value = context[key];
            const valueType = typeof value;
            if (Util_1.Util.isPotentialKeyword(key)) {
              switch (key.substr(1)) {
                case "vocab":
                  if (value !== null && valueType !== "string") {
                    throw new ErrorCoded_1.ErrorCoded(`Found an invalid @vocab IRI: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);
                  }
                  break;
                case "base":
                  if (value !== null && valueType !== "string") {
                    throw new ErrorCoded_1.ErrorCoded(`Found an invalid @base IRI: ${context[key]}`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_IRI);
                  }
                  break;
                case "language":
                  if (value !== null) {
                    ContextParser.validateLanguage(value, true, ErrorCoded_1.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);
                  }
                  break;
                case "version":
                  if (value !== null && valueType !== "number") {
                    throw new ErrorCoded_1.ErrorCoded(`Found an invalid @version number: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);
                  }
                  break;
                case "direction":
                  if (value !== null) {
                    ContextParser.validateDirection(value, true);
                  }
                  break;
                case "propagate":
                  if (processingMode === 1) {
                    throw new ErrorCoded_1.ErrorCoded(`Found an illegal @propagate keyword: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);
                  }
                  if (value !== null && valueType !== "boolean") {
                    throw new ErrorCoded_1.ErrorCoded(`Found an invalid @propagate value: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_PROPAGATE_VALUE);
                  }
                  break;
              }
              if (Util_1.Util.isValidKeyword(key) && Util_1.Util.isValidKeyword(Util_1.Util.getContextValueId(value))) {
                throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${Util_1.Util.getContextValueId(value)}'`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);
              }
              continue;
            }
            if (value !== null) {
              switch (valueType) {
                case "string":
                  if (Util_1.Util.getPrefix(value, context) === key) {
                    throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);
                  }
                  if (Util_1.Util.isValidIriWeak(key)) {
                    if (value === "@type") {
                      throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                    } else if (Util_1.Util.isValidIri(value) && value !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {
                      throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                    }
                  }
                  break;
                case "object":
                  if (!Util_1.Util.isCompactIri(key) && !("@id" in value) && (value["@type"] === "@id" ? !context["@base"] : !context["@vocab"])) {
                    throw new ErrorCoded_1.ErrorCoded(`Missing @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                  }
                  for (const objectKey of Object.keys(value)) {
                    const objectValue = value[objectKey];
                    if (!objectValue) {
                      continue;
                    }
                    switch (objectKey) {
                      case "@id":
                        if (Util_1.Util.isValidKeyword(objectValue) && objectValue !== "@type" && objectValue !== "@id" && objectValue !== "@graph") {
                          throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                        }
                        if (Util_1.Util.isValidIriWeak(key)) {
                          if (objectValue === "@type") {
                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                          } else if (Util_1.Util.isValidIri(objectValue) && objectValue !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {
                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                          }
                        }
                        if (typeof objectValue !== "string") {
                          throw new ErrorCoded_1.ErrorCoded(`Detected non-string @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);
                        }
                        if (Util_1.Util.getPrefix(objectValue, context) === key) {
                          throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);
                        }
                        break;
                      case "@type":
                        if (value["@container"] === "@type" && objectValue !== "@id" && objectValue !== "@vocab") {
                          throw new ErrorCoded_1.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);
                        }
                        if (typeof objectValue !== "string") {
                          throw new ErrorCoded_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);
                        }
                        if (objectValue !== "@id" && objectValue !== "@vocab" && (processingMode === 1 || objectValue !== "@json") && (processingMode === 1 || objectValue !== "@none") && (objectValue[0] === "_" || !Util_1.Util.isValidIri(objectValue))) {
                          throw new ErrorCoded_1.ErrorCoded(`A context @type must be an absolute IRI, found: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);
                        }
                        break;
                      case "@reverse":
                        if (typeof objectValue === "string" && value["@id"] && value["@id"] !== objectValue) {
                          throw new ErrorCoded_1.ErrorCoded(`Found non-matching @id and @reverse term values in '${key}':'${objectValue}' and '${value["@id"]}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                        }
                        if ("@nest" in value) {
                          throw new ErrorCoded_1.ErrorCoded(`@nest is not allowed in the reverse property '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                        }
                        break;
                      case "@container":
                        if (processingMode === 1) {
                          if (Object.keys(objectValue).length > 1 || Util_1.Util.CONTAINERS_1_0.indexOf(Object.keys(objectValue)[0]) < 0) {
                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${Object.keys(objectValue)}') in 1.0, must be only one of ${Util_1.Util.CONTAINERS_1_0.join(", ")}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                          }
                        }
                        for (const containerValue of Object.keys(objectValue)) {
                          if (containerValue === "@list" && value["@reverse"]) {
                            throw new ErrorCoded_1.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                          }
                          if (Util_1.Util.CONTAINERS.indexOf(containerValue) < 0) {
                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${containerValue}'), must be one of ${Util_1.Util.CONTAINERS.join(", ")}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                          }
                        }
                        break;
                      case "@language":
                        ContextParser.validateLanguage(objectValue, true, ErrorCoded_1.ERROR_CODES.INVALID_LANGUAGE_MAPPING);
                        break;
                      case "@direction":
                        ContextParser.validateDirection(objectValue, true);
                        break;
                      case "@prefix":
                        if (objectValue !== null && typeof objectValue !== "boolean") {
                          throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @prefix boolean in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_PREFIX_VALUE);
                        }
                        if (!("@id" in value) && !Util_1.Util.isValidIri(key)) {
                          throw new ErrorCoded_1.ErrorCoded(`Invalid @prefix definition for '${key}' ('${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);
                        }
                        break;
                      case "@index":
                        if (processingMode === 1 || !value["@container"] || !value["@container"]["@index"]) {
                          throw new ErrorCoded_1.ErrorCoded(`Attempt to add illegal key to value object: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);
                        }
                        break;
                      case "@nest":
                        if (Util_1.Util.isPotentialKeyword(objectValue) && objectValue !== "@nest") {
                          throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @nest value in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_NEST_VALUE);
                        }
                    }
                  }
                  break;
                default:
                  throw new ErrorCoded_1.ErrorCoded(`Found an invalid term value: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);
              }
            }
          }
        }
        applyBaseEntry(context, options, inheritFromParent) {
          if (typeof context === "string") {
            return context;
          }
          if (inheritFromParent && !("@base" in context) && options.parentContext && typeof options.parentContext === "object" && "@base" in options.parentContext) {
            context["@base"] = options.parentContext["@base"];
            if (options.parentContext["@__baseDocument"]) {
              context["@__baseDocument"] = true;
            }
          }
          if (options.baseIRI && !options.external) {
            if (!("@base" in context)) {
              context["@base"] = options.baseIRI;
              context["@__baseDocument"] = true;
            } else if (context["@base"] !== null && typeof context["@base"] === "string" && !Util_1.Util.isValidIri(context["@base"])) {
              context["@base"] = relative_to_absolute_iri_1.resolve(context["@base"], options.parentContext && options.parentContext["@base"] || options.baseIRI);
            }
          }
          return context;
        }
        normalizeContextIri(contextIri, baseIRI) {
          if (!Util_1.Util.isValidIri(contextIri)) {
            try {
              contextIri = relative_to_absolute_iri_1.resolve(contextIri, baseIRI);
            } catch (_a) {
              throw new Error(`Invalid context IRI: ${contextIri}`);
            }
          }
          if (this.redirectSchemaOrgHttps && contextIri.startsWith("http://schema.org")) {
            contextIri = "https://schema.org/";
          }
          return contextIri;
        }
        async parseInnerContexts(context, options) {
          for (const key of Object.keys(context)) {
            const value = context[key];
            if (value && typeof value === "object") {
              if ("@context" in value && value["@context"] !== null && !options.ignoreScopedContexts) {
                if (this.validateContext) {
                  try {
                    const parentContext = Object.assign({}, context);
                    parentContext[key] = Object.assign({}, parentContext[key]);
                    delete parentContext[key]["@context"];
                    await this.parse(value["@context"], Object.assign(Object.assign({}, options), { parentContext, ignoreProtection: true, ignoreRemoteScopedContexts: true, ignoreScopedContexts: true }));
                  } catch (e) {
                    throw new ErrorCoded_1.ErrorCoded(e.message, ErrorCoded_1.ERROR_CODES.INVALID_SCOPED_CONTEXT);
                  }
                }
                value["@context"] = (await this.parse(value["@context"], Object.assign(Object.assign({}, options), { minimalProcessing: true, ignoreRemoteScopedContexts: true, parentContext: context }))).getContextRaw();
              }
            }
          }
          return context;
        }
        async parse(context, options = {}) {
          const { baseIRI, parentContext: parentContextInitial, external, processingMode = ContextParser.DEFAULT_PROCESSING_MODE, normalizeLanguageTags, ignoreProtection, minimalProcessing } = options;
          let parentContext = parentContextInitial;
          const remoteContexts = options.remoteContexts || {};
          if (Object.keys(remoteContexts).length >= this.remoteContextsDepthLimit) {
            throw new ErrorCoded_1.ErrorCoded("Detected an overflow in remote context inclusions: " + Object.keys(remoteContexts), ErrorCoded_1.ERROR_CODES.CONTEXT_OVERFLOW);
          }
          if (context === null || context === void 0) {
            if (!ignoreProtection && parentContext && Util_1.Util.hasProtectedTerms(parentContext)) {
              throw new ErrorCoded_1.ErrorCoded("Illegal context nullification when terms are protected", ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);
            }
            return new JsonLdContextNormalized_1.JsonLdContextNormalized(this.applyBaseEntry({}, options, false));
          } else if (typeof context === "string") {
            const contextIri = this.normalizeContextIri(context, baseIRI);
            const overriddenLoad = this.getOverriddenLoad(contextIri, options);
            if (overriddenLoad) {
              return new JsonLdContextNormalized_1.JsonLdContextNormalized(overriddenLoad);
            }
            const parsedStringContext = await this.parse(await this.load(contextIri), Object.assign(Object.assign({}, options), { baseIRI: contextIri, external: true, remoteContexts: Object.assign(Object.assign({}, remoteContexts), { [contextIri]: true }) }));
            this.applyBaseEntry(parsedStringContext.getContextRaw(), options, true);
            return parsedStringContext;
          } else if (Array.isArray(context)) {
            const contextIris = [];
            const contexts = await Promise.all(context.map((subContext, i) => {
              if (typeof subContext === "string") {
                const contextIri = this.normalizeContextIri(subContext, baseIRI);
                contextIris[i] = contextIri;
                const overriddenLoad = this.getOverriddenLoad(contextIri, options);
                if (overriddenLoad) {
                  return overriddenLoad;
                }
                return this.load(contextIri);
              } else {
                return subContext;
              }
            }));
            if (minimalProcessing) {
              return new JsonLdContextNormalized_1.JsonLdContextNormalized(contexts);
            }
            const reducedContexts = await contexts.reduce((accContextPromise, contextEntry, i) => accContextPromise.then((accContext) => this.parse(contextEntry, Object.assign(Object.assign({}, options), { baseIRI: contextIris[i] || options.baseIRI, external: !!contextIris[i] || options.external, parentContext: accContext.getContextRaw(), remoteContexts: contextIris[i] ? Object.assign(Object.assign({}, remoteContexts), { [contextIris[i]]: true }) : remoteContexts }))), Promise.resolve(new JsonLdContextNormalized_1.JsonLdContextNormalized(parentContext || {})));
            this.applyBaseEntry(reducedContexts.getContextRaw(), options, true);
            return reducedContexts;
          } else if (typeof context === "object") {
            if ("@context" in context) {
              return await this.parse(context["@context"], options);
            }
            context = JSON.parse(JSON.stringify(context));
            if (parentContext && !minimalProcessing) {
              parentContext = JSON.parse(JSON.stringify(parentContext));
            }
            let newContext = {};
            if (external) {
              delete context["@base"];
            }
            this.applyBaseEntry(context, options, true);
            this.containersToHash(context);
            if (minimalProcessing) {
              return new JsonLdContextNormalized_1.JsonLdContextNormalized(context);
            }
            let importContext = {};
            if ("@import" in context) {
              if (processingMode >= 1.1) {
                if (typeof context["@import"] !== "string") {
                  throw new ErrorCoded_1.ErrorCoded("An @import value must be a string, but got " + typeof context["@import"], ErrorCoded_1.ERROR_CODES.INVALID_IMPORT_VALUE);
                }
                importContext = await this.loadImportContext(this.normalizeContextIri(context["@import"], baseIRI));
                delete context["@import"];
              } else {
                throw new ErrorCoded_1.ErrorCoded("Context importing is not supported in JSON-LD 1.0", ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);
              }
            }
            newContext = Object.assign(Object.assign(Object.assign(Object.assign({}, newContext), typeof parentContext === "object" ? parentContext : {}), importContext), context);
            const newContextWrapped = new JsonLdContextNormalized_1.JsonLdContextNormalized(newContext);
            await this.parseInnerContexts(newContext, options);
            if ((newContext && newContext["@version"] || ContextParser.DEFAULT_PROCESSING_MODE) >= 1.1 && (context["@vocab"] && typeof context["@vocab"] === "string" || context["@vocab"] === "") && context["@vocab"].indexOf(":") < 0 && parentContext && "@vocab" in parentContext) {
              newContext["@vocab"] = parentContext["@vocab"] + context["@vocab"];
            }
            this.idifyReverseTerms(newContext);
            this.expandPrefixedTerms(newContextWrapped, this.expandContentTypeToBase);
            if (!ignoreProtection && parentContext && processingMode >= 1.1) {
              this.validateKeywordRedefinitions(parentContext, newContext, exports.defaultExpandOptions);
            }
            this.normalize(newContext, { processingMode, normalizeLanguageTags });
            this.applyScopedProtected(newContext, { processingMode });
            if (this.validateContext) {
              this.validate(newContext, { processingMode });
            }
            return newContextWrapped;
          } else {
            throw new ErrorCoded_1.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${context}`, ErrorCoded_1.ERROR_CODES.INVALID_LOCAL_CONTEXT);
          }
        }
        async load(url) {
          const cached = this.documentCache[url];
          if (cached) {
            return typeof cached === "string" ? cached : Array.isArray(cached) ? cached.slice() : Object.assign({}, cached);
          }
          let document2;
          try {
            document2 = await this.documentLoader.load(url);
          } catch (e) {
            throw new ErrorCoded_1.ErrorCoded(`Failed to load remote context ${url}: ${e.message}`, ErrorCoded_1.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);
          }
          if (!("@context" in document2)) {
            throw new ErrorCoded_1.ErrorCoded(`Missing @context in remote context at ${url}`, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);
          }
          return this.documentCache[url] = document2["@context"];
        }
        getOverriddenLoad(url, options) {
          if (url in (options.remoteContexts || {})) {
            if (options.ignoreRemoteScopedContexts) {
              return url;
            } else {
              throw new ErrorCoded_1.ErrorCoded("Detected a cyclic context inclusion of " + url, ErrorCoded_1.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);
            }
          }
          return null;
        }
        async loadImportContext(importContextIri) {
          const importContext = await this.load(importContextIri);
          if (typeof importContext !== "object" || Array.isArray(importContext)) {
            throw new ErrorCoded_1.ErrorCoded("An imported context must be a single object: " + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);
          }
          if ("@import" in importContext) {
            throw new ErrorCoded_1.ErrorCoded("An imported context can not import another context: " + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);
          }
          this.containersToHash(importContext);
          return importContext;
        }
      };
      exports.ContextParser = ContextParser;
      ContextParser.DEFAULT_PROCESSING_MODE = 1.1;
      exports.defaultExpandOptions = {
        allowPrefixForcing: true,
        allowPrefixNonGenDelims: false,
        allowVocabRelativeToBase: true
      };
    }
  });

  // node_modules/jsonld-context-parser/lib/IDocumentLoader.js
  var require_IDocumentLoader = __commonJS({
    "node_modules/jsonld-context-parser/lib/IDocumentLoader.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/jsonld-context-parser/lib/JsonLdContext.js
  var require_JsonLdContext = __commonJS({
    "node_modules/jsonld-context-parser/lib/JsonLdContext.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/jsonld-context-parser/index.js
  var require_jsonld_context_parser = __commonJS({
    "node_modules/jsonld-context-parser/index.js"(exports) {
      "use strict";
      init_shim();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_ContextParser(), exports);
      __exportStar(require_ErrorCoded(), exports);
      __exportStar(require_FetchDocumentLoader(), exports);
      __exportStar(require_IDocumentLoader(), exports);
      __exportStar(require_JsonLdContext(), exports);
      __exportStar(require_JsonLdContextNormalized(), exports);
      __exportStar(require_Util(), exports);
    }
  });

  // node_modules/rdf-data-factory/lib/BlankNode.js
  var require_BlankNode2 = __commonJS({
    "node_modules/rdf-data-factory/lib/BlankNode.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BlankNode = void 0;
      var BlankNode3 = class {
        constructor(value) {
          this.termType = "BlankNode";
          this.value = value;
        }
        equals(other) {
          return !!other && other.termType === "BlankNode" && other.value === this.value;
        }
      };
      exports.BlankNode = BlankNode3;
    }
  });

  // node_modules/rdf-data-factory/lib/DefaultGraph.js
  var require_DefaultGraph2 = __commonJS({
    "node_modules/rdf-data-factory/lib/DefaultGraph.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultGraph = void 0;
      var DefaultGraph3 = class {
        constructor() {
          this.termType = "DefaultGraph";
          this.value = "";
        }
        equals(other) {
          return !!other && other.termType === "DefaultGraph";
        }
      };
      exports.DefaultGraph = DefaultGraph3;
      DefaultGraph3.INSTANCE = new DefaultGraph3();
    }
  });

  // node_modules/rdf-data-factory/lib/NamedNode.js
  var require_NamedNode2 = __commonJS({
    "node_modules/rdf-data-factory/lib/NamedNode.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NamedNode = void 0;
      var NamedNode3 = class {
        constructor(value) {
          this.termType = "NamedNode";
          this.value = value;
        }
        equals(other) {
          return !!other && other.termType === "NamedNode" && other.value === this.value;
        }
      };
      exports.NamedNode = NamedNode3;
    }
  });

  // node_modules/rdf-data-factory/lib/Literal.js
  var require_Literal2 = __commonJS({
    "node_modules/rdf-data-factory/lib/Literal.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Literal = void 0;
      var NamedNode_1 = require_NamedNode2();
      var Literal3 = class {
        constructor(value, languageOrDatatype) {
          this.termType = "Literal";
          this.value = value;
          if (typeof languageOrDatatype === "string") {
            this.language = languageOrDatatype;
            this.datatype = Literal3.RDF_LANGUAGE_STRING;
          } else if (languageOrDatatype) {
            this.language = "";
            this.datatype = languageOrDatatype;
          } else {
            this.language = "";
            this.datatype = Literal3.XSD_STRING;
          }
        }
        equals(other) {
          return !!other && other.termType === "Literal" && other.value === this.value && other.language === this.language && other.datatype.equals(this.datatype);
        }
      };
      exports.Literal = Literal3;
      Literal3.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString");
      Literal3.XSD_STRING = new NamedNode_1.NamedNode("http://www.w3.org/2001/XMLSchema#string");
    }
  });

  // node_modules/rdf-data-factory/lib/Quad.js
  var require_Quad2 = __commonJS({
    "node_modules/rdf-data-factory/lib/Quad.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Quad = void 0;
      var Quad3 = class {
        constructor(subject, predicate, object, graph2) {
          this.termType = "Quad";
          this.value = "";
          this.subject = subject;
          this.predicate = predicate;
          this.object = object;
          this.graph = graph2;
        }
        equals(other) {
          return !!other && (other.termType === "Quad" || !other.termType) && this.subject.equals(other.subject) && this.predicate.equals(other.predicate) && this.object.equals(other.object) && this.graph.equals(other.graph);
        }
      };
      exports.Quad = Quad3;
    }
  });

  // node_modules/rdf-data-factory/lib/Variable.js
  var require_Variable2 = __commonJS({
    "node_modules/rdf-data-factory/lib/Variable.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Variable = void 0;
      var Variable3 = class {
        constructor(value) {
          this.termType = "Variable";
          this.value = value;
        }
        equals(other) {
          return !!other && other.termType === "Variable" && other.value === this.value;
        }
      };
      exports.Variable = Variable3;
    }
  });

  // node_modules/rdf-data-factory/lib/DataFactory.js
  var require_DataFactory2 = __commonJS({
    "node_modules/rdf-data-factory/lib/DataFactory.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DataFactory = void 0;
      var BlankNode_1 = require_BlankNode2();
      var DefaultGraph_1 = require_DefaultGraph2();
      var Literal_1 = require_Literal2();
      var NamedNode_1 = require_NamedNode2();
      var Quad_1 = require_Quad2();
      var Variable_1 = require_Variable2();
      var dataFactoryCounter = 0;
      var DataFactory3 = class {
        constructor(options) {
          this.blankNodeCounter = 0;
          options = options || {};
          this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;
        }
        namedNode(value) {
          return new NamedNode_1.NamedNode(value);
        }
        blankNode(value) {
          return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);
        }
        literal(value, languageOrDatatype) {
          return new Literal_1.Literal(value, languageOrDatatype);
        }
        variable(value) {
          return new Variable_1.Variable(value);
        }
        defaultGraph() {
          return DefaultGraph_1.DefaultGraph.INSTANCE;
        }
        quad(subject, predicate, object, graph2) {
          return new Quad_1.Quad(subject, predicate, object, graph2 || this.defaultGraph());
        }
        fromTerm(original) {
          switch (original.termType) {
            case "NamedNode":
              return this.namedNode(original.value);
            case "BlankNode":
              return this.blankNode(original.value);
            case "Literal":
              if (original.language) {
                return this.literal(original.value, original.language);
              }
              if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {
                return this.literal(original.value, this.fromTerm(original.datatype));
              }
              return this.literal(original.value);
            case "Variable":
              return this.variable(original.value);
            case "DefaultGraph":
              return this.defaultGraph();
            case "Quad":
              return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));
          }
        }
        fromQuad(original) {
          return this.fromTerm(original);
        }
        resetBlankNodeCounter() {
          this.blankNodeCounter = 0;
        }
      };
      exports.DataFactory = DataFactory3;
    }
  });

  // node_modules/rdf-data-factory/index.js
  var require_rdf_data_factory = __commonJS({
    "node_modules/rdf-data-factory/index.js"(exports) {
      "use strict";
      init_shim();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_BlankNode2(), exports);
      __exportStar(require_DataFactory2(), exports);
      __exportStar(require_DefaultGraph2(), exports);
      __exportStar(require_Literal2(), exports);
      __exportStar(require_NamedNode2(), exports);
      __exportStar(require_Quad2(), exports);
      __exportStar(require_Variable2(), exports);
    }
  });

  // node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIdentifier.js
  var require_ContainerHandlerIdentifier = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIdentifier.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContainerHandlerIdentifier = void 0;
      var ContainerHandlerIdentifier = class {
        canCombineWithGraph() {
          return true;
        }
        async handle(containers, parsingContext, util, keys, value, depth) {
          let id;
          if (parsingContext.emittedStack[depth + 1] && parsingContext.idStack[depth + 1]) {
            id = parsingContext.idStack[depth + 1][0];
          } else {
            const keyUnaliased = await util.getContainerKey(keys[depth], keys, depth);
            const maybeId = keyUnaliased !== null ? await util.resourceToTerm(await parsingContext.getContext(keys), keys[depth]) : util.dataFactory.blankNode();
            if (!maybeId) {
              parsingContext.emittedStack[depth] = false;
              return;
            }
            id = maybeId;
            parsingContext.idStack[depth + 1] = [id];
          }
          let ids = parsingContext.idStack[depth];
          if (!ids) {
            ids = parsingContext.idStack[depth] = [];
          }
          if (!ids.some((term) => term.equals(id))) {
            ids.push(id);
          }
          if (!await parsingContext.handlePendingContainerFlushBuffers()) {
            parsingContext.emittedStack[depth] = false;
          }
        }
      };
      exports.ContainerHandlerIdentifier = ContainerHandlerIdentifier;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerPredicate.js
  var require_EntryHandlerPredicate = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerPredicate.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerPredicate = void 0;
      var jsonld_context_parser_1 = require_jsonld_context_parser();
      var Util_1 = require_Util2();
      var EntryHandlerPredicate = class {
        static async handlePredicateObject(parsingContext, util, keys, depth, predicate, object, reverse) {
          const depthProperties = await util.getPropertiesDepth(keys, depth);
          const depthOffsetGraph = await util.getDepthOffsetGraph(depth, keys);
          const depthPropertiesGraph = depth - depthOffsetGraph;
          const subjects = parsingContext.idStack[depthProperties];
          if (subjects) {
            for (const subject of subjects) {
              const atGraph = depthOffsetGraph >= 0;
              if (atGraph) {
                const graphs = parsingContext.idStack[depthPropertiesGraph - 1];
                if (graphs) {
                  for (const graph2 of graphs) {
                    if (reverse) {
                      util.validateReverseSubject(object);
                      parsingContext.emitQuad(depth, util.dataFactory.quad(object, predicate, subject, graph2));
                    } else {
                      parsingContext.emitQuad(depth, util.dataFactory.quad(subject, predicate, object, graph2));
                    }
                  }
                } else {
                  if (reverse) {
                    util.validateReverseSubject(object);
                    parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1).push({ subject: object, predicate, object: subject });
                  } else {
                    parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1).push({ subject, predicate, object });
                  }
                }
              } else {
                const graph2 = await util.getGraphContainerValue(keys, depthProperties);
                if (reverse) {
                  util.validateReverseSubject(object);
                  parsingContext.emitQuad(depth, util.dataFactory.quad(object, predicate, subject, graph2));
                } else {
                  parsingContext.emitQuad(depth, util.dataFactory.quad(subject, predicate, object, graph2));
                }
              }
            }
          } else {
            if (reverse) {
              util.validateReverseSubject(object);
            }
            parsingContext.getUnidentifiedValueBufferSafe(depthProperties).push({ predicate, object, reverse });
          }
        }
        isPropertyHandler() {
          return true;
        }
        isStackProcessor() {
          return true;
        }
        async validate(parsingContext, util, keys, depth, inProperty) {
          const key = keys[depth];
          if (key) {
            const context = await parsingContext.getContext(keys);
            if (!parsingContext.jsonLiteralStack[depth] && await util.predicateToTerm(context, keys[depth])) {
              if (Util_1.Util.getContextValueType(context, key) === "@json") {
                parsingContext.jsonLiteralStack[depth + 1] = true;
              }
              return true;
            }
          }
          return false;
        }
        async test(parsingContext, util, key, keys, depth) {
          return keys[depth];
        }
        async handle(parsingContext, util, key, keys, value, depth, testResult) {
          const keyOriginal = keys[depth];
          const context = await parsingContext.getContext(keys);
          const predicate = await util.predicateToTerm(context, key);
          if (predicate) {
            const objects = await util.valueToTerm(context, key, value, depth, keys);
            if (objects.length) {
              for (let object of objects) {
                const reverse = Util_1.Util.isPropertyReverse(context, keyOriginal, await util.unaliasKeywordParent(keys, depth));
                if (value) {
                  const listValueContainer = "@list" in Util_1.Util.getContextValueContainer(context, key);
                  if (listValueContainer || value["@list"]) {
                    if ((listValueContainer && !Array.isArray(value) && !value["@list"] || value["@list"] && !Array.isArray(value["@list"])) && object !== util.rdfNil) {
                      const listPointer = util.dataFactory.blankNode();
                      parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfRest, util.rdfNil, util.getDefaultGraph()));
                      parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfFirst, object, util.getDefaultGraph()));
                      object = listPointer;
                    }
                    if (reverse && !parsingContext.allowSubjectList) {
                      throw new jsonld_context_parser_1.ErrorCoded(`Found illegal list value in subject position at ${key}`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);
                    }
                  }
                }
                await EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth, predicate, object, reverse);
              }
            }
          }
        }
      };
      exports.EntryHandlerPredicate = EntryHandlerPredicate;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIndex.js
  var require_ContainerHandlerIndex = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIndex.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContainerHandlerIndex = void 0;
      var jsonld_context_parser_1 = require_jsonld_context_parser();
      var EntryHandlerPredicate_1 = require_EntryHandlerPredicate();
      var Util_1 = require_Util2();
      var ContainerHandlerIndex = class {
        canCombineWithGraph() {
          return true;
        }
        async handle(containers, parsingContext, util, keys, value, depth) {
          if (!Array.isArray(value)) {
            const graphContainer = "@graph" in containers;
            const context = await parsingContext.getContext(keys);
            const indexKey = keys[depth - 1];
            const indexPropertyRaw = Util_1.Util.getContextValueIndex(context, indexKey);
            if (indexPropertyRaw) {
              if (jsonld_context_parser_1.Util.isPotentialKeyword(indexPropertyRaw)) {
                throw new jsonld_context_parser_1.ErrorCoded(`Keywords can not be used as @index value, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);
              }
              if (typeof indexPropertyRaw !== "string") {
                throw new jsonld_context_parser_1.ErrorCoded(`@index values must be strings, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);
              }
              if (typeof value !== "object") {
                if (Util_1.Util.getContextValueType(context, indexKey) !== "@id") {
                  throw new jsonld_context_parser_1.ErrorCoded(`Property-based index containers require nodes as values or strings with @type: @id, but got: ${value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);
                }
                const id = util.resourceToTerm(context, value);
                if (id) {
                  parsingContext.idStack[depth + 1] = [id];
                }
              }
              const indexProperty = util.createVocabOrBaseTerm(context, indexPropertyRaw);
              if (indexProperty) {
                const indexValues = await util.valueToTerm(context, indexPropertyRaw, await util.getContainerKey(keys[depth], keys, depth), depth, keys);
                if (graphContainer) {
                  const graphId = await util.getGraphContainerValue(keys, depth + 1);
                  for (const indexValue of indexValues) {
                    parsingContext.emitQuad(depth, util.dataFactory.quad(graphId, indexProperty, indexValue, util.getDefaultGraph()));
                  }
                } else {
                  for (const indexValue of indexValues) {
                    await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, indexProperty, indexValue, false);
                  }
                }
              }
            }
            const depthOffset = graphContainer ? 2 : 1;
            await parsingContext.newOnValueJob(keys.slice(0, keys.length - depthOffset), value, depth - depthOffset, true);
            await parsingContext.handlePendingContainerFlushBuffers();
          }
          parsingContext.emittedStack[depth] = false;
        }
      };
      exports.ContainerHandlerIndex = ContainerHandlerIndex;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerLanguage.js
  var require_ContainerHandlerLanguage = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerLanguage.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContainerHandlerLanguage = void 0;
      var jsonld_context_parser_1 = require_jsonld_context_parser();
      var ContainerHandlerLanguage = class {
        canCombineWithGraph() {
          return false;
        }
        async handle(containers, parsingContext, util, keys, value, depth) {
          const language = await util.getContainerKey(keys[depth], keys, depth);
          if (Array.isArray(value)) {
            value = value.map((subValue) => ({ "@value": subValue, "@language": language }));
          } else {
            if (typeof value !== "string") {
              throw new jsonld_context_parser_1.ErrorCoded(`Got invalid language map value, got '${JSON.stringify(value)}', but expected string`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_MAP_VALUE);
            }
            value = { "@value": value, "@language": language };
          }
          await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);
          parsingContext.emittedStack[depth] = false;
        }
      };
      exports.ContainerHandlerLanguage = ContainerHandlerLanguage;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerType.js
  var require_ContainerHandlerType = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerType.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContainerHandlerType = void 0;
      var EntryHandlerPredicate_1 = require_EntryHandlerPredicate();
      var Util_1 = require_Util2();
      var ContainerHandlerType = class {
        canCombineWithGraph() {
          return false;
        }
        async handle(containers, parsingContext, util, keys, value, depth) {
          if (!Array.isArray(value)) {
            if (typeof value === "string") {
              const context = await parsingContext.getContext(keys);
              const containerTypeType = Util_1.Util.getContextValueType(context, keys[depth - 1]);
              const id = containerTypeType === "@vocab" ? await util.createVocabOrBaseTerm(context, value) : await util.resourceToTerm(context, value);
              if (id) {
                const subValue = { "@id": id.termType === "NamedNode" ? id.value : value };
                await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), subValue, depth - 1, true);
                parsingContext.idStack[depth + 1] = [id];
              }
            } else {
              const entryHasIdentifier = !!parsingContext.idStack[depth + 1];
              if (!entryHasIdentifier) {
                delete parsingContext.idStack[depth];
              }
              await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);
              if (!entryHasIdentifier) {
                parsingContext.idStack[depth + 1] = parsingContext.idStack[depth];
              }
            }
            const keyOriginal = await util.getContainerKey(keys[depth], keys, depth);
            const type = keyOriginal !== null ? util.createVocabOrBaseTerm(await parsingContext.getContext(keys), keyOriginal) : null;
            if (type) {
              await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, util.rdfType, type, false);
            }
            await parsingContext.handlePendingContainerFlushBuffers();
          }
          parsingContext.emittedStack[depth] = false;
        }
      };
      exports.ContainerHandlerType = ContainerHandlerType;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerContainer.js
  var require_EntryHandlerContainer = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerContainer.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerContainer = void 0;
      var ContainerHandlerIdentifier_1 = require_ContainerHandlerIdentifier();
      var ContainerHandlerIndex_1 = require_ContainerHandlerIndex();
      var ContainerHandlerLanguage_1 = require_ContainerHandlerLanguage();
      var ContainerHandlerType_1 = require_ContainerHandlerType();
      var Util_1 = require_Util2();
      var EntryHandlerContainer = class {
        static isSimpleGraphContainer(containers) {
          return "@graph" in containers && ("@set" in containers && Object.keys(containers).length === 2 || Object.keys(containers).length === 1);
        }
        static isComplexGraphContainer(containers) {
          return "@graph" in containers && ("@set" in containers && Object.keys(containers).length > 2 || !("@set" in containers) && Object.keys(containers).length > 1);
        }
        static getContainerGraphIndex(containers, depth, keys) {
          let isSimpleGraphContainer = EntryHandlerContainer.isSimpleGraphContainer(containers);
          let index = "";
          for (let i = depth; i < keys.length; i++) {
            if (!isSimpleGraphContainer || typeof keys[i] === "number") {
              index += ":" + keys[i];
            }
            if (!isSimpleGraphContainer && typeof keys[i] !== "number") {
              isSimpleGraphContainer = true;
            }
          }
          return index;
        }
        static async getContainerHandler(parsingContext, keys, depth) {
          const fallback = {
            containers: { "@set": true },
            depth,
            fallback: true
          };
          let checkGraphContainer = false;
          const context = await parsingContext.getContext(keys, 2);
          for (let i = depth - 1; i >= 0; i--) {
            if (typeof keys[i] !== "number") {
              const containersSelf = Util_1.Util.getContextValue(context, "@container", keys[i], false);
              if (containersSelf && EntryHandlerContainer.isSimpleGraphContainer(containersSelf)) {
                return {
                  containers: containersSelf,
                  depth: i + 1,
                  fallback: false
                };
              }
              const containersParent = Util_1.Util.getContextValue(context, "@container", keys[i - 1], false);
              if (!containersParent) {
                if (checkGraphContainer) {
                  return fallback;
                }
                checkGraphContainer = true;
              } else {
                const graphContainer = "@graph" in containersParent;
                for (const containerHandleName in EntryHandlerContainer.CONTAINER_HANDLERS) {
                  if (containersParent[containerHandleName]) {
                    if (graphContainer) {
                      if (EntryHandlerContainer.CONTAINER_HANDLERS[containerHandleName].canCombineWithGraph()) {
                        return {
                          containers: containersParent,
                          depth: i,
                          fallback: false
                        };
                      } else {
                        return fallback;
                      }
                    } else {
                      if (checkGraphContainer) {
                        return fallback;
                      } else {
                        return {
                          containers: containersParent,
                          depth: i,
                          fallback: false
                        };
                      }
                    }
                  }
                }
                return fallback;
              }
            }
          }
          return fallback;
        }
        static async isBufferableContainerHandler(parsingContext, keys, depth) {
          const handler2 = await EntryHandlerContainer.getContainerHandler(parsingContext, keys, depth);
          return !handler2.fallback && !("@graph" in handler2.containers);
        }
        isPropertyHandler() {
          return false;
        }
        isStackProcessor() {
          return true;
        }
        async validate(parsingContext, util, keys, depth, inProperty) {
          return !!await this.test(parsingContext, util, null, keys, depth);
        }
        async test(parsingContext, util, key, keys, depth) {
          const containers = Util_1.Util.getContextValueContainer(await parsingContext.getContext(keys, 2), keys[depth - 1]);
          for (const containerName in EntryHandlerContainer.CONTAINER_HANDLERS) {
            if (containers[containerName]) {
              return {
                containers,
                handler: EntryHandlerContainer.CONTAINER_HANDLERS[containerName]
              };
            }
          }
          return null;
        }
        async handle(parsingContext, util, key, keys, value, depth, testResult) {
          return testResult.handler.handle(testResult.containers, parsingContext, util, keys, value, depth);
        }
      };
      exports.EntryHandlerContainer = EntryHandlerContainer;
      EntryHandlerContainer.CONTAINER_HANDLERS = {
        "@id": new ContainerHandlerIdentifier_1.ContainerHandlerIdentifier(),
        "@index": new ContainerHandlerIndex_1.ContainerHandlerIndex(),
        "@language": new ContainerHandlerLanguage_1.ContainerHandlerLanguage(),
        "@type": new ContainerHandlerType_1.ContainerHandlerType()
      };
    }
  });

  // node_modules/jsonld-streaming-parser/lib/Util.js
  var require_Util2 = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/Util.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Util = void 0;
      var jsonld_context_parser_1 = require_jsonld_context_parser();
      var rdf_data_factory_1 = require_rdf_data_factory();
      var EntryHandlerContainer_1 = require_EntryHandlerContainer();
      var canonicalizeJson = require_canonicalize();
      var Util = class {
        constructor(options) {
          this.parsingContext = options.parsingContext;
          this.dataFactory = options.dataFactory || new rdf_data_factory_1.DataFactory();
          this.rdfFirst = this.dataFactory.namedNode(Util.RDF + "first");
          this.rdfRest = this.dataFactory.namedNode(Util.RDF + "rest");
          this.rdfNil = this.dataFactory.namedNode(Util.RDF + "nil");
          this.rdfType = this.dataFactory.namedNode(Util.RDF + "type");
          this.rdfJson = this.dataFactory.namedNode(Util.RDF + "JSON");
        }
        static getContextValue(context, contextKey, key, fallback) {
          const entry = context.getContextRaw()[key];
          if (!entry) {
            return fallback;
          }
          const type = entry[contextKey];
          return type === void 0 ? fallback : type;
        }
        static getContextValueContainer(context, key) {
          return Util.getContextValue(context, "@container", key, { "@set": true });
        }
        static getContextValueType(context, key) {
          const valueType = Util.getContextValue(context, "@type", key, null);
          if (valueType === "@none") {
            return null;
          }
          return valueType;
        }
        static getContextValueLanguage(context, key) {
          return Util.getContextValue(context, "@language", key, context.getContextRaw()["@language"] || null);
        }
        static getContextValueDirection(context, key) {
          return Util.getContextValue(context, "@direction", key, context.getContextRaw()["@direction"] || null);
        }
        static isContextValueReverse(context, key) {
          return !!Util.getContextValue(context, "@reverse", key, null);
        }
        static getContextValueIndex(context, key) {
          return Util.getContextValue(context, "@index", key, context.getContextRaw()["@index"] || null);
        }
        static isPropertyReverse(context, key, parentKey) {
          return parentKey === "@reverse" !== Util.isContextValueReverse(context, key);
        }
        static isValidIri(iri) {
          return iri !== null && jsonld_context_parser_1.Util.isValidIri(iri);
        }
        static isPrefixArray(needle, haystack) {
          if (needle.length > haystack.length) {
            return false;
          }
          for (let i = 0; i < needle.length; i++) {
            if (needle[i] !== haystack[i]) {
              return false;
            }
          }
          return true;
        }
        async validateValueIndexes(value) {
          if (this.parsingContext.validateValueIndexes) {
            const indexHashes = {};
            for (const entry of value) {
              if (entry && typeof entry === "object") {
                const id = entry["@id"];
                const index = entry["@index"];
                if (id && index) {
                  const existingIndexValue = indexHashes[id];
                  if (existingIndexValue && existingIndexValue !== index) {
                    throw new jsonld_context_parser_1.ErrorCoded(`Conflicting @index value for ${id}`, jsonld_context_parser_1.ERROR_CODES.CONFLICTING_INDEXES);
                  }
                  indexHashes[id] = index;
                }
              }
            }
          }
        }
        async valueToTerm(context, key, value, depth, keys) {
          if (Util.getContextValueType(context, key) === "@json") {
            return [this.dataFactory.literal(this.valueToJsonString(value), this.rdfJson)];
          }
          const type = typeof value;
          switch (type) {
            case "object":
              if (value === null || value === void 0) {
                return [];
              }
              if (Array.isArray(value)) {
                if ("@list" in Util.getContextValueContainer(context, key)) {
                  if (value.length === 0) {
                    return [this.rdfNil];
                  } else {
                    return this.parsingContext.idStack[depth + 1] || [];
                  }
                }
                await this.validateValueIndexes(value);
                return [];
              }
              context = await this.getContextSelfOrPropertyScoped(context, key);
              if ("@context" in value) {
                context = await this.parsingContext.parseContext(value["@context"], (await this.parsingContext.getContext(keys, 0)).getContextRaw());
              }
              value = await this.unaliasKeywords(value, keys, depth, context);
              if ("@value" in value) {
                let val;
                let valueLanguage;
                let valueDirection;
                let valueType;
                let valueIndex;
                for (key in value) {
                  const subValue = value[key];
                  switch (key) {
                    case "@value":
                      val = subValue;
                      break;
                    case "@language":
                      valueLanguage = subValue;
                      break;
                    case "@direction":
                      valueDirection = subValue;
                      break;
                    case "@type":
                      valueType = subValue;
                      break;
                    case "@index":
                      valueIndex = subValue;
                      break;
                    default:
                      throw new jsonld_context_parser_1.ErrorCoded(`Unknown value entry '${key}' in @value: ${JSON.stringify(value)}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);
                  }
                }
                if (await this.unaliasKeyword(valueType, keys, depth, true, context) === "@json") {
                  return [this.dataFactory.literal(this.valueToJsonString(val), this.rdfJson)];
                }
                if (val === null) {
                  return [];
                }
                if (typeof val === "object") {
                  throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@value' can not be an object, got '${JSON.stringify(val)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT_VALUE);
                }
                if (this.parsingContext.validateValueIndexes && valueIndex && typeof valueIndex !== "string") {
                  throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@index' must be a string, got '${JSON.stringify(valueIndex)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INDEX_VALUE);
                }
                if (valueLanguage) {
                  if (typeof val !== "string") {
                    throw new jsonld_context_parser_1.ErrorCoded(`When an '@language' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_TAGGED_VALUE);
                  }
                  if (!jsonld_context_parser_1.ContextParser.validateLanguage(valueLanguage, this.parsingContext.strictValues, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_TAGGED_STRING)) {
                    return [];
                  }
                  if (this.parsingContext.normalizeLanguageTags || this.parsingContext.activeProcessingMode === 1) {
                    valueLanguage = valueLanguage.toLowerCase();
                  }
                }
                if (valueDirection) {
                  if (typeof val !== "string") {
                    throw new Error(`When an '@direction' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`);
                  }
                  if (!jsonld_context_parser_1.ContextParser.validateDirection(valueDirection, this.parsingContext.strictValues)) {
                    return [];
                  }
                }
                if (valueLanguage && valueDirection && this.parsingContext.rdfDirection) {
                  if (valueType) {
                    throw new jsonld_context_parser_1.ErrorCoded(`Can not have '@language', '@direction' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);
                  }
                  return this.nullableTermToArray(this.createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));
                } else if (valueLanguage) {
                  if (valueType) {
                    throw new jsonld_context_parser_1.ErrorCoded(`Can not have both '@language' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);
                  }
                  return [this.dataFactory.literal(val, valueLanguage)];
                } else if (valueDirection && this.parsingContext.rdfDirection) {
                  if (valueType) {
                    throw new jsonld_context_parser_1.ErrorCoded(`Can not have both '@direction' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);
                  }
                  return this.nullableTermToArray(this.createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));
                } else if (valueType) {
                  if (typeof valueType !== "string") {
                    throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);
                  }
                  const typeTerm = this.createVocabOrBaseTerm(context, valueType);
                  if (!typeTerm) {
                    throw new jsonld_context_parser_1.ErrorCoded(`Invalid '@type' value, got '${JSON.stringify(valueType)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);
                  }
                  if (typeTerm.termType !== "NamedNode") {
                    throw new jsonld_context_parser_1.ErrorCoded(`Illegal value type (${typeTerm.termType}): ${valueType}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);
                  }
                  return [this.dataFactory.literal(val, typeTerm)];
                }
                return await this.valueToTerm(new jsonld_context_parser_1.JsonLdContextNormalized({}), key, val, depth, keys);
              } else if ("@set" in value) {
                if (Object.keys(value).length > 1) {
                  throw new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @set for key: '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);
                }
                return [];
              } else if ("@list" in value) {
                if (Object.keys(value).length > 1) {
                  throw new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);
                }
                const listValue = value["@list"];
                if (Array.isArray(listValue)) {
                  if (listValue.length === 0) {
                    return [this.rdfNil];
                  } else {
                    return this.parsingContext.idStack[depth + 1] || [];
                  }
                } else {
                  return await this.valueToTerm(await this.parsingContext.getContext(keys), key, listValue, depth - 1, keys.slice(0, -1));
                }
              } else if ("@reverse" in value && typeof value["@reverse"] === "boolean") {
                return [];
              } else if ("@graph" in Util.getContextValueContainer(await this.parsingContext.getContext(keys), key)) {
                const graphContainerEntries = this.parsingContext.graphContainerTermStack[depth + 1];
                return graphContainerEntries ? Object.values(graphContainerEntries) : [this.dataFactory.blankNode()];
              } else if ("@id" in value) {
                if (Object.keys(value).length > 1) {
                  context = await this.parsingContext.getContext(keys, 0);
                }
                if ("@context" in value) {
                  context = await this.parsingContext.parseContext(value["@context"], context.getContextRaw());
                }
                if (value["@type"] === "@vocab") {
                  return this.nullableTermToArray(this.createVocabOrBaseTerm(context, value["@id"]));
                } else {
                  return this.nullableTermToArray(this.resourceToTerm(context, value["@id"]));
                }
              } else {
                if (this.parsingContext.emittedStack[depth + 1] || value && typeof value === "object" && Object.keys(value).length === 0) {
                  return this.parsingContext.idStack[depth + 1] || (this.parsingContext.idStack[depth + 1] = [this.dataFactory.blankNode()]);
                } else {
                  return [];
                }
              }
            case "string":
              return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, value, null));
            case "boolean":
              return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, Boolean(value).toString(), this.dataFactory.namedNode(Util.XSD_BOOLEAN)));
            case "number":
              return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, value, this.dataFactory.namedNode(value % 1 === 0 && value < 1e21 ? Util.XSD_INTEGER : Util.XSD_DOUBLE)));
            default:
              this.parsingContext.emitError(new Error(`Could not determine the RDF type of a ${type}`));
              return [];
          }
        }
        async getContextSelfOrPropertyScoped(context, key) {
          const contextKeyEntry = context.getContextRaw()[key];
          if (contextKeyEntry && typeof contextKeyEntry === "object" && "@context" in contextKeyEntry) {
            context = await this.parsingContext.parseContext(contextKeyEntry, context.getContextRaw(), true);
          }
          return context;
        }
        nullableTermToArray(term) {
          return term ? [term] : [];
        }
        predicateToTerm(context, key) {
          const expanded = context.expandTerm(key, true, this.parsingContext.getExpandOptions());
          if (!expanded) {
            return null;
          }
          if (expanded[0] === "_" && expanded[1] === ":") {
            if (this.parsingContext.produceGeneralizedRdf) {
              return this.dataFactory.blankNode(expanded.substr(2));
            } else {
              return null;
            }
          }
          if (Util.isValidIri(expanded)) {
            return this.dataFactory.namedNode(expanded);
          } else {
            if (expanded && this.parsingContext.strictValues) {
              this.parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Invalid predicate IRI: ${expanded}`, jsonld_context_parser_1.ERROR_CODES.INVALID_IRI_MAPPING));
            } else {
              return null;
            }
          }
          return null;
        }
        resourceToTerm(context, key) {
          if (key.startsWith("_:")) {
            return this.dataFactory.blankNode(key.substr(2));
          }
          const iri = context.expandTerm(key, false, this.parsingContext.getExpandOptions());
          if (!Util.isValidIri(iri)) {
            if (iri && this.parsingContext.strictValues) {
              this.parsingContext.emitError(new Error(`Invalid resource IRI: ${iri}`));
            } else {
              return null;
            }
          }
          return this.dataFactory.namedNode(iri);
        }
        createVocabOrBaseTerm(context, key) {
          if (key.startsWith("_:")) {
            return this.dataFactory.blankNode(key.substr(2));
          }
          const expandOptions = this.parsingContext.getExpandOptions();
          let expanded = context.expandTerm(key, true, expandOptions);
          if (expanded === key) {
            expanded = context.expandTerm(key, false, expandOptions);
          }
          if (!Util.isValidIri(expanded)) {
            if (expanded && this.parsingContext.strictValues && !expanded.startsWith("@")) {
              this.parsingContext.emitError(new Error(`Invalid term IRI: ${expanded}`));
            } else {
              return null;
            }
          }
          return this.dataFactory.namedNode(expanded);
        }
        intToString(value, datatype) {
          if (typeof value === "number") {
            if (Number.isFinite(value)) {
              const isInteger = value % 1 === 0;
              if (isInteger && (!datatype || datatype.value !== Util.XSD_DOUBLE)) {
                return Number(value).toString();
              } else {
                return value.toExponential(15).replace(/(\d)0*e\+?/, "$1E");
              }
            } else {
              return value > 0 ? "INF" : "-INF";
            }
          } else {
            return value;
          }
        }
        stringValueToTerm(depth, context, key, value, defaultDatatype) {
          const contextType = Util.getContextValueType(context, key);
          if (contextType) {
            if (contextType === "@id") {
              if (!defaultDatatype) {
                return this.resourceToTerm(context, this.intToString(value, defaultDatatype));
              }
            } else if (contextType === "@vocab") {
              if (!defaultDatatype) {
                return this.createVocabOrBaseTerm(context, this.intToString(value, defaultDatatype));
              }
            } else {
              defaultDatatype = this.dataFactory.namedNode(contextType);
            }
          }
          if (!defaultDatatype) {
            const contextLanguage = Util.getContextValueLanguage(context, key);
            const contextDirection = Util.getContextValueDirection(context, key);
            if (contextDirection && this.parsingContext.rdfDirection) {
              return this.createLanguageDirectionLiteral(depth, this.intToString(value, defaultDatatype), contextLanguage, contextDirection);
            } else {
              return this.dataFactory.literal(this.intToString(value, defaultDatatype), contextLanguage);
            }
          }
          return this.dataFactory.literal(this.intToString(value, defaultDatatype), defaultDatatype);
        }
        createLanguageDirectionLiteral(depth, value, language, direction) {
          if (this.parsingContext.rdfDirection === "i18n-datatype") {
            if (!language) {
              language = "";
            }
            return this.dataFactory.literal(value, this.dataFactory.namedNode(`https://www.w3.org/ns/i18n#${language}_${direction}`));
          } else {
            const valueNode = this.dataFactory.blankNode();
            const graph2 = this.getDefaultGraph();
            this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + "value"), this.dataFactory.literal(value), graph2));
            if (language) {
              this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + "language"), this.dataFactory.literal(language), graph2));
            }
            this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + "direction"), this.dataFactory.literal(direction), graph2));
            return valueNode;
          }
        }
        valueToJsonString(value) {
          return canonicalizeJson(value);
        }
        async unaliasKeyword(key, keys, depth, disableCache, context) {
          if (Number.isInteger(key)) {
            return key;
          }
          if (!disableCache) {
            const cachedUnaliasedKeyword = this.parsingContext.unaliasedKeywordCacheStack[depth];
            if (cachedUnaliasedKeyword) {
              return cachedUnaliasedKeyword;
            }
          }
          if (!jsonld_context_parser_1.Util.isPotentialKeyword(key)) {
            context = context || await this.parsingContext.getContext(keys);
            let unliased = context.getContextRaw()[key];
            if (unliased && typeof unliased === "object") {
              unliased = unliased["@id"];
            }
            if (jsonld_context_parser_1.Util.isValidKeyword(unliased)) {
              key = unliased;
            }
          }
          return disableCache ? key : this.parsingContext.unaliasedKeywordCacheStack[depth] = key;
        }
        async unaliasKeywordParent(keys, depth) {
          return await this.unaliasKeyword(depth > 0 && keys[depth - 1], keys, depth - 1);
        }
        async unaliasKeywords(hash, keys, depth, context) {
          const newHash = {};
          for (const key in hash) {
            newHash[await this.unaliasKeyword(key, keys, depth + 1, true, context)] = hash[key];
          }
          return newHash;
        }
        isLiteral(depth) {
          for (let i = depth; i >= 0; i--) {
            if (this.parsingContext.literalStack[i] || this.parsingContext.jsonLiteralStack[i]) {
              return true;
            }
          }
          return false;
        }
        async getDepthOffsetGraph(depth, keys) {
          for (let i = depth - 1; i > 0; i--) {
            if (await this.unaliasKeyword(keys[i], keys, i) === "@graph") {
              const containers = (await EntryHandlerContainer_1.EntryHandlerContainer.getContainerHandler(this.parsingContext, keys, i)).containers;
              if (EntryHandlerContainer_1.EntryHandlerContainer.isComplexGraphContainer(containers)) {
                return -1;
              }
              return depth - i - 1;
            }
          }
          return -1;
        }
        validateReverseSubject(subject) {
          if (subject.termType === "Literal") {
            throw new jsonld_context_parser_1.ErrorCoded(`Found illegal literal in subject position: ${subject.value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);
          }
        }
        getDefaultGraph() {
          return this.parsingContext.defaultGraph || this.dataFactory.defaultGraph();
        }
        async getGraphContainerValue(keys, depth) {
          let graph2 = this.getDefaultGraph();
          const { containers, depth: depthContainer } = await EntryHandlerContainer_1.EntryHandlerContainer.getContainerHandler(this.parsingContext, keys, depth);
          if ("@graph" in containers) {
            const graphContainerIndex = EntryHandlerContainer_1.EntryHandlerContainer.getContainerGraphIndex(containers, depthContainer, keys);
            const entry = this.parsingContext.graphContainerTermStack[depthContainer];
            graph2 = entry ? entry[graphContainerIndex] : null;
            if (!graph2) {
              let graphId = null;
              if ("@id" in containers) {
                const keyUnaliased = await this.getContainerKey(keys[depthContainer], keys, depthContainer);
                if (keyUnaliased !== null) {
                  graphId = await this.resourceToTerm(await this.parsingContext.getContext(keys), keyUnaliased);
                }
              }
              if (!graphId) {
                graphId = this.dataFactory.blankNode();
              }
              if (!this.parsingContext.graphContainerTermStack[depthContainer]) {
                this.parsingContext.graphContainerTermStack[depthContainer] = {};
              }
              graph2 = this.parsingContext.graphContainerTermStack[depthContainer][graphContainerIndex] = graphId;
            }
          }
          return graph2;
        }
        async getPropertiesDepth(keys, depth) {
          let lastValidDepth = depth;
          for (let i = depth - 1; i > 0; i--) {
            if (typeof keys[i] !== "number") {
              const parentKey = await this.unaliasKeyword(keys[i], keys, i);
              if (parentKey === "@reverse") {
                return i;
              } else if (parentKey === "@nest") {
                lastValidDepth = i;
              } else {
                return lastValidDepth;
              }
            }
          }
          return lastValidDepth;
        }
        async getContainerKey(key, keys, depth) {
          const keyUnaliased = await this.unaliasKeyword(key, keys, depth);
          return keyUnaliased === "@none" ? null : keyUnaliased;
        }
      };
      exports.Util = Util;
      Util.XSD = "http://www.w3.org/2001/XMLSchema#";
      Util.XSD_BOOLEAN = Util.XSD + "boolean";
      Util.XSD_INTEGER = Util.XSD + "integer";
      Util.XSD_DOUBLE = Util.XSD + "double";
      Util.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerArrayValue.js
  var require_EntryHandlerArrayValue = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerArrayValue.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerArrayValue = void 0;
      var Util_1 = require_Util2();
      var EntryHandlerArrayValue = class {
        isPropertyHandler() {
          return false;
        }
        isStackProcessor() {
          return true;
        }
        async validate(parsingContext, util, keys, depth, inProperty) {
          return this.test(parsingContext, util, null, keys, depth);
        }
        async test(parsingContext, util, key, keys, depth) {
          return typeof keys[depth] === "number";
        }
        async handle(parsingContext, util, key, keys, value, depth) {
          let parentKey = await util.unaliasKeywordParent(keys, depth);
          if (parentKey === "@list") {
            let listRootKey = null;
            let listRootDepth = 0;
            for (let i = depth - 2; i > 0; i--) {
              const keyOption = keys[i];
              if (typeof keyOption === "string" || typeof keyOption === "number") {
                listRootDepth = i;
                listRootKey = keyOption;
                break;
              }
            }
            if (listRootKey !== null) {
              const values = await util.valueToTerm(await parsingContext.getContext(keys), listRootKey, value, depth, keys);
              for (const object of values) {
                await this.handleListElement(parsingContext, util, object, value, depth, keys.slice(0, listRootDepth), listRootDepth);
              }
              if (values.length === 0) {
                await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, listRootDepth), listRootDepth);
              }
            }
          } else if (parentKey === "@set") {
            await parsingContext.newOnValueJob(keys.slice(0, -2), value, depth - 2, false);
          } else if (parentKey !== void 0 && parentKey !== "@type") {
            for (let i = depth - 1; i > 0; i--) {
              if (typeof keys[i] !== "number") {
                parentKey = await util.unaliasKeyword(keys[i], keys, i);
                break;
              }
            }
            const parentContext = await parsingContext.getContext(keys.slice(0, -1));
            if ("@list" in Util_1.Util.getContextValueContainer(parentContext, parentKey)) {
              parsingContext.emittedStack[depth + 1] = true;
              const values = await util.valueToTerm(await parsingContext.getContext(keys), parentKey, value, depth, keys);
              for (const object of values) {
                await this.handleListElement(parsingContext, util, object, value, depth, keys.slice(0, -1), depth - 1);
              }
              if (values.length === 0) {
                await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, -1), depth - 1);
              }
            } else {
              parsingContext.shiftStack(depth, 1);
              await parsingContext.newOnValueJob(keys.slice(0, -1), value, depth - 1, false);
              parsingContext.contextTree.removeContext(keys.slice(0, -1));
            }
          }
        }
        async handleListElement(parsingContext, util, value, valueOriginal, depth, listRootKeys, listRootDepth) {
          let listPointer = parsingContext.listPointerStack[depth];
          if (valueOriginal !== null && (await util.unaliasKeywords(valueOriginal, listRootKeys, depth))["@value"] !== null) {
            if (!listPointer || !listPointer.value) {
              const linkTerm = util.dataFactory.blankNode();
              listPointer = { value: linkTerm, listRootDepth, listId: linkTerm };
            } else {
              const newLinkTerm = util.dataFactory.blankNode();
              parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfRest, newLinkTerm, util.getDefaultGraph()));
              listPointer.value = newLinkTerm;
            }
            if (value) {
              parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfFirst, value, util.getDefaultGraph()));
            }
          } else {
            if (!listPointer) {
              listPointer = { listRootDepth, listId: util.rdfNil };
            }
          }
          parsingContext.listPointerStack[depth] = listPointer;
        }
      };
      exports.EntryHandlerArrayValue = EntryHandlerArrayValue;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerInvalidFallback.js
  var require_EntryHandlerInvalidFallback = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerInvalidFallback.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerInvalidFallback = void 0;
      var EntryHandlerInvalidFallback = class {
        isPropertyHandler() {
          return false;
        }
        isStackProcessor() {
          return true;
        }
        async validate(parsingContext, util, keys, depth, inProperty) {
          return false;
        }
        async test(parsingContext, util, key, keys, depth) {
          return true;
        }
        async handle(parsingContext, util, key, keys, value, depth) {
          parsingContext.emittedStack[depth] = false;
        }
      };
      exports.EntryHandlerInvalidFallback = EntryHandlerInvalidFallback;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeyword.js
  var require_EntryHandlerKeyword = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeyword.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerKeyword = void 0;
      var EntryHandlerKeyword = class {
        constructor(keyword) {
          this.keyword = keyword;
        }
        isPropertyHandler() {
          return false;
        }
        isStackProcessor() {
          return true;
        }
        async validate(parsingContext, util, keys, depth, inProperty) {
          return false;
        }
        async test(parsingContext, util, key, keys, depth) {
          return key === this.keyword;
        }
      };
      exports.EntryHandlerKeyword = EntryHandlerKeyword;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordContext.js
  var require_EntryHandlerKeywordContext = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordContext.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerKeywordContext = void 0;
      var jsonld_context_parser_1 = require_jsonld_context_parser();
      var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
      var EntryHandlerKeywordContext = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
        constructor() {
          super("@context");
        }
        isStackProcessor() {
          return false;
        }
        async handle(parsingContext, util, key, keys, value, depth) {
          if (parsingContext.streamingProfile && (parsingContext.processingStack[depth] || parsingContext.processingType[depth] || parsingContext.idStack[depth] !== void 0)) {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded("Found an out-of-order context, while streaming is enabled.(disable `streamingProfile`)", jsonld_context_parser_1.ERROR_CODES.INVALID_STREAMING_KEY_ORDER));
          }
          const parentContext = parsingContext.getContext(keys);
          const context = parsingContext.parseContext(value, (await parentContext).getContextRaw());
          parsingContext.contextTree.setContext(keys.slice(0, -1), context);
          parsingContext.emitContext(value);
          await parsingContext.validateContext(await context);
        }
      };
      exports.EntryHandlerKeywordContext = EntryHandlerKeywordContext;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordGraph.js
  var require_EntryHandlerKeywordGraph = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordGraph.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerKeywordGraph = void 0;
      var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
      var EntryHandlerKeywordGraph = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
        constructor() {
          super("@graph");
        }
        async handle(parsingContext, util, key, keys, value, depth) {
          parsingContext.graphStack[depth + 1] = true;
        }
      };
      exports.EntryHandlerKeywordGraph = EntryHandlerKeywordGraph;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordId.js
  var require_EntryHandlerKeywordId = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordId.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerKeywordId = void 0;
      var jsonld_context_parser_1 = require_jsonld_context_parser();
      var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
      var EntryHandlerKeywordId = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
        constructor() {
          super("@id");
        }
        isStackProcessor() {
          return false;
        }
        async handle(parsingContext, util, key, keys, value, depth) {
          if (typeof value !== "string") {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @id '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_ID_VALUE));
          }
          const depthProperties = await util.getPropertiesDepth(keys, depth);
          if (parsingContext.idStack[depthProperties] !== void 0) {
            if (parsingContext.idStack[depthProperties][0].listHead) {
              parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${keys[depth - 1]}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT));
            } else {
              parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found duplicate @ids '${parsingContext.idStack[depthProperties][0].value}' and '${value}'`, jsonld_context_parser_1.ERROR_CODES.COLLIDING_KEYWORDS));
            }
          }
          parsingContext.idStack[depthProperties] = util.nullableTermToArray(await util.resourceToTerm(await parsingContext.getContext(keys), value));
        }
      };
      exports.EntryHandlerKeywordId = EntryHandlerKeywordId;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordIncluded.js
  var require_EntryHandlerKeywordIncluded = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordIncluded.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerKeywordIncluded = void 0;
      var jsonld_context_parser_1 = require_jsonld_context_parser();
      var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
      var EntryHandlerKeywordIncluded = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
        constructor() {
          super("@included");
        }
        async handle(parsingContext, util, key, keys, value, depth) {
          if (typeof value !== "object") {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @included '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INCLUDED_VALUE));
          }
          const valueUnliased = await util.unaliasKeywords(value, keys, depth, await parsingContext.getContext(keys));
          if ("@value" in valueUnliased) {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal @included @value node '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INCLUDED_VALUE));
          }
          if ("@list" in valueUnliased) {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal @included @list node '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INCLUDED_VALUE));
          }
          parsingContext.emittedStack[depth] = false;
        }
      };
      exports.EntryHandlerKeywordIncluded = EntryHandlerKeywordIncluded;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordNest.js
  var require_EntryHandlerKeywordNest = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordNest.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerKeywordNest = void 0;
      var jsonld_context_parser_1 = require_jsonld_context_parser();
      var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
      var EntryHandlerKeywordNest = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
        constructor() {
          super("@nest");
        }
        async handle(parsingContext, util, key, keys, value, depth) {
          if (typeof value !== "object") {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found invalid @nest entry for '${key}': '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_NEST_VALUE));
          }
          if ("@value" in await util.unaliasKeywords(value, keys, depth, await parsingContext.getContext(keys))) {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an invalid @value node for '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_NEST_VALUE));
          }
          parsingContext.emittedStack[depth] = false;
        }
      };
      exports.EntryHandlerKeywordNest = EntryHandlerKeywordNest;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordType.js
  var require_EntryHandlerKeywordType = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordType.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerKeywordType = void 0;
      var jsonld_context_parser_1 = require_jsonld_context_parser();
      var Util_1 = require_Util2();
      var EntryHandlerPredicate_1 = require_EntryHandlerPredicate();
      var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
      var EntryHandlerKeywordType = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
        constructor() {
          super("@type");
        }
        isStackProcessor() {
          return false;
        }
        async handle(parsingContext, util, key, keys, value, depth) {
          const keyOriginal = keys[depth];
          const context = await parsingContext.getContext(keys);
          const predicate = util.rdfType;
          const reverse = Util_1.Util.isPropertyReverse(context, keyOriginal, await util.unaliasKeywordParent(keys, depth));
          const elements = Array.isArray(value) ? value : [value];
          for (const element of elements) {
            if (typeof element !== "string") {
              parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @type '${element}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPE_VALUE));
            }
            const type = util.createVocabOrBaseTerm(context, element);
            if (type) {
              await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth, predicate, type, reverse);
            }
          }
          let scopedContext = Promise.resolve(context);
          let hasTypedScopedContext = false;
          for (const element of elements.sort()) {
            const typeContext = Util_1.Util.getContextValue(context, "@context", element, null);
            if (typeContext) {
              hasTypedScopedContext = true;
              scopedContext = scopedContext.then((c) => parsingContext.parseContext(typeContext, c.getContextRaw()));
            }
          }
          if (parsingContext.streamingProfile && (hasTypedScopedContext || !parsingContext.streamingProfileAllowOutOfOrderPlainType) && (parsingContext.processingStack[depth] || parsingContext.idStack[depth])) {
            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded("Found an out-of-order type-scoped context, while streaming is enabled.(disable `streamingProfile`)", jsonld_context_parser_1.ERROR_CODES.INVALID_STREAMING_KEY_ORDER));
          }
          if (hasTypedScopedContext) {
            scopedContext = scopedContext.then((c) => {
              if (!("@propagate" in c.getContextRaw())) {
                c.getContextRaw()["@propagate"] = false;
              }
              if (c.getContextRaw()["@propagate"] === false) {
                c.getContextRaw()["@__propagateFallback"] = context.getContextRaw();
              }
              return c;
            });
            parsingContext.contextTree.setContext(keys.slice(0, keys.length - 1), scopedContext);
          }
          parsingContext.processingType[depth] = true;
        }
      };
      exports.EntryHandlerKeywordType = EntryHandlerKeywordType;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordUnknownFallback.js
  var require_EntryHandlerKeywordUnknownFallback = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordUnknownFallback.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerKeywordUnknownFallback = void 0;
      var jsonld_context_parser_1 = require_jsonld_context_parser();
      var EntryHandlerKeywordUnknownFallback = class {
        isPropertyHandler() {
          return false;
        }
        isStackProcessor() {
          return true;
        }
        async validate(parsingContext, util, keys, depth, inProperty) {
          const key = await util.unaliasKeyword(keys[depth], keys, depth);
          if (jsonld_context_parser_1.Util.isPotentialKeyword(key)) {
            if (!inProperty) {
              if (key === "@list") {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        async test(parsingContext, util, key, keys, depth) {
          return jsonld_context_parser_1.Util.isPotentialKeyword(key);
        }
        async handle(parsingContext, util, key, keys, value, depth) {
          const keywordType = EntryHandlerKeywordUnknownFallback.VALID_KEYWORDS_TYPES[key];
          if (keywordType !== void 0) {
            if (keywordType && typeof value !== keywordType.type) {
              parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Invalid value type for '${key}' with value '${value}'`, keywordType.errorCode));
            }
          } else if (parsingContext.strictValues) {
            parsingContext.emitError(new Error(`Unknown keyword '${key}' with value '${value}'`));
          }
          parsingContext.emittedStack[depth] = false;
        }
      };
      exports.EntryHandlerKeywordUnknownFallback = EntryHandlerKeywordUnknownFallback;
      EntryHandlerKeywordUnknownFallback.VALID_KEYWORDS_TYPES = {
        "@index": { type: "string", errorCode: jsonld_context_parser_1.ERROR_CODES.INVALID_INDEX_VALUE },
        "@list": null,
        "@reverse": { type: "object", errorCode: jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_VALUE },
        "@set": null,
        "@value": null
      };
    }
  });

  // node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordValue.js
  var require_EntryHandlerKeywordValue = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordValue.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EntryHandlerKeywordValue = void 0;
      var EntryHandlerKeyword_1 = require_EntryHandlerKeyword();
      var EntryHandlerKeywordValue = class extends EntryHandlerKeyword_1.EntryHandlerKeyword {
        constructor() {
          super("@value");
        }
        async validate(parsingContext, util, keys, depth, inProperty) {
          const key = keys[depth];
          if (key && !parsingContext.literalStack[depth] && await this.test(parsingContext, util, key, keys, depth)) {
            parsingContext.literalStack[depth] = true;
          }
          return super.validate(parsingContext, util, keys, depth, inProperty);
        }
        async test(parsingContext, util, key, keys, depth) {
          return await util.unaliasKeyword(keys[depth], keys.slice(0, keys.length - 1), depth - 1, true) === "@value";
        }
        async handle(parsingContext, util, key, keys, value, depth) {
          parsingContext.literalStack[depth] = true;
          delete parsingContext.unidentifiedValuesBuffer[depth];
          delete parsingContext.unidentifiedGraphsBuffer[depth];
          parsingContext.emittedStack[depth] = false;
        }
      };
      exports.EntryHandlerKeywordValue = EntryHandlerKeywordValue;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/ContextTree.js
  var require_ContextTree = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/ContextTree.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContextTree = void 0;
      var ContextTree = class {
        constructor() {
          this.subTrees = {};
        }
        getContext(keys) {
          if (keys.length > 0) {
            const [head, ...tail] = keys;
            const subTree = this.subTrees[head];
            if (subTree) {
              const subContext = subTree.getContext(tail);
              if (subContext) {
                return subContext.then(({ context, depth }) => ({ context, depth: depth + 1 }));
              }
            }
          }
          return this.context ? this.context.then((context) => ({ context, depth: 0 })) : null;
        }
        setContext(keys, context) {
          if (keys.length === 0) {
            this.context = context;
          } else {
            const [head, ...tail] = keys;
            let subTree = this.subTrees[head];
            if (!subTree) {
              subTree = this.subTrees[head] = new ContextTree();
            }
            subTree.setContext(tail, context);
          }
        }
        removeContext(path) {
          this.setContext(path, null);
        }
      };
      exports.ContextTree = ContextTree;
    }
  });

  // node_modules/jsonld-streaming-parser/lib/ParsingContext.js
  var require_ParsingContext = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/ParsingContext.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParsingContext = void 0;
      var jsonld_context_parser_1 = require_jsonld_context_parser();
      var ErrorCoded_1 = require_ErrorCoded();
      var ContextTree_1 = require_ContextTree();
      var JsonLdParser_1 = require_JsonLdParser();
      var ParsingContext = class {
        constructor(options) {
          this.contextParser = new jsonld_context_parser_1.ContextParser({ documentLoader: options.documentLoader, skipValidation: options.skipContextValidation });
          this.streamingProfile = !!options.streamingProfile;
          this.baseIRI = options.baseIRI;
          this.produceGeneralizedRdf = !!options.produceGeneralizedRdf;
          this.allowSubjectList = !!options.allowSubjectList;
          this.processingMode = options.processingMode || JsonLdParser_1.JsonLdParser.DEFAULT_PROCESSING_MODE;
          this.strictValues = !!options.strictValues;
          this.validateValueIndexes = !!options.validateValueIndexes;
          this.defaultGraph = options.defaultGraph;
          this.rdfDirection = options.rdfDirection;
          this.normalizeLanguageTags = options.normalizeLanguageTags;
          this.streamingProfileAllowOutOfOrderPlainType = options.streamingProfileAllowOutOfOrderPlainType;
          this.topLevelProperties = false;
          this.activeProcessingMode = parseFloat(this.processingMode);
          this.processingStack = [];
          this.processingType = [];
          this.emittedStack = [];
          this.idStack = [];
          this.graphStack = [];
          this.graphContainerTermStack = [];
          this.listPointerStack = [];
          this.contextTree = new ContextTree_1.ContextTree();
          this.literalStack = [];
          this.validationStack = [];
          this.unaliasedKeywordCacheStack = [];
          this.jsonLiteralStack = [];
          this.unidentifiedValuesBuffer = [];
          this.unidentifiedGraphsBuffer = [];
          this.pendingContainerFlushBuffers = [];
          this.parser = options.parser;
          if (options.context) {
            this.rootContext = this.parseContext(options.context);
            this.rootContext.then((context) => this.validateContext(context));
          } else {
            this.rootContext = Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized(this.baseIRI ? { "@base": this.baseIRI, "@__baseDocument": true } : {}));
          }
        }
        async parseContext(context, parentContext, ignoreProtection) {
          return this.contextParser.parse(context, {
            baseIRI: this.baseIRI,
            ignoreProtection,
            normalizeLanguageTags: this.normalizeLanguageTags,
            parentContext,
            processingMode: this.activeProcessingMode
          });
        }
        validateContext(context) {
          const activeVersion = context.getContextRaw()["@version"];
          if (activeVersion) {
            if (this.activeProcessingMode && activeVersion > this.activeProcessingMode) {
              throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD version '${activeVersion}' under active processing mode ${this.activeProcessingMode}.`, ErrorCoded_1.ERROR_CODES.PROCESSING_MODE_CONFLICT);
            } else {
              if (this.activeProcessingMode && activeVersion < this.activeProcessingMode) {
                throw new ErrorCoded_1.ErrorCoded(`Invalid JSON-LD version ${activeVersion} under active processing mode ${this.activeProcessingMode}.`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);
              }
              this.activeProcessingMode = activeVersion;
            }
          }
        }
        async getContext(keys, offset = 1) {
          const keysOriginal = keys;
          while (typeof keys[keys.length - 1] === "number") {
            keys = keys.slice(0, keys.length - 1);
          }
          if (offset) {
            keys = keys.slice(0, -offset);
          }
          const contextData = await this.getContextPropagationAware(keys);
          const context = contextData.context;
          let contextRaw = context.getContextRaw();
          for (let i = contextData.depth; i < keysOriginal.length - offset; i++) {
            const key = keysOriginal[i];
            const contextKeyEntry = contextRaw[key];
            if (contextKeyEntry && typeof contextKeyEntry === "object" && "@context" in contextKeyEntry) {
              const scopedContext = (await this.parseContext(contextKeyEntry, contextRaw, true)).getContextRaw();
              const propagate = !(key in scopedContext) || scopedContext[key]["@context"]["@propagate"];
              if (propagate !== false || i === keysOriginal.length - 1 - offset) {
                contextRaw = scopedContext;
                delete contextRaw["@propagate"];
                contextRaw[key] = Object.assign({}, contextRaw[key]);
                if ("@id" in contextKeyEntry) {
                  contextRaw[key]["@id"] = contextKeyEntry["@id"];
                }
                delete contextRaw[key]["@context"];
                if (propagate !== false) {
                  this.contextTree.setContext(keysOriginal.slice(0, i + offset), Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized(contextRaw)));
                }
              }
            }
          }
          return new jsonld_context_parser_1.JsonLdContextNormalized(contextRaw);
        }
        async getContextPropagationAware(keys) {
          const originalDepth = keys.length;
          let contextData = null;
          let hasApplicablePropertyScopedContext;
          do {
            hasApplicablePropertyScopedContext = false;
            if (contextData && "@__propagateFallback" in contextData.context.getContextRaw()) {
              contextData.context = new jsonld_context_parser_1.JsonLdContextNormalized(contextData.context.getContextRaw()["@__propagateFallback"]);
            } else {
              if (contextData) {
                keys = keys.slice(0, contextData.depth - 1);
              }
              contextData = await this.contextTree.getContext(keys) || { context: await this.rootContext, depth: 0 };
            }
            const lastKey = keys[keys.length - 1];
            if (lastKey in contextData.context.getContextRaw()) {
              const lastKeyValue = contextData.context.getContextRaw()[lastKey];
              if (lastKeyValue && typeof lastKeyValue === "object" && "@context" in lastKeyValue) {
                hasApplicablePropertyScopedContext = true;
              }
            }
          } while (contextData.depth > 0 && contextData.context.getContextRaw()["@propagate"] === false && contextData.depth !== originalDepth && !hasApplicablePropertyScopedContext);
          if (contextData.depth === 0 && contextData.context.getContextRaw()["@propagate"] === false && contextData.depth !== originalDepth) {
            contextData.context = new jsonld_context_parser_1.JsonLdContextNormalized({});
          }
          return contextData;
        }
        async newOnValueJob(keys, value, depth, lastDepthCheck) {
          await this.parser.newOnValueJob(keys, value, depth, lastDepthCheck);
        }
        async handlePendingContainerFlushBuffers() {
          if (this.pendingContainerFlushBuffers.length > 0) {
            for (const pendingFlushBuffer of this.pendingContainerFlushBuffers) {
              await this.parser.flushBuffer(pendingFlushBuffer.depth, pendingFlushBuffer.keys);
              this.parser.flushStacks(pendingFlushBuffer.depth);
            }
            this.pendingContainerFlushBuffers.splice(0, this.pendingContainerFlushBuffers.length);
            return true;
          } else {
            return false;
          }
        }
        emitQuad(depth, quad) {
          if (depth === 1) {
            this.topLevelProperties = true;
          }
          this.parser.push(quad);
        }
        emitError(error) {
          this.parser.emit("error", error);
        }
        emitContext(context) {
          this.parser.emit("context", context);
        }
        getUnidentifiedValueBufferSafe(depth) {
          let buffer = this.unidentifiedValuesBuffer[depth];
          if (!buffer) {
            buffer = [];
            this.unidentifiedValuesBuffer[depth] = buffer;
          }
          return buffer;
        }
        getUnidentifiedGraphBufferSafe(depth) {
          let buffer = this.unidentifiedGraphsBuffer[depth];
          if (!buffer) {
            buffer = [];
            this.unidentifiedGraphsBuffer[depth] = buffer;
          }
          return buffer;
        }
        getExpandOptions() {
          return ParsingContext.EXPAND_OPTIONS[this.activeProcessingMode];
        }
        shiftStack(depth, depthOffset) {
          const deeperIdStack = this.idStack[depth + depthOffset];
          if (deeperIdStack) {
            this.idStack[depth] = deeperIdStack;
            this.emittedStack[depth] = true;
            delete this.idStack[depth + depthOffset];
          }
          if (this.pendingContainerFlushBuffers.length) {
            for (const buffer of this.pendingContainerFlushBuffers) {
              if (buffer.depth >= depth + depthOffset) {
                buffer.depth -= depthOffset;
                buffer.keys.splice(depth, depthOffset);
              }
            }
          }
          if (this.unidentifiedValuesBuffer[depth + depthOffset]) {
            this.unidentifiedValuesBuffer[depth] = this.unidentifiedValuesBuffer[depth + depthOffset];
            delete this.unidentifiedValuesBuffer[depth + depthOffset];
          }
        }
      };
      exports.ParsingContext = ParsingContext;
      ParsingContext.EXPAND_OPTIONS = {
        1: {
          allowPrefixForcing: false,
          allowPrefixNonGenDelims: false,
          allowVocabRelativeToBase: false
        },
        1.1: {
          allowPrefixForcing: true,
          allowPrefixNonGenDelims: false,
          allowVocabRelativeToBase: true
        }
      };
    }
  });

  // node_modules/jsonld-streaming-parser/lib/JsonLdParser.js
  var require_JsonLdParser = __commonJS({
    "node_modules/jsonld-streaming-parser/lib/JsonLdParser.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JsonLdParser = void 0;
      var Parser = require_jsonparse();
      var jsonld_context_parser_1 = require_jsonld_context_parser();
      var stream_1 = require_stream_browserify();
      var EntryHandlerArrayValue_1 = require_EntryHandlerArrayValue();
      var EntryHandlerContainer_1 = require_EntryHandlerContainer();
      var EntryHandlerInvalidFallback_1 = require_EntryHandlerInvalidFallback();
      var EntryHandlerPredicate_1 = require_EntryHandlerPredicate();
      var EntryHandlerKeywordContext_1 = require_EntryHandlerKeywordContext();
      var EntryHandlerKeywordGraph_1 = require_EntryHandlerKeywordGraph();
      var EntryHandlerKeywordId_1 = require_EntryHandlerKeywordId();
      var EntryHandlerKeywordIncluded_1 = require_EntryHandlerKeywordIncluded();
      var EntryHandlerKeywordNest_1 = require_EntryHandlerKeywordNest();
      var EntryHandlerKeywordType_1 = require_EntryHandlerKeywordType();
      var EntryHandlerKeywordUnknownFallback_1 = require_EntryHandlerKeywordUnknownFallback();
      var EntryHandlerKeywordValue_1 = require_EntryHandlerKeywordValue();
      var ParsingContext_1 = require_ParsingContext();
      var Util_1 = require_Util2();
      var http_link_header_1 = require_link();
      var JsonLdParser = class extends stream_1.Transform {
        constructor(options) {
          super({ readableObjectMode: true });
          options = options || {};
          this.options = options;
          this.parsingContext = new ParsingContext_1.ParsingContext(Object.assign({ parser: this }, options));
          this.util = new Util_1.Util({ dataFactory: options.dataFactory, parsingContext: this.parsingContext });
          this.jsonParser = new Parser();
          this.contextJobs = [];
          this.typeJobs = [];
          this.contextAwaitingJobs = [];
          this.lastDepth = 0;
          this.lastKeys = [];
          this.lastOnValueJob = Promise.resolve();
          this.attachJsonParserListeners();
          this.on("end", () => {
            if (typeof this.jsonParser.mode !== "undefined") {
              this.emit("error", new Error("Unclosed document"));
            }
          });
        }
        static fromHttpResponse(baseIRI, mediaType, headers, options) {
          let context;
          if (mediaType !== "application/ld+json") {
            if (mediaType !== "application/json" && !mediaType.endsWith("+json")) {
              throw new jsonld_context_parser_1.ErrorCoded(`Unsupported JSON-LD media type ${mediaType}`, jsonld_context_parser_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);
            }
            if (headers && headers.has("Link")) {
              headers.forEach((value, key) => {
                if (key === "link") {
                  const linkHeader = http_link_header_1.parse(value);
                  for (const link of linkHeader.get("rel", "http://www.w3.org/ns/json-ld#context")) {
                    if (context) {
                      throw new jsonld_context_parser_1.ErrorCoded("Multiple JSON-LD context link headers were found on " + baseIRI, jsonld_context_parser_1.ERROR_CODES.MULTIPLE_CONTEXT_LINK_HEADERS);
                    }
                    context = link.uri;
                  }
                }
              });
            }
            if (!context && !(options === null || options === void 0 ? void 0 : options.ignoreMissingContextLinkHeader)) {
              throw new jsonld_context_parser_1.ErrorCoded(`Missing context link header for media type ${mediaType} on ${baseIRI}`, jsonld_context_parser_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);
            }
          }
          let streamingProfile;
          if (headers && headers.has("Content-Type")) {
            const contentType = headers.get("Content-Type");
            const match = /; *profile=([^"]*)/.exec(contentType);
            if (match && match[1] === "http://www.w3.org/ns/json-ld#streaming") {
              streamingProfile = true;
            }
          }
          return new JsonLdParser(Object.assign({
            baseIRI,
            context,
            streamingProfile
          }, options ? options : {}));
        }
        import(stream) {
          const output = new stream_1.PassThrough({ readableObjectMode: true });
          stream.on("error", (error) => parsed.emit("error", error));
          stream.on("data", (data) => output.push(data));
          stream.on("end", () => output.push(null));
          const parsed = output.pipe(new JsonLdParser(this.options));
          return parsed;
        }
        _transform(chunk, encoding2, callback) {
          this.jsonParser.write(chunk);
          this.lastOnValueJob.then(() => callback(), (error) => callback(error));
        }
        async newOnValueJob(keys, value, depth, lastDepthCheck) {
          let flushStacks = true;
          if (lastDepthCheck && depth < this.lastDepth) {
            const listPointer = this.parsingContext.listPointerStack[this.lastDepth];
            if (listPointer) {
              if (listPointer.value) {
                this.emit("data", this.util.dataFactory.quad(listPointer.value, this.util.rdfRest, this.util.rdfNil, this.util.getDefaultGraph()));
              }
              listPointer.listId.listHead = true;
              this.parsingContext.idStack[listPointer.listRootDepth + 1] = [listPointer.listId];
              this.parsingContext.listPointerStack.splice(this.lastDepth, 1);
            }
            if (await EntryHandlerContainer_1.EntryHandlerContainer.isBufferableContainerHandler(this.parsingContext, this.lastKeys, this.lastDepth)) {
              this.parsingContext.pendingContainerFlushBuffers.push({ depth: this.lastDepth, keys: this.lastKeys.slice(0, this.lastKeys.length) });
              flushStacks = false;
            } else {
              await this.flushBuffer(this.lastDepth, this.lastKeys);
            }
          }
          const key = await this.util.unaliasKeyword(keys[depth], keys, depth);
          const parentKey = await this.util.unaliasKeywordParent(keys, depth);
          this.parsingContext.emittedStack[depth] = true;
          let handleKey = true;
          if (jsonld_context_parser_1.Util.isValidKeyword(key) && parentKey === "@reverse" && key !== "@context") {
            this.emit("error", new jsonld_context_parser_1.ErrorCoded(`Found the @id '${value}' inside an @reverse property`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_MAP));
          }
          let inProperty = false;
          if (this.parsingContext.validationStack.length > 1) {
            inProperty = this.parsingContext.validationStack[this.parsingContext.validationStack.length - 1].property;
          }
          for (let i = Math.max(1, this.parsingContext.validationStack.length - 1); i < keys.length - 1; i++) {
            const validationResult = this.parsingContext.validationStack[i] || (this.parsingContext.validationStack[i] = await this.validateKey(keys.slice(0, i + 1), i, inProperty));
            if (!validationResult.valid) {
              this.parsingContext.emittedStack[depth] = false;
              handleKey = false;
              break;
            } else if (!inProperty && validationResult.property) {
              inProperty = true;
            }
          }
          if (this.util.isLiteral(depth)) {
            handleKey = false;
          }
          if (handleKey) {
            for (const entryHandler of JsonLdParser.ENTRY_HANDLERS) {
              const testResult = await entryHandler.test(this.parsingContext, this.util, key, keys, depth);
              if (testResult) {
                await entryHandler.handle(this.parsingContext, this.util, key, keys, value, depth, testResult);
                if (entryHandler.isStackProcessor()) {
                  this.parsingContext.processingStack[depth] = true;
                }
                break;
              }
            }
          }
          if (depth === 0 && Array.isArray(value)) {
            await this.util.validateValueIndexes(value);
          }
          if (flushStacks && depth < this.lastDepth) {
            this.flushStacks(this.lastDepth);
          }
          this.lastDepth = depth;
          this.lastKeys = keys;
          this.parsingContext.unaliasedKeywordCacheStack.splice(depth - 1);
        }
        flushStacks(depth) {
          this.parsingContext.processingStack.splice(depth, 1);
          this.parsingContext.processingType.splice(depth, 1);
          this.parsingContext.emittedStack.splice(depth, 1);
          this.parsingContext.idStack.splice(depth, 1);
          this.parsingContext.graphStack.splice(depth + 1, 1);
          this.parsingContext.graphContainerTermStack.splice(depth, 1);
          this.parsingContext.jsonLiteralStack.splice(depth, 1);
          this.parsingContext.validationStack.splice(depth - 1, 2);
          this.parsingContext.literalStack.splice(depth, this.parsingContext.literalStack.length - depth);
        }
        async flushBuffer(depth, keys) {
          let subjects = this.parsingContext.idStack[depth];
          if (!subjects) {
            subjects = this.parsingContext.idStack[depth] = [this.util.dataFactory.blankNode()];
          }
          const valueBuffer = this.parsingContext.unidentifiedValuesBuffer[depth];
          if (valueBuffer) {
            for (const subject of subjects) {
              const depthOffsetGraph = await this.util.getDepthOffsetGraph(depth, keys);
              const graphs = this.parsingContext.graphStack[depth] || depthOffsetGraph >= 0 ? this.parsingContext.idStack[depth - depthOffsetGraph - 1] : [await this.util.getGraphContainerValue(keys, depth)];
              if (graphs) {
                for (const graph2 of graphs) {
                  this.parsingContext.emittedStack[depth] = true;
                  for (const bufferedValue of valueBuffer) {
                    if (bufferedValue.reverse) {
                      this.parsingContext.emitQuad(depth, this.util.dataFactory.quad(bufferedValue.object, bufferedValue.predicate, subject, graph2));
                    } else {
                      this.parsingContext.emitQuad(depth, this.util.dataFactory.quad(subject, bufferedValue.predicate, bufferedValue.object, graph2));
                    }
                  }
                }
              } else {
                const subGraphBuffer = this.parsingContext.getUnidentifiedGraphBufferSafe(depth - await this.util.getDepthOffsetGraph(depth, keys) - 1);
                for (const bufferedValue of valueBuffer) {
                  if (bufferedValue.reverse) {
                    subGraphBuffer.push({
                      object: subject,
                      predicate: bufferedValue.predicate,
                      subject: bufferedValue.object
                    });
                  } else {
                    subGraphBuffer.push({
                      object: bufferedValue.object,
                      predicate: bufferedValue.predicate,
                      subject
                    });
                  }
                }
              }
            }
            this.parsingContext.unidentifiedValuesBuffer.splice(depth, 1);
            this.parsingContext.literalStack.splice(depth, 1);
            this.parsingContext.jsonLiteralStack.splice(depth, 1);
          }
          const graphBuffer = this.parsingContext.unidentifiedGraphsBuffer[depth];
          if (graphBuffer) {
            for (const subject of subjects) {
              const graph2 = depth === 1 && subject.termType === "BlankNode" && !this.parsingContext.topLevelProperties ? this.util.getDefaultGraph() : subject;
              this.parsingContext.emittedStack[depth] = true;
              for (const bufferedValue of graphBuffer) {
                this.parsingContext.emitQuad(depth, this.util.dataFactory.quad(bufferedValue.subject, bufferedValue.predicate, bufferedValue.object, graph2));
              }
            }
            this.parsingContext.unidentifiedGraphsBuffer.splice(depth, 1);
          }
        }
        async validateKey(keys, depth, inProperty) {
          for (const entryHandler of JsonLdParser.ENTRY_HANDLERS) {
            if (await entryHandler.validate(this.parsingContext, this.util, keys, depth, inProperty)) {
              return { valid: true, property: inProperty || entryHandler.isPropertyHandler() };
            }
          }
          return { valid: false, property: false };
        }
        attachJsonParserListeners() {
          this.jsonParser.onValue = (value) => {
            const depth = this.jsonParser.stack.length;
            const keys = new Array(depth + 1).fill(0).map((v, i) => {
              return i === depth ? this.jsonParser.key : this.jsonParser.stack[i].key;
            });
            if (!this.isParsingContextInner(depth)) {
              const valueJobCb = () => this.newOnValueJob(keys, value, depth, true);
              if (!this.parsingContext.streamingProfile && !this.parsingContext.contextTree.getContext(keys.slice(0, -1))) {
                if (keys[depth] === "@context") {
                  let jobs = this.contextJobs[depth];
                  if (!jobs) {
                    jobs = this.contextJobs[depth] = [];
                  }
                  jobs.push(valueJobCb);
                } else if (keys[depth] === "@type" || typeof keys[depth] === "number" && keys[depth - 1] === "@type") {
                  this.typeJobs.push({ job: valueJobCb, keys: keys.slice(0, keys.length - 1) });
                } else {
                  this.contextAwaitingJobs.push({ job: valueJobCb, keys });
                }
              } else {
                this.lastOnValueJob = this.lastOnValueJob.then(valueJobCb);
              }
              if (!this.parsingContext.streamingProfile && depth === 0) {
                this.lastOnValueJob = this.lastOnValueJob.then(() => this.executeBufferedJobs());
              }
            }
          };
          this.jsonParser.onError = (error) => {
            this.emit("error", error);
          };
        }
        isParsingContextInner(depth) {
          for (let i = depth; i > 0; i--) {
            if (this.jsonParser.stack[i - 1].key === "@context") {
              return true;
            }
          }
          return false;
        }
        async executeBufferedJobs() {
          for (const jobs of this.contextJobs) {
            if (jobs) {
              for (const job of jobs) {
                await job();
              }
            }
          }
          this.parsingContext.unaliasedKeywordCacheStack.splice(0);
          for (const job of this.contextAwaitingJobs) {
            if (this.typeJobs.length > 0) {
              const applicableTypeJobs = [];
              const applicableTypeJobIds = [];
              for (let i = 0; i < this.typeJobs.length; i++) {
                const typeJob = this.typeJobs[i];
                if (Util_1.Util.isPrefixArray(typeJob.keys, job.keys)) {
                  applicableTypeJobs.push(typeJob);
                  applicableTypeJobIds.push(i);
                }
              }
              const sortedTypeJobs = applicableTypeJobs.sort((job1, job2) => job1.keys.length - job2.keys.length);
              for (const typeJob of sortedTypeJobs) {
                await typeJob.job();
              }
              const sortedApplicableTypeJobIds = applicableTypeJobIds.sort().reverse();
              for (const jobId of sortedApplicableTypeJobIds) {
                this.typeJobs.splice(jobId, 1);
              }
            }
            await job.job();
          }
        }
      };
      exports.JsonLdParser = JsonLdParser;
      JsonLdParser.DEFAULT_PROCESSING_MODE = "1.1";
      JsonLdParser.ENTRY_HANDLERS = [
        new EntryHandlerArrayValue_1.EntryHandlerArrayValue(),
        new EntryHandlerKeywordContext_1.EntryHandlerKeywordContext(),
        new EntryHandlerKeywordId_1.EntryHandlerKeywordId(),
        new EntryHandlerKeywordIncluded_1.EntryHandlerKeywordIncluded(),
        new EntryHandlerKeywordGraph_1.EntryHandlerKeywordGraph(),
        new EntryHandlerKeywordNest_1.EntryHandlerKeywordNest(),
        new EntryHandlerKeywordType_1.EntryHandlerKeywordType(),
        new EntryHandlerKeywordValue_1.EntryHandlerKeywordValue(),
        new EntryHandlerContainer_1.EntryHandlerContainer(),
        new EntryHandlerKeywordUnknownFallback_1.EntryHandlerKeywordUnknownFallback(),
        new EntryHandlerPredicate_1.EntryHandlerPredicate(),
        new EntryHandlerInvalidFallback_1.EntryHandlerInvalidFallback()
      ];
    }
  });

  // node_modules/jsonld-streaming-parser/index.js
  var require_jsonld_streaming_parser = __commonJS({
    "node_modules/jsonld-streaming-parser/index.js"(exports) {
      "use strict";
      init_shim();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_JsonLdParser(), exports);
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser7 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list6 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_shim();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer3 = _require.Buffer;
      var _require2 = require_util2();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer3.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer3.alloc(0);
            var ret = Buffer3.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer3.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy7 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              import_process.default.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              import_process.default.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            import_process.default.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/errors-browser.js
  var require_errors_browser6 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_shim();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state6 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_INVALID_OPT_VALUE = require_errors_browser6().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable7 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser7();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy7();
      var _require = require_state6();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser6().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex7();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex7();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          import_process.default.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding2, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer3.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (isBuf)
          encoding2 = "buffer";
        else if (!encoding2)
          encoding2 = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ending)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding2, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
        if (typeof encoding2 === "string")
          encoding2 = encoding2.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding2);
        this._writableState.defaultEncoding = encoding2;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding2) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer3.from(chunk, encoding2);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding2, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding2);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding2 = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding: encoding2,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding2, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding2, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          import_process.default.nextTick(cb, er);
          import_process.default.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished4 = needFinish(state) || stream.destroyed;
          if (!finished4 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            import_process.default.nextTick(afterWrite, stream, state, finished4, cb);
          } else {
            afterWrite(stream, state, finished4, cb);
          }
        }
      }
      function afterWrite(stream, state, finished4, cb) {
        if (!finished4)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding2 = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding2, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding2, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding2 = null;
        } else if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding2);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            import_process.default.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            import_process.default.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex7 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var Readable5 = require_stream_readable7();
      var Writable = require_stream_writable7();
      require_inherits_browser()(Duplex, Readable5);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable5.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended)
          return;
        import_process.default.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream6 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser6().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once2(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator6 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_shim();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished4 = require_end_of_stream6();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        import_process.default.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              import_process.default.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished4(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser6 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_shim();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable7 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Readable5;
      var Duplex;
      Readable5.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser7();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list6();
      var destroyImpl = require_destroy7();
      var _require = require_state6();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser6().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable5, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex7();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder2().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable5(options) {
        Duplex = Duplex || require_stream_duplex7();
        if (!(this instanceof Readable5))
          return new Readable5(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable5.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable5.prototype.destroy = destroyImpl.destroy;
      Readable5.prototype._undestroy = destroyImpl.undestroy;
      Readable5.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable5.prototype.push = function(chunk, encoding2) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding2 = encoding2 || state.defaultEncoding;
            if (encoding2 !== state.encoding) {
              chunk = Buffer3.from(chunk, encoding2);
              encoding2 = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
      };
      Readable5.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding2) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable5.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable5.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable5.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          import_process.default.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          import_process.default.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable5.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable5.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          import_process.default.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable5.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable5.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              import_process.default.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable5.prototype.addListener = Readable5.prototype.on;
      Readable5.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable5.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable5.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          import_process.default.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable5.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable5.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable5.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator6();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable5.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableBuffer", {
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableFlowing", {
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable5._fromList = fromList;
      Object.defineProperty(Readable5.prototype, "readableLength", {
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          import_process.default.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable5.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser6();
          }
          return from(Readable5, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform7 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform;
      var _require$codes = require_errors_browser6().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex7();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding2) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding2);
      };
      Transform.prototype._transform = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding2, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding2;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough7 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough;
      var Transform = require_stream_transform7();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding2, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline6 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_shim();
      var eos;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser6().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once2(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream6();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/readable-browser.js
  var require_readable_browser6 = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_shim();
      exports = module.exports = require_stream_readable7();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable7();
      exports.Duplex = require_stream_duplex7();
      exports.Transform = require_stream_transform7();
      exports.PassThrough = require_stream_passthrough7();
      exports.finished = require_end_of_stream6();
      exports.pipeline = require_pipeline6();
    }
  });

  // node_modules/@rdfjs/parser-jsonld/lib/ParserStream.js
  var require_ParserStream = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/lib/ParserStream.js"(exports, module) {
      init_shim();
      var rdf = require_data_model();
      var { JsonLdParser } = require_jsonld_streaming_parser();
      var { Transform } = require_readable_browser6();
      var relativeIriProtocol = "null:";
      function termCleanup(factory3) {
        return (term) => {
          if (term.termType !== "NamedNode") {
            return null;
          }
          if (!term.value.startsWith(relativeIriProtocol)) {
            return null;
          }
          return factory3.namedNode(term.value.slice(relativeIriProtocol.length));
        };
      }
      function quadCleanup(factory3) {
        const cleanup = termCleanup(factory3);
        return (quad) => {
          const subject = cleanup(quad.subject);
          const predicate = cleanup(quad.predicate);
          const object = cleanup(quad.object);
          const graph2 = cleanup(quad.graph);
          if (subject || predicate || object || graph2) {
            return factory3.quad(subject || quad.subject, predicate || quad.predicate, object || quad.object, graph2 || quad.graph);
          }
          return quad;
        };
      }
      var ParserStream = class {
        constructor(input, { baseIRI = relativeIriProtocol, context = null, factory: factory3 = rdf } = {}) {
          const parser = new JsonLdParser({
            baseIRI,
            context,
            dataFactory: factory3,
            streamingProfile: false
          });
          input.pipe(parser);
          const cleanup = quadCleanup(factory3);
          const transform = new Transform({
            objectMode: true,
            transform: (quad, encoding2, callback) => {
              callback(null, cleanup(quad));
            }
          });
          parser.on("context", (context2) => {
            Object.entries(context2).forEach(([prefix, iri]) => {
              transform.emit("prefix", prefix, factory3.namedNode(iri));
            });
          });
          parser.on("error", (err) => transform.destroy(err));
          parser.pipe(transform);
          return transform;
        }
      };
      module.exports = ParserStream;
    }
  });

  // node_modules/@rdfjs/parser-jsonld/index.js
  var require_parser_jsonld = __commonJS({
    "node_modules/@rdfjs/parser-jsonld/index.js"(exports, module) {
      init_shim();
      var Sink = require_sink();
      var ParserStream = require_ParserStream();
      var Parser = class extends Sink {
        constructor(options) {
          super(ParserStream, options);
        }
      };
      module.exports = Parser;
    }
  });

  // node_modules/n3/lib/IRIs.js
  var require_IRIs = __commonJS({
    "node_modules/n3/lib/IRIs.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
      var XSD = "http://www.w3.org/2001/XMLSchema#";
      var SWAP = "http://www.w3.org/2000/10/swap/";
      var _default = {
        xsd: {
          decimal: `${XSD}decimal`,
          boolean: `${XSD}boolean`,
          double: `${XSD}double`,
          integer: `${XSD}integer`,
          string: `${XSD}string`
        },
        rdf: {
          type: `${RDF}type`,
          nil: `${RDF}nil`,
          first: `${RDF}first`,
          rest: `${RDF}rest`,
          langString: `${RDF}langString`
        },
        owl: {
          sameAs: "http://www.w3.org/2002/07/owl#sameAs"
        },
        r: {
          forSome: `${SWAP}reify#forSome`,
          forAll: `${SWAP}reify#forAll`
        },
        log: {
          implies: `${SWAP}log#implies`
        }
      };
      exports.default = _default;
    }
  });

  // node_modules/queue-microtask/index.js
  var require_queue_microtask = __commonJS({
    "node_modules/queue-microtask/index.js"(exports, module) {
      init_shim();
      var promise;
      module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : _global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
        throw err;
      }, 0));
    }
  });

  // node_modules/n3/lib/N3Lexer.js
  var require_N3Lexer = __commonJS({
    "node_modules/n3/lib/N3Lexer.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _IRIs = _interopRequireDefault(require_IRIs());
      var _queueMicrotask = _interopRequireDefault(require_queue_microtask());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var {
        xsd
      } = _IRIs.default;
      var escapeSequence = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g;
      var escapeReplacements = {
        "\\": "\\",
        "'": "'",
        '"': '"',
        "n": "\n",
        "r": "\r",
        "t": "	",
        "f": "\f",
        "b": "\b",
        "_": "_",
        "~": "~",
        ".": ".",
        "-": "-",
        "!": "!",
        "$": "$",
        "&": "&",
        "(": "(",
        ")": ")",
        "*": "*",
        "+": "+",
        ",": ",",
        ";": ";",
        "=": "=",
        "/": "/",
        "?": "?",
        "#": "#",
        "@": "@",
        "%": "%"
      };
      var illegalIriChars = /[\x00-\x20<>\\"\{\}\|\^\`]/;
      var lineModeRegExps = {
        _iri: true,
        _unescapedIri: true,
        _simpleQuotedString: true,
        _langcode: true,
        _blank: true,
        _newline: true,
        _comment: true,
        _whitespace: true,
        _endOfFile: true
      };
      var invalidRegExp = /$0^/;
      var N3Lexer = class {
        constructor(options) {
          this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/;
          this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/;
          this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/;
          this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/;
          this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i;
          this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/;
          this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/;
          this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/;
          this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/;
          this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/;
          this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/;
          this._keyword = /^@[a-z]+(?=[\s#<:])/i;
          this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i;
          this._shortPredicates = /^a(?=[\s#()\[\]\{\}"'<>])/;
          this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/;
          this._comment = /#([^\n\r]*)/;
          this._whitespace = /^[ \t]+/;
          this._endOfFile = /^(?:#[^\n\r]*)?$/;
          options = options || {};
          if (this._lineMode = !!options.lineMode) {
            this._n3Mode = false;
            for (const key in this) {
              if (!(key in lineModeRegExps) && this[key] instanceof RegExp)
                this[key] = invalidRegExp;
            }
          } else {
            this._n3Mode = options.n3 !== false;
          }
          this._comments = !!options.comments;
          this._literalClosingPos = 0;
        }
        _tokenizeToEnd(callback, inputFinished) {
          let input = this._input;
          let currentLineLength = input.length;
          while (true) {
            let whiteSpaceMatch, comment;
            while (whiteSpaceMatch = this._newline.exec(input)) {
              if (this._comments && (comment = this._comment.exec(whiteSpaceMatch[0])))
                emitToken("comment", comment[1], "", this._line, whiteSpaceMatch[0].length);
              input = input.substr(whiteSpaceMatch[0].length, input.length);
              currentLineLength = input.length;
              this._line++;
            }
            if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input)))
              input = input.substr(whiteSpaceMatch[0].length, input.length);
            if (this._endOfFile.test(input)) {
              if (inputFinished) {
                if (this._comments && (comment = this._comment.exec(input)))
                  emitToken("comment", comment[1], "", this._line, input.length);
                input = null;
                emitToken("eof", "", "", this._line, 0);
              }
              return this._input = input;
            }
            const line = this._line, firstChar = input[0];
            let type = "", value = "", prefix = "", match = null, matchLength = 0, inconclusive = false;
            switch (firstChar) {
              case "^":
                if (input.length < 3)
                  break;
                else if (input[1] === "^") {
                  this._previousMarker = "^^";
                  input = input.substr(2);
                  if (input[0] !== "<") {
                    inconclusive = true;
                    break;
                  }
                } else {
                  if (this._n3Mode) {
                    matchLength = 1;
                    type = "^";
                  }
                  break;
                }
              case "<":
                if (match = this._unescapedIri.exec(input))
                  type = "IRI", value = match[1];
                else if (match = this._iri.exec(input)) {
                  value = this._unescape(match[1]);
                  if (value === null || illegalIriChars.test(value))
                    return reportSyntaxError(this);
                  type = "IRI";
                } else if (input.length > 1 && input[1] === "<")
                  type = "<<", matchLength = 2;
                else if (this._n3Mode && input.length > 1 && input[1] === "=")
                  type = "inverse", matchLength = 2, value = ">";
                break;
              case ">":
                if (input.length > 1 && input[1] === ">")
                  type = ">>", matchLength = 2;
                break;
              case "_":
                if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(`${input} `)))
                  type = "blank", prefix = "_", value = match[1];
                break;
              case '"':
                if (match = this._simpleQuotedString.exec(input))
                  value = match[1];
                else {
                  ({
                    value,
                    matchLength
                  } = this._parseLiteral(input));
                  if (value === null)
                    return reportSyntaxError(this);
                }
                if (match !== null || matchLength !== 0) {
                  type = "literal";
                  this._literalClosingPos = 0;
                }
                break;
              case "'":
                if (!this._lineMode) {
                  if (match = this._simpleApostropheString.exec(input))
                    value = match[1];
                  else {
                    ({
                      value,
                      matchLength
                    } = this._parseLiteral(input));
                    if (value === null)
                      return reportSyntaxError(this);
                  }
                  if (match !== null || matchLength !== 0) {
                    type = "literal";
                    this._literalClosingPos = 0;
                  }
                }
                break;
              case "?":
                if (this._n3Mode && (match = this._variable.exec(input)))
                  type = "var", value = match[0];
                break;
              case "@":
                if (this._previousMarker === "literal" && (match = this._langcode.exec(input)))
                  type = "langcode", value = match[1];
                else if (match = this._keyword.exec(input))
                  type = match[0];
                break;
              case ".":
                if (input.length === 1 ? inputFinished : input[1] < "0" || input[1] > "9") {
                  type = ".";
                  matchLength = 1;
                  break;
                }
              case "0":
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
              case "+":
              case "-":
                if (match = this._number.exec(input) || inputFinished && (match = this._number.exec(`${input} `))) {
                  type = "literal", value = match[0];
                  prefix = typeof match[1] === "string" ? xsd.double : typeof match[2] === "string" ? xsd.decimal : xsd.integer;
                }
                break;
              case "B":
              case "b":
              case "p":
              case "P":
              case "G":
              case "g":
                if (match = this._sparqlKeyword.exec(input))
                  type = match[0].toUpperCase();
                else
                  inconclusive = true;
                break;
              case "f":
              case "t":
                if (match = this._boolean.exec(input))
                  type = "literal", value = match[0], prefix = xsd.boolean;
                else
                  inconclusive = true;
                break;
              case "a":
                if (match = this._shortPredicates.exec(input))
                  type = "abbreviation", value = "a";
                else
                  inconclusive = true;
                break;
              case "=":
                if (this._n3Mode && input.length > 1) {
                  type = "abbreviation";
                  if (input[1] !== ">")
                    matchLength = 1, value = "=";
                  else
                    matchLength = 2, value = ">";
                }
                break;
              case "!":
                if (!this._n3Mode)
                  break;
              case ",":
              case ";":
              case "[":
              case "]":
              case "(":
              case ")":
              case "{":
              case "}":
                if (!this._lineMode) {
                  matchLength = 1;
                  type = firstChar;
                }
                break;
              default:
                inconclusive = true;
            }
            if (inconclusive) {
              if ((this._previousMarker === "@prefix" || this._previousMarker === "PREFIX") && (match = this._prefix.exec(input)))
                type = "prefix", value = match[1] || "";
              else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(`${input} `)))
                type = "prefixed", prefix = match[1] || "", value = this._unescape(match[2]);
            }
            if (this._previousMarker === "^^") {
              switch (type) {
                case "prefixed":
                  type = "type";
                  break;
                case "IRI":
                  type = "typeIRI";
                  break;
                default:
                  type = "";
              }
            }
            if (!type) {
              if (inputFinished || !/^'''|^"""/.test(input) && /\n|\r/.test(input))
                return reportSyntaxError(this);
              else
                return this._input = input;
            }
            const length = matchLength || match[0].length;
            const token = emitToken(type, value, prefix, line, length);
            this.previousToken = token;
            this._previousMarker = type;
            input = input.substr(length, input.length);
          }
          function emitToken(type, value, prefix, line, length) {
            const start = input ? currentLineLength - input.length : currentLineLength;
            const end = start + length;
            const token = {
              type,
              value,
              prefix,
              line,
              start,
              end
            };
            callback(null, token);
            return token;
          }
          function reportSyntaxError(self2) {
            callback(self2._syntaxError(/^\S*/.exec(input)[0]));
          }
        }
        _unescape(item) {
          let invalid = false;
          const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {
            if (typeof unicode4 === "string")
              return String.fromCharCode(Number.parseInt(unicode4, 16));
            if (typeof unicode8 === "string") {
              let charCode = Number.parseInt(unicode8, 16);
              return charCode <= 65535 ? String.fromCharCode(Number.parseInt(unicode8, 16)) : String.fromCharCode(55296 + ((charCode -= 65536) >> 10), 56320 + (charCode & 1023));
            }
            if (escapedChar in escapeReplacements)
              return escapeReplacements[escapedChar];
            invalid = true;
            return "";
          });
          return invalid ? null : replaced;
        }
        _parseLiteral(input) {
          if (input.length >= 3) {
            const opening = input.match(/^(?:"""|"|'''|'|)/)[0];
            const openingLength = opening.length;
            let closingPos = Math.max(this._literalClosingPos, openingLength);
            while ((closingPos = input.indexOf(opening, closingPos)) > 0) {
              let backslashCount = 0;
              while (input[closingPos - backslashCount - 1] === "\\")
                backslashCount++;
              if (backslashCount % 2 === 0) {
                const raw = input.substring(openingLength, closingPos);
                const lines = raw.split(/\r\n|\r|\n/).length - 1;
                const matchLength = closingPos + openingLength;
                if (openingLength === 1 && lines !== 0 || openingLength === 3 && this._lineMode)
                  break;
                this._line += lines;
                return {
                  value: this._unescape(raw),
                  matchLength
                };
              }
              closingPos++;
            }
            this._literalClosingPos = input.length - openingLength + 1;
          }
          return {
            value: "",
            matchLength: 0
          };
        }
        _syntaxError(issue) {
          this._input = null;
          const err = new Error(`Unexpected "${issue}" on line ${this._line}.`);
          err.context = {
            token: void 0,
            line: this._line,
            previousToken: this.previousToken
          };
          return err;
        }
        _readStartingBom(input) {
          return input.startsWith("\uFEFF") ? input.substr(1) : input;
        }
        tokenize(input, callback) {
          this._line = 1;
          if (typeof input === "string") {
            this._input = this._readStartingBom(input);
            if (typeof callback === "function")
              (0, _queueMicrotask.default)(() => this._tokenizeToEnd(callback, true));
            else {
              const tokens = [];
              let error;
              this._tokenizeToEnd((e, t) => e ? error = e : tokens.push(t), true);
              if (error)
                throw error;
              return tokens;
            }
          } else {
            this._pendingBuffer = null;
            if (typeof input.setEncoding === "function")
              input.setEncoding("utf8");
            input.on("data", (data) => {
              if (this._input !== null && data.length !== 0) {
                if (this._pendingBuffer) {
                  data = import_buffer.Buffer.concat([this._pendingBuffer, data]);
                  this._pendingBuffer = null;
                }
                if (data[data.length - 1] & 128) {
                  this._pendingBuffer = data;
                } else {
                  if (typeof this._input === "undefined")
                    this._input = this._readStartingBom(typeof data === "string" ? data : data.toString());
                  else
                    this._input += data;
                  this._tokenizeToEnd(callback, false);
                }
              }
            });
            input.on("end", () => {
              if (typeof this._input === "string")
                this._tokenizeToEnd(callback, true);
            });
            input.on("error", callback);
          }
        }
      };
      exports.default = N3Lexer;
    }
  });

  // node_modules/n3/lib/N3Util.js
  var require_N3Util = __commonJS({
    "node_modules/n3/lib/N3Util.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.inDefaultGraph = inDefaultGraph;
      exports.isBlankNode = isBlankNode;
      exports.isDefaultGraph = isDefaultGraph;
      exports.isLiteral = isLiteral;
      exports.isNamedNode = isNamedNode;
      exports.isVariable = isVariable;
      exports.prefix = prefix;
      exports.prefixes = prefixes;
      var _N3DataFactory = _interopRequireDefault(require_N3DataFactory());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isNamedNode(term) {
        return !!term && term.termType === "NamedNode";
      }
      function isBlankNode(term) {
        return !!term && term.termType === "BlankNode";
      }
      function isLiteral(term) {
        return !!term && term.termType === "Literal";
      }
      function isVariable(term) {
        return !!term && term.termType === "Variable";
      }
      function isDefaultGraph(term) {
        return !!term && term.termType === "DefaultGraph";
      }
      function inDefaultGraph(quad) {
        return isDefaultGraph(quad.graph);
      }
      function prefix(iri, factory3) {
        return prefixes({
          "": iri.value || iri
        }, factory3)("");
      }
      function prefixes(defaultPrefixes, factory3) {
        const prefixes2 = /* @__PURE__ */ Object.create(null);
        for (const prefix2 in defaultPrefixes)
          processPrefix(prefix2, defaultPrefixes[prefix2]);
        factory3 = factory3 || _N3DataFactory.default;
        function processPrefix(prefix2, iri) {
          if (typeof iri === "string") {
            const cache = /* @__PURE__ */ Object.create(null);
            prefixes2[prefix2] = (local) => {
              return cache[local] || (cache[local] = factory3.namedNode(iri + local));
            };
          } else if (!(prefix2 in prefixes2)) {
            throw new Error(`Unknown prefix: ${prefix2}`);
          }
          return prefixes2[prefix2];
        }
        return processPrefix;
      }
    }
  });

  // node_modules/n3/lib/N3DataFactory.js
  var require_N3DataFactory = __commonJS({
    "node_modules/n3/lib/N3DataFactory.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = exports.Variable = exports.Triple = exports.Term = exports.Quad = exports.NamedNode = exports.Literal = exports.DefaultGraph = exports.BlankNode = void 0;
      exports.escapeQuotes = escapeQuotes2;
      exports.termFromId = termFromId;
      exports.termToId = termToId2;
      exports.unescapeQuotes = unescapeQuotes;
      var _IRIs = _interopRequireDefault(require_IRIs());
      var _N3Util = require_N3Util();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var {
        rdf,
        xsd
      } = _IRIs.default;
      var DEFAULTGRAPH;
      var _blankNodeCounter = 0;
      var escapedLiteral2 = /^"(.*".*)(?="[^"]*$)/;
      var quadId = /^<<("(?:""|[^"])*"[^ ]*|[^ ]+) ("(?:""|[^"])*"[^ ]*|[^ ]+) ("(?:""|[^"])*"[^ ]*|[^ ]+) ?("(?:""|[^"])*"[^ ]*|[^ ]+)?>>$/;
      var DataFactory3 = {
        namedNode,
        blankNode,
        variable,
        literal,
        defaultGraph,
        quad,
        triple: quad
      };
      var _default = DataFactory3;
      exports.default = _default;
      var Term = class {
        constructor(id) {
          this.id = id;
        }
        get value() {
          return this.id;
        }
        equals(other) {
          if (other instanceof Term)
            return this.id === other.id;
          return !!other && this.termType === other.termType && this.value === other.value;
        }
        hashCode() {
          return 0;
        }
        toJSON() {
          return {
            termType: this.termType,
            value: this.value
          };
        }
      };
      exports.Term = Term;
      var NamedNode3 = class extends Term {
        get termType() {
          return "NamedNode";
        }
      };
      exports.NamedNode = NamedNode3;
      var Literal3 = class extends Term {
        get termType() {
          return "Literal";
        }
        get value() {
          return this.id.substring(1, this.id.lastIndexOf('"'));
        }
        get language() {
          const id = this.id;
          let atPos = id.lastIndexOf('"') + 1;
          return atPos < id.length && id[atPos++] === "@" ? id.substr(atPos).toLowerCase() : "";
        }
        get datatype() {
          return new NamedNode3(this.datatypeString);
        }
        get datatypeString() {
          const id = this.id, dtPos = id.lastIndexOf('"') + 1;
          const char = dtPos < id.length ? id[dtPos] : "";
          return char === "^" ? id.substr(dtPos + 2) : char !== "@" ? xsd.string : rdf.langString;
        }
        equals(other) {
          if (other instanceof Literal3)
            return this.id === other.id;
          return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;
        }
        toJSON() {
          return {
            termType: this.termType,
            value: this.value,
            language: this.language,
            datatype: {
              termType: "NamedNode",
              value: this.datatypeString
            }
          };
        }
      };
      exports.Literal = Literal3;
      var BlankNode3 = class extends Term {
        constructor(name) {
          super(`_:${name}`);
        }
        get termType() {
          return "BlankNode";
        }
        get value() {
          return this.id.substr(2);
        }
      };
      exports.BlankNode = BlankNode3;
      var Variable3 = class extends Term {
        constructor(name) {
          super(`?${name}`);
        }
        get termType() {
          return "Variable";
        }
        get value() {
          return this.id.substr(1);
        }
      };
      exports.Variable = Variable3;
      var DefaultGraph3 = class extends Term {
        constructor() {
          super("");
          return DEFAULTGRAPH || this;
        }
        get termType() {
          return "DefaultGraph";
        }
        equals(other) {
          return this === other || !!other && this.termType === other.termType;
        }
      };
      exports.DefaultGraph = DefaultGraph3;
      DEFAULTGRAPH = new DefaultGraph3();
      function termFromId(id, factory3) {
        factory3 = factory3 || DataFactory3;
        if (!id)
          return factory3.defaultGraph();
        switch (id[0]) {
          case "?":
            return factory3.variable(id.substr(1));
          case "_":
            return factory3.blankNode(id.substr(2));
          case '"':
            if (factory3 === DataFactory3)
              return new Literal3(id);
            if (id[id.length - 1] === '"')
              return factory3.literal(id.substr(1, id.length - 2));
            const endPos = id.lastIndexOf('"', id.length - 1);
            return factory3.literal(id.substr(1, endPos - 1), id[endPos + 1] === "@" ? id.substr(endPos + 2) : factory3.namedNode(id.substr(endPos + 3)));
          case "<":
            const components2 = quadId.exec(id);
            return factory3.quad(termFromId(unescapeQuotes(components2[1]), factory3), termFromId(unescapeQuotes(components2[2]), factory3), termFromId(unescapeQuotes(components2[3]), factory3), components2[4] && termFromId(unescapeQuotes(components2[4]), factory3));
          default:
            return factory3.namedNode(id);
        }
      }
      function termToId2(term) {
        if (typeof term === "string")
          return term;
        if (term instanceof Term && term.termType !== "Quad")
          return term.id;
        if (!term)
          return DEFAULTGRAPH.id;
        switch (term.termType) {
          case "NamedNode":
            return term.value;
          case "BlankNode":
            return `_:${term.value}`;
          case "Variable":
            return `?${term.value}`;
          case "DefaultGraph":
            return "";
          case "Literal":
            return `"${term.value}"${term.language ? `@${term.language}` : term.datatype && term.datatype.value !== xsd.string ? `^^${term.datatype.value}` : ""}`;
          case "Quad":
            return `<<${escapeQuotes2(termToId2(term.subject))} ${escapeQuotes2(termToId2(term.predicate))} ${escapeQuotes2(termToId2(term.object))}${(0, _N3Util.isDefaultGraph)(term.graph) ? "" : ` ${termToId2(term.graph)}`}>>`;
          default:
            throw new Error(`Unexpected termType: ${term.termType}`);
        }
      }
      var Quad3 = class extends Term {
        constructor(subject, predicate, object, graph2) {
          super("");
          this._subject = subject;
          this._predicate = predicate;
          this._object = object;
          this._graph = graph2 || DEFAULTGRAPH;
        }
        get termType() {
          return "Quad";
        }
        get subject() {
          return this._subject;
        }
        get predicate() {
          return this._predicate;
        }
        get object() {
          return this._object;
        }
        get graph() {
          return this._graph;
        }
        toJSON() {
          return {
            termType: this.termType,
            subject: this._subject.toJSON(),
            predicate: this._predicate.toJSON(),
            object: this._object.toJSON(),
            graph: this._graph.toJSON()
          };
        }
        equals(other) {
          return !!other && this._subject.equals(other.subject) && this._predicate.equals(other.predicate) && this._object.equals(other.object) && this._graph.equals(other.graph);
        }
      };
      exports.Triple = exports.Quad = Quad3;
      function escapeQuotes2(id) {
        return id.replace(escapedLiteral2, (_, quoted) => `"${quoted.replace(/"/g, '""')}`);
      }
      function unescapeQuotes(id) {
        return id.replace(escapedLiteral2, (_, quoted) => `"${quoted.replace(/""/g, '"')}`);
      }
      function namedNode(iri) {
        return new NamedNode3(iri);
      }
      function blankNode(name) {
        return new BlankNode3(name || `n3-${_blankNodeCounter++}`);
      }
      function literal(value, languageOrDataType) {
        if (typeof languageOrDataType === "string")
          return new Literal3(`"${value}"@${languageOrDataType.toLowerCase()}`);
        let datatype = languageOrDataType ? languageOrDataType.value : "";
        if (datatype === "") {
          if (typeof value === "boolean")
            datatype = xsd.boolean;
          else if (typeof value === "number") {
            if (Number.isFinite(value))
              datatype = Number.isInteger(value) ? xsd.integer : xsd.double;
            else {
              datatype = xsd.double;
              if (!Number.isNaN(value))
                value = value > 0 ? "INF" : "-INF";
            }
          }
        }
        return datatype === "" || datatype === xsd.string ? new Literal3(`"${value}"`) : new Literal3(`"${value}"^^${datatype}`);
      }
      function variable(name) {
        return new Variable3(name);
      }
      function defaultGraph() {
        return DEFAULTGRAPH;
      }
      function quad(subject, predicate, object, graph2) {
        return new Quad3(subject, predicate, object, graph2);
      }
    }
  });

  // node_modules/n3/lib/N3Parser.js
  var require_N3Parser = __commonJS({
    "node_modules/n3/lib/N3Parser.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _N3Lexer = _interopRequireDefault(require_N3Lexer());
      var _N3DataFactory = _interopRequireDefault(require_N3DataFactory());
      var _IRIs = _interopRequireDefault(require_IRIs());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var blankNodePrefix = 0;
      var N3Parser = class {
        constructor(options) {
          this._contextStack = [];
          this._graph = null;
          options = options || {};
          this._setBase(options.baseIRI);
          options.factory && initDataFactory(this, options.factory);
          const format = typeof options.format === "string" ? options.format.match(/\w*$/)[0].toLowerCase() : "", isTurtle = /turtle/.test(format), isTriG = /trig/.test(format), isNTriples = /triple/.test(format), isNQuads = /quad/.test(format), isN3 = this._n3Mode = /n3/.test(format), isLineMode = isNTriples || isNQuads;
          if (!(this._supportsNamedGraphs = !(isTurtle || isN3)))
            this._readPredicateOrNamedGraph = this._readPredicate;
          this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);
          this._supportsRDFStar = format === "" || /star|\*$/.test(format);
          if (isLineMode)
            this._resolveRelativeIRI = (iri) => {
              return null;
            };
          this._blankNodePrefix = typeof options.blankNodePrefix !== "string" ? "" : options.blankNodePrefix.replace(/^(?!_:)/, "_:");
          this._lexer = options.lexer || new _N3Lexer.default({
            lineMode: isLineMode,
            n3: isN3
          });
          this._explicitQuantifiers = !!options.explicitQuantifiers;
        }
        static _resetBlankNodePrefix() {
          blankNodePrefix = 0;
        }
        _setBase(baseIRI) {
          if (!baseIRI) {
            this._base = "";
            this._basePath = "";
          } else {
            const fragmentPos = baseIRI.indexOf("#");
            if (fragmentPos >= 0)
              baseIRI = baseIRI.substr(0, fragmentPos);
            this._base = baseIRI;
            this._basePath = baseIRI.indexOf("/") < 0 ? baseIRI : baseIRI.replace(/[^\/?]*(?:\?.*)?$/, "");
            baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i);
            this._baseRoot = baseIRI[0];
            this._baseScheme = baseIRI[1];
          }
        }
        _saveContext(type, graph2, subject, predicate, object) {
          const n3Mode = this._n3Mode;
          this._contextStack.push({
            type,
            subject,
            predicate,
            object,
            graph: graph2,
            inverse: n3Mode ? this._inversePredicate : false,
            blankPrefix: n3Mode ? this._prefixes._ : "",
            quantified: n3Mode ? this._quantified : null
          });
          if (n3Mode) {
            this._inversePredicate = false;
            this._prefixes._ = this._graph ? `${this._graph.id.substr(2)}.` : ".";
            this._quantified = Object.create(this._quantified);
          }
        }
        _restoreContext(type, token) {
          const context = this._contextStack.pop();
          if (!context || context.type !== type)
            return this._error(`Unexpected ${token.type}`, token);
          this._subject = context.subject;
          this._predicate = context.predicate;
          this._object = context.object;
          this._graph = context.graph;
          if (this._n3Mode) {
            this._inversePredicate = context.inverse;
            this._prefixes._ = context.blankPrefix;
            this._quantified = context.quantified;
          }
        }
        _readInTopContext(token) {
          switch (token.type) {
            case "eof":
              if (this._graph !== null)
                return this._error("Unclosed graph", token);
              delete this._prefixes._;
              return this._callback(null, null, this._prefixes);
            case "PREFIX":
              this._sparqlStyle = true;
            case "@prefix":
              return this._readPrefix;
            case "BASE":
              this._sparqlStyle = true;
            case "@base":
              return this._readBaseIRI;
            case "{":
              if (this._supportsNamedGraphs) {
                this._graph = "";
                this._subject = null;
                return this._readSubject;
              }
            case "GRAPH":
              if (this._supportsNamedGraphs)
                return this._readNamedGraphLabel;
            default:
              return this._readSubject(token);
          }
        }
        _readEntity(token, quantifier) {
          let value;
          switch (token.type) {
            case "IRI":
            case "typeIRI":
              const iri = this._resolveIRI(token.value);
              if (iri === null)
                return this._error("Invalid IRI", token);
              value = this._namedNode(iri);
              break;
            case "type":
            case "prefixed":
              const prefix = this._prefixes[token.prefix];
              if (prefix === void 0)
                return this._error(`Undefined prefix "${token.prefix}:"`, token);
              value = this._namedNode(prefix + token.value);
              break;
            case "blank":
              value = this._blankNode(this._prefixes[token.prefix] + token.value);
              break;
            case "var":
              value = this._variable(token.value.substr(1));
              break;
            default:
              return this._error(`Expected entity but got ${token.type}`, token);
          }
          if (!quantifier && this._n3Mode && value.id in this._quantified)
            value = this._quantified[value.id];
          return value;
        }
        _readSubject(token) {
          this._predicate = null;
          switch (token.type) {
            case "[":
              this._saveContext("blank", this._graph, this._subject = this._blankNode(), null, null);
              return this._readBlankNodeHead;
            case "(":
              this._saveContext("list", this._graph, this.RDF_NIL, null, null);
              this._subject = null;
              return this._readListItem;
            case "{":
              if (!this._n3Mode)
                return this._error("Unexpected graph", token);
              this._saveContext("formula", this._graph, this._graph = this._blankNode(), null, null);
              return this._readSubject;
            case "}":
              return this._readPunctuation(token);
            case "@forSome":
              if (!this._n3Mode)
                return this._error('Unexpected "@forSome"', token);
              this._subject = null;
              this._predicate = this.N3_FORSOME;
              this._quantifier = this._blankNode;
              return this._readQuantifierList;
            case "@forAll":
              if (!this._n3Mode)
                return this._error('Unexpected "@forAll"', token);
              this._subject = null;
              this._predicate = this.N3_FORALL;
              this._quantifier = this._variable;
              return this._readQuantifierList;
            case "literal":
              if (!this._n3Mode)
                return this._error("Unexpected literal", token);
              if (token.prefix.length === 0) {
                this._literalValue = token.value;
                return this._completeSubjectLiteral;
              } else
                this._subject = this._literal(token.value, this._namedNode(token.prefix));
              break;
            case "<<":
              if (!this._supportsRDFStar)
                return this._error("Unexpected RDF* syntax", token);
              this._saveContext("<<", this._graph, null, null, null);
              this._graph = null;
              return this._readSubject;
            default:
              if ((this._subject = this._readEntity(token)) === void 0)
                return;
              if (this._n3Mode)
                return this._getPathReader(this._readPredicateOrNamedGraph);
          }
          return this._readPredicateOrNamedGraph;
        }
        _readPredicate(token) {
          const type = token.type;
          switch (type) {
            case "inverse":
              this._inversePredicate = true;
            case "abbreviation":
              this._predicate = this.ABBREVIATIONS[token.value];
              break;
            case ".":
            case "]":
            case "}":
              if (this._predicate === null)
                return this._error(`Unexpected ${type}`, token);
              this._subject = null;
              return type === "]" ? this._readBlankNodeTail(token) : this._readPunctuation(token);
            case ";":
              return this._predicate !== null ? this._readPredicate : this._error("Expected predicate but got ;", token);
            case "[":
              if (this._n3Mode) {
                this._saveContext("blank", this._graph, this._subject, this._subject = this._blankNode(), null);
                return this._readBlankNodeHead;
              }
            case "blank":
              if (!this._n3Mode)
                return this._error("Disallowed blank node as predicate", token);
            default:
              if ((this._predicate = this._readEntity(token)) === void 0)
                return;
          }
          return this._readObject;
        }
        _readObject(token) {
          switch (token.type) {
            case "literal":
              if (token.prefix.length === 0) {
                this._literalValue = token.value;
                return this._readDataTypeOrLang;
              } else
                this._object = this._literal(token.value, this._namedNode(token.prefix));
              break;
            case "[":
              this._saveContext("blank", this._graph, this._subject, this._predicate, this._subject = this._blankNode());
              return this._readBlankNodeHead;
            case "(":
              this._saveContext("list", this._graph, this._subject, this._predicate, this.RDF_NIL);
              this._subject = null;
              return this._readListItem;
            case "{":
              if (!this._n3Mode)
                return this._error("Unexpected graph", token);
              this._saveContext("formula", this._graph, this._subject, this._predicate, this._graph = this._blankNode());
              return this._readSubject;
            case "<<":
              if (!this._supportsRDFStar)
                return this._error("Unexpected RDF* syntax", token);
              this._saveContext("<<", this._graph, this._subject, this._predicate, null);
              this._graph = null;
              return this._readSubject;
            default:
              if ((this._object = this._readEntity(token)) === void 0)
                return;
              if (this._n3Mode)
                return this._getPathReader(this._getContextEndReader());
          }
          return this._getContextEndReader();
        }
        _readPredicateOrNamedGraph(token) {
          return token.type === "{" ? this._readGraph(token) : this._readPredicate(token);
        }
        _readGraph(token) {
          if (token.type !== "{")
            return this._error(`Expected graph but got ${token.type}`, token);
          this._graph = this._subject, this._subject = null;
          return this._readSubject;
        }
        _readBlankNodeHead(token) {
          if (token.type === "]") {
            this._subject = null;
            return this._readBlankNodeTail(token);
          } else {
            this._predicate = null;
            return this._readPredicate(token);
          }
        }
        _readBlankNodeTail(token) {
          if (token.type !== "]")
            return this._readBlankNodePunctuation(token);
          if (this._subject !== null)
            this._emit(this._subject, this._predicate, this._object, this._graph);
          const empty = this._predicate === null;
          this._restoreContext("blank", token);
          if (this._object !== null)
            return this._getContextEndReader();
          else if (this._predicate !== null)
            return this._readObject;
          else
            return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;
        }
        _readPredicateAfterBlank(token) {
          switch (token.type) {
            case ".":
            case "}":
              this._subject = null;
              return this._readPunctuation(token);
            default:
              return this._readPredicate(token);
          }
        }
        _readListItem(token) {
          let item = null, list = null, next = this._readListItem;
          const previousList = this._subject, stack = this._contextStack, parent = stack[stack.length - 1];
          switch (token.type) {
            case "[":
              this._saveContext("blank", this._graph, list = this._blankNode(), this.RDF_FIRST, this._subject = item = this._blankNode());
              next = this._readBlankNodeHead;
              break;
            case "(":
              this._saveContext("list", this._graph, list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);
              this._subject = null;
              break;
            case ")":
              this._restoreContext("list", token);
              if (stack.length !== 0 && stack[stack.length - 1].type === "list")
                this._emit(this._subject, this._predicate, this._object, this._graph);
              if (this._predicate === null) {
                next = this._readPredicate;
                if (this._subject === this.RDF_NIL)
                  return next;
              } else {
                next = this._getContextEndReader();
                if (this._object === this.RDF_NIL)
                  return next;
              }
              list = this.RDF_NIL;
              break;
            case "literal":
              if (token.prefix.length === 0) {
                this._literalValue = token.value;
                next = this._readListItemDataTypeOrLang;
              } else {
                item = this._literal(token.value, this._namedNode(token.prefix));
                next = this._getContextEndReader();
              }
              break;
            case "{":
              if (!this._n3Mode)
                return this._error("Unexpected graph", token);
              this._saveContext("formula", this._graph, this._subject, this._predicate, this._graph = this._blankNode());
              return this._readSubject;
            default:
              if ((item = this._readEntity(token)) === void 0)
                return;
          }
          if (list === null)
            this._subject = list = this._blankNode();
          if (previousList === null) {
            if (parent.predicate === null)
              parent.subject = list;
            else
              parent.object = list;
          } else {
            this._emit(previousList, this.RDF_REST, list, this._graph);
          }
          if (item !== null) {
            if (this._n3Mode && (token.type === "IRI" || token.type === "prefixed")) {
              this._saveContext("item", this._graph, list, this.RDF_FIRST, item);
              this._subject = item, this._predicate = null;
              return this._getPathReader(this._readListItem);
            }
            this._emit(list, this.RDF_FIRST, item, this._graph);
          }
          return next;
        }
        _readDataTypeOrLang(token) {
          return this._completeObjectLiteral(token, false);
        }
        _readListItemDataTypeOrLang(token) {
          return this._completeObjectLiteral(token, true);
        }
        _completeLiteral(token) {
          let literal = this._literal(this._literalValue);
          switch (token.type) {
            case "type":
            case "typeIRI":
              const datatype = this._readEntity(token);
              if (datatype === void 0)
                return;
              literal = this._literal(this._literalValue, datatype);
              token = null;
              break;
            case "langcode":
              literal = this._literal(this._literalValue, token.value);
              token = null;
              break;
          }
          return {
            token,
            literal
          };
        }
        _completeSubjectLiteral(token) {
          this._subject = this._completeLiteral(token).literal;
          return this._readPredicateOrNamedGraph;
        }
        _completeObjectLiteral(token, listItem) {
          const completed = this._completeLiteral(token);
          if (!completed)
            return;
          this._object = completed.literal;
          if (listItem)
            this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);
          if (completed.token === null)
            return this._getContextEndReader();
          else {
            this._readCallback = this._getContextEndReader();
            return this._readCallback(completed.token);
          }
        }
        _readFormulaTail(token) {
          if (token.type !== "}")
            return this._readPunctuation(token);
          if (this._subject !== null)
            this._emit(this._subject, this._predicate, this._object, this._graph);
          this._restoreContext("formula", token);
          return this._object === null ? this._readPredicate : this._getContextEndReader();
        }
        _readPunctuation(token) {
          let next, graph2 = this._graph;
          const subject = this._subject, inversePredicate = this._inversePredicate;
          switch (token.type) {
            case "}":
              if (this._graph === null)
                return this._error("Unexpected graph closing", token);
              if (this._n3Mode)
                return this._readFormulaTail(token);
              this._graph = null;
            case ".":
              this._subject = null;
              next = this._contextStack.length ? this._readSubject : this._readInTopContext;
              if (inversePredicate)
                this._inversePredicate = false;
              break;
            case ";":
              next = this._readPredicate;
              break;
            case ",":
              next = this._readObject;
              break;
            default:
              if (this._supportsQuads && this._graph === null && (graph2 = this._readEntity(token)) !== void 0) {
                next = this._readQuadPunctuation;
                break;
              }
              return this._error(`Expected punctuation to follow "${this._object.id}"`, token);
          }
          if (subject !== null) {
            const predicate = this._predicate, object = this._object;
            if (!inversePredicate)
              this._emit(subject, predicate, object, graph2);
            else
              this._emit(object, predicate, subject, graph2);
          }
          return next;
        }
        _readBlankNodePunctuation(token) {
          let next;
          switch (token.type) {
            case ";":
              next = this._readPredicate;
              break;
            case ",":
              next = this._readObject;
              break;
            default:
              return this._error(`Expected punctuation to follow "${this._object.id}"`, token);
          }
          this._emit(this._subject, this._predicate, this._object, this._graph);
          return next;
        }
        _readQuadPunctuation(token) {
          if (token.type !== ".")
            return this._error("Expected dot to follow quad", token);
          return this._readInTopContext;
        }
        _readPrefix(token) {
          if (token.type !== "prefix")
            return this._error("Expected prefix to follow @prefix", token);
          this._prefix = token.value;
          return this._readPrefixIRI;
        }
        _readPrefixIRI(token) {
          if (token.type !== "IRI")
            return this._error(`Expected IRI to follow prefix "${this._prefix}:"`, token);
          const prefixNode = this._readEntity(token);
          this._prefixes[this._prefix] = prefixNode.value;
          this._prefixCallback(this._prefix, prefixNode);
          return this._readDeclarationPunctuation;
        }
        _readBaseIRI(token) {
          const iri = token.type === "IRI" && this._resolveIRI(token.value);
          if (!iri)
            return this._error("Expected valid IRI to follow base declaration", token);
          this._setBase(iri);
          return this._readDeclarationPunctuation;
        }
        _readNamedGraphLabel(token) {
          switch (token.type) {
            case "IRI":
            case "blank":
            case "prefixed":
              return this._readSubject(token), this._readGraph;
            case "[":
              return this._readNamedGraphBlankLabel;
            default:
              return this._error("Invalid graph label", token);
          }
        }
        _readNamedGraphBlankLabel(token) {
          if (token.type !== "]")
            return this._error("Invalid graph label", token);
          this._subject = this._blankNode();
          return this._readGraph;
        }
        _readDeclarationPunctuation(token) {
          if (this._sparqlStyle) {
            this._sparqlStyle = false;
            return this._readInTopContext(token);
          }
          if (token.type !== ".")
            return this._error("Expected declaration to end with a dot", token);
          return this._readInTopContext;
        }
        _readQuantifierList(token) {
          let entity;
          switch (token.type) {
            case "IRI":
            case "prefixed":
              if ((entity = this._readEntity(token, true)) !== void 0)
                break;
            default:
              return this._error(`Unexpected ${token.type}`, token);
          }
          if (!this._explicitQuantifiers)
            this._quantified[entity.id] = this._quantifier(this._blankNode().value);
          else {
            if (this._subject === null)
              this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);
            else
              this._emit(this._subject, this.RDF_REST, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);
            this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);
          }
          return this._readQuantifierPunctuation;
        }
        _readQuantifierPunctuation(token) {
          if (token.type === ",")
            return this._readQuantifierList;
          else {
            if (this._explicitQuantifiers) {
              this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);
              this._subject = null;
            }
            this._readCallback = this._getContextEndReader();
            return this._readCallback(token);
          }
        }
        _getPathReader(afterPath) {
          this._afterPath = afterPath;
          return this._readPath;
        }
        _readPath(token) {
          switch (token.type) {
            case "!":
              return this._readForwardPath;
            case "^":
              return this._readBackwardPath;
            default:
              const stack = this._contextStack, parent = stack.length && stack[stack.length - 1];
              if (parent && parent.type === "item") {
                const item = this._subject;
                this._restoreContext("item", token);
                this._emit(this._subject, this.RDF_FIRST, item, this._graph);
              }
              return this._afterPath(token);
          }
        }
        _readForwardPath(token) {
          let subject, predicate;
          const object = this._blankNode();
          if ((predicate = this._readEntity(token)) === void 0)
            return;
          if (this._predicate === null)
            subject = this._subject, this._subject = object;
          else
            subject = this._object, this._object = object;
          this._emit(subject, predicate, object, this._graph);
          return this._readPath;
        }
        _readBackwardPath(token) {
          const subject = this._blankNode();
          let predicate, object;
          if ((predicate = this._readEntity(token)) === void 0)
            return;
          if (this._predicate === null)
            object = this._subject, this._subject = subject;
          else
            object = this._object, this._object = subject;
          this._emit(subject, predicate, object, this._graph);
          return this._readPath;
        }
        _readRDFStarTailOrGraph(token) {
          if (token.type !== ">>") {
            if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== void 0)
              return this._readRDFStarTail;
            return this._error(`Expected >> to follow "${this._object.id}"`, token);
          }
          return this._readRDFStarTail(token);
        }
        _readRDFStarTail(token) {
          if (token.type !== ">>")
            return this._error(`Expected >> but got ${token.type}`, token);
          const quad = this._quad(this._subject, this._predicate, this._object, this._graph || this.DEFAULTGRAPH);
          this._restoreContext("<<", token);
          if (this._subject === null) {
            this._subject = quad;
            return this._readPredicate;
          } else {
            this._object = quad;
            return this._getContextEndReader();
          }
        }
        _getContextEndReader() {
          const contextStack = this._contextStack;
          if (!contextStack.length)
            return this._readPunctuation;
          switch (contextStack[contextStack.length - 1].type) {
            case "blank":
              return this._readBlankNodeTail;
            case "list":
              return this._readListItem;
            case "formula":
              return this._readFormulaTail;
            case "<<":
              return this._readRDFStarTailOrGraph;
          }
        }
        _emit(subject, predicate, object, graph2) {
          this._callback(null, this._quad(subject, predicate, object, graph2 || this.DEFAULTGRAPH));
        }
        _error(message, token) {
          const err = new Error(`${message} on line ${token.line}.`);
          err.context = {
            token,
            line: token.line,
            previousToken: this._lexer.previousToken
          };
          this._callback(err);
          this._callback = noop;
        }
        _resolveIRI(iri) {
          return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);
        }
        _resolveRelativeIRI(iri) {
          if (!iri.length)
            return this._base;
          switch (iri[0]) {
            case "#":
              return this._base + iri;
            case "?":
              return this._base.replace(/(?:\?.*)?$/, iri);
            case "/":
              return (iri[1] === "/" ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);
            default:
              return /^[^/:]*:/.test(iri) ? null : this._removeDotSegments(this._basePath + iri);
          }
        }
        _removeDotSegments(iri) {
          if (!/(^|\/)\.\.?($|[/#?])/.test(iri))
            return iri;
          const length = iri.length;
          let result = "", i = -1, pathStart = -1, segmentStart = 0, next = "/";
          while (i < length) {
            switch (next) {
              case ":":
                if (pathStart < 0) {
                  if (iri[++i] === "/" && iri[++i] === "/")
                    while ((pathStart = i + 1) < length && iri[pathStart] !== "/")
                      i = pathStart;
                }
                break;
              case "?":
              case "#":
                i = length;
                break;
              case "/":
                if (iri[i + 1] === ".") {
                  next = iri[++i + 1];
                  switch (next) {
                    case "/":
                      result += iri.substring(segmentStart, i - 1);
                      segmentStart = i + 1;
                      break;
                    case void 0:
                    case "?":
                    case "#":
                      return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
                    case ".":
                      next = iri[++i + 1];
                      if (next === void 0 || next === "/" || next === "?" || next === "#") {
                        result += iri.substring(segmentStart, i - 2);
                        if ((segmentStart = result.lastIndexOf("/")) >= pathStart)
                          result = result.substr(0, segmentStart);
                        if (next !== "/")
                          return `${result}/${iri.substr(i + 1)}`;
                        segmentStart = i + 1;
                      }
                  }
                }
            }
            next = iri[++i];
          }
          return result + iri.substring(segmentStart);
        }
        parse(input, quadCallback, prefixCallback) {
          this._readCallback = this._readInTopContext;
          this._sparqlStyle = false;
          this._prefixes = /* @__PURE__ */ Object.create(null);
          this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b${blankNodePrefix++}_`;
          this._prefixCallback = prefixCallback || noop;
          this._inversePredicate = false;
          this._quantified = /* @__PURE__ */ Object.create(null);
          if (!quadCallback) {
            const quads = [];
            let error;
            this._callback = (e, t) => {
              e ? error = e : t && quads.push(t);
            };
            this._lexer.tokenize(input).every((token) => {
              return this._readCallback = this._readCallback(token);
            });
            if (error)
              throw error;
            return quads;
          }
          this._callback = quadCallback;
          this._lexer.tokenize(input, (error, token) => {
            if (error !== null)
              this._callback(error), this._callback = noop;
            else if (this._readCallback)
              this._readCallback = this._readCallback(token);
          });
        }
      };
      exports.default = N3Parser;
      function noop() {
      }
      function initDataFactory(parser, factory3) {
        const namedNode = factory3.namedNode;
        parser._namedNode = namedNode;
        parser._blankNode = factory3.blankNode;
        parser._literal = factory3.literal;
        parser._variable = factory3.variable;
        parser._quad = factory3.quad;
        parser.DEFAULTGRAPH = factory3.defaultGraph();
        parser.RDF_FIRST = namedNode(_IRIs.default.rdf.first);
        parser.RDF_REST = namedNode(_IRIs.default.rdf.rest);
        parser.RDF_NIL = namedNode(_IRIs.default.rdf.nil);
        parser.N3_FORALL = namedNode(_IRIs.default.r.forAll);
        parser.N3_FORSOME = namedNode(_IRIs.default.r.forSome);
        parser.ABBREVIATIONS = {
          "a": namedNode(_IRIs.default.rdf.type),
          "=": namedNode(_IRIs.default.owl.sameAs),
          ">": namedNode(_IRIs.default.log.implies)
        };
        parser.QUANTIFIERS_GRAPH = namedNode("urn:n3:quantifiers");
      }
      initDataFactory(N3Parser.prototype, _N3DataFactory.default);
    }
  });

  // node_modules/n3/lib/N3Writer.js
  var require_N3Writer = __commonJS({
    "node_modules/n3/lib/N3Writer.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _IRIs = _interopRequireDefault(require_IRIs());
      var _N3DataFactory = _interopRequireWildcard(require_N3DataFactory());
      var _N3Util = require_N3Util();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { default: obj };
        }
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) {
          return cache.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        if (cache) {
          cache.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var DEFAULTGRAPH = _N3DataFactory.default.defaultGraph();
      var {
        rdf,
        xsd
      } = _IRIs.default;
      var escape = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/;
      var escapeAll = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g;
      var escapedCharacters = {
        "\\": "\\\\",
        '"': '\\"',
        "	": "\\t",
        "\n": "\\n",
        "\r": "\\r",
        "\b": "\\b",
        "\f": "\\f"
      };
      var SerializedTerm = class extends _N3DataFactory.Term {
        equals() {
          return false;
        }
      };
      var N3Writer = class {
        constructor(outputStream, options) {
          this._prefixRegex = /$0^/;
          if (outputStream && typeof outputStream.write !== "function")
            options = outputStream, outputStream = null;
          options = options || {};
          this._lists = options.lists;
          if (!outputStream) {
            let output = "";
            this._outputStream = {
              write(chunk, encoding2, done) {
                output += chunk;
                done && done();
              },
              end: (done) => {
                done && done(null, output);
              }
            };
            this._endStream = true;
          } else {
            this._outputStream = outputStream;
            this._endStream = options.end === void 0 ? true : !!options.end;
          }
          this._subject = null;
          if (!/triple|quad/i.test(options.format)) {
            this._lineMode = false;
            this._graph = DEFAULTGRAPH;
            this._prefixIRIs = /* @__PURE__ */ Object.create(null);
            options.prefixes && this.addPrefixes(options.prefixes);
            if (options.baseIRI) {
              this._baseMatcher = new RegExp(`^${escapeRegex(options.baseIRI)}${options.baseIRI.endsWith("/") ? "" : "[#?]"}`);
              this._baseLength = options.baseIRI.length;
            }
          } else {
            this._lineMode = true;
            this._writeQuad = this._writeQuadLine;
          }
        }
        get _inDefaultGraph() {
          return DEFAULTGRAPH.equals(this._graph);
        }
        _write(string, callback) {
          this._outputStream.write(string, "utf8", callback);
        }
        _writeQuad(subject, predicate, object, graph2, done) {
          try {
            if (!graph2.equals(this._graph)) {
              this._write((this._subject === null ? "" : this._inDefaultGraph ? ".\n" : "\n}\n") + (DEFAULTGRAPH.equals(graph2) ? "" : `${this._encodeIriOrBlank(graph2)} {
`));
              this._graph = graph2;
              this._subject = null;
            }
            if (subject.equals(this._subject)) {
              if (predicate.equals(this._predicate))
                this._write(`, ${this._encodeObject(object)}`, done);
              else
                this._write(`;
    ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object)}`, done);
            } else
              this._write(`${(this._subject === null ? "" : ".\n") + this._encodeSubject(this._subject = subject)} ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object)}`, done);
          } catch (error) {
            done && done(error);
          }
        }
        _writeQuadLine(subject, predicate, object, graph2, done) {
          delete this._prefixMatch;
          this._write(this.quadToString(subject, predicate, object, graph2), done);
        }
        quadToString(subject, predicate, object, graph2) {
          return `${this._encodeSubject(subject)} ${this._encodeIriOrBlank(predicate)} ${this._encodeObject(object)}${graph2 && graph2.value ? ` ${this._encodeIriOrBlank(graph2)} .
` : " .\n"}`;
        }
        quadsToString(quads) {
          return quads.map((t) => {
            return this.quadToString(t.subject, t.predicate, t.object, t.graph);
          }).join("");
        }
        _encodeSubject(entity) {
          return entity.termType === "Quad" ? this._encodeQuad(entity) : this._encodeIriOrBlank(entity);
        }
        _encodeIriOrBlank(entity) {
          if (entity.termType !== "NamedNode") {
            if (this._lists && entity.value in this._lists)
              entity = this.list(this._lists[entity.value]);
            return "id" in entity ? entity.id : `_:${entity.value}`;
          }
          let iri = entity.value;
          if (this._baseMatcher && this._baseMatcher.test(iri))
            iri = iri.substr(this._baseLength);
          if (escape.test(iri))
            iri = iri.replace(escapeAll, characterReplacer);
          const prefixMatch = this._prefixRegex.exec(iri);
          return !prefixMatch ? `<${iri}>` : !prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];
        }
        _encodeLiteral(literal) {
          let value = literal.value;
          if (escape.test(value))
            value = value.replace(escapeAll, characterReplacer);
          if (literal.language)
            return `"${value}"@${literal.language}`;
          if (this._lineMode) {
            if (literal.datatype.value === xsd.string)
              return `"${value}"`;
          } else {
            switch (literal.datatype.value) {
              case xsd.string:
                return `"${value}"`;
              case xsd.boolean:
                if (value === "true" || value === "false")
                  return value;
                break;
              case xsd.integer:
                if (/^[+-]?\d+$/.test(value))
                  return value;
                break;
              case xsd.decimal:
                if (/^[+-]?\d*\.\d+$/.test(value))
                  return value;
                break;
              case xsd.double:
                if (/^[+-]?(?:\d+\.\d*|\.?\d+)[eE][+-]?\d+$/.test(value))
                  return value;
                break;
            }
          }
          return `"${value}"^^${this._encodeIriOrBlank(literal.datatype)}`;
        }
        _encodePredicate(predicate) {
          return predicate.value === rdf.type ? "a" : this._encodeIriOrBlank(predicate);
        }
        _encodeObject(object) {
          switch (object.termType) {
            case "Quad":
              return this._encodeQuad(object);
            case "Literal":
              return this._encodeLiteral(object);
            default:
              return this._encodeIriOrBlank(object);
          }
        }
        _encodeQuad({
          subject,
          predicate,
          object,
          graph: graph2
        }) {
          return `<<${this._encodeSubject(subject)} ${this._encodePredicate(predicate)} ${this._encodeObject(object)}${(0, _N3Util.isDefaultGraph)(graph2) ? "" : ` ${this._encodeIriOrBlank(graph2)}`}>>`;
        }
        _blockedWrite() {
          throw new Error("Cannot write because the writer has been closed.");
        }
        addQuad(subject, predicate, object, graph2, done) {
          if (object === void 0)
            this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate);
          else if (typeof graph2 === "function")
            this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph2);
          else
            this._writeQuad(subject, predicate, object, graph2 || DEFAULTGRAPH, done);
        }
        addQuads(quads) {
          for (let i = 0; i < quads.length; i++)
            this.addQuad(quads[i]);
        }
        addPrefix(prefix, iri, done) {
          const prefixes = {};
          prefixes[prefix] = iri;
          this.addPrefixes(prefixes, done);
        }
        addPrefixes(prefixes, done) {
          if (!this._prefixIRIs)
            return done && done();
          let hasPrefixes = false;
          for (let prefix in prefixes) {
            let iri = prefixes[prefix];
            if (typeof iri !== "string")
              iri = iri.value;
            hasPrefixes = true;
            if (this._subject !== null) {
              this._write(this._inDefaultGraph ? ".\n" : "\n}\n");
              this._subject = null, this._graph = "";
            }
            this._prefixIRIs[iri] = prefix += ":";
            this._write(`@prefix ${prefix} <${iri}>.
`);
          }
          if (hasPrefixes) {
            let IRIlist = "", prefixList = "";
            for (const prefixIRI in this._prefixIRIs) {
              IRIlist += IRIlist ? `|${prefixIRI}` : prefixIRI;
              prefixList += (prefixList ? "|" : "") + this._prefixIRIs[prefixIRI];
            }
            IRIlist = escapeRegex(IRIlist, /[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
            this._prefixRegex = new RegExp(`^(?:${prefixList})[^/]*$|^(${IRIlist})([a-zA-Z][\\-_a-zA-Z0-9]*)$`);
          }
          this._write(hasPrefixes ? "\n" : "", done);
        }
        blank(predicate, object) {
          let children = predicate, child, length;
          if (predicate === void 0)
            children = [];
          else if (predicate.termType)
            children = [{
              predicate,
              object
            }];
          else if (!("length" in predicate))
            children = [predicate];
          switch (length = children.length) {
            case 0:
              return new SerializedTerm("[]");
            case 1:
              child = children[0];
              if (!(child.object instanceof SerializedTerm))
                return new SerializedTerm(`[ ${this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)} ]`);
            default:
              let contents = "[";
              for (let i = 0; i < length; i++) {
                child = children[i];
                if (child.predicate.equals(predicate))
                  contents += `, ${this._encodeObject(child.object)}`;
                else {
                  contents += `${(i ? ";\n  " : "\n  ") + this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)}`;
                  predicate = child.predicate;
                }
              }
              return new SerializedTerm(`${contents}
]`);
          }
        }
        list(elements) {
          const length = elements && elements.length || 0, contents = new Array(length);
          for (let i = 0; i < length; i++)
            contents[i] = this._encodeObject(elements[i]);
          return new SerializedTerm(`(${contents.join(" ")})`);
        }
        end(done) {
          if (this._subject !== null) {
            this._write(this._inDefaultGraph ? ".\n" : "\n}\n");
            this._subject = null;
          }
          this._write = this._blockedWrite;
          let singleDone = done && ((error, result) => {
            singleDone = null, done(error, result);
          });
          if (this._endStream) {
            try {
              return this._outputStream.end(singleDone);
            } catch (error) {
            }
          }
          singleDone && singleDone();
        }
      };
      exports.default = N3Writer;
      function characterReplacer(character) {
        let result = escapedCharacters[character];
        if (result === void 0) {
          if (character.length === 1) {
            result = character.charCodeAt(0).toString(16);
            result = "\\u0000".substr(0, 6 - result.length) + result;
          } else {
            result = ((character.charCodeAt(0) - 55296) * 1024 + character.charCodeAt(1) + 9216).toString(16);
            result = "\\U00000000".substr(0, 10 - result.length) + result;
          }
        }
        return result;
      }
      function escapeRegex(regex) {
        return regex.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
      }
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser8 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list7 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_shim();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer3 = _require.Buffer;
      var _require2 = require_util2();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer3.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer3.alloc(0);
            var ret = Buffer3.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer3.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy8 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              import_process.default.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              import_process.default.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            import_process.default.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/n3/node_modules/readable-stream/errors-browser.js
  var require_errors_browser7 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_shim();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state7 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_INVALID_OPT_VALUE = require_errors_browser7().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable8 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser8();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy8();
      var _require = require_state7();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser7().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex8();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex8();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          import_process.default.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding2, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer3.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (isBuf)
          encoding2 = "buffer";
        else if (!encoding2)
          encoding2 = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ending)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding2, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
        if (typeof encoding2 === "string")
          encoding2 = encoding2.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding2);
        this._writableState.defaultEncoding = encoding2;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding2) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer3.from(chunk, encoding2);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding2, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding2);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding2 = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding: encoding2,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding2, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding2, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          import_process.default.nextTick(cb, er);
          import_process.default.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished4 = needFinish(state) || stream.destroyed;
          if (!finished4 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            import_process.default.nextTick(afterWrite, stream, state, finished4, cb);
          } else {
            afterWrite(stream, state, finished4, cb);
          }
        }
      }
      function afterWrite(stream, state, finished4, cb) {
        if (!finished4)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding2 = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding2, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding2, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding2 = null;
        } else if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding2);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            import_process.default.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            import_process.default.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex8 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var Readable5 = require_stream_readable8();
      var Writable = require_stream_writable8();
      require_inherits_browser()(Duplex, Readable5);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable5.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended)
          return;
        import_process.default.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream7 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser7().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once2(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator7 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_shim();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished4 = require_end_of_stream7();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        import_process.default.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              import_process.default.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished4(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser7 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_shim();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable8 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Readable5;
      var Duplex;
      Readable5.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser8();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list7();
      var destroyImpl = require_destroy8();
      var _require = require_state7();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser7().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable5, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex8();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder2().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable5(options) {
        Duplex = Duplex || require_stream_duplex8();
        if (!(this instanceof Readable5))
          return new Readable5(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable5.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable5.prototype.destroy = destroyImpl.destroy;
      Readable5.prototype._undestroy = destroyImpl.undestroy;
      Readable5.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable5.prototype.push = function(chunk, encoding2) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding2 = encoding2 || state.defaultEncoding;
            if (encoding2 !== state.encoding) {
              chunk = Buffer3.from(chunk, encoding2);
              encoding2 = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
      };
      Readable5.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding2) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable5.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable5.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable5.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          import_process.default.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          import_process.default.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable5.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable5.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          import_process.default.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable5.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable5.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              import_process.default.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable5.prototype.addListener = Readable5.prototype.on;
      Readable5.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable5.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable5.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          import_process.default.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable5.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable5.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable5.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator7();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable5.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableBuffer", {
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableFlowing", {
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable5._fromList = fromList;
      Object.defineProperty(Readable5.prototype, "readableLength", {
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          import_process.default.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable5.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser7();
          }
          return from(Readable5, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform8 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform;
      var _require$codes = require_errors_browser7().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex8();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding2) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding2);
      };
      Transform.prototype._transform = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding2, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding2;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough8 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough;
      var Transform = require_stream_transform8();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding2, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/n3/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline7 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_shim();
      var eos;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser7().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once2(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream7();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/n3/node_modules/readable-stream/readable-browser.js
  var require_readable_browser7 = __commonJS({
    "node_modules/n3/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_shim();
      exports = module.exports = require_stream_readable8();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable8();
      exports.Duplex = require_stream_duplex8();
      exports.Transform = require_stream_transform8();
      exports.PassThrough = require_stream_passthrough8();
      exports.finished = require_end_of_stream7();
      exports.pipeline = require_pipeline7();
    }
  });

  // node_modules/n3/lib/N3Store.js
  var require_N3Store = __commonJS({
    "node_modules/n3/lib/N3Store.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _N3DataFactory = _interopRequireWildcard(require_N3DataFactory());
      var _readableStream = require_readable_browser7();
      var _IRIs = _interopRequireDefault(require_IRIs());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { default: obj };
        }
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) {
          return cache.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        if (cache) {
          cache.set(obj, newObj);
        }
        return newObj;
      }
      var N3Store = class {
        constructor(quads, options) {
          this._size = 0;
          this._graphs = /* @__PURE__ */ Object.create(null);
          this._id = 0;
          this._ids = /* @__PURE__ */ Object.create(null);
          this._ids["><"] = 0;
          this._entities = /* @__PURE__ */ Object.create(null);
          this._blankNodeIndex = 0;
          if (!options && quads && !quads[0])
            options = quads, quads = null;
          options = options || {};
          this._factory = options.factory || _N3DataFactory.default;
          if (quads)
            this.addQuads(quads);
        }
        get size() {
          let size = this._size;
          if (size !== null)
            return size;
          size = 0;
          const graphs = this._graphs;
          let subjects, subject;
          for (const graphKey in graphs)
            for (const subjectKey in subjects = graphs[graphKey].subjects)
              for (const predicateKey in subject = subjects[subjectKey])
                size += Object.keys(subject[predicateKey]).length;
          return this._size = size;
        }
        _addToIndex(index0, key0, key1, key2) {
          const index1 = index0[key0] || (index0[key0] = {});
          const index2 = index1[key1] || (index1[key1] = {});
          const existed = key2 in index2;
          if (!existed)
            index2[key2] = null;
          return !existed;
        }
        _removeFromIndex(index0, key0, key1, key2) {
          const index1 = index0[key0], index2 = index1[key1];
          delete index2[key2];
          for (const key in index2)
            return;
          delete index1[key1];
          for (const key in index1)
            return;
          delete index0[key0];
        }
        *_findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {
          let tmp, index1, index2;
          const entityKeys = this._entities;
          const graph2 = (0, _N3DataFactory.termFromId)(graphId, this._factory);
          const parts = {
            subject: null,
            predicate: null,
            object: null
          };
          if (key0)
            (tmp = index0, index0 = {})[key0] = tmp[key0];
          for (const value0 in index0) {
            if (index1 = index0[value0]) {
              parts[name0] = (0, _N3DataFactory.termFromId)(entityKeys[value0], this._factory);
              if (key1)
                (tmp = index1, index1 = {})[key1] = tmp[key1];
              for (const value1 in index1) {
                if (index2 = index1[value1]) {
                  parts[name1] = (0, _N3DataFactory.termFromId)(entityKeys[value1], this._factory);
                  const values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2);
                  for (let l = 0; l < values.length; l++) {
                    parts[name2] = (0, _N3DataFactory.termFromId)(entityKeys[values[l]], this._factory);
                    yield this._factory.quad(parts.subject, parts.predicate, parts.object, graph2);
                  }
                }
              }
            }
          }
        }
        _loop(index0, callback) {
          for (const key0 in index0)
            callback(key0);
        }
        _loopByKey0(index0, key0, callback) {
          let index1, key1;
          if (index1 = index0[key0]) {
            for (key1 in index1)
              callback(key1);
          }
        }
        _loopByKey1(index0, key1, callback) {
          let key0, index1;
          for (key0 in index0) {
            index1 = index0[key0];
            if (index1[key1])
              callback(key0);
          }
        }
        _loopBy2Keys(index0, key0, key1, callback) {
          let index1, index2, key2;
          if ((index1 = index0[key0]) && (index2 = index1[key1])) {
            for (key2 in index2)
              callback(key2);
          }
        }
        _countInIndex(index0, key0, key1, key2) {
          let count = 0, tmp, index1, index2;
          if (key0)
            (tmp = index0, index0 = {})[key0] = tmp[key0];
          for (const value0 in index0) {
            if (index1 = index0[value0]) {
              if (key1)
                (tmp = index1, index1 = {})[key1] = tmp[key1];
              for (const value1 in index1) {
                if (index2 = index1[value1]) {
                  if (key2)
                    key2 in index2 && count++;
                  else
                    count += Object.keys(index2).length;
                }
              }
            }
          }
          return count;
        }
        _getGraphs(graph2) {
          if (!isString2(graph2))
            return this._graphs;
          const graphs = {};
          graphs[graph2] = this._graphs[graph2];
          return graphs;
        }
        _uniqueEntities(callback) {
          const uniqueIds = /* @__PURE__ */ Object.create(null);
          return (id) => {
            if (!(id in uniqueIds)) {
              uniqueIds[id] = true;
              callback((0, _N3DataFactory.termFromId)(this._entities[id], this._factory));
            }
          };
        }
        add(quad) {
          this.addQuad(quad);
          return this;
        }
        addQuad(subject, predicate, object, graph2) {
          if (!predicate)
            graph2 = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject;
          subject = (0, _N3DataFactory.termToId)(subject);
          predicate = (0, _N3DataFactory.termToId)(predicate);
          object = (0, _N3DataFactory.termToId)(object);
          graph2 = (0, _N3DataFactory.termToId)(graph2);
          let graphItem = this._graphs[graph2];
          if (!graphItem) {
            graphItem = this._graphs[graph2] = {
              subjects: {},
              predicates: {},
              objects: {}
            };
            Object.freeze(graphItem);
          }
          const ids = this._ids;
          const entities = this._entities;
          subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);
          predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);
          object = ids[object] || (ids[entities[++this._id] = object] = this._id);
          const changed = this._addToIndex(graphItem.subjects, subject, predicate, object);
          this._addToIndex(graphItem.predicates, predicate, object, subject);
          this._addToIndex(graphItem.objects, object, subject, predicate);
          this._size = null;
          return changed;
        }
        addQuads(quads) {
          for (let i = 0; i < quads.length; i++)
            this.addQuad(quads[i]);
        }
        delete(quad) {
          this.removeQuad(quad);
          return this;
        }
        has(subjectOrQuad, predicate, object, graph2) {
          if (subjectOrQuad && subjectOrQuad.subject)
            ({
              subject: subjectOrQuad,
              predicate,
              object,
              graph: graph2
            } = subjectOrQuad);
          return !this.readQuads(subjectOrQuad, predicate, object, graph2).next().done;
        }
        import(stream) {
          stream.on("data", (quad) => {
            this.addQuad(quad);
          });
          return stream;
        }
        removeQuad(subject, predicate, object, graph2) {
          if (!predicate)
            graph2 = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject;
          subject = (0, _N3DataFactory.termToId)(subject);
          predicate = (0, _N3DataFactory.termToId)(predicate);
          object = (0, _N3DataFactory.termToId)(object);
          graph2 = (0, _N3DataFactory.termToId)(graph2);
          const ids = this._ids, graphs = this._graphs;
          let graphItem, subjects, predicates;
          if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph2]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates))
            return false;
          this._removeFromIndex(graphItem.subjects, subject, predicate, object);
          this._removeFromIndex(graphItem.predicates, predicate, object, subject);
          this._removeFromIndex(graphItem.objects, object, subject, predicate);
          if (this._size !== null)
            this._size--;
          for (subject in graphItem.subjects)
            return true;
          delete graphs[graph2];
          return true;
        }
        removeQuads(quads) {
          for (let i = 0; i < quads.length; i++)
            this.removeQuad(quads[i]);
        }
        remove(stream) {
          stream.on("data", (quad) => {
            this.removeQuad(quad);
          });
          return stream;
        }
        removeMatches(subject, predicate, object, graph2) {
          const stream = new _readableStream.Readable({
            objectMode: true
          });
          stream._read = () => {
            for (const quad of this.readQuads(subject, predicate, object, graph2))
              stream.push(quad);
            stream.push(null);
          };
          return this.remove(stream);
        }
        deleteGraph(graph2) {
          return this.removeMatches(null, null, null, graph2);
        }
        getQuads(subject, predicate, object, graph2) {
          return [...this.readQuads(subject, predicate, object, graph2)];
        }
        *readQuads(subject, predicate, object, graph2) {
          subject = subject && (0, _N3DataFactory.termToId)(subject);
          predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
          object = object && (0, _N3DataFactory.termToId)(object);
          graph2 = graph2 && (0, _N3DataFactory.termToId)(graph2);
          const graphs = this._getGraphs(graph2), ids = this._ids;
          let content, subjectId, predicateId, objectId;
          if (isString2(subject) && !(subjectId = ids[subject]) || isString2(predicate) && !(predicateId = ids[predicate]) || isString2(object) && !(objectId = ids[object]))
            return;
          for (const graphId in graphs) {
            if (content = graphs[graphId]) {
              if (subjectId) {
                if (objectId)
                  yield* this._findInIndex(content.objects, objectId, subjectId, predicateId, "object", "subject", "predicate", graphId);
                else
                  yield* this._findInIndex(content.subjects, subjectId, predicateId, null, "subject", "predicate", "object", graphId);
              } else if (predicateId)
                yield* this._findInIndex(content.predicates, predicateId, objectId, null, "predicate", "object", "subject", graphId);
              else if (objectId)
                yield* this._findInIndex(content.objects, objectId, null, null, "object", "subject", "predicate", graphId);
              else
                yield* this._findInIndex(content.subjects, null, null, null, "subject", "predicate", "object", graphId);
            }
          }
        }
        match(subject, predicate, object, graph2) {
          return new DatasetCoreAndReadableStream(this, subject, predicate, object, graph2);
        }
        countQuads(subject, predicate, object, graph2) {
          subject = subject && (0, _N3DataFactory.termToId)(subject);
          predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
          object = object && (0, _N3DataFactory.termToId)(object);
          graph2 = graph2 && (0, _N3DataFactory.termToId)(graph2);
          const graphs = this._getGraphs(graph2), ids = this._ids;
          let count = 0, content, subjectId, predicateId, objectId;
          if (isString2(subject) && !(subjectId = ids[subject]) || isString2(predicate) && !(predicateId = ids[predicate]) || isString2(object) && !(objectId = ids[object]))
            return 0;
          for (const graphId in graphs) {
            if (content = graphs[graphId]) {
              if (subject) {
                if (object)
                  count += this._countInIndex(content.objects, objectId, subjectId, predicateId);
                else
                  count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);
              } else if (predicate) {
                count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);
              } else {
                count += this._countInIndex(content.objects, objectId, subjectId, predicateId);
              }
            }
          }
          return count;
        }
        forEach(callback, subject, predicate, object, graph2) {
          this.some((quad) => {
            callback(quad);
            return false;
          }, subject, predicate, object, graph2);
        }
        every(callback, subject, predicate, object, graph2) {
          let some = false;
          const every = !this.some((quad) => {
            some = true;
            return !callback(quad);
          }, subject, predicate, object, graph2);
          return some && every;
        }
        some(callback, subject, predicate, object, graph2) {
          for (const quad of this.readQuads(subject, predicate, object, graph2))
            if (callback(quad))
              return true;
          return false;
        }
        getSubjects(predicate, object, graph2) {
          const results = [];
          this.forSubjects((s) => {
            results.push(s);
          }, predicate, object, graph2);
          return results;
        }
        forSubjects(callback, predicate, object, graph2) {
          predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
          object = object && (0, _N3DataFactory.termToId)(object);
          graph2 = graph2 && (0, _N3DataFactory.termToId)(graph2);
          const ids = this._ids, graphs = this._getGraphs(graph2);
          let content, predicateId, objectId;
          callback = this._uniqueEntities(callback);
          if (isString2(predicate) && !(predicateId = ids[predicate]) || isString2(object) && !(objectId = ids[object]))
            return;
          for (graph2 in graphs) {
            if (content = graphs[graph2]) {
              if (predicateId) {
                if (objectId)
                  this._loopBy2Keys(content.predicates, predicateId, objectId, callback);
                else
                  this._loopByKey1(content.subjects, predicateId, callback);
              } else if (objectId)
                this._loopByKey0(content.objects, objectId, callback);
              else
                this._loop(content.subjects, callback);
            }
          }
        }
        getPredicates(subject, object, graph2) {
          const results = [];
          this.forPredicates((p) => {
            results.push(p);
          }, subject, object, graph2);
          return results;
        }
        forPredicates(callback, subject, object, graph2) {
          subject = subject && (0, _N3DataFactory.termToId)(subject);
          object = object && (0, _N3DataFactory.termToId)(object);
          graph2 = graph2 && (0, _N3DataFactory.termToId)(graph2);
          const ids = this._ids, graphs = this._getGraphs(graph2);
          let content, subjectId, objectId;
          callback = this._uniqueEntities(callback);
          if (isString2(subject) && !(subjectId = ids[subject]) || isString2(object) && !(objectId = ids[object]))
            return;
          for (graph2 in graphs) {
            if (content = graphs[graph2]) {
              if (subjectId) {
                if (objectId)
                  this._loopBy2Keys(content.objects, objectId, subjectId, callback);
                else
                  this._loopByKey0(content.subjects, subjectId, callback);
              } else if (objectId)
                this._loopByKey1(content.predicates, objectId, callback);
              else
                this._loop(content.predicates, callback);
            }
          }
        }
        getObjects(subject, predicate, graph2) {
          const results = [];
          this.forObjects((o) => {
            results.push(o);
          }, subject, predicate, graph2);
          return results;
        }
        forObjects(callback, subject, predicate, graph2) {
          subject = subject && (0, _N3DataFactory.termToId)(subject);
          predicate = predicate && (0, _N3DataFactory.termToId)(predicate);
          graph2 = graph2 && (0, _N3DataFactory.termToId)(graph2);
          const ids = this._ids, graphs = this._getGraphs(graph2);
          let content, subjectId, predicateId;
          callback = this._uniqueEntities(callback);
          if (isString2(subject) && !(subjectId = ids[subject]) || isString2(predicate) && !(predicateId = ids[predicate]))
            return;
          for (graph2 in graphs) {
            if (content = graphs[graph2]) {
              if (subjectId) {
                if (predicateId)
                  this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);
                else
                  this._loopByKey1(content.objects, subjectId, callback);
              } else if (predicateId)
                this._loopByKey0(content.predicates, predicateId, callback);
              else
                this._loop(content.objects, callback);
            }
          }
        }
        getGraphs(subject, predicate, object) {
          const results = [];
          this.forGraphs((g) => {
            results.push(g);
          }, subject, predicate, object);
          return results;
        }
        forGraphs(callback, subject, predicate, object) {
          for (const graph2 in this._graphs) {
            this.some((quad) => {
              callback(quad.graph);
              return true;
            }, subject, predicate, object, graph2);
          }
        }
        createBlankNode(suggestedName) {
          let name, index;
          if (suggestedName) {
            name = suggestedName = `_:${suggestedName}`, index = 1;
            while (this._ids[name])
              name = suggestedName + index++;
          } else {
            do {
              name = `_:b${this._blankNodeIndex++}`;
            } while (this._ids[name]);
          }
          this._ids[name] = ++this._id;
          this._entities[this._id] = name;
          return this._factory.blankNode(name.substr(2));
        }
        extractLists({
          remove = false,
          ignoreErrors = false
        } = {}) {
          const lists = {};
          const onError = ignoreErrors ? () => true : (node19, message) => {
            throw new Error(`${node19.value} ${message}`);
          };
          const tails = this.getQuads(null, _IRIs.default.rdf.rest, _IRIs.default.rdf.nil, null);
          const toRemove = remove ? [...tails] : [];
          tails.forEach((tailQuad) => {
            const items = [];
            let malformed = false;
            let head;
            let headPos;
            const graph2 = tailQuad.graph;
            let current = tailQuad.subject;
            while (current && !malformed) {
              const objectQuads = this.getQuads(null, null, current, null);
              const subjectQuads = this.getQuads(current, null, null, null);
              let quad, first = null, rest = null, parent = null;
              for (let i = 0; i < subjectQuads.length && !malformed; i++) {
                quad = subjectQuads[i];
                if (!quad.graph.equals(graph2))
                  malformed = onError(current, "not confined to single graph");
                else if (head)
                  malformed = onError(current, "has non-list arcs out");
                else if (quad.predicate.value === _IRIs.default.rdf.first) {
                  if (first)
                    malformed = onError(current, "has multiple rdf:first arcs");
                  else
                    toRemove.push(first = quad);
                } else if (quad.predicate.value === _IRIs.default.rdf.rest) {
                  if (rest)
                    malformed = onError(current, "has multiple rdf:rest arcs");
                  else
                    toRemove.push(rest = quad);
                } else if (objectQuads.length)
                  malformed = onError(current, "can't be subject and object");
                else {
                  head = quad;
                  headPos = "subject";
                }
              }
              for (let i = 0; i < objectQuads.length && !malformed; ++i) {
                quad = objectQuads[i];
                if (head)
                  malformed = onError(current, "can't have coreferences");
                else if (quad.predicate.value === _IRIs.default.rdf.rest) {
                  if (parent)
                    malformed = onError(current, "has incoming rdf:rest arcs");
                  else
                    parent = quad;
                } else {
                  head = quad;
                  headPos = "object";
                }
              }
              if (!first)
                malformed = onError(current, "has no list head");
              else
                items.unshift(first.object);
              current = parent && parent.subject;
            }
            if (malformed)
              remove = false;
            else if (head)
              lists[head[headPos].value] = items;
          });
          if (remove)
            this.removeQuads(toRemove);
          return lists;
        }
        *[Symbol.iterator]() {
          yield* this.readQuads();
        }
      };
      exports.default = N3Store;
      function isString2(s) {
        return typeof s === "string" || s instanceof String;
      }
      var DatasetCoreAndReadableStream = class extends _readableStream.Readable {
        constructor(n3Store, subject, predicate, object, graph2) {
          super({
            objectMode: true
          });
          Object.assign(this, {
            n3Store,
            subject,
            predicate,
            object,
            graph: graph2
          });
        }
        get filtered() {
          if (!this._filtered) {
            const {
              n3Store,
              graph: graph2,
              object,
              predicate,
              subject
            } = this;
            const newStore = this._filtered = new N3Store({
              factory: n3Store._factory
            });
            for (const quad of n3Store.readQuads(subject, predicate, object, graph2))
              newStore.addQuad(quad);
          }
          return this._filtered;
        }
        get size() {
          return this.filtered.size;
        }
        _read() {
          for (const quad of this)
            this.push(quad);
          this.push(null);
        }
        add(quad) {
          return this.filtered.add(quad);
        }
        delete(quad) {
          return this.filtered.delete(quad);
        }
        has(quad) {
          return this.filtered.has(quad);
        }
        match(subject, predicate, object, graph2) {
          return new DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph2);
        }
        *[Symbol.iterator]() {
          yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);
        }
      };
    }
  });

  // node_modules/n3/lib/N3StreamParser.js
  var require_N3StreamParser = __commonJS({
    "node_modules/n3/lib/N3StreamParser.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _N3Parser = _interopRequireDefault(require_N3Parser());
      var _readableStream = require_readable_browser7();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var N3StreamParser = class extends _readableStream.Transform {
        constructor(options) {
          super({
            decodeStrings: true
          });
          this._readableState.objectMode = true;
          const parser = new _N3Parser.default(options);
          let onData, onEnd;
          parser.parse({
            on: (event, callback) => {
              switch (event) {
                case "data":
                  onData = callback;
                  break;
                case "end":
                  onEnd = callback;
                  break;
              }
            }
          }, (error, quad) => {
            error && this.emit("error", error) || quad && this.push(quad);
          }, (prefix, uri) => {
            this.emit("prefix", prefix, uri);
          });
          this._transform = (chunk, encoding2, done) => {
            onData(chunk);
            done();
          };
          this._flush = (done) => {
            onEnd();
            done();
          };
        }
        import(stream) {
          stream.on("data", (chunk) => {
            this.write(chunk);
          });
          stream.on("end", () => {
            this.end();
          });
          stream.on("error", (error) => {
            this.emit("error", error);
          });
          return this;
        }
      };
      exports.default = N3StreamParser;
    }
  });

  // node_modules/n3/lib/N3StreamWriter.js
  var require_N3StreamWriter = __commonJS({
    "node_modules/n3/lib/N3StreamWriter.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _readableStream = require_readable_browser7();
      var _N3Writer = _interopRequireDefault(require_N3Writer());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var N3StreamWriter = class extends _readableStream.Transform {
        constructor(options) {
          super({
            encoding: "utf8",
            writableObjectMode: true
          });
          const writer = this._writer = new _N3Writer.default({
            write: (quad, encoding2, callback) => {
              this.push(quad);
              callback && callback();
            },
            end: (callback) => {
              this.push(null);
              callback && callback();
            }
          }, options);
          this._transform = (quad, encoding2, done) => {
            writer.addQuad(quad, done);
          };
          this._flush = (done) => {
            writer.end(done);
          };
        }
        import(stream) {
          stream.on("data", (quad) => {
            this.write(quad);
          });
          stream.on("end", () => {
            this.end();
          });
          stream.on("error", (error) => {
            this.emit("error", error);
          });
          stream.on("prefix", (prefix, iri) => {
            this._writer.addPrefix(prefix, iri);
          });
          return this;
        }
      };
      exports.default = N3StreamWriter;
    }
  });

  // node_modules/n3/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/n3/lib/index.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "BlankNode", {
        enumerable: true,
        get: function() {
          return _N3DataFactory.BlankNode;
        }
      });
      Object.defineProperty(exports, "DataFactory", {
        enumerable: true,
        get: function() {
          return _N3DataFactory.default;
        }
      });
      Object.defineProperty(exports, "DefaultGraph", {
        enumerable: true,
        get: function() {
          return _N3DataFactory.DefaultGraph;
        }
      });
      Object.defineProperty(exports, "Lexer", {
        enumerable: true,
        get: function() {
          return _N3Lexer.default;
        }
      });
      Object.defineProperty(exports, "Literal", {
        enumerable: true,
        get: function() {
          return _N3DataFactory.Literal;
        }
      });
      Object.defineProperty(exports, "NamedNode", {
        enumerable: true,
        get: function() {
          return _N3DataFactory.NamedNode;
        }
      });
      Object.defineProperty(exports, "Parser", {
        enumerable: true,
        get: function() {
          return _N3Parser.default;
        }
      });
      Object.defineProperty(exports, "Quad", {
        enumerable: true,
        get: function() {
          return _N3DataFactory.Quad;
        }
      });
      Object.defineProperty(exports, "Store", {
        enumerable: true,
        get: function() {
          return _N3Store.default;
        }
      });
      Object.defineProperty(exports, "StreamParser", {
        enumerable: true,
        get: function() {
          return _N3StreamParser.default;
        }
      });
      Object.defineProperty(exports, "StreamWriter", {
        enumerable: true,
        get: function() {
          return _N3StreamWriter.default;
        }
      });
      Object.defineProperty(exports, "Term", {
        enumerable: true,
        get: function() {
          return _N3DataFactory.Term;
        }
      });
      Object.defineProperty(exports, "Triple", {
        enumerable: true,
        get: function() {
          return _N3DataFactory.Triple;
        }
      });
      exports.Util = void 0;
      Object.defineProperty(exports, "Variable", {
        enumerable: true,
        get: function() {
          return _N3DataFactory.Variable;
        }
      });
      Object.defineProperty(exports, "Writer", {
        enumerable: true,
        get: function() {
          return _N3Writer.default;
        }
      });
      exports.default = void 0;
      Object.defineProperty(exports, "termFromId", {
        enumerable: true,
        get: function() {
          return _N3DataFactory.termFromId;
        }
      });
      Object.defineProperty(exports, "termToId", {
        enumerable: true,
        get: function() {
          return _N3DataFactory.termToId;
        }
      });
      var _N3Lexer = _interopRequireDefault(require_N3Lexer());
      var _N3Parser = _interopRequireDefault(require_N3Parser());
      var _N3Writer = _interopRequireDefault(require_N3Writer());
      var _N3Store = _interopRequireDefault(require_N3Store());
      var _N3StreamParser = _interopRequireDefault(require_N3StreamParser());
      var _N3StreamWriter = _interopRequireDefault(require_N3StreamWriter());
      var Util = _interopRequireWildcard(require_N3Util());
      exports.Util = Util;
      var _N3DataFactory = _interopRequireWildcard(require_N3DataFactory());
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { default: obj };
        }
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) {
          return cache.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        if (cache) {
          cache.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _default = {
        Lexer: _N3Lexer.default,
        Parser: _N3Parser.default,
        Writer: _N3Writer.default,
        Store: _N3Store.default,
        StreamParser: _N3StreamParser.default,
        StreamWriter: _N3StreamWriter.default,
        Util,
        DataFactory: _N3DataFactory.default,
        Term: _N3DataFactory.Term,
        NamedNode: _N3DataFactory.NamedNode,
        Literal: _N3DataFactory.Literal,
        BlankNode: _N3DataFactory.BlankNode,
        Variable: _N3DataFactory.Variable,
        DefaultGraph: _N3DataFactory.DefaultGraph,
        Quad: _N3DataFactory.Quad,
        Triple: _N3DataFactory.Triple,
        termFromId: _N3DataFactory.termFromId,
        termToId: _N3DataFactory.termToId
      };
      exports.default = _default;
    }
  });

  // node_modules/@rdfjs/to-ntriples/lib/blankNode.js
  var require_blankNode4 = __commonJS({
    "node_modules/@rdfjs/to-ntriples/lib/blankNode.js"(exports, module) {
      init_shim();
      function blankNode(blankNode2) {
        return "_:" + blankNode2.value;
      }
      module.exports = blankNode;
    }
  });

  // node_modules/@rdfjs/to-ntriples/lib/defaultGraph.js
  var require_defaultGraph4 = __commonJS({
    "node_modules/@rdfjs/to-ntriples/lib/defaultGraph.js"(exports, module) {
      init_shim();
      function defaultGraph(defaultGraph2) {
        return "";
      }
      module.exports = defaultGraph;
    }
  });

  // node_modules/@rdfjs/to-ntriples/lib/namedNode.js
  var require_namedNode4 = __commonJS({
    "node_modules/@rdfjs/to-ntriples/lib/namedNode.js"(exports, module) {
      init_shim();
      function namedNode(namedNode2) {
        return "<" + namedNode2.value + ">";
      }
      module.exports = namedNode;
    }
  });

  // node_modules/@rdfjs/to-ntriples/lib/literal.js
  var require_literal4 = __commonJS({
    "node_modules/@rdfjs/to-ntriples/lib/literal.js"(exports, module) {
      init_shim();
      var namedNode = require_namedNode4();
      var echarRegEx = new RegExp('["\\\\\n\r]');
      var echarRegExAll = new RegExp('["\\\\\n\r]', "g");
      var echarReplacement = {
        '"': '\\"',
        "\\": "\\\\",
        "\n": "\\n",
        "\r": "\\r"
      };
      function echarReplacer(char) {
        return echarReplacement[char];
      }
      function escapeValue(value) {
        if (echarRegEx.test(value)) {
          return value.replace(echarRegExAll, echarReplacer);
        }
        return value;
      }
      function literal(literal2) {
        const escapedValue = escapeValue(literal2.value);
        if (literal2.datatype.value === "http://www.w3.org/2001/XMLSchema#string") {
          return '"' + escapedValue + '"';
        }
        if (literal2.datatype.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString") {
          return '"' + escapedValue + '"@' + literal2.language;
        }
        return '"' + escapedValue + '"^^' + namedNode(literal2.datatype);
      }
      module.exports = literal;
    }
  });

  // node_modules/@rdfjs/to-ntriples/lib/variable.js
  var require_variable4 = __commonJS({
    "node_modules/@rdfjs/to-ntriples/lib/variable.js"(exports, module) {
      init_shim();
      function variable(variable2) {
        return "?" + variable2.value;
      }
      module.exports = variable;
    }
  });

  // node_modules/@rdfjs/to-ntriples/lib/term.js
  var require_term2 = __commonJS({
    "node_modules/@rdfjs/to-ntriples/lib/term.js"(exports, module) {
      init_shim();
      var blankNode = require_blankNode4();
      var defaultGraph = require_defaultGraph4();
      var literal = require_literal4();
      var namedNode = require_namedNode4();
      var variable = require_variable4();
      function term(term2) {
        switch (term2.termType) {
          case "BlankNode":
            return blankNode(term2);
          case "DefaultGraph":
            return defaultGraph(term2);
          case "Literal":
            return literal(term2);
          case "NamedNode":
            return namedNode(term2);
          case "Variable":
            return variable(term2);
          default:
            return void 0;
        }
      }
      module.exports = term;
    }
  });

  // node_modules/@rdfjs/to-ntriples/lib/quad.js
  var require_quad4 = __commonJS({
    "node_modules/@rdfjs/to-ntriples/lib/quad.js"(exports, module) {
      init_shim();
      var term = require_term2();
      function quad(quad2) {
        const subjectString = term(quad2.subject);
        const predicateString = term(quad2.predicate);
        const objectString = term(quad2.object);
        const graphString = term(quad2.graph);
        return `${subjectString} ${predicateString} ${objectString} ${graphString ? graphString + " " : ""}.`;
      }
      module.exports = quad;
    }
  });

  // node_modules/@rdfjs/to-ntriples/index.js
  var require_to_ntriples4 = __commonJS({
    "node_modules/@rdfjs/to-ntriples/index.js"(exports, module) {
      init_shim();
      var quad = require_quad4();
      var term = require_term2();
      module.exports = {
        quadToNTriples: quad,
        termToNTriples: term
      };
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser9 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list8 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_shim();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer3 = _require.Buffer;
      var _require2 = require_util2();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer3.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer3.alloc(0);
            var ret = Buffer3.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer3.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy9 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              import_process.default.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              import_process.default.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            import_process.default.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/errors-browser.js
  var require_errors_browser8 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_shim();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state8 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_INVALID_OPT_VALUE = require_errors_browser8().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable9 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser9();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy9();
      var _require = require_state8();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser8().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex9();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex9();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          import_process.default.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding2, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer3.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (isBuf)
          encoding2 = "buffer";
        else if (!encoding2)
          encoding2 = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ending)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding2, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
        if (typeof encoding2 === "string")
          encoding2 = encoding2.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding2);
        this._writableState.defaultEncoding = encoding2;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding2) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer3.from(chunk, encoding2);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding2, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding2);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding2 = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding: encoding2,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding2, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding2, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          import_process.default.nextTick(cb, er);
          import_process.default.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished4 = needFinish(state) || stream.destroyed;
          if (!finished4 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            import_process.default.nextTick(afterWrite, stream, state, finished4, cb);
          } else {
            afterWrite(stream, state, finished4, cb);
          }
        }
      }
      function afterWrite(stream, state, finished4, cb) {
        if (!finished4)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding2 = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding2, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding2, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding2 = null;
        } else if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding2);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            import_process.default.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            import_process.default.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex9 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var Readable5 = require_stream_readable9();
      var Writable = require_stream_writable9();
      require_inherits_browser()(Duplex, Readable5);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable5.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended)
          return;
        import_process.default.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream8 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser8().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once2(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator8 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_shim();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished4 = require_end_of_stream8();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        import_process.default.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              import_process.default.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished4(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser8 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_shim();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable9 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Readable5;
      var Duplex;
      Readable5.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser9();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list8();
      var destroyImpl = require_destroy9();
      var _require = require_state8();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser8().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable5, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex9();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder2().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable5(options) {
        Duplex = Duplex || require_stream_duplex9();
        if (!(this instanceof Readable5))
          return new Readable5(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable5.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable5.prototype.destroy = destroyImpl.destroy;
      Readable5.prototype._undestroy = destroyImpl.undestroy;
      Readable5.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable5.prototype.push = function(chunk, encoding2) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding2 = encoding2 || state.defaultEncoding;
            if (encoding2 !== state.encoding) {
              chunk = Buffer3.from(chunk, encoding2);
              encoding2 = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
      };
      Readable5.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding2) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable5.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable5.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable5.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          import_process.default.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          import_process.default.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable5.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable5.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          import_process.default.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable5.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable5.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              import_process.default.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable5.prototype.addListener = Readable5.prototype.on;
      Readable5.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable5.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable5.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          import_process.default.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable5.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable5.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable5.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator8();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable5.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableBuffer", {
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableFlowing", {
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable5._fromList = fromList;
      Object.defineProperty(Readable5.prototype, "readableLength", {
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          import_process.default.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable5.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser8();
          }
          return from(Readable5, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform9 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform;
      var _require$codes = require_errors_browser8().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex9();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding2) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding2);
      };
      Transform.prototype._transform = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding2, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding2;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough9 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough;
      var Transform = require_stream_transform9();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding2, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline8 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_shim();
      var eos;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser8().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once2(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream8();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/readable-to-readable/node_modules/readable-stream/readable-browser.js
  var require_readable_browser8 = __commonJS({
    "node_modules/readable-to-readable/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_shim();
      exports = module.exports = require_stream_readable9();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable9();
      exports.Duplex = require_stream_duplex9();
      exports.Transform = require_stream_transform9();
      exports.PassThrough = require_stream_passthrough9();
      exports.finished = require_end_of_stream8();
      exports.pipeline = require_pipeline8();
    }
  });

  // node_modules/readable-to-readable/index.js
  var require_readable_to_readable = __commonJS({
    "node_modules/readable-to-readable/index.js"(exports, module) {
      init_shim();
      var { finished: finished4, Readable: Readable5 } = require_readable_browser8();
      function nextLoop() {
        return new Promise((resolve) => setTimeout(resolve, 0));
      }
      var ReadableToReadable = class extends Readable5 {
        constructor(input, { end = true, map, ...args } = {}) {
          super({
            read: ReadableToReadable.readFrom(input, { end, map }),
            ...args
          });
        }
        static readFrom(input, { end = true, map = (v) => v } = {}) {
          let done = false;
          finished4(input, () => {
            done = true;
          });
          const read = async function() {
            while (true) {
              const chunk = input.read();
              if (!chunk) {
                if (done && end) {
                  this.push(null);
                }
                if (done) {
                  return true;
                }
                await nextLoop();
              } else {
                if (!this.push(map(chunk))) {
                  return false;
                }
              }
            }
          };
          return read;
        }
      };
      module.exports = ReadableToReadable;
    }
  });

  // node_modules/@rdfjs/serializer-ntriples/lib/SerializerStream.js
  var require_SerializerStream = __commonJS({
    "node_modules/@rdfjs/serializer-ntriples/lib/SerializerStream.js"(exports, module) {
      init_shim();
      var quadToNTriples = require_to_ntriples4().quadToNTriples;
      var ReadableToReadable = require_readable_to_readable();
      var SerializerStream = class extends ReadableToReadable {
        constructor(input) {
          super(input, {
            map: (quad) => quadToNTriples(quad) + "\n"
          });
        }
      };
      module.exports = SerializerStream;
    }
  });

  // node_modules/@rdfjs/serializer-ntriples/index.js
  var require_serializer_ntriples = __commonJS({
    "node_modules/@rdfjs/serializer-ntriples/index.js"(exports, module) {
      init_shim();
      var SerializerStream = require_SerializerStream();
      var Sink = require_sink();
      var Serializer = class extends Sink {
        constructor() {
          super(SerializerStream);
        }
      };
      module.exports = Serializer;
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser10 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list9 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_shim();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer3 = _require.Buffer;
      var _require2 = require_util2();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer3.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer3.alloc(0);
            var ret = Buffer3.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer3.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy10 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              import_process.default.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              import_process.default.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            import_process.default.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/errors-browser.js
  var require_errors_browser9 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_shim();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state9 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_INVALID_OPT_VALUE = require_errors_browser9().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable10 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser10();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy10();
      var _require = require_state9();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser9().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex10();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex10();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          import_process.default.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding2, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer3.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (isBuf)
          encoding2 = "buffer";
        else if (!encoding2)
          encoding2 = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ending)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding2, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
        if (typeof encoding2 === "string")
          encoding2 = encoding2.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding2);
        this._writableState.defaultEncoding = encoding2;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding2) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer3.from(chunk, encoding2);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding2, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding2);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding2 = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding: encoding2,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding2, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding2, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          import_process.default.nextTick(cb, er);
          import_process.default.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished4 = needFinish(state) || stream.destroyed;
          if (!finished4 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            import_process.default.nextTick(afterWrite, stream, state, finished4, cb);
          } else {
            afterWrite(stream, state, finished4, cb);
          }
        }
      }
      function afterWrite(stream, state, finished4, cb) {
        if (!finished4)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding2 = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding2, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding2, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding2 = null;
        } else if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding2);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            import_process.default.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            import_process.default.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex10 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var Readable5 = require_stream_readable10();
      var Writable = require_stream_writable10();
      require_inherits_browser()(Duplex, Readable5);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable5.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended)
          return;
        import_process.default.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream9 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser9().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once2(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator9 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_shim();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished4 = require_end_of_stream9();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        import_process.default.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              import_process.default.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished4(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser9 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_shim();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable10 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Readable5;
      var Duplex;
      Readable5.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser10();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list9();
      var destroyImpl = require_destroy10();
      var _require = require_state9();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser9().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable5, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex10();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder2().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable5(options) {
        Duplex = Duplex || require_stream_duplex10();
        if (!(this instanceof Readable5))
          return new Readable5(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable5.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable5.prototype.destroy = destroyImpl.destroy;
      Readable5.prototype._undestroy = destroyImpl.undestroy;
      Readable5.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable5.prototype.push = function(chunk, encoding2) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding2 = encoding2 || state.defaultEncoding;
            if (encoding2 !== state.encoding) {
              chunk = Buffer3.from(chunk, encoding2);
              encoding2 = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
      };
      Readable5.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding2) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable5.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable5.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable5.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          import_process.default.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          import_process.default.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable5.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable5.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          import_process.default.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable5.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable5.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              import_process.default.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable5.prototype.addListener = Readable5.prototype.on;
      Readable5.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable5.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable5.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          import_process.default.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable5.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable5.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable5.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator9();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable5.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableBuffer", {
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableFlowing", {
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable5._fromList = fromList;
      Object.defineProperty(Readable5.prototype, "readableLength", {
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          import_process.default.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable5.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser9();
          }
          return from(Readable5, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform10 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform;
      var _require$codes = require_errors_browser9().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex10();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding2) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding2);
      };
      Transform.prototype._transform = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding2, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding2;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough10 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough;
      var Transform = require_stream_transform10();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding2, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline9 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_shim();
      var eos;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser9().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once2(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream9();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/readable-browser.js
  var require_readable_browser9 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_shim();
      exports = module.exports = require_stream_readable10();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable10();
      exports.Duplex = require_stream_duplex10();
      exports.Transform = require_stream_transform10();
      exports.PassThrough = require_stream_passthrough10();
      exports.finished = require_end_of_stream9();
      exports.pipeline = require_pipeline9();
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/lib/ObjectEncoder.js
  var require_ObjectEncoder = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/lib/ObjectEncoder.js"(exports, module) {
      init_shim();
      var ObjectEncoder = class {
        constructor(stream) {
          this.stream = stream;
          this.array = [];
        }
        push(jsonld) {
          this.array.push(jsonld);
        }
        end() {
          this.stream.push(this.array);
          this.stream.push(null);
        }
      };
      module.exports = ObjectEncoder;
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/lib/StringEncoder.js
  var require_StringEncoder = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/lib/StringEncoder.js"(exports, module) {
      init_shim();
      var StringEncoder = class {
        constructor(stream) {
          this.stream = stream;
          this.first = true;
          this.stream.push("[");
        }
        push(jsonld) {
          if (this.first) {
            this.first = false;
          } else {
            this.stream.push(",");
          }
          this.stream.push(JSON.stringify(jsonld));
        }
        end() {
          this.stream.push("]");
          this.stream.push(null);
        }
      };
      module.exports = StringEncoder;
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/lib/SerializerStream.js
  var require_SerializerStream2 = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/lib/SerializerStream.js"(exports, module) {
      init_shim();
      var Readable5 = require_readable_browser9();
      var ObjectEncoder = require_ObjectEncoder();
      var StringEncoder = require_StringEncoder();
      var SerializerStream = class extends Readable5 {
        constructor(input, { encoding: encoding2 = "object" } = {}) {
          super({
            objectMode: true,
            read: () => {
            }
          });
          if (encoding2 === "object") {
            this.encoder = new ObjectEncoder(this);
          }
          if (encoding2 === "string") {
            this.encoder = new StringEncoder(this);
          }
          if (!this.encoder) {
            throw new Error(`unknown encoding: ${encoding2}`);
          }
          input.on("data", (quad) => {
            const jsonld = {};
            let triple6 = jsonld;
            if (quad.graph.termType !== "DefaultGraph") {
              jsonld["@id"] = quad.graph.value;
              jsonld["@graph"] = {};
              triple6 = jsonld["@graph"];
            }
            triple6["@id"] = SerializerStream.subjectValue(quad.subject);
            if (quad.predicate.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
              triple6["@type"] = SerializerStream.subjectValue(quad.object);
            } else {
              triple6[quad.predicate.value] = SerializerStream.objectValue(quad.object);
            }
            this.encoder.push(jsonld);
          });
          input.on("end", () => this.encoder.end());
          input.on("error", (err) => this.emit("error", err));
        }
        static subjectValue(subject) {
          return subject.termType === "BlankNode" ? "_:" + subject.value : subject.value;
        }
        static objectValue(object) {
          if (object.termType === "NamedNode") {
            return { "@id": object.value };
          }
          if (object.termType === "BlankNode") {
            return { "@id": "_:" + object.value };
          }
          if (object.language) {
            return { "@language": object.language, "@value": object.value };
          } else if (object.datatype && object.datatype.value !== "http://www.w3.org/2001/XMLSchema#string") {
            return { "@type": object.datatype.value, "@value": object.value };
          } else {
            return object.value;
          }
        }
      };
      module.exports = SerializerStream;
    }
  });

  // node_modules/@rdfjs/serializer-jsonld/index.js
  var require_serializer_jsonld = __commonJS({
    "node_modules/@rdfjs/serializer-jsonld/index.js"(exports, module) {
      init_shim();
      var SerializerStream = require_SerializerStream2();
      var Sink = require_sink();
      var Serializer = class extends Sink {
        constructor(options) {
          super(SerializerStream, options);
        }
      };
      module.exports = Serializer;
    }
  });

  // node_modules/rdfxml-streaming-parser/node_modules/sax/lib/sax.js
  var require_sax = __commonJS({
    "node_modules/rdfxml-streaming-parser/node_modules/sax/lib/sax.js"(exports) {
      init_shim();
      (function(sax) {
        sax.parser = function(strict, opt) {
          return new SAXParser(strict, opt);
        };
        sax.SAXParser = SAXParser;
        sax.SAXStream = SAXStream;
        sax.createStream = createStream;
        sax.MAX_BUFFER_LENGTH = 64 * 1024;
        var buffers = [
          "comment",
          "sgmlDecl",
          "textNode",
          "tagName",
          "doctype",
          "procInstName",
          "procInstBody",
          "entity",
          "attribName",
          "attribValue",
          "cdata",
          "script"
        ];
        sax.EVENTS = [
          "text",
          "processinginstruction",
          "sgmldeclaration",
          "doctype",
          "comment",
          "opentagstart",
          "attribute",
          "opentag",
          "closetag",
          "opencdata",
          "cdata",
          "closecdata",
          "error",
          "end",
          "ready",
          "script",
          "opennamespace",
          "closenamespace"
        ];
        function SAXParser(strict, opt) {
          if (!(this instanceof SAXParser)) {
            return new SAXParser(strict, opt);
          }
          var parser = this;
          clearBuffers(parser);
          parser.q = parser.c = "";
          parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
          parser.opt = opt || {};
          parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
          parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
          parser.tags = [];
          parser.closed = parser.closedRoot = parser.sawRoot = false;
          parser.tag = parser.error = null;
          parser.strict = !!strict;
          parser.noscript = !!(strict || parser.opt.noscript);
          parser.state = S.BEGIN;
          parser.strictEntities = parser.opt.strictEntities;
          parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
          parser.attribList = [];
          if (parser.opt.xmlns) {
            parser.ns = Object.create(rootNS);
          }
          parser.trackPosition = parser.opt.position !== false;
          if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0;
          }
          emit(parser, "onready");
        }
        if (!Object.create) {
          Object.create = function(o) {
            function F() {
            }
            F.prototype = o;
            var newf = new F();
            return newf;
          };
        }
        if (!Object.keys) {
          Object.keys = function(o) {
            var a = [];
            for (var i in o)
              if (o.hasOwnProperty(i))
                a.push(i);
            return a;
          };
        }
        function checkBufferLength(parser) {
          var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
          var maxActual = 0;
          for (var i = 0, l = buffers.length; i < l; i++) {
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) {
              switch (buffers[i]) {
                case "textNode":
                  closeText(parser);
                  break;
                case "cdata":
                  emitNode(parser, "oncdata", parser.cdata);
                  parser.cdata = "";
                  break;
                case "script":
                  emitNode(parser, "onscript", parser.script);
                  parser.script = "";
                  break;
                default:
                  error(parser, "Max buffer length exceeded: " + buffers[i]);
              }
            }
            maxActual = Math.max(maxActual, len);
          }
          var m = sax.MAX_BUFFER_LENGTH - maxActual;
          parser.bufferCheckPosition = m + parser.position;
        }
        function clearBuffers(parser) {
          for (var i = 0, l = buffers.length; i < l; i++) {
            parser[buffers[i]] = "";
          }
        }
        function flushBuffers(parser) {
          closeText(parser);
          if (parser.cdata !== "") {
            emitNode(parser, "oncdata", parser.cdata);
            parser.cdata = "";
          }
          if (parser.script !== "") {
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
        }
        SAXParser.prototype = {
          end: function() {
            end(this);
          },
          write,
          resume: function() {
            this.error = null;
            return this;
          },
          close: function() {
            return this.write(null);
          },
          flush: function() {
            flushBuffers(this);
          }
        };
        var Stream;
        try {
          Stream = require_stream_browserify().Stream;
        } catch (ex) {
          Stream = function() {
          };
        }
        var streamWraps = sax.EVENTS.filter(function(ev) {
          return ev !== "error" && ev !== "end";
        });
        function createStream(strict, opt) {
          return new SAXStream(strict, opt);
        }
        function SAXStream(strict, opt) {
          if (!(this instanceof SAXStream)) {
            return new SAXStream(strict, opt);
          }
          Stream.apply(this);
          this._parser = new SAXParser(strict, opt);
          this.writable = true;
          this.readable = true;
          var me = this;
          this._parser.onend = function() {
            me.emit("end");
          };
          this._parser.onerror = function(er) {
            me.emit("error", er);
            me._parser.error = null;
          };
          this._decoder = null;
          streamWraps.forEach(function(ev) {
            Object.defineProperty(me, "on" + ev, {
              get: function() {
                return me._parser["on" + ev];
              },
              set: function(h) {
                if (!h) {
                  me.removeAllListeners(ev);
                  me._parser["on" + ev] = h;
                  return h;
                }
                me.on(ev, h);
              },
              enumerable: true,
              configurable: false
            });
          });
        }
        SAXStream.prototype = Object.create(Stream.prototype, {
          constructor: {
            value: SAXStream
          }
        });
        SAXStream.prototype.write = function(data) {
          if (typeof import_buffer.Buffer === "function" && typeof import_buffer.Buffer.isBuffer === "function" && import_buffer.Buffer.isBuffer(data)) {
            if (!this._decoder) {
              var SD = require_string_decoder2().StringDecoder;
              this._decoder = new SD("utf8");
            }
            data = this._decoder.write(data);
          }
          this._parser.write(data.toString());
          this.emit("data", data);
          return true;
        };
        SAXStream.prototype.end = function(chunk) {
          if (chunk && chunk.length) {
            this.write(chunk);
          }
          this._parser.end();
          return true;
        };
        SAXStream.prototype.on = function(ev, handler2) {
          var me = this;
          if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
            me._parser["on" + ev] = function() {
              var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
              args.splice(0, 0, ev);
              me.emit.apply(me, args);
            };
          }
          return Stream.prototype.on.call(me, ev, handler2);
        };
        var CDATA = "[CDATA[";
        var DOCTYPE = "DOCTYPE";
        var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
        var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
        var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
        var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        function isWhitespace(c) {
          return c === " " || c === "\n" || c === "\r" || c === "	";
        }
        function isQuote(c) {
          return c === '"' || c === "'";
        }
        function isAttribEnd(c) {
          return c === ">" || isWhitespace(c);
        }
        function isMatch(regex, c) {
          return regex.test(c);
        }
        function notMatch(regex, c) {
          return !isMatch(regex, c);
        }
        var S = 0;
        sax.STATE = {
          BEGIN: S++,
          BEGIN_WHITESPACE: S++,
          TEXT: S++,
          TEXT_ENTITY: S++,
          OPEN_WAKA: S++,
          SGML_DECL: S++,
          SGML_DECL_QUOTED: S++,
          DOCTYPE: S++,
          DOCTYPE_QUOTED: S++,
          DOCTYPE_DTD: S++,
          DOCTYPE_DTD_QUOTED: S++,
          COMMENT_STARTING: S++,
          COMMENT: S++,
          COMMENT_ENDING: S++,
          COMMENT_ENDED: S++,
          CDATA: S++,
          CDATA_ENDING: S++,
          CDATA_ENDING_2: S++,
          PROC_INST: S++,
          PROC_INST_BODY: S++,
          PROC_INST_ENDING: S++,
          OPEN_TAG: S++,
          OPEN_TAG_SLASH: S++,
          ATTRIB: S++,
          ATTRIB_NAME: S++,
          ATTRIB_NAME_SAW_WHITE: S++,
          ATTRIB_VALUE: S++,
          ATTRIB_VALUE_QUOTED: S++,
          ATTRIB_VALUE_CLOSED: S++,
          ATTRIB_VALUE_UNQUOTED: S++,
          ATTRIB_VALUE_ENTITY_Q: S++,
          ATTRIB_VALUE_ENTITY_U: S++,
          CLOSE_TAG: S++,
          CLOSE_TAG_SAW_WHITE: S++,
          SCRIPT: S++,
          SCRIPT_ENDING: S++
        };
        sax.XML_ENTITIES = {
          "amp": "&",
          "gt": ">",
          "lt": "<",
          "quot": '"',
          "apos": "'"
        };
        sax.ENTITIES = {
          "amp": "&",
          "gt": ">",
          "lt": "<",
          "quot": '"',
          "apos": "'",
          "AElig": 198,
          "Aacute": 193,
          "Acirc": 194,
          "Agrave": 192,
          "Aring": 197,
          "Atilde": 195,
          "Auml": 196,
          "Ccedil": 199,
          "ETH": 208,
          "Eacute": 201,
          "Ecirc": 202,
          "Egrave": 200,
          "Euml": 203,
          "Iacute": 205,
          "Icirc": 206,
          "Igrave": 204,
          "Iuml": 207,
          "Ntilde": 209,
          "Oacute": 211,
          "Ocirc": 212,
          "Ograve": 210,
          "Oslash": 216,
          "Otilde": 213,
          "Ouml": 214,
          "THORN": 222,
          "Uacute": 218,
          "Ucirc": 219,
          "Ugrave": 217,
          "Uuml": 220,
          "Yacute": 221,
          "aacute": 225,
          "acirc": 226,
          "aelig": 230,
          "agrave": 224,
          "aring": 229,
          "atilde": 227,
          "auml": 228,
          "ccedil": 231,
          "eacute": 233,
          "ecirc": 234,
          "egrave": 232,
          "eth": 240,
          "euml": 235,
          "iacute": 237,
          "icirc": 238,
          "igrave": 236,
          "iuml": 239,
          "ntilde": 241,
          "oacute": 243,
          "ocirc": 244,
          "ograve": 242,
          "oslash": 248,
          "otilde": 245,
          "ouml": 246,
          "szlig": 223,
          "thorn": 254,
          "uacute": 250,
          "ucirc": 251,
          "ugrave": 249,
          "uuml": 252,
          "yacute": 253,
          "yuml": 255,
          "copy": 169,
          "reg": 174,
          "nbsp": 160,
          "iexcl": 161,
          "cent": 162,
          "pound": 163,
          "curren": 164,
          "yen": 165,
          "brvbar": 166,
          "sect": 167,
          "uml": 168,
          "ordf": 170,
          "laquo": 171,
          "not": 172,
          "shy": 173,
          "macr": 175,
          "deg": 176,
          "plusmn": 177,
          "sup1": 185,
          "sup2": 178,
          "sup3": 179,
          "acute": 180,
          "micro": 181,
          "para": 182,
          "middot": 183,
          "cedil": 184,
          "ordm": 186,
          "raquo": 187,
          "frac14": 188,
          "frac12": 189,
          "frac34": 190,
          "iquest": 191,
          "times": 215,
          "divide": 247,
          "OElig": 338,
          "oelig": 339,
          "Scaron": 352,
          "scaron": 353,
          "Yuml": 376,
          "fnof": 402,
          "circ": 710,
          "tilde": 732,
          "Alpha": 913,
          "Beta": 914,
          "Gamma": 915,
          "Delta": 916,
          "Epsilon": 917,
          "Zeta": 918,
          "Eta": 919,
          "Theta": 920,
          "Iota": 921,
          "Kappa": 922,
          "Lambda": 923,
          "Mu": 924,
          "Nu": 925,
          "Xi": 926,
          "Omicron": 927,
          "Pi": 928,
          "Rho": 929,
          "Sigma": 931,
          "Tau": 932,
          "Upsilon": 933,
          "Phi": 934,
          "Chi": 935,
          "Psi": 936,
          "Omega": 937,
          "alpha": 945,
          "beta": 946,
          "gamma": 947,
          "delta": 948,
          "epsilon": 949,
          "zeta": 950,
          "eta": 951,
          "theta": 952,
          "iota": 953,
          "kappa": 954,
          "lambda": 955,
          "mu": 956,
          "nu": 957,
          "xi": 958,
          "omicron": 959,
          "pi": 960,
          "rho": 961,
          "sigmaf": 962,
          "sigma": 963,
          "tau": 964,
          "upsilon": 965,
          "phi": 966,
          "chi": 967,
          "psi": 968,
          "omega": 969,
          "thetasym": 977,
          "upsih": 978,
          "piv": 982,
          "ensp": 8194,
          "emsp": 8195,
          "thinsp": 8201,
          "zwnj": 8204,
          "zwj": 8205,
          "lrm": 8206,
          "rlm": 8207,
          "ndash": 8211,
          "mdash": 8212,
          "lsquo": 8216,
          "rsquo": 8217,
          "sbquo": 8218,
          "ldquo": 8220,
          "rdquo": 8221,
          "bdquo": 8222,
          "dagger": 8224,
          "Dagger": 8225,
          "bull": 8226,
          "hellip": 8230,
          "permil": 8240,
          "prime": 8242,
          "Prime": 8243,
          "lsaquo": 8249,
          "rsaquo": 8250,
          "oline": 8254,
          "frasl": 8260,
          "euro": 8364,
          "image": 8465,
          "weierp": 8472,
          "real": 8476,
          "trade": 8482,
          "alefsym": 8501,
          "larr": 8592,
          "uarr": 8593,
          "rarr": 8594,
          "darr": 8595,
          "harr": 8596,
          "crarr": 8629,
          "lArr": 8656,
          "uArr": 8657,
          "rArr": 8658,
          "dArr": 8659,
          "hArr": 8660,
          "forall": 8704,
          "part": 8706,
          "exist": 8707,
          "empty": 8709,
          "nabla": 8711,
          "isin": 8712,
          "notin": 8713,
          "ni": 8715,
          "prod": 8719,
          "sum": 8721,
          "minus": 8722,
          "lowast": 8727,
          "radic": 8730,
          "prop": 8733,
          "infin": 8734,
          "ang": 8736,
          "and": 8743,
          "or": 8744,
          "cap": 8745,
          "cup": 8746,
          "int": 8747,
          "there4": 8756,
          "sim": 8764,
          "cong": 8773,
          "asymp": 8776,
          "ne": 8800,
          "equiv": 8801,
          "le": 8804,
          "ge": 8805,
          "sub": 8834,
          "sup": 8835,
          "nsub": 8836,
          "sube": 8838,
          "supe": 8839,
          "oplus": 8853,
          "otimes": 8855,
          "perp": 8869,
          "sdot": 8901,
          "lceil": 8968,
          "rceil": 8969,
          "lfloor": 8970,
          "rfloor": 8971,
          "lang": 9001,
          "rang": 9002,
          "loz": 9674,
          "spades": 9824,
          "clubs": 9827,
          "hearts": 9829,
          "diams": 9830
        };
        Object.keys(sax.ENTITIES).forEach(function(key) {
          var e = sax.ENTITIES[key];
          var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
          sax.ENTITIES[key] = s2;
        });
        for (var s in sax.STATE) {
          sax.STATE[sax.STATE[s]] = s;
        }
        S = sax.STATE;
        function emit(parser, event, data) {
          parser[event] && parser[event](data);
        }
        function emitNode(parser, nodeType, data) {
          if (parser.textNode)
            closeText(parser);
          emit(parser, nodeType, data);
        }
        function closeText(parser) {
          parser.textNode = textopts(parser.opt, parser.textNode);
          if (parser.textNode)
            emit(parser, "ontext", parser.textNode);
          parser.textNode = "";
        }
        function textopts(opt, text5) {
          if (opt.trim)
            text5 = text5.trim();
          if (opt.normalize)
            text5 = text5.replace(/\s+/g, " ");
          return text5;
        }
        function error(parser, er) {
          closeText(parser);
          if (parser.trackPosition) {
            er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
          }
          er = new Error(er);
          parser.error = er;
          emit(parser, "onerror", er);
          return parser;
        }
        function end(parser) {
          if (parser.sawRoot && !parser.closedRoot)
            strictFail(parser, "Unclosed root tag");
          if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
            error(parser, "Unexpected end");
          }
          closeText(parser);
          parser.c = "";
          parser.closed = true;
          emit(parser, "onend");
          SAXParser.call(parser, parser.strict, parser.opt);
          return parser;
        }
        function strictFail(parser, message) {
          if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
            throw new Error("bad call to strictFail");
          }
          if (parser.strict) {
            error(parser, message);
          }
        }
        function newTag(parser) {
          if (!parser.strict)
            parser.tagName = parser.tagName[parser.looseCase]();
          var parent = parser.tags[parser.tags.length - 1] || parser;
          var tag = parser.tag = { name: parser.tagName, attributes: {} };
          if (parser.opt.xmlns) {
            tag.ns = parent.ns;
          }
          parser.attribList.length = 0;
          emitNode(parser, "onopentagstart", tag);
        }
        function qname(name, attribute) {
          var i = name.indexOf(":");
          var qualName = i < 0 ? ["", name] : name.split(":");
          var prefix = qualName[0];
          var local = qualName[1];
          if (attribute && name === "xmlns") {
            prefix = "xmlns";
            local = "";
          }
          return { prefix, local };
        }
        function attrib(parser) {
          if (!parser.strict) {
            parser.attribName = parser.attribName[parser.looseCase]();
          }
          if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = "";
            return;
          }
          if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === "xmlns") {
              if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
              } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
              } else {
                var tag = parser.tag;
                var parent = parser.tags[parser.tags.length - 1] || parser;
                if (tag.ns === parent.ns) {
                  tag.ns = Object.create(parent.ns);
                }
                tag.ns[local] = parser.attribValue;
              }
            }
            parser.attribList.push([parser.attribName, parser.attribValue]);
          } else {
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, "onattribute", {
              name: parser.attribName,
              value: parser.attribValue
            });
          }
          parser.attribName = parser.attribValue = "";
        }
        function openTag(parser, selfClosing) {
          if (parser.opt.xmlns) {
            var tag = parser.tag;
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || "";
            if (tag.prefix && !tag.uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
              tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) {
              Object.keys(tag.ns).forEach(function(p) {
                emitNode(parser, "onopennamespace", {
                  prefix: p,
                  uri: tag.ns[p]
                });
              });
            }
            for (var i = 0, l = parser.attribList.length; i < l; i++) {
              var nv = parser.attribList[i];
              var name = nv[0];
              var value = nv[1];
              var qualName = qname(name, true);
              var prefix = qualName.prefix;
              var local = qualName.local;
              var uri = prefix === "" ? "" : tag.ns[prefix] || "";
              var a = {
                name,
                value,
                prefix,
                local,
                uri
              };
              if (prefix && prefix !== "xmlns" && !uri) {
                strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
                a.uri = prefix;
              }
              parser.tag.attributes[name] = a;
              emitNode(parser, "onattribute", a);
            }
            parser.attribList.length = 0;
          }
          parser.tag.isSelfClosing = !!selfClosing;
          parser.sawRoot = true;
          parser.tags.push(parser.tag);
          emitNode(parser, "onopentag", parser.tag);
          if (!selfClosing) {
            if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
              parser.state = S.SCRIPT;
            } else {
              parser.state = S.TEXT;
            }
            parser.tag = null;
            parser.tagName = "";
          }
          parser.attribName = parser.attribValue = "";
          parser.attribList.length = 0;
        }
        function closeTag(parser) {
          if (!parser.tagName) {
            strictFail(parser, "Weird empty close tag.");
            parser.textNode += "</>";
            parser.state = S.TEXT;
            return;
          }
          if (parser.script) {
            if (parser.tagName !== "script") {
              parser.script += "</" + parser.tagName + ">";
              parser.tagName = "";
              parser.state = S.SCRIPT;
              return;
            }
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
          var t = parser.tags.length;
          var tagName = parser.tagName;
          if (!parser.strict) {
            tagName = tagName[parser.looseCase]();
          }
          var closeTo = tagName;
          while (t--) {
            var close = parser.tags[t];
            if (close.name !== closeTo) {
              strictFail(parser, "Unexpected close tag");
            } else {
              break;
            }
          }
          if (t < 0) {
            strictFail(parser, "Unmatched closing tag: " + parser.tagName);
            parser.textNode += "</" + parser.tagName + ">";
            parser.state = S.TEXT;
            return;
          }
          parser.tagName = tagName;
          var s2 = parser.tags.length;
          while (s2-- > t) {
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, "onclosetag", parser.tagName);
            var x = {};
            for (var i in tag.ns) {
              x[i] = tag.ns[i];
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
              Object.keys(tag.ns).forEach(function(p) {
                var n = tag.ns[p];
                emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
              });
            }
          }
          if (t === 0)
            parser.closedRoot = true;
          parser.tagName = parser.attribValue = parser.attribName = "";
          parser.attribList.length = 0;
          parser.state = S.TEXT;
        }
        function parseEntity(parser) {
          var entity = parser.entity;
          var entityLC = entity.toLowerCase();
          var num;
          var numStr = "";
          if (parser.ENTITIES[entity]) {
            return parser.ENTITIES[entity];
          }
          if (parser.ENTITIES[entityLC]) {
            return parser.ENTITIES[entityLC];
          }
          entity = entityLC;
          if (entity.charAt(0) === "#") {
            if (entity.charAt(1) === "x") {
              entity = entity.slice(2);
              num = parseInt(entity, 16);
              numStr = num.toString(16);
            } else {
              entity = entity.slice(1);
              num = parseInt(entity, 10);
              numStr = num.toString(10);
            }
          }
          entity = entity.replace(/^0+/, "");
          if (isNaN(num) || numStr.toLowerCase() !== entity) {
            strictFail(parser, "Invalid character entity");
            return "&" + parser.entity + ";";
          }
          return String.fromCodePoint(num);
        }
        function beginWhiteSpace(parser, c) {
          if (c === "<") {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else if (!isWhitespace(c)) {
            strictFail(parser, "Non-whitespace before first tag.");
            parser.textNode = c;
            parser.state = S.TEXT;
          }
        }
        function charAt(chunk, i) {
          var result = "";
          if (i < chunk.length) {
            result = chunk.charAt(i);
          }
          return result;
        }
        function write(chunk) {
          var parser = this;
          if (this.error) {
            throw this.error;
          }
          if (parser.closed) {
            return error(parser, "Cannot write after close. Assign an onready handler.");
          }
          if (chunk === null) {
            return end(parser);
          }
          if (typeof chunk === "object") {
            chunk = chunk.toString();
          }
          var i = 0;
          var c = "";
          while (true) {
            c = charAt(chunk, i++);
            parser.c = c;
            if (!c) {
              break;
            }
            if (parser.trackPosition) {
              parser.position++;
              if (c === "\n") {
                parser.line++;
                parser.column = 0;
              } else {
                parser.column++;
              }
            }
            switch (parser.state) {
              case S.BEGIN:
                parser.state = S.BEGIN_WHITESPACE;
                if (c === "\uFEFF") {
                  continue;
                }
                beginWhiteSpace(parser, c);
                continue;
              case S.BEGIN_WHITESPACE:
                beginWhiteSpace(parser, c);
                continue;
              case S.TEXT:
                if (parser.sawRoot && !parser.closedRoot) {
                  var starti = i - 1;
                  while (c && c !== "<" && c !== "&") {
                    c = charAt(chunk, i++);
                    if (c && parser.trackPosition) {
                      parser.position++;
                      if (c === "\n") {
                        parser.line++;
                        parser.column = 0;
                      } else {
                        parser.column++;
                      }
                    }
                  }
                  parser.textNode += chunk.substring(starti, i - 1);
                }
                if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                  parser.state = S.OPEN_WAKA;
                  parser.startTagPosition = parser.position;
                } else {
                  if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                    strictFail(parser, "Text data outside of root node.");
                  }
                  if (c === "&") {
                    parser.state = S.TEXT_ENTITY;
                  } else {
                    parser.textNode += c;
                  }
                }
                continue;
              case S.SCRIPT:
                if (c === "<") {
                  parser.state = S.SCRIPT_ENDING;
                } else {
                  parser.script += c;
                }
                continue;
              case S.SCRIPT_ENDING:
                if (c === "/") {
                  parser.state = S.CLOSE_TAG;
                } else {
                  parser.script += "<" + c;
                  parser.state = S.SCRIPT;
                }
                continue;
              case S.OPEN_WAKA:
                if (c === "!") {
                  parser.state = S.SGML_DECL;
                  parser.sgmlDecl = "";
                } else if (isWhitespace(c)) {
                } else if (isMatch(nameStart, c)) {
                  parser.state = S.OPEN_TAG;
                  parser.tagName = c;
                } else if (c === "/") {
                  parser.state = S.CLOSE_TAG;
                  parser.tagName = "";
                } else if (c === "?") {
                  parser.state = S.PROC_INST;
                  parser.procInstName = parser.procInstBody = "";
                } else {
                  strictFail(parser, "Unencoded <");
                  if (parser.startTagPosition + 1 < parser.position) {
                    var pad = parser.position - parser.startTagPosition;
                    c = new Array(pad).join(" ") + c;
                  }
                  parser.textNode += "<" + c;
                  parser.state = S.TEXT;
                }
                continue;
              case S.SGML_DECL:
                if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                  emitNode(parser, "onopencdata");
                  parser.state = S.CDATA;
                  parser.sgmlDecl = "";
                  parser.cdata = "";
                } else if (parser.sgmlDecl + c === "--") {
                  parser.state = S.COMMENT;
                  parser.comment = "";
                  parser.sgmlDecl = "";
                } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                  parser.state = S.DOCTYPE;
                  if (parser.doctype || parser.sawRoot) {
                    strictFail(parser, "Inappropriately located doctype declaration");
                  }
                  parser.doctype = "";
                  parser.sgmlDecl = "";
                } else if (c === ">") {
                  emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                  parser.sgmlDecl = "";
                  parser.state = S.TEXT;
                } else if (isQuote(c)) {
                  parser.state = S.SGML_DECL_QUOTED;
                  parser.sgmlDecl += c;
                } else {
                  parser.sgmlDecl += c;
                }
                continue;
              case S.SGML_DECL_QUOTED:
                if (c === parser.q) {
                  parser.state = S.SGML_DECL;
                  parser.q = "";
                }
                parser.sgmlDecl += c;
                continue;
              case S.DOCTYPE:
                if (c === ">") {
                  parser.state = S.TEXT;
                  emitNode(parser, "ondoctype", parser.doctype);
                  parser.doctype = true;
                } else {
                  parser.doctype += c;
                  if (c === "[") {
                    parser.state = S.DOCTYPE_DTD;
                  } else if (isQuote(c)) {
                    parser.state = S.DOCTYPE_QUOTED;
                    parser.q = c;
                  }
                }
                continue;
              case S.DOCTYPE_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.q = "";
                  parser.state = S.DOCTYPE;
                }
                continue;
              case S.DOCTYPE_DTD:
                parser.doctype += c;
                if (c === "]") {
                  parser.state = S.DOCTYPE;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_DTD_QUOTED;
                  parser.q = c;
                }
                continue;
              case S.DOCTYPE_DTD_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.state = S.DOCTYPE_DTD;
                  parser.q = "";
                }
                continue;
              case S.COMMENT:
                if (c === "-") {
                  parser.state = S.COMMENT_ENDING;
                } else {
                  parser.comment += c;
                }
                continue;
              case S.COMMENT_ENDING:
                if (c === "-") {
                  parser.state = S.COMMENT_ENDED;
                  parser.comment = textopts(parser.opt, parser.comment);
                  if (parser.comment) {
                    emitNode(parser, "oncomment", parser.comment);
                  }
                  parser.comment = "";
                } else {
                  parser.comment += "-" + c;
                  parser.state = S.COMMENT;
                }
                continue;
              case S.COMMENT_ENDED:
                if (c !== ">") {
                  strictFail(parser, "Malformed comment");
                  parser.comment += "--" + c;
                  parser.state = S.COMMENT;
                } else {
                  parser.state = S.TEXT;
                }
                continue;
              case S.CDATA:
                if (c === "]") {
                  parser.state = S.CDATA_ENDING;
                } else {
                  parser.cdata += c;
                }
                continue;
              case S.CDATA_ENDING:
                if (c === "]") {
                  parser.state = S.CDATA_ENDING_2;
                } else {
                  parser.cdata += "]" + c;
                  parser.state = S.CDATA;
                }
                continue;
              case S.CDATA_ENDING_2:
                if (c === ">") {
                  if (parser.cdata) {
                    emitNode(parser, "oncdata", parser.cdata);
                  }
                  emitNode(parser, "onclosecdata");
                  parser.cdata = "";
                  parser.state = S.TEXT;
                } else if (c === "]") {
                  parser.cdata += "]";
                } else {
                  parser.cdata += "]]" + c;
                  parser.state = S.CDATA;
                }
                continue;
              case S.PROC_INST:
                if (c === "?") {
                  parser.state = S.PROC_INST_ENDING;
                } else if (isWhitespace(c)) {
                  parser.state = S.PROC_INST_BODY;
                } else {
                  parser.procInstName += c;
                }
                continue;
              case S.PROC_INST_BODY:
                if (!parser.procInstBody && isWhitespace(c)) {
                  continue;
                } else if (c === "?") {
                  parser.state = S.PROC_INST_ENDING;
                } else {
                  parser.procInstBody += c;
                }
                continue;
              case S.PROC_INST_ENDING:
                if (c === ">") {
                  emitNode(parser, "onprocessinginstruction", {
                    name: parser.procInstName,
                    body: parser.procInstBody
                  });
                  parser.procInstName = parser.procInstBody = "";
                  parser.state = S.TEXT;
                } else {
                  parser.procInstBody += "?" + c;
                  parser.state = S.PROC_INST_BODY;
                }
                continue;
              case S.OPEN_TAG:
                if (isMatch(nameBody, c)) {
                  parser.tagName += c;
                } else {
                  newTag(parser);
                  if (c === ">") {
                    openTag(parser);
                  } else if (c === "/") {
                    parser.state = S.OPEN_TAG_SLASH;
                  } else {
                    if (!isWhitespace(c)) {
                      strictFail(parser, "Invalid character in tag name");
                    }
                    parser.state = S.ATTRIB;
                  }
                }
                continue;
              case S.OPEN_TAG_SLASH:
                if (c === ">") {
                  openTag(parser, true);
                  closeTag(parser);
                } else {
                  strictFail(parser, "Forward-slash in opening tag not followed by >");
                  parser.state = S.ATTRIB;
                }
                continue;
              case S.ATTRIB:
                if (isWhitespace(c)) {
                  continue;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_NAME:
                if (c === "=") {
                  parser.state = S.ATTRIB_VALUE;
                } else if (c === ">") {
                  strictFail(parser, "Attribute without value");
                  parser.attribValue = parser.attribName;
                  attrib(parser);
                  openTag(parser);
                } else if (isWhitespace(c)) {
                  parser.state = S.ATTRIB_NAME_SAW_WHITE;
                } else if (isMatch(nameBody, c)) {
                  parser.attribName += c;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_NAME_SAW_WHITE:
                if (c === "=") {
                  parser.state = S.ATTRIB_VALUE;
                } else if (isWhitespace(c)) {
                  continue;
                } else {
                  strictFail(parser, "Attribute without value");
                  parser.tag.attributes[parser.attribName] = "";
                  parser.attribValue = "";
                  emitNode(parser, "onattribute", {
                    name: parser.attribName,
                    value: ""
                  });
                  parser.attribName = "";
                  if (c === ">") {
                    openTag(parser);
                  } else if (isMatch(nameStart, c)) {
                    parser.attribName = c;
                    parser.state = S.ATTRIB_NAME;
                  } else {
                    strictFail(parser, "Invalid attribute name");
                    parser.state = S.ATTRIB;
                  }
                }
                continue;
              case S.ATTRIB_VALUE:
                if (isWhitespace(c)) {
                  continue;
                } else if (isQuote(c)) {
                  parser.q = c;
                  parser.state = S.ATTRIB_VALUE_QUOTED;
                } else {
                  strictFail(parser, "Unquoted attribute value");
                  parser.state = S.ATTRIB_VALUE_UNQUOTED;
                  parser.attribValue = c;
                }
                continue;
              case S.ATTRIB_VALUE_QUOTED:
                if (c !== parser.q) {
                  if (c === "&") {
                    parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                parser.q = "";
                parser.state = S.ATTRIB_VALUE_CLOSED;
                continue;
              case S.ATTRIB_VALUE_CLOSED:
                if (isWhitespace(c)) {
                  parser.state = S.ATTRIB;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                  strictFail(parser, "No whitespace between attributes");
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_VALUE_UNQUOTED:
                if (!isAttribEnd(c)) {
                  if (c === "&") {
                    parser.state = S.ATTRIB_VALUE_ENTITY_U;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                if (c === ">") {
                  openTag(parser);
                } else {
                  parser.state = S.ATTRIB;
                }
                continue;
              case S.CLOSE_TAG:
                if (!parser.tagName) {
                  if (isWhitespace(c)) {
                    continue;
                  } else if (notMatch(nameStart, c)) {
                    if (parser.script) {
                      parser.script += "</" + c;
                      parser.state = S.SCRIPT;
                    } else {
                      strictFail(parser, "Invalid tagname in closing tag.");
                    }
                  } else {
                    parser.tagName = c;
                  }
                } else if (c === ">") {
                  closeTag(parser);
                } else if (isMatch(nameBody, c)) {
                  parser.tagName += c;
                } else if (parser.script) {
                  parser.script += "</" + parser.tagName;
                  parser.tagName = "";
                  parser.state = S.SCRIPT;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid tagname in closing tag");
                  }
                  parser.state = S.CLOSE_TAG_SAW_WHITE;
                }
                continue;
              case S.CLOSE_TAG_SAW_WHITE:
                if (isWhitespace(c)) {
                  continue;
                }
                if (c === ">") {
                  closeTag(parser);
                } else {
                  strictFail(parser, "Invalid characters in closing tag");
                }
                continue;
              case S.TEXT_ENTITY:
              case S.ATTRIB_VALUE_ENTITY_Q:
              case S.ATTRIB_VALUE_ENTITY_U:
                var returnState;
                var buffer;
                switch (parser.state) {
                  case S.TEXT_ENTITY:
                    returnState = S.TEXT;
                    buffer = "textNode";
                    break;
                  case S.ATTRIB_VALUE_ENTITY_Q:
                    returnState = S.ATTRIB_VALUE_QUOTED;
                    buffer = "attribValue";
                    break;
                  case S.ATTRIB_VALUE_ENTITY_U:
                    returnState = S.ATTRIB_VALUE_UNQUOTED;
                    buffer = "attribValue";
                    break;
                }
                if (c === ";") {
                  parser[buffer] += parseEntity(parser);
                  parser.entity = "";
                  parser.state = returnState;
                } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                  parser.entity += c;
                } else {
                  strictFail(parser, "Invalid character in entity name");
                  parser[buffer] += "&" + parser.entity + c;
                  parser.entity = "";
                  parser.state = returnState;
                }
                continue;
              default:
                throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
          if (parser.position >= parser.bufferCheckPosition) {
            checkBufferLength(parser);
          }
          return parser;
        }
        if (!String.fromCodePoint) {
          (function() {
            var stringFromCharCode = String.fromCharCode;
            var floor = Math.floor;
            var fromCodePoint = function() {
              var MAX_SIZE = 16384;
              var codeUnits = [];
              var highSurrogate;
              var lowSurrogate;
              var index = -1;
              var length = arguments.length;
              if (!length) {
                return "";
              }
              var result = "";
              while (++index < length) {
                var codePoint = Number(arguments[index]);
                if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
                  throw RangeError("Invalid code point: " + codePoint);
                }
                if (codePoint <= 65535) {
                  codeUnits.push(codePoint);
                } else {
                  codePoint -= 65536;
                  highSurrogate = (codePoint >> 10) + 55296;
                  lowSurrogate = codePoint % 1024 + 56320;
                  codeUnits.push(highSurrogate, lowSurrogate);
                }
                if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                  result += stringFromCharCode.apply(null, codeUnits);
                  codeUnits.length = 0;
                }
              }
              return result;
            };
            if (Object.defineProperty) {
              Object.defineProperty(String, "fromCodePoint", {
                value: fromCodePoint,
                configurable: true,
                writable: true
              });
            } else {
              String.fromCodePoint = fromCodePoint;
            }
          })();
        }
      })(typeof exports === "undefined" ? exports.sax = {} : exports);
    }
  });

  // node_modules/rdfxml-streaming-parser/lib/ParseError.js
  var require_ParseError = __commonJS({
    "node_modules/rdfxml-streaming-parser/lib/ParseError.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseError = void 0;
      var ParseError = class extends Error {
        constructor(parser, message) {
          const saxParser = parser.saxStream._parser;
          super(parser.trackPosition ? `Line ${saxParser.line + 1} column ${saxParser.column + 1}: ${message}` : message);
        }
      };
      exports.ParseError = ParseError;
    }
  });

  // node_modules/rdfxml-streaming-parser/lib/RdfXmlParser.js
  var require_RdfXmlParser = __commonJS({
    "node_modules/rdfxml-streaming-parser/lib/RdfXmlParser.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParseType = exports.RdfXmlParser = void 0;
      var relative_to_absolute_iri_1 = require_relative_to_absolute_iri();
      var sax_1 = require_sax();
      var stream_1 = require_stream_browserify();
      var ParseError_1 = require_ParseError();
      var rdf_data_factory_1 = require_rdf_data_factory();
      var RdfXmlParser = class extends stream_1.Transform {
        constructor(args) {
          super({ readableObjectMode: true });
          this.activeTagStack = [];
          this.nodeIds = {};
          if (args) {
            Object.assign(this, args);
            this.options = args;
          }
          if (!this.dataFactory) {
            this.dataFactory = new rdf_data_factory_1.DataFactory();
          }
          if (!this.baseIRI) {
            this.baseIRI = "";
          }
          if (!this.defaultGraph) {
            this.defaultGraph = this.dataFactory.defaultGraph();
          }
          this.saxStream = sax_1.createStream(this.strict, { xmlns: false, position: this.trackPosition });
          if (!this.strict) {
            this.saxStream._parser.looseCase = "toString";
          }
          this.attachSaxListeners();
        }
        static parseNamespace(tag, parentTag) {
          const thisNs = {};
          let hasNs = false;
          for (const attributeKey in tag.attributes) {
            if (attributeKey.startsWith("xmlns")) {
              if (attributeKey.length === 5) {
                hasNs = true;
                thisNs[""] = tag.attributes[attributeKey];
              } else if (attributeKey.charAt(5) === ":") {
                hasNs = true;
                thisNs[attributeKey.substr(6)] = tag.attributes[attributeKey];
              }
            }
          }
          const parentNs = parentTag && parentTag.ns ? parentTag.ns : [RdfXmlParser.DEFAULT_NS];
          return hasNs ? parentNs.concat([thisNs]) : parentNs;
        }
        static expandPrefixedTerm(term, ns, parser) {
          const colonIndex = term.indexOf(":");
          let prefix;
          let local;
          if (colonIndex >= 0) {
            prefix = term.substr(0, colonIndex);
            local = term.substr(colonIndex + 1);
          } else {
            prefix = "";
            local = term;
          }
          let uri = null;
          let defaultNamespace = null;
          for (let i = ns.length - 1; i >= 0; i--) {
            const nsElement = ns[i][prefix];
            if (nsElement) {
              uri = nsElement;
              break;
            } else if (!defaultNamespace) {
              defaultNamespace = ns[i][""];
            }
          }
          if (!uri) {
            if (prefix && prefix !== "xmlns") {
              throw new ParseError_1.ParseError(parser, `The prefix '${prefix}' in term '${term}' was not bound.`);
            }
            uri = defaultNamespace || "";
          }
          return { prefix, local, uri };
        }
        static isValidIri(iri) {
          return RdfXmlParser.IRI_REGEX.test(iri);
        }
        import(stream) {
          const output = new stream_1.PassThrough({ readableObjectMode: true });
          stream.on("error", (error) => parsed.emit("error", error));
          stream.on("data", (data) => output.push(data));
          stream.on("end", () => output.push(null));
          const parsed = output.pipe(new RdfXmlParser(this.options));
          return parsed;
        }
        _transform(chunk, encoding2, callback) {
          try {
            this.saxStream.write(chunk, encoding2);
          } catch (e) {
            return callback(e);
          }
          callback();
        }
        newParseError(message) {
          return new ParseError_1.ParseError(this, message);
        }
        valueToUri(value, activeTag) {
          return this.uriToNamedNode(relative_to_absolute_iri_1.resolve(value, activeTag.baseIRI));
        }
        uriToNamedNode(uri) {
          if (!RdfXmlParser.isValidIri(uri)) {
            throw this.newParseError(`Invalid URI: ${uri}`);
          }
          return this.dataFactory.namedNode(uri);
        }
        validateNcname(value) {
          if (!RdfXmlParser.NCNAME_MATCHER.test(value)) {
            throw this.newParseError(`Not a valid NCName: ${value}`);
          }
        }
        attachSaxListeners() {
          this.saxStream.on("error", (error) => this.emit("error", error));
          this.saxStream.on("opentag", this.onTag.bind(this));
          this.saxStream.on("text", this.onText.bind(this));
          this.saxStream.on("closetag", this.onCloseTag.bind(this));
          this.saxStream.on("doctype", this.onDoctype.bind(this));
        }
        onTag(tag) {
          const parentTag = this.activeTagStack.length ? this.activeTagStack[this.activeTagStack.length - 1] : null;
          let currentParseType = ParseType.RESOURCE;
          if (parentTag) {
            parentTag.hadChildren = true;
            currentParseType = parentTag.childrenParseType;
          }
          if (parentTag && parentTag.childrenStringTags) {
            const tagName = tag.name;
            let attributes = "";
            for (const attributeKey in tag.attributes) {
              attributes += ` ${attributeKey}="${tag.attributes[attributeKey]}"`;
            }
            const tagContents = `${tagName}${attributes}`;
            const tagString = `<${tagContents}>`;
            parentTag.childrenStringTags.push(tagString);
            const stringActiveTag = { childrenStringTags: parentTag.childrenStringTags };
            stringActiveTag.childrenStringEmitClosingTag = `</${tagName}>`;
            this.activeTagStack.push(stringActiveTag);
            return;
          }
          const activeTag = {};
          if (parentTag) {
            activeTag.language = parentTag.language;
            activeTag.baseIRI = parentTag.baseIRI;
          } else {
            activeTag.baseIRI = this.baseIRI;
          }
          this.activeTagStack.push(activeTag);
          activeTag.ns = RdfXmlParser.parseNamespace(tag, parentTag);
          if (currentParseType === ParseType.RESOURCE) {
            this.onTagResource(tag, activeTag, parentTag, !parentTag);
          } else {
            this.onTagProperty(tag, activeTag, parentTag);
          }
        }
        onTagResource(tag, activeTag, parentTag, rootTag) {
          const tagExpanded = RdfXmlParser.expandPrefixedTerm(tag.name, activeTag.ns, this);
          activeTag.childrenParseType = ParseType.PROPERTY;
          let typedNode = true;
          if (tagExpanded.uri === RdfXmlParser.RDF) {
            if (!rootTag && RdfXmlParser.FORBIDDEN_NODE_ELEMENTS.indexOf(tagExpanded.local) >= 0) {
              throw this.newParseError(`Illegal node element name: ${tagExpanded.local}`);
            }
            switch (tagExpanded.local) {
              case "RDF":
                activeTag.childrenParseType = ParseType.RESOURCE;
              case "Description":
                typedNode = false;
            }
          }
          const predicates = [];
          const objects = [];
          let activeSubjectValue = null;
          let claimSubjectNodeId = false;
          let subjectValueBlank = false;
          let explicitType = null;
          for (const attributeKey in tag.attributes) {
            const attributeValue = tag.attributes[attributeKey];
            const attributeKeyExpanded = RdfXmlParser.expandPrefixedTerm(attributeKey, activeTag.ns, this);
            if (parentTag && attributeKeyExpanded.uri === RdfXmlParser.RDF) {
              switch (attributeKeyExpanded.local) {
                case "about":
                  if (activeSubjectValue) {
                    throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while ${attributeValue} and ${activeSubjectValue} where found.`);
                  }
                  activeSubjectValue = attributeValue;
                  continue;
                case "ID":
                  if (activeSubjectValue) {
                    throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while ${attributeValue} and ${activeSubjectValue} where found.`);
                  }
                  this.validateNcname(attributeValue);
                  activeSubjectValue = "#" + attributeValue;
                  claimSubjectNodeId = true;
                  continue;
                case "nodeID":
                  if (activeSubjectValue) {
                    throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while ${attributeValue} and ${activeSubjectValue} where found.`);
                  }
                  this.validateNcname(attributeValue);
                  activeSubjectValue = attributeValue;
                  subjectValueBlank = true;
                  continue;
                case "bagID":
                  throw this.newParseError(`rdf:bagID is not supported.`);
                case "type":
                  explicitType = attributeValue;
                  continue;
                case "aboutEach":
                  throw this.newParseError(`rdf:aboutEach is not supported.`);
                case "aboutEachPrefix":
                  throw this.newParseError(`rdf:aboutEachPrefix is not supported.`);
                case "li":
                  throw this.newParseError(`rdf:li on node elements are not supported.`);
              }
            } else if (attributeKeyExpanded.uri === RdfXmlParser.XML) {
              if (attributeKeyExpanded.local === "lang") {
                activeTag.language = attributeValue === "" ? null : attributeValue.toLowerCase();
                continue;
              } else if (attributeKeyExpanded.local === "base") {
                activeTag.baseIRI = relative_to_absolute_iri_1.resolve(attributeValue, activeTag.baseIRI);
                continue;
              }
            }
            if (attributeKeyExpanded.prefix !== "xml" && attributeKeyExpanded.uri) {
              predicates.push(this.uriToNamedNode(attributeKeyExpanded.uri + attributeKeyExpanded.local));
              objects.push(attributeValue);
            }
          }
          if (activeSubjectValue !== null) {
            activeTag.subject = subjectValueBlank ? this.dataFactory.blankNode(activeSubjectValue) : this.valueToUri(activeSubjectValue, activeTag);
            if (claimSubjectNodeId) {
              this.claimNodeId(activeTag.subject);
            }
          }
          if (!activeTag.subject) {
            activeTag.subject = this.dataFactory.blankNode();
          }
          if (typedNode) {
            const type = this.uriToNamedNode(tagExpanded.uri + tagExpanded.local);
            this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + "type"), type, parentTag ? parentTag.reifiedStatementId : null);
          }
          if (parentTag) {
            if (parentTag.predicate) {
              if (parentTag.childrenCollectionSubject) {
                const linkTerm = this.dataFactory.blankNode();
                this.emitTriple(parentTag.childrenCollectionSubject, parentTag.childrenCollectionPredicate, linkTerm, parentTag.reifiedStatementId);
                this.emitTriple(linkTerm, this.dataFactory.namedNode(RdfXmlParser.RDF + "first"), activeTag.subject, activeTag.reifiedStatementId);
                parentTag.childrenCollectionSubject = linkTerm;
                parentTag.childrenCollectionPredicate = this.dataFactory.namedNode(RdfXmlParser.RDF + "rest");
              } else {
                this.emitTriple(parentTag.subject, parentTag.predicate, activeTag.subject, parentTag.reifiedStatementId);
                for (let i = 0; i < parentTag.predicateSubPredicates.length; i++) {
                  this.emitTriple(activeTag.subject, parentTag.predicateSubPredicates[i], parentTag.predicateSubObjects[i], null);
                }
                parentTag.predicateSubPredicates = [];
                parentTag.predicateSubObjects = [];
                parentTag.predicateEmitted = true;
              }
            }
            for (let i = 0; i < predicates.length; i++) {
              const object = this.dataFactory.literal(objects[i], activeTag.datatype || activeTag.language);
              this.emitTriple(activeTag.subject, predicates[i], object, parentTag.reifiedStatementId);
            }
            if (explicitType) {
              this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + "type"), this.uriToNamedNode(explicitType), null);
            }
          }
        }
        onTagProperty(tag, activeTag, parentTag) {
          const tagExpanded = RdfXmlParser.expandPrefixedTerm(tag.name, activeTag.ns, this);
          activeTag.childrenParseType = ParseType.RESOURCE;
          activeTag.subject = parentTag.subject;
          if (tagExpanded.uri === RdfXmlParser.RDF && tagExpanded.local === "li") {
            if (!parentTag.listItemCounter) {
              parentTag.listItemCounter = 1;
            }
            activeTag.predicate = this.uriToNamedNode(tagExpanded.uri + "_" + parentTag.listItemCounter++);
          } else {
            activeTag.predicate = this.uriToNamedNode(tagExpanded.uri + tagExpanded.local);
          }
          if (tagExpanded.uri === RdfXmlParser.RDF && RdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS.indexOf(tagExpanded.local) >= 0) {
            throw this.newParseError(`Illegal property element name: ${tagExpanded.local}`);
          }
          activeTag.predicateSubPredicates = [];
          activeTag.predicateSubObjects = [];
          let parseType = false;
          let attributedProperty = false;
          let activeSubSubjectValue = null;
          let subSubjectValueBlank = true;
          const predicates = [];
          const objects = [];
          for (const propertyAttributeKey in tag.attributes) {
            const propertyAttributeValue = tag.attributes[propertyAttributeKey];
            const propertyAttributeKeyExpanded = RdfXmlParser.expandPrefixedTerm(propertyAttributeKey, activeTag.ns, this);
            if (propertyAttributeKeyExpanded.uri === RdfXmlParser.RDF) {
              switch (propertyAttributeKeyExpanded.local) {
                case "resource":
                  if (activeSubSubjectValue) {
                    throw this.newParseError(`Found both rdf:resource (${propertyAttributeValue}) and rdf:nodeID (${activeSubSubjectValue}).`);
                  }
                  if (parseType) {
                    throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:resource (${propertyAttributeValue})`);
                  }
                  activeTag.hadChildren = true;
                  activeSubSubjectValue = propertyAttributeValue;
                  subSubjectValueBlank = false;
                  continue;
                case "datatype":
                  if (attributedProperty) {
                    throw this.newParseError(`Found both non-rdf:* property attributes and rdf:datatype (${propertyAttributeValue}).`);
                  }
                  if (parseType) {
                    throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${propertyAttributeValue})`);
                  }
                  activeTag.datatype = this.valueToUri(propertyAttributeValue, activeTag);
                  continue;
                case "nodeID":
                  if (attributedProperty) {
                    throw this.newParseError(`Found both non-rdf:* property attributes and rdf:nodeID (${propertyAttributeValue}).`);
                  }
                  if (activeTag.hadChildren) {
                    throw this.newParseError(`Found both rdf:resource and rdf:nodeID (${propertyAttributeValue}).`);
                  }
                  if (parseType) {
                    throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID (${propertyAttributeValue})`);
                  }
                  this.validateNcname(propertyAttributeValue);
                  activeTag.hadChildren = true;
                  activeSubSubjectValue = propertyAttributeValue;
                  subSubjectValueBlank = true;
                  continue;
                case "bagID":
                  throw this.newParseError(`rdf:bagID is not supported.`);
                case "parseType":
                  if (attributedProperty) {
                    throw this.newParseError(`rdf:parseType is not allowed when non-rdf:* property attributes are present`);
                  }
                  if (activeTag.datatype) {
                    throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${activeTag.datatype.value})`);
                  }
                  if (activeSubSubjectValue) {
                    throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID or rdf:resource (${activeSubSubjectValue})`);
                  }
                  if (propertyAttributeValue === "Resource") {
                    parseType = true;
                    activeTag.childrenParseType = ParseType.PROPERTY;
                    const nestedBNode = this.dataFactory.blankNode();
                    this.emitTriple(activeTag.subject, activeTag.predicate, nestedBNode, activeTag.reifiedStatementId);
                    activeTag.subject = nestedBNode;
                    activeTag.predicate = null;
                  } else if (propertyAttributeValue === "Collection") {
                    parseType = true;
                    activeTag.hadChildren = true;
                    activeTag.childrenCollectionSubject = activeTag.subject;
                    activeTag.childrenCollectionPredicate = activeTag.predicate;
                    subSubjectValueBlank = false;
                  } else if (propertyAttributeValue === "Literal") {
                    parseType = true;
                    activeTag.childrenTagsToString = true;
                    activeTag.childrenStringTags = [];
                  }
                  continue;
                case "ID":
                  this.validateNcname(propertyAttributeValue);
                  activeTag.reifiedStatementId = this.valueToUri("#" + propertyAttributeValue, activeTag);
                  this.claimNodeId(activeTag.reifiedStatementId);
                  continue;
              }
            } else if (propertyAttributeKeyExpanded.uri === RdfXmlParser.XML && propertyAttributeKeyExpanded.local === "lang") {
              activeTag.language = propertyAttributeValue === "" ? null : propertyAttributeValue.toLowerCase();
              continue;
            }
            if (propertyAttributeKeyExpanded.prefix !== "xml" && propertyAttributeKeyExpanded.prefix !== "xmlns" && propertyAttributeKeyExpanded.uri) {
              if (parseType || activeTag.datatype) {
                throw this.newParseError(`Found illegal rdf:* properties on property element with attribute: ${propertyAttributeValue}`);
              }
              activeTag.hadChildren = true;
              attributedProperty = true;
              predicates.push(this.uriToNamedNode(propertyAttributeKeyExpanded.uri + propertyAttributeKeyExpanded.local));
              objects.push(this.dataFactory.literal(propertyAttributeValue, activeTag.datatype || activeTag.language));
            }
          }
          if (activeSubSubjectValue !== null) {
            const subjectParent = activeTag.subject;
            activeTag.subject = subSubjectValueBlank ? this.dataFactory.blankNode(activeSubSubjectValue) : this.valueToUri(activeSubSubjectValue, activeTag);
            this.emitTriple(subjectParent, activeTag.predicate, activeTag.subject, activeTag.reifiedStatementId);
            for (let i = 0; i < predicates.length; i++) {
              this.emitTriple(activeTag.subject, predicates[i], objects[i], null);
            }
            activeTag.predicateEmitted = true;
          } else if (subSubjectValueBlank) {
            activeTag.predicateSubPredicates = predicates;
            activeTag.predicateSubObjects = objects;
            activeTag.predicateEmitted = false;
          }
        }
        emitTriple(subject, predicate, object, statementId) {
          this.push(this.dataFactory.quad(subject, predicate, object, this.defaultGraph));
          if (statementId) {
            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + "type"), this.dataFactory.namedNode(RdfXmlParser.RDF + "Statement"), this.defaultGraph));
            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + "subject"), subject, this.defaultGraph));
            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + "predicate"), predicate, this.defaultGraph));
            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + "object"), object, this.defaultGraph));
          }
        }
        claimNodeId(term) {
          if (!this.allowDuplicateRdfIds) {
            if (this.nodeIds[term.value]) {
              throw this.newParseError(`Found multiple occurrences of rdf:ID='${term.value}'.`);
            }
            this.nodeIds[term.value] = true;
          }
        }
        onText(text5) {
          const activeTag = this.activeTagStack.length ? this.activeTagStack[this.activeTagStack.length - 1] : null;
          if (activeTag) {
            if (activeTag.childrenStringTags) {
              activeTag.childrenStringTags.push(text5);
            } else if (activeTag.predicate) {
              activeTag.text = text5;
            }
          }
        }
        onCloseTag() {
          const poppedTag = this.activeTagStack.pop();
          if (poppedTag.childrenStringEmitClosingTag) {
            poppedTag.childrenStringTags.push(poppedTag.childrenStringEmitClosingTag);
          }
          if (poppedTag.childrenTagsToString) {
            poppedTag.datatype = this.dataFactory.namedNode(RdfXmlParser.RDF + "XMLLiteral");
            poppedTag.text = poppedTag.childrenStringTags.join("");
            poppedTag.hadChildren = false;
          }
          if (poppedTag.childrenCollectionSubject) {
            this.emitTriple(poppedTag.childrenCollectionSubject, poppedTag.childrenCollectionPredicate, this.dataFactory.namedNode(RdfXmlParser.RDF + "nil"), poppedTag.reifiedStatementId);
          } else if (poppedTag.predicate) {
            if (!poppedTag.hadChildren && poppedTag.childrenParseType !== ParseType.PROPERTY) {
              this.emitTriple(poppedTag.subject, poppedTag.predicate, this.dataFactory.literal(poppedTag.text || "", poppedTag.datatype || poppedTag.language), poppedTag.reifiedStatementId);
            } else if (!poppedTag.predicateEmitted) {
              const subject = this.dataFactory.blankNode();
              this.emitTriple(poppedTag.subject, poppedTag.predicate, subject, poppedTag.reifiedStatementId);
              for (let i = 0; i < poppedTag.predicateSubPredicates.length; i++) {
                this.emitTriple(subject, poppedTag.predicateSubPredicates[i], poppedTag.predicateSubObjects[i], null);
              }
            }
          }
        }
        onDoctype(doctype) {
          doctype.replace(/<!ENTITY\s+([^\s]+)\s+["']([^"']+)["']\s*>/g, (match, prefix, uri) => {
            this.saxStream._parser.ENTITIES[prefix] = uri;
            return "";
          });
        }
      };
      exports.RdfXmlParser = RdfXmlParser;
      RdfXmlParser.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*):[^ "<>{}|\\\[\]`]*$/;
      RdfXmlParser.MIME_TYPE = "application/rdf+xml";
      RdfXmlParser.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
      RdfXmlParser.XML = "http://www.w3.org/XML/1998/namespace";
      RdfXmlParser.XMLNS = "http://www.w3.org/2000/xmlns/";
      RdfXmlParser.DEFAULT_NS = {
        xml: RdfXmlParser.XML
      };
      RdfXmlParser.FORBIDDEN_NODE_ELEMENTS = [
        "RDF",
        "ID",
        "about",
        "bagID",
        "parseType",
        "resource",
        "nodeID",
        "li",
        "aboutEach",
        "aboutEachPrefix"
      ];
      RdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS = [
        "Description",
        "RDF",
        "ID",
        "about",
        "bagID",
        "parseType",
        "resource",
        "nodeID",
        "aboutEach",
        "aboutEachPrefix"
      ];
      RdfXmlParser.NCNAME_MATCHER = /^([A-Za-z\xC0-\xD6\xD8-\xF6\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}_])([A-Za-z\xC0-\xD6\xD8-\xF6\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}_\-.0-9#xB7\u{0300}-\u{036F}\u{203F}-\u{2040}])*$/u;
      var ParseType;
      (function(ParseType2) {
        ParseType2[ParseType2["RESOURCE"] = 0] = "RESOURCE";
        ParseType2[ParseType2["PROPERTY"] = 1] = "PROPERTY";
      })(ParseType = exports.ParseType || (exports.ParseType = {}));
    }
  });

  // node_modules/rdfxml-streaming-parser/index.js
  var require_rdfxml_streaming_parser = __commonJS({
    "node_modules/rdfxml-streaming-parser/index.js"(exports) {
      "use strict";
      init_shim();
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_RdfXmlParser(), exports);
    }
  });

  // node_modules/rdfoo/dist/rdfoo/formats.js
  var require_formats = __commonJS({
    "node_modules/rdfoo/dist/rdfoo/formats.js"(exports) {
      "use strict";
      init_shim();
      var __rest = exports && exports.__rest || function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var JsonLdParser = require_parser_jsonld();
      var N3 = require_lib2();
      var NTriplesSerializer = require_serializer_ntriples();
      var SinkMap2 = require_sink_map();
      var JsonLdSerializer = require_serializer_jsonld();
      var { RdfXmlParser } = require_rdfxml_streaming_parser();
      var CustomJsonLdSerializer = class extends JsonLdSerializer {
        constructor(_a = {}) {
          var args = __rest(_a, []);
          super(Object.assign({ encoding: "string" }, args));
        }
      };
      var CustomRdfXmlParser = class extends RdfXmlParser {
        constructor(_a = {}) {
          var { factory: factory3 } = _a, args = __rest(_a, ["factory"]);
          super(Object.assign(Object.assign({}, args), { dataFactory: factory3 }));
        }
      };
      var formats = {
        parsers: new SinkMap2(),
        serializers: new SinkMap2()
      };
      formats.parsers.set("application/ld+json", new JsonLdParser());
      formats.parsers.set("application/trig", new N3.Parser());
      formats.parsers.set("application/n-quads", new N3.Parser());
      formats.parsers.set("application/n-triples", new N3.Parser());
      formats.parsers.set("text/n3", new N3.Parser());
      formats.parsers.set("text/turtle", new N3.Parser());
      formats.parsers.set("application/rdf+xml", new CustomRdfXmlParser());
      formats.serializers.set("application/ld+json", new CustomJsonLdSerializer());
      formats.serializers.set("application/n-quads", new N3.Writer());
      formats.serializers.set("application/n-triples", new N3.Writer());
      formats.serializers.set("text/n3", new N3.Writer());
      formats.serializers.set("text/turtle", new N3.Writer());
      exports.default = formats;
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser11 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_shim();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list10 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_shim();
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer3 = _require.Buffer;
      var _require2 = require_util2();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer3.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer3.alloc(0);
            var ret = Buffer3.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer3.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy11 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_shim();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              import_process.default.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              import_process.default.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            import_process.default.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/errors-browser.js
  var require_errors_browser10 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_shim();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state10 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_INVALID_OPT_VALUE = require_errors_browser10().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable11 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser2()
      };
      var Stream = require_stream_browser11();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy11();
      var _require = require_state10();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser10().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex11();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex11();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          import_process.default.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding2, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer3.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (isBuf)
          encoding2 = "buffer";
        else if (!encoding2)
          encoding2 = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ending)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding2, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
        if (typeof encoding2 === "string")
          encoding2 = encoding2.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding2);
        this._writableState.defaultEncoding = encoding2;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding2) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer3.from(chunk, encoding2);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding2, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding2);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding2 = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding: encoding2,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding2, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding2, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          import_process.default.nextTick(cb, er);
          import_process.default.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished4 = needFinish(state) || stream.destroyed;
          if (!finished4 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            import_process.default.nextTick(afterWrite, stream, state, finished4, cb);
          } else {
            afterWrite(stream, state, finished4, cb);
          }
        }
      }
      function afterWrite(stream, state, finished4, cb) {
        if (!finished4)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding2 = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding2, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding2, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding2 = null;
        } else if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding2);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            import_process.default.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            import_process.default.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex11 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_shim();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var Readable5 = require_stream_readable11();
      var Writable = require_stream_writable11();
      require_inherits_browser()(Duplex, Readable5);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable5.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended)
          return;
        import_process.default.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream10 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_shim();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser10().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once2(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator10 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_shim();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished4 = require_end_of_stream10();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        import_process.default.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              import_process.default.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished4(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser10 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_shim();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable11 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Readable5;
      var Duplex;
      Readable5.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser11();
      var Buffer3 = require_buffer().Buffer;
      var OurUint8Array = _global.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list10();
      var destroyImpl = require_destroy11();
      var _require = require_state10();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser10().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable5, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex11();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder2().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable5(options) {
        Duplex = Duplex || require_stream_duplex11();
        if (!(this instanceof Readable5))
          return new Readable5(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable5.prototype, "destroyed", {
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable5.prototype.destroy = destroyImpl.destroy;
      Readable5.prototype._undestroy = destroyImpl.undestroy;
      Readable5.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable5.prototype.push = function(chunk, encoding2) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding2 = encoding2 || state.defaultEncoding;
            if (encoding2 !== state.encoding) {
              chunk = Buffer3.from(chunk, encoding2);
              encoding2 = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
      };
      Readable5.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding2) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable5.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable5.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable5.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          import_process.default.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          import_process.default.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable5.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable5.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          import_process.default.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable5.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable5.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              import_process.default.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable5.prototype.addListener = Readable5.prototype.on;
      Readable5.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable5.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          import_process.default.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable5.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          import_process.default.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable5.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable5.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable5.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator10();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable5.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableBuffer", {
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable5.prototype, "readableFlowing", {
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable5._fromList = fromList;
      Object.defineProperty(Readable5.prototype, "readableLength", {
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          import_process.default.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable5.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser10();
          }
          return from(Readable5, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform11 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = Transform;
      var _require$codes = require_errors_browser10().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex11();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding2) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding2);
      };
      Transform.prototype._transform = function(chunk, encoding2, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding2, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding2;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough11 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = PassThrough;
      var Transform = require_stream_transform11();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding2, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline10 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_shim();
      var eos;
      function once2(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser10().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once2(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream10();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/rdfoo/node_modules/readable-stream/readable-browser.js
  var require_readable_browser10 = __commonJS({
    "node_modules/rdfoo/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_shim();
      exports = module.exports = require_stream_readable11();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable11();
      exports.Duplex = require_stream_duplex11();
      exports.Transform = require_stream_transform11();
      exports.PassThrough = require_stream_passthrough11();
      exports.finished = require_end_of_stream10();
      exports.pipeline = require_pipeline10();
    }
  });

  // node_modules/rdfoo/dist/rdfoo/parseRDF.js
  var require_parseRDF = __commonJS({
    "node_modules/rdfoo/dist/rdfoo/parseRDF.js"(exports) {
      "use strict";
      init_shim();
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var identifyFiletype_1 = require_identifyFiletype();
      var formats_1 = require_formats();
      var readable_stream_1 = require_readable_browser10();
      function parseRDF(graph2, rdf, filetype) {
        return __awaiter(this, void 0, void 0, function* () {
          var s = new readable_stream_1.Readable();
          s.push(rdf);
          s.push(null);
          if (filetype === identifyFiletype_1.Filetype.NTriples) {
            yield graph2.graph.import(formats_1.default.parsers.import("text/n3", s));
          } else if (filetype === identifyFiletype_1.Filetype.RDFXML) {
            yield graph2.graph.import(formats_1.default.parsers.import("application/rdf+xml", s));
          } else {
            throw new Error("Unknown type " + filetype);
          }
        });
      }
      exports.default = parseRDF;
    }
  });

  // node_modules/elementtree/lib/sprintf.js
  var require_sprintf = __commonJS({
    "node_modules/elementtree/lib/sprintf.js"(exports) {
      init_shim();
      var cache = {};
      var TO_ESCAPE = {
        "'": "\\'",
        "\n": "\\n"
      };
      function populate(formatter) {
        var i, type, key = formatter, prev = 0, arg = 1, builder = "return '";
        for (i = 0; i < formatter.length; i++) {
          if (formatter[i] === "%") {
            type = formatter[i + 1];
            switch (type) {
              case "s":
                builder += formatter.slice(prev, i) + "' + arguments[" + arg + "] + '";
                prev = i + 2;
                arg++;
                break;
              case "j":
                builder += formatter.slice(prev, i) + "' + JSON.stringify(arguments[" + arg + "]) + '";
                prev = i + 2;
                arg++;
                break;
              case "%":
                builder += formatter.slice(prev, i + 1);
                prev = i + 2;
                i++;
                break;
            }
          } else if (TO_ESCAPE[formatter[i]]) {
            builder += formatter.slice(prev, i) + TO_ESCAPE[formatter[i]];
            prev = i + 1;
          }
        }
        builder += formatter.slice(prev) + "';";
        cache[key] = new Function(builder);
      }
      exports.sprintf = function(formatter, var_args) {
        if (!cache[formatter]) {
          populate(formatter);
        }
        return cache[formatter].apply(null, arguments);
      };
    }
  });

  // node_modules/elementtree/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/elementtree/lib/utils.js"(exports) {
      init_shim();
      function items(hash, ignored) {
        ignored = ignored || null;
        var k, rv = [];
        function is_ignored(key) {
          if (!ignored || ignored.length === 0) {
            return false;
          }
          return ignored.indexOf(key);
        }
        for (k in hash) {
          if (hash.hasOwnProperty(k) && !is_ignored(ignored)) {
            rv.push([k, hash[k]]);
          }
        }
        return rv;
      }
      function findall(re, str) {
        var match, matches = [];
        while (match = re.exec(str)) {
          matches.push(match);
        }
        return matches;
      }
      function merge(a, b) {
        var c = {}, attrname;
        for (attrname in a) {
          if (a.hasOwnProperty(attrname)) {
            c[attrname] = a[attrname];
          }
        }
        for (attrname in b) {
          if (b.hasOwnProperty(attrname)) {
            c[attrname] = b[attrname];
          }
        }
        return c;
      }
      exports.items = items;
      exports.findall = findall;
      exports.merge = merge;
    }
  });

  // node_modules/elementtree/lib/errors.js
  var require_errors = __commonJS({
    "node_modules/elementtree/lib/errors.js"(exports) {
      init_shim();
      var util = require_util2();
      var sprintf = require_sprintf().sprintf;
      function SyntaxError2(token, msg) {
        msg = msg || sprintf("Syntax Error at token %s", token.toString());
        this.token = token;
        this.message = msg;
        Error.call(this, msg);
      }
      util.inherits(SyntaxError2, Error);
      exports.SyntaxError = SyntaxError2;
    }
  });

  // node_modules/elementtree/lib/elementpath.js
  var require_elementpath = __commonJS({
    "node_modules/elementtree/lib/elementpath.js"(exports) {
      init_shim();
      var sprintf = require_sprintf().sprintf;
      var utils = require_utils();
      var SyntaxError2 = require_errors().SyntaxError;
      var _cache = {};
      var RE = new RegExp(`('[^']*'|"[^"]*"|::|//?|\\.\\.|\\(\\)|[/.*:\\[\\]\\(\\)@=])|((?:\\{[^}]+\\})?[^/\\[\\]\\(\\)@=\\s]+)|\\s+`, "g");
      var xpath_tokenizer = utils.findall.bind(null, RE);
      function prepare_tag(next, token) {
        var tag = token[0];
        function select(context, result) {
          var i, len, elem, rv = [];
          for (i = 0, len = result.length; i < len; i++) {
            elem = result[i];
            elem._children.forEach(function(e) {
              if (e.tag === tag) {
                rv.push(e);
              }
            });
          }
          return rv;
        }
        return select;
      }
      function prepare_star(next, token) {
        function select(context, result) {
          var i, len, elem, rv = [];
          for (i = 0, len = result.length; i < len; i++) {
            elem = result[i];
            elem._children.forEach(function(e) {
              rv.push(e);
            });
          }
          return rv;
        }
        return select;
      }
      function prepare_dot(next, token) {
        function select(context, result) {
          var i, len, elem, rv = [];
          for (i = 0, len = result.length; i < len; i++) {
            elem = result[i];
            rv.push(elem);
          }
          return rv;
        }
        return select;
      }
      function prepare_iter(next, token) {
        var tag;
        token = next();
        if (token[1] === "*") {
          tag = "*";
        } else if (!token[1]) {
          tag = token[0] || "";
        } else {
          throw new SyntaxError2(token);
        }
        function select(context, result) {
          var i, len, elem, rv = [];
          for (i = 0, len = result.length; i < len; i++) {
            elem = result[i];
            elem.iter(tag, function(e) {
              if (e !== elem) {
                rv.push(e);
              }
            });
          }
          return rv;
        }
        return select;
      }
      function prepare_dot_dot(next, token) {
        function select(context, result) {
          var i, len, elem, rv = [], parent_map = context.parent_map;
          if (!parent_map) {
            context.parent_map = parent_map = {};
            context.root.iter(null, function(p) {
              p._children.forEach(function(e) {
                parent_map[e] = p;
              });
            });
          }
          for (i = 0, len = result.length; i < len; i++) {
            elem = result[i];
            if (parent_map.hasOwnProperty(elem)) {
              rv.push(parent_map[elem]);
            }
          }
          return rv;
        }
        return select;
      }
      function prepare_predicate(next, token) {
        var tag, key, value, select;
        token = next();
        if (token[1] === "@") {
          token = next();
          if (token[1]) {
            throw new SyntaxError2(token, "Invalid attribute predicate");
          }
          key = token[0];
          token = next();
          if (token[1] === "]") {
            select = function(context, result) {
              var i, len, elem, rv = [];
              for (i = 0, len = result.length; i < len; i++) {
                elem = result[i];
                if (elem.get(key)) {
                  rv.push(elem);
                }
              }
              return rv;
            };
          } else if (token[1] === "=") {
            value = next()[1];
            if (value[0] === '"' || value[value.length - 1] === "'") {
              value = value.slice(1, value.length - 1);
            } else {
              throw new SyntaxError2(token, "Ivalid comparison target");
            }
            token = next();
            select = function(context, result) {
              var i, len, elem, rv = [];
              for (i = 0, len = result.length; i < len; i++) {
                elem = result[i];
                if (elem.get(key) === value) {
                  rv.push(elem);
                }
              }
              return rv;
            };
          }
          if (token[1] !== "]") {
            throw new SyntaxError2(token, "Invalid attribute predicate");
          }
        } else if (!token[1]) {
          tag = token[0] || "";
          token = next();
          if (token[1] !== "]") {
            throw new SyntaxError2(token, "Invalid node predicate");
          }
          select = function(context, result) {
            var i, len, elem, rv = [];
            for (i = 0, len = result.length; i < len; i++) {
              elem = result[i];
              if (elem.find(tag)) {
                rv.push(elem);
              }
            }
            return rv;
          };
        } else {
          throw new SyntaxError2(null, "Invalid predicate");
        }
        return select;
      }
      var ops = {
        "": prepare_tag,
        "*": prepare_star,
        ".": prepare_dot,
        "..": prepare_dot_dot,
        "//": prepare_iter,
        "[": prepare_predicate
      };
      function _SelectorContext(root) {
        this.parent_map = null;
        this.root = root;
      }
      function findall(elem, path) {
        var selector, result, i, len, token, value, select, context;
        if (_cache.hasOwnProperty(path)) {
          selector = _cache[path];
        } else {
          let getToken2 = function() {
            return result.shift();
          };
          var getToken = getToken2;
          if (Object.keys(_cache).length > 100) {
            _cache = {};
          }
          if (path.charAt(0) === "/") {
            throw new SyntaxError2(null, "Cannot use absolute path on element");
          }
          result = xpath_tokenizer(path);
          selector = [];
          token = getToken2();
          while (true) {
            var c = token[1] || "";
            value = ops[c](getToken2, token);
            if (!value) {
              throw new SyntaxError2(null, sprintf("Invalid path: %s", path));
            }
            selector.push(value);
            token = getToken2();
            if (!token) {
              break;
            } else if (token[1] === "/") {
              token = getToken2();
            }
            if (!token) {
              break;
            }
          }
          _cache[path] = selector;
        }
        result = [elem];
        context = new _SelectorContext(elem);
        for (i = 0, len = selector.length; i < len; i++) {
          select = selector[i];
          result = select(context, result);
        }
        return result || [];
      }
      function find(element, path) {
        var resultElements = findall(element, path);
        if (resultElements && resultElements.length > 0) {
          return resultElements[0];
        }
        return null;
      }
      function findtext(element, path, defvalue) {
        var resultElements = findall(element, path);
        if (resultElements && resultElements.length > 0) {
          return resultElements[0].text;
        }
        return defvalue;
      }
      exports.find = find;
      exports.findall = findall;
      exports.findtext = findtext;
    }
  });

  // node_modules/elementtree/lib/treebuilder.js
  var require_treebuilder = __commonJS({
    "node_modules/elementtree/lib/treebuilder.js"(exports) {
      init_shim();
      function TreeBuilder(element_factory) {
        this._data = [];
        this._elem = [];
        this._last = null;
        this._tail = null;
        if (!element_factory) {
          element_factory = require_elementtree().Element;
        }
        this._factory = element_factory;
      }
      TreeBuilder.prototype.close = function() {
        return this._last;
      };
      TreeBuilder.prototype._flush = function() {
        if (this._data) {
          if (this._last !== null) {
            var text5 = this._data.join("");
            if (this._tail) {
              this._last.tail = text5;
            } else {
              this._last.text = text5;
            }
          }
          this._data = [];
        }
      };
      TreeBuilder.prototype.data = function(data) {
        this._data.push(data);
      };
      TreeBuilder.prototype.start = function(tag, attrs) {
        this._flush();
        var elem = this._factory(tag, attrs);
        this._last = elem;
        if (this._elem.length) {
          this._elem[this._elem.length - 1].append(elem);
        }
        this._elem.push(elem);
        this._tail = null;
      };
      TreeBuilder.prototype.end = function(tag) {
        this._flush();
        this._last = this._elem.pop();
        if (this._last.tag !== tag) {
          throw new Error("end tag mismatch");
        }
        this._tail = 1;
        return this._last;
      };
      exports.TreeBuilder = TreeBuilder;
    }
  });

  // node_modules/sax/lib/sax.js
  var require_sax2 = __commonJS({
    "node_modules/sax/lib/sax.js"(exports) {
      init_shim();
      (function(sax) {
        sax.parser = function(strict, opt) {
          return new SAXParser(strict, opt);
        };
        sax.SAXParser = SAXParser;
        sax.SAXStream = SAXStream;
        sax.createStream = createStream;
        sax.MAX_BUFFER_LENGTH = 64 * 1024;
        var buffers = [
          "comment",
          "sgmlDecl",
          "textNode",
          "tagName",
          "doctype",
          "procInstName",
          "procInstBody",
          "entity",
          "attribName",
          "attribValue",
          "cdata",
          "script"
        ];
        sax.EVENTS = [
          "text",
          "processinginstruction",
          "sgmldeclaration",
          "doctype",
          "comment",
          "attribute",
          "opentag",
          "closetag",
          "opencdata",
          "cdata",
          "closecdata",
          "error",
          "end",
          "ready",
          "script",
          "opennamespace",
          "closenamespace"
        ];
        function SAXParser(strict, opt) {
          if (!(this instanceof SAXParser)) {
            return new SAXParser(strict, opt);
          }
          var parser = this;
          clearBuffers(parser);
          parser.q = parser.c = "";
          parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
          parser.opt = opt || {};
          parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
          parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
          parser.tags = [];
          parser.closed = parser.closedRoot = parser.sawRoot = false;
          parser.tag = parser.error = null;
          parser.strict = !!strict;
          parser.noscript = !!(strict || parser.opt.noscript);
          parser.state = S.BEGIN;
          parser.strictEntities = parser.opt.strictEntities;
          parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
          parser.attribList = [];
          if (parser.opt.xmlns) {
            parser.ns = Object.create(rootNS);
          }
          parser.trackPosition = parser.opt.position !== false;
          if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0;
          }
          emit(parser, "onready");
        }
        if (!Object.create) {
          Object.create = function(o) {
            function F() {
            }
            F.prototype = o;
            var newf = new F();
            return newf;
          };
        }
        if (!Object.keys) {
          Object.keys = function(o) {
            var a = [];
            for (var i in o)
              if (o.hasOwnProperty(i))
                a.push(i);
            return a;
          };
        }
        function checkBufferLength(parser) {
          var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
          var maxActual = 0;
          for (var i = 0, l = buffers.length; i < l; i++) {
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) {
              switch (buffers[i]) {
                case "textNode":
                  closeText(parser);
                  break;
                case "cdata":
                  emitNode(parser, "oncdata", parser.cdata);
                  parser.cdata = "";
                  break;
                case "script":
                  emitNode(parser, "onscript", parser.script);
                  parser.script = "";
                  break;
                default:
                  error(parser, "Max buffer length exceeded: " + buffers[i]);
              }
            }
            maxActual = Math.max(maxActual, len);
          }
          var m = sax.MAX_BUFFER_LENGTH - maxActual;
          parser.bufferCheckPosition = m + parser.position;
        }
        function clearBuffers(parser) {
          for (var i = 0, l = buffers.length; i < l; i++) {
            parser[buffers[i]] = "";
          }
        }
        function flushBuffers(parser) {
          closeText(parser);
          if (parser.cdata !== "") {
            emitNode(parser, "oncdata", parser.cdata);
            parser.cdata = "";
          }
          if (parser.script !== "") {
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
        }
        SAXParser.prototype = {
          end: function() {
            end(this);
          },
          write,
          resume: function() {
            this.error = null;
            return this;
          },
          close: function() {
            return this.write(null);
          },
          flush: function() {
            flushBuffers(this);
          }
        };
        var Stream;
        try {
          Stream = require_stream_browserify().Stream;
        } catch (ex) {
          Stream = function() {
          };
        }
        var streamWraps = sax.EVENTS.filter(function(ev) {
          return ev !== "error" && ev !== "end";
        });
        function createStream(strict, opt) {
          return new SAXStream(strict, opt);
        }
        function SAXStream(strict, opt) {
          if (!(this instanceof SAXStream)) {
            return new SAXStream(strict, opt);
          }
          Stream.apply(this);
          this._parser = new SAXParser(strict, opt);
          this.writable = true;
          this.readable = true;
          var me = this;
          this._parser.onend = function() {
            me.emit("end");
          };
          this._parser.onerror = function(er) {
            me.emit("error", er);
            me._parser.error = null;
          };
          this._decoder = null;
          streamWraps.forEach(function(ev) {
            Object.defineProperty(me, "on" + ev, {
              get: function() {
                return me._parser["on" + ev];
              },
              set: function(h) {
                if (!h) {
                  me.removeAllListeners(ev);
                  me._parser["on" + ev] = h;
                  return h;
                }
                me.on(ev, h);
              },
              enumerable: true,
              configurable: false
            });
          });
        }
        SAXStream.prototype = Object.create(Stream.prototype, {
          constructor: {
            value: SAXStream
          }
        });
        SAXStream.prototype.write = function(data) {
          if (typeof import_buffer.Buffer === "function" && typeof import_buffer.Buffer.isBuffer === "function" && import_buffer.Buffer.isBuffer(data)) {
            if (!this._decoder) {
              var SD = require_string_decoder2().StringDecoder;
              this._decoder = new SD("utf8");
            }
            data = this._decoder.write(data);
          }
          this._parser.write(data.toString());
          this.emit("data", data);
          return true;
        };
        SAXStream.prototype.end = function(chunk) {
          if (chunk && chunk.length) {
            this.write(chunk);
          }
          this._parser.end();
          return true;
        };
        SAXStream.prototype.on = function(ev, handler2) {
          var me = this;
          if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
            me._parser["on" + ev] = function() {
              var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
              args.splice(0, 0, ev);
              me.emit.apply(me, args);
            };
          }
          return Stream.prototype.on.call(me, ev, handler2);
        };
        var whitespace = "\r\n	 ";
        var number = "0124356789";
        var letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        var quote = `'"`;
        var attribEnd = whitespace + ">";
        var CDATA = "[CDATA[";
        var DOCTYPE = "DOCTYPE";
        var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
        var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
        var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
        whitespace = charClass(whitespace);
        number = charClass(number);
        letter = charClass(letter);
        var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
        var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
        quote = charClass(quote);
        attribEnd = charClass(attribEnd);
        function charClass(str) {
          return str.split("").reduce(function(s2, c) {
            s2[c] = true;
            return s2;
          }, {});
        }
        function isRegExp(c) {
          return Object.prototype.toString.call(c) === "[object RegExp]";
        }
        function is(charclass, c) {
          return isRegExp(charclass) ? !!c.match(charclass) : charclass[c];
        }
        function not(charclass, c) {
          return !is(charclass, c);
        }
        var S = 0;
        sax.STATE = {
          BEGIN: S++,
          BEGIN_WHITESPACE: S++,
          TEXT: S++,
          TEXT_ENTITY: S++,
          OPEN_WAKA: S++,
          SGML_DECL: S++,
          SGML_DECL_QUOTED: S++,
          DOCTYPE: S++,
          DOCTYPE_QUOTED: S++,
          DOCTYPE_DTD: S++,
          DOCTYPE_DTD_QUOTED: S++,
          COMMENT_STARTING: S++,
          COMMENT: S++,
          COMMENT_ENDING: S++,
          COMMENT_ENDED: S++,
          CDATA: S++,
          CDATA_ENDING: S++,
          CDATA_ENDING_2: S++,
          PROC_INST: S++,
          PROC_INST_BODY: S++,
          PROC_INST_ENDING: S++,
          OPEN_TAG: S++,
          OPEN_TAG_SLASH: S++,
          ATTRIB: S++,
          ATTRIB_NAME: S++,
          ATTRIB_NAME_SAW_WHITE: S++,
          ATTRIB_VALUE: S++,
          ATTRIB_VALUE_QUOTED: S++,
          ATTRIB_VALUE_CLOSED: S++,
          ATTRIB_VALUE_UNQUOTED: S++,
          ATTRIB_VALUE_ENTITY_Q: S++,
          ATTRIB_VALUE_ENTITY_U: S++,
          CLOSE_TAG: S++,
          CLOSE_TAG_SAW_WHITE: S++,
          SCRIPT: S++,
          SCRIPT_ENDING: S++
        };
        sax.XML_ENTITIES = {
          "amp": "&",
          "gt": ">",
          "lt": "<",
          "quot": '"',
          "apos": "'"
        };
        sax.ENTITIES = {
          "amp": "&",
          "gt": ">",
          "lt": "<",
          "quot": '"',
          "apos": "'",
          "AElig": 198,
          "Aacute": 193,
          "Acirc": 194,
          "Agrave": 192,
          "Aring": 197,
          "Atilde": 195,
          "Auml": 196,
          "Ccedil": 199,
          "ETH": 208,
          "Eacute": 201,
          "Ecirc": 202,
          "Egrave": 200,
          "Euml": 203,
          "Iacute": 205,
          "Icirc": 206,
          "Igrave": 204,
          "Iuml": 207,
          "Ntilde": 209,
          "Oacute": 211,
          "Ocirc": 212,
          "Ograve": 210,
          "Oslash": 216,
          "Otilde": 213,
          "Ouml": 214,
          "THORN": 222,
          "Uacute": 218,
          "Ucirc": 219,
          "Ugrave": 217,
          "Uuml": 220,
          "Yacute": 221,
          "aacute": 225,
          "acirc": 226,
          "aelig": 230,
          "agrave": 224,
          "aring": 229,
          "atilde": 227,
          "auml": 228,
          "ccedil": 231,
          "eacute": 233,
          "ecirc": 234,
          "egrave": 232,
          "eth": 240,
          "euml": 235,
          "iacute": 237,
          "icirc": 238,
          "igrave": 236,
          "iuml": 239,
          "ntilde": 241,
          "oacute": 243,
          "ocirc": 244,
          "ograve": 242,
          "oslash": 248,
          "otilde": 245,
          "ouml": 246,
          "szlig": 223,
          "thorn": 254,
          "uacute": 250,
          "ucirc": 251,
          "ugrave": 249,
          "uuml": 252,
          "yacute": 253,
          "yuml": 255,
          "copy": 169,
          "reg": 174,
          "nbsp": 160,
          "iexcl": 161,
          "cent": 162,
          "pound": 163,
          "curren": 164,
          "yen": 165,
          "brvbar": 166,
          "sect": 167,
          "uml": 168,
          "ordf": 170,
          "laquo": 171,
          "not": 172,
          "shy": 173,
          "macr": 175,
          "deg": 176,
          "plusmn": 177,
          "sup1": 185,
          "sup2": 178,
          "sup3": 179,
          "acute": 180,
          "micro": 181,
          "para": 182,
          "middot": 183,
          "cedil": 184,
          "ordm": 186,
          "raquo": 187,
          "frac14": 188,
          "frac12": 189,
          "frac34": 190,
          "iquest": 191,
          "times": 215,
          "divide": 247,
          "OElig": 338,
          "oelig": 339,
          "Scaron": 352,
          "scaron": 353,
          "Yuml": 376,
          "fnof": 402,
          "circ": 710,
          "tilde": 732,
          "Alpha": 913,
          "Beta": 914,
          "Gamma": 915,
          "Delta": 916,
          "Epsilon": 917,
          "Zeta": 918,
          "Eta": 919,
          "Theta": 920,
          "Iota": 921,
          "Kappa": 922,
          "Lambda": 923,
          "Mu": 924,
          "Nu": 925,
          "Xi": 926,
          "Omicron": 927,
          "Pi": 928,
          "Rho": 929,
          "Sigma": 931,
          "Tau": 932,
          "Upsilon": 933,
          "Phi": 934,
          "Chi": 935,
          "Psi": 936,
          "Omega": 937,
          "alpha": 945,
          "beta": 946,
          "gamma": 947,
          "delta": 948,
          "epsilon": 949,
          "zeta": 950,
          "eta": 951,
          "theta": 952,
          "iota": 953,
          "kappa": 954,
          "lambda": 955,
          "mu": 956,
          "nu": 957,
          "xi": 958,
          "omicron": 959,
          "pi": 960,
          "rho": 961,
          "sigmaf": 962,
          "sigma": 963,
          "tau": 964,
          "upsilon": 965,
          "phi": 966,
          "chi": 967,
          "psi": 968,
          "omega": 969,
          "thetasym": 977,
          "upsih": 978,
          "piv": 982,
          "ensp": 8194,
          "emsp": 8195,
          "thinsp": 8201,
          "zwnj": 8204,
          "zwj": 8205,
          "lrm": 8206,
          "rlm": 8207,
          "ndash": 8211,
          "mdash": 8212,
          "lsquo": 8216,
          "rsquo": 8217,
          "sbquo": 8218,
          "ldquo": 8220,
          "rdquo": 8221,
          "bdquo": 8222,
          "dagger": 8224,
          "Dagger": 8225,
          "bull": 8226,
          "hellip": 8230,
          "permil": 8240,
          "prime": 8242,
          "Prime": 8243,
          "lsaquo": 8249,
          "rsaquo": 8250,
          "oline": 8254,
          "frasl": 8260,
          "euro": 8364,
          "image": 8465,
          "weierp": 8472,
          "real": 8476,
          "trade": 8482,
          "alefsym": 8501,
          "larr": 8592,
          "uarr": 8593,
          "rarr": 8594,
          "darr": 8595,
          "harr": 8596,
          "crarr": 8629,
          "lArr": 8656,
          "uArr": 8657,
          "rArr": 8658,
          "dArr": 8659,
          "hArr": 8660,
          "forall": 8704,
          "part": 8706,
          "exist": 8707,
          "empty": 8709,
          "nabla": 8711,
          "isin": 8712,
          "notin": 8713,
          "ni": 8715,
          "prod": 8719,
          "sum": 8721,
          "minus": 8722,
          "lowast": 8727,
          "radic": 8730,
          "prop": 8733,
          "infin": 8734,
          "ang": 8736,
          "and": 8743,
          "or": 8744,
          "cap": 8745,
          "cup": 8746,
          "int": 8747,
          "there4": 8756,
          "sim": 8764,
          "cong": 8773,
          "asymp": 8776,
          "ne": 8800,
          "equiv": 8801,
          "le": 8804,
          "ge": 8805,
          "sub": 8834,
          "sup": 8835,
          "nsub": 8836,
          "sube": 8838,
          "supe": 8839,
          "oplus": 8853,
          "otimes": 8855,
          "perp": 8869,
          "sdot": 8901,
          "lceil": 8968,
          "rceil": 8969,
          "lfloor": 8970,
          "rfloor": 8971,
          "lang": 9001,
          "rang": 9002,
          "loz": 9674,
          "spades": 9824,
          "clubs": 9827,
          "hearts": 9829,
          "diams": 9830
        };
        Object.keys(sax.ENTITIES).forEach(function(key) {
          var e = sax.ENTITIES[key];
          var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
          sax.ENTITIES[key] = s2;
        });
        for (var s in sax.STATE) {
          sax.STATE[sax.STATE[s]] = s;
        }
        S = sax.STATE;
        function emit(parser, event, data) {
          parser[event] && parser[event](data);
        }
        function emitNode(parser, nodeType, data) {
          if (parser.textNode)
            closeText(parser);
          emit(parser, nodeType, data);
        }
        function closeText(parser) {
          parser.textNode = textopts(parser.opt, parser.textNode);
          if (parser.textNode)
            emit(parser, "ontext", parser.textNode);
          parser.textNode = "";
        }
        function textopts(opt, text5) {
          if (opt.trim)
            text5 = text5.trim();
          if (opt.normalize)
            text5 = text5.replace(/\s+/g, " ");
          return text5;
        }
        function error(parser, er) {
          closeText(parser);
          if (parser.trackPosition) {
            er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
          }
          er = new Error(er);
          parser.error = er;
          emit(parser, "onerror", er);
          return parser;
        }
        function end(parser) {
          if (parser.sawRoot && !parser.closedRoot)
            strictFail(parser, "Unclosed root tag");
          if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
            error(parser, "Unexpected end");
          }
          closeText(parser);
          parser.c = "";
          parser.closed = true;
          emit(parser, "onend");
          SAXParser.call(parser, parser.strict, parser.opt);
          return parser;
        }
        function strictFail(parser, message) {
          if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
            throw new Error("bad call to strictFail");
          }
          if (parser.strict) {
            error(parser, message);
          }
        }
        function newTag(parser) {
          if (!parser.strict)
            parser.tagName = parser.tagName[parser.looseCase]();
          var parent = parser.tags[parser.tags.length - 1] || parser;
          var tag = parser.tag = { name: parser.tagName, attributes: {} };
          if (parser.opt.xmlns) {
            tag.ns = parent.ns;
          }
          parser.attribList.length = 0;
        }
        function qname(name, attribute) {
          var i = name.indexOf(":");
          var qualName = i < 0 ? ["", name] : name.split(":");
          var prefix = qualName[0];
          var local = qualName[1];
          if (attribute && name === "xmlns") {
            prefix = "xmlns";
            local = "";
          }
          return { prefix, local };
        }
        function attrib(parser) {
          if (!parser.strict) {
            parser.attribName = parser.attribName[parser.looseCase]();
          }
          if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = "";
            return;
          }
          if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === "xmlns") {
              if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
              } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
              } else {
                var tag = parser.tag;
                var parent = parser.tags[parser.tags.length - 1] || parser;
                if (tag.ns === parent.ns) {
                  tag.ns = Object.create(parent.ns);
                }
                tag.ns[local] = parser.attribValue;
              }
            }
            parser.attribList.push([parser.attribName, parser.attribValue]);
          } else {
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, "onattribute", {
              name: parser.attribName,
              value: parser.attribValue
            });
          }
          parser.attribName = parser.attribValue = "";
        }
        function openTag(parser, selfClosing) {
          if (parser.opt.xmlns) {
            var tag = parser.tag;
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || "";
            if (tag.prefix && !tag.uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
              tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) {
              Object.keys(tag.ns).forEach(function(p) {
                emitNode(parser, "onopennamespace", {
                  prefix: p,
                  uri: tag.ns[p]
                });
              });
            }
            for (var i = 0, l = parser.attribList.length; i < l; i++) {
              var nv = parser.attribList[i];
              var name = nv[0];
              var value = nv[1];
              var qualName = qname(name, true);
              var prefix = qualName.prefix;
              var local = qualName.local;
              var uri = prefix === "" ? "" : tag.ns[prefix] || "";
              var a = {
                name,
                value,
                prefix,
                local,
                uri
              };
              if (prefix && prefix !== "xmlns" && !uri) {
                strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
                a.uri = prefix;
              }
              parser.tag.attributes[name] = a;
              emitNode(parser, "onattribute", a);
            }
            parser.attribList.length = 0;
          }
          parser.tag.isSelfClosing = !!selfClosing;
          parser.sawRoot = true;
          parser.tags.push(parser.tag);
          emitNode(parser, "onopentag", parser.tag);
          if (!selfClosing) {
            if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
              parser.state = S.SCRIPT;
            } else {
              parser.state = S.TEXT;
            }
            parser.tag = null;
            parser.tagName = "";
          }
          parser.attribName = parser.attribValue = "";
          parser.attribList.length = 0;
        }
        function closeTag(parser) {
          if (!parser.tagName) {
            strictFail(parser, "Weird empty close tag.");
            parser.textNode += "</>";
            parser.state = S.TEXT;
            return;
          }
          if (parser.script) {
            if (parser.tagName !== "script") {
              parser.script += "</" + parser.tagName + ">";
              parser.tagName = "";
              parser.state = S.SCRIPT;
              return;
            }
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
          var t = parser.tags.length;
          var tagName = parser.tagName;
          if (!parser.strict) {
            tagName = tagName[parser.looseCase]();
          }
          var closeTo = tagName;
          while (t--) {
            var close = parser.tags[t];
            if (close.name !== closeTo) {
              strictFail(parser, "Unexpected close tag");
            } else {
              break;
            }
          }
          if (t < 0) {
            strictFail(parser, "Unmatched closing tag: " + parser.tagName);
            parser.textNode += "</" + parser.tagName + ">";
            parser.state = S.TEXT;
            return;
          }
          parser.tagName = tagName;
          var s2 = parser.tags.length;
          while (s2-- > t) {
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, "onclosetag", parser.tagName);
            var x = {};
            for (var i in tag.ns) {
              x[i] = tag.ns[i];
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
              Object.keys(tag.ns).forEach(function(p) {
                var n = tag.ns[p];
                emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
              });
            }
          }
          if (t === 0)
            parser.closedRoot = true;
          parser.tagName = parser.attribValue = parser.attribName = "";
          parser.attribList.length = 0;
          parser.state = S.TEXT;
        }
        function parseEntity(parser) {
          var entity = parser.entity;
          var entityLC = entity.toLowerCase();
          var num;
          var numStr = "";
          if (parser.ENTITIES[entity]) {
            return parser.ENTITIES[entity];
          }
          if (parser.ENTITIES[entityLC]) {
            return parser.ENTITIES[entityLC];
          }
          entity = entityLC;
          if (entity.charAt(0) === "#") {
            if (entity.charAt(1) === "x") {
              entity = entity.slice(2);
              num = parseInt(entity, 16);
              numStr = num.toString(16);
            } else {
              entity = entity.slice(1);
              num = parseInt(entity, 10);
              numStr = num.toString(10);
            }
          }
          entity = entity.replace(/^0+/, "");
          if (numStr.toLowerCase() !== entity) {
            strictFail(parser, "Invalid character entity");
            return "&" + parser.entity + ";";
          }
          return String.fromCodePoint(num);
        }
        function beginWhiteSpace(parser, c) {
          if (c === "<") {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else if (not(whitespace, c)) {
            strictFail(parser, "Non-whitespace before first tag.");
            parser.textNode = c;
            parser.state = S.TEXT;
          }
        }
        function write(chunk) {
          var parser = this;
          if (this.error) {
            throw this.error;
          }
          if (parser.closed) {
            return error(parser, "Cannot write after close. Assign an onready handler.");
          }
          if (chunk === null) {
            return end(parser);
          }
          var i = 0;
          var c = "";
          while (true) {
            c = chunk.charAt(i++);
            parser.c = c;
            if (!c) {
              break;
            }
            if (parser.trackPosition) {
              parser.position++;
              if (c === "\n") {
                parser.line++;
                parser.column = 0;
              } else {
                parser.column++;
              }
            }
            switch (parser.state) {
              case S.BEGIN:
                parser.state = S.BEGIN_WHITESPACE;
                if (c === "\uFEFF") {
                  continue;
                }
                beginWhiteSpace(parser, c);
                continue;
              case S.BEGIN_WHITESPACE:
                beginWhiteSpace(parser, c);
                continue;
              case S.TEXT:
                if (parser.sawRoot && !parser.closedRoot) {
                  var starti = i - 1;
                  while (c && c !== "<" && c !== "&") {
                    c = chunk.charAt(i++);
                    if (c && parser.trackPosition) {
                      parser.position++;
                      if (c === "\n") {
                        parser.line++;
                        parser.column = 0;
                      } else {
                        parser.column++;
                      }
                    }
                  }
                  parser.textNode += chunk.substring(starti, i - 1);
                }
                if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                  parser.state = S.OPEN_WAKA;
                  parser.startTagPosition = parser.position;
                } else {
                  if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
                    strictFail(parser, "Text data outside of root node.");
                  }
                  if (c === "&") {
                    parser.state = S.TEXT_ENTITY;
                  } else {
                    parser.textNode += c;
                  }
                }
                continue;
              case S.SCRIPT:
                if (c === "<") {
                  parser.state = S.SCRIPT_ENDING;
                } else {
                  parser.script += c;
                }
                continue;
              case S.SCRIPT_ENDING:
                if (c === "/") {
                  parser.state = S.CLOSE_TAG;
                } else {
                  parser.script += "<" + c;
                  parser.state = S.SCRIPT;
                }
                continue;
              case S.OPEN_WAKA:
                if (c === "!") {
                  parser.state = S.SGML_DECL;
                  parser.sgmlDecl = "";
                } else if (is(whitespace, c)) {
                } else if (is(nameStart, c)) {
                  parser.state = S.OPEN_TAG;
                  parser.tagName = c;
                } else if (c === "/") {
                  parser.state = S.CLOSE_TAG;
                  parser.tagName = "";
                } else if (c === "?") {
                  parser.state = S.PROC_INST;
                  parser.procInstName = parser.procInstBody = "";
                } else {
                  strictFail(parser, "Unencoded <");
                  if (parser.startTagPosition + 1 < parser.position) {
                    var pad = parser.position - parser.startTagPosition;
                    c = new Array(pad).join(" ") + c;
                  }
                  parser.textNode += "<" + c;
                  parser.state = S.TEXT;
                }
                continue;
              case S.SGML_DECL:
                if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                  emitNode(parser, "onopencdata");
                  parser.state = S.CDATA;
                  parser.sgmlDecl = "";
                  parser.cdata = "";
                } else if (parser.sgmlDecl + c === "--") {
                  parser.state = S.COMMENT;
                  parser.comment = "";
                  parser.sgmlDecl = "";
                } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                  parser.state = S.DOCTYPE;
                  if (parser.doctype || parser.sawRoot) {
                    strictFail(parser, "Inappropriately located doctype declaration");
                  }
                  parser.doctype = "";
                  parser.sgmlDecl = "";
                } else if (c === ">") {
                  emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                  parser.sgmlDecl = "";
                  parser.state = S.TEXT;
                } else if (is(quote, c)) {
                  parser.state = S.SGML_DECL_QUOTED;
                  parser.sgmlDecl += c;
                } else {
                  parser.sgmlDecl += c;
                }
                continue;
              case S.SGML_DECL_QUOTED:
                if (c === parser.q) {
                  parser.state = S.SGML_DECL;
                  parser.q = "";
                }
                parser.sgmlDecl += c;
                continue;
              case S.DOCTYPE:
                if (c === ">") {
                  parser.state = S.TEXT;
                  emitNode(parser, "ondoctype", parser.doctype);
                  parser.doctype = true;
                } else {
                  parser.doctype += c;
                  if (c === "[") {
                    parser.state = S.DOCTYPE_DTD;
                  } else if (is(quote, c)) {
                    parser.state = S.DOCTYPE_QUOTED;
                    parser.q = c;
                  }
                }
                continue;
              case S.DOCTYPE_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.q = "";
                  parser.state = S.DOCTYPE;
                }
                continue;
              case S.DOCTYPE_DTD:
                parser.doctype += c;
                if (c === "]") {
                  parser.state = S.DOCTYPE;
                } else if (is(quote, c)) {
                  parser.state = S.DOCTYPE_DTD_QUOTED;
                  parser.q = c;
                }
                continue;
              case S.DOCTYPE_DTD_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.state = S.DOCTYPE_DTD;
                  parser.q = "";
                }
                continue;
              case S.COMMENT:
                if (c === "-") {
                  parser.state = S.COMMENT_ENDING;
                } else {
                  parser.comment += c;
                }
                continue;
              case S.COMMENT_ENDING:
                if (c === "-") {
                  parser.state = S.COMMENT_ENDED;
                  parser.comment = textopts(parser.opt, parser.comment);
                  if (parser.comment) {
                    emitNode(parser, "oncomment", parser.comment);
                  }
                  parser.comment = "";
                } else {
                  parser.comment += "-" + c;
                  parser.state = S.COMMENT;
                }
                continue;
              case S.COMMENT_ENDED:
                if (c !== ">") {
                  strictFail(parser, "Malformed comment");
                  parser.comment += "--" + c;
                  parser.state = S.COMMENT;
                } else {
                  parser.state = S.TEXT;
                }
                continue;
              case S.CDATA:
                if (c === "]") {
                  parser.state = S.CDATA_ENDING;
                } else {
                  parser.cdata += c;
                }
                continue;
              case S.CDATA_ENDING:
                if (c === "]") {
                  parser.state = S.CDATA_ENDING_2;
                } else {
                  parser.cdata += "]" + c;
                  parser.state = S.CDATA;
                }
                continue;
              case S.CDATA_ENDING_2:
                if (c === ">") {
                  if (parser.cdata) {
                    emitNode(parser, "oncdata", parser.cdata);
                  }
                  emitNode(parser, "onclosecdata");
                  parser.cdata = "";
                  parser.state = S.TEXT;
                } else if (c === "]") {
                  parser.cdata += "]";
                } else {
                  parser.cdata += "]]" + c;
                  parser.state = S.CDATA;
                }
                continue;
              case S.PROC_INST:
                if (c === "?") {
                  parser.state = S.PROC_INST_ENDING;
                } else if (is(whitespace, c)) {
                  parser.state = S.PROC_INST_BODY;
                } else {
                  parser.procInstName += c;
                }
                continue;
              case S.PROC_INST_BODY:
                if (!parser.procInstBody && is(whitespace, c)) {
                  continue;
                } else if (c === "?") {
                  parser.state = S.PROC_INST_ENDING;
                } else {
                  parser.procInstBody += c;
                }
                continue;
              case S.PROC_INST_ENDING:
                if (c === ">") {
                  emitNode(parser, "onprocessinginstruction", {
                    name: parser.procInstName,
                    body: parser.procInstBody
                  });
                  parser.procInstName = parser.procInstBody = "";
                  parser.state = S.TEXT;
                } else {
                  parser.procInstBody += "?" + c;
                  parser.state = S.PROC_INST_BODY;
                }
                continue;
              case S.OPEN_TAG:
                if (is(nameBody, c)) {
                  parser.tagName += c;
                } else {
                  newTag(parser);
                  if (c === ">") {
                    openTag(parser);
                  } else if (c === "/") {
                    parser.state = S.OPEN_TAG_SLASH;
                  } else {
                    if (not(whitespace, c)) {
                      strictFail(parser, "Invalid character in tag name");
                    }
                    parser.state = S.ATTRIB;
                  }
                }
                continue;
              case S.OPEN_TAG_SLASH:
                if (c === ">") {
                  openTag(parser, true);
                  closeTag(parser);
                } else {
                  strictFail(parser, "Forward-slash in opening tag not followed by >");
                  parser.state = S.ATTRIB;
                }
                continue;
              case S.ATTRIB:
                if (is(whitespace, c)) {
                  continue;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else if (is(nameStart, c)) {
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_NAME:
                if (c === "=") {
                  parser.state = S.ATTRIB_VALUE;
                } else if (c === ">") {
                  strictFail(parser, "Attribute without value");
                  parser.attribValue = parser.attribName;
                  attrib(parser);
                  openTag(parser);
                } else if (is(whitespace, c)) {
                  parser.state = S.ATTRIB_NAME_SAW_WHITE;
                } else if (is(nameBody, c)) {
                  parser.attribName += c;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_NAME_SAW_WHITE:
                if (c === "=") {
                  parser.state = S.ATTRIB_VALUE;
                } else if (is(whitespace, c)) {
                  continue;
                } else {
                  strictFail(parser, "Attribute without value");
                  parser.tag.attributes[parser.attribName] = "";
                  parser.attribValue = "";
                  emitNode(parser, "onattribute", {
                    name: parser.attribName,
                    value: ""
                  });
                  parser.attribName = "";
                  if (c === ">") {
                    openTag(parser);
                  } else if (is(nameStart, c)) {
                    parser.attribName = c;
                    parser.state = S.ATTRIB_NAME;
                  } else {
                    strictFail(parser, "Invalid attribute name");
                    parser.state = S.ATTRIB;
                  }
                }
                continue;
              case S.ATTRIB_VALUE:
                if (is(whitespace, c)) {
                  continue;
                } else if (is(quote, c)) {
                  parser.q = c;
                  parser.state = S.ATTRIB_VALUE_QUOTED;
                } else {
                  strictFail(parser, "Unquoted attribute value");
                  parser.state = S.ATTRIB_VALUE_UNQUOTED;
                  parser.attribValue = c;
                }
                continue;
              case S.ATTRIB_VALUE_QUOTED:
                if (c !== parser.q) {
                  if (c === "&") {
                    parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                parser.q = "";
                parser.state = S.ATTRIB_VALUE_CLOSED;
                continue;
              case S.ATTRIB_VALUE_CLOSED:
                if (is(whitespace, c)) {
                  parser.state = S.ATTRIB;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else if (is(nameStart, c)) {
                  strictFail(parser, "No whitespace between attributes");
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_VALUE_UNQUOTED:
                if (not(attribEnd, c)) {
                  if (c === "&") {
                    parser.state = S.ATTRIB_VALUE_ENTITY_U;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                if (c === ">") {
                  openTag(parser);
                } else {
                  parser.state = S.ATTRIB;
                }
                continue;
              case S.CLOSE_TAG:
                if (!parser.tagName) {
                  if (is(whitespace, c)) {
                    continue;
                  } else if (not(nameStart, c)) {
                    if (parser.script) {
                      parser.script += "</" + c;
                      parser.state = S.SCRIPT;
                    } else {
                      strictFail(parser, "Invalid tagname in closing tag.");
                    }
                  } else {
                    parser.tagName = c;
                  }
                } else if (c === ">") {
                  closeTag(parser);
                } else if (is(nameBody, c)) {
                  parser.tagName += c;
                } else if (parser.script) {
                  parser.script += "</" + parser.tagName;
                  parser.tagName = "";
                  parser.state = S.SCRIPT;
                } else {
                  if (not(whitespace, c)) {
                    strictFail(parser, "Invalid tagname in closing tag");
                  }
                  parser.state = S.CLOSE_TAG_SAW_WHITE;
                }
                continue;
              case S.CLOSE_TAG_SAW_WHITE:
                if (is(whitespace, c)) {
                  continue;
                }
                if (c === ">") {
                  closeTag(parser);
                } else {
                  strictFail(parser, "Invalid characters in closing tag");
                }
                continue;
              case S.TEXT_ENTITY:
              case S.ATTRIB_VALUE_ENTITY_Q:
              case S.ATTRIB_VALUE_ENTITY_U:
                var returnState;
                var buffer;
                switch (parser.state) {
                  case S.TEXT_ENTITY:
                    returnState = S.TEXT;
                    buffer = "textNode";
                    break;
                  case S.ATTRIB_VALUE_ENTITY_Q:
                    returnState = S.ATTRIB_VALUE_QUOTED;
                    buffer = "attribValue";
                    break;
                  case S.ATTRIB_VALUE_ENTITY_U:
                    returnState = S.ATTRIB_VALUE_UNQUOTED;
                    buffer = "attribValue";
                    break;
                }
                if (c === ";") {
                  parser[buffer] += parseEntity(parser);
                  parser.entity = "";
                  parser.state = returnState;
                } else if (is(parser.entity.length ? entityBody : entityStart, c)) {
                  parser.entity += c;
                } else {
                  strictFail(parser, "Invalid character in entity name");
                  parser[buffer] += "&" + parser.entity + c;
                  parser.entity = "";
                  parser.state = returnState;
                }
                continue;
              default:
                throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
          if (parser.position >= parser.bufferCheckPosition) {
            checkBufferLength(parser);
          }
          return parser;
        }
        if (!String.fromCodePoint) {
          (function() {
            var stringFromCharCode = String.fromCharCode;
            var floor = Math.floor;
            var fromCodePoint = function() {
              var MAX_SIZE = 16384;
              var codeUnits = [];
              var highSurrogate;
              var lowSurrogate;
              var index = -1;
              var length = arguments.length;
              if (!length) {
                return "";
              }
              var result = "";
              while (++index < length) {
                var codePoint = Number(arguments[index]);
                if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
                  throw RangeError("Invalid code point: " + codePoint);
                }
                if (codePoint <= 65535) {
                  codeUnits.push(codePoint);
                } else {
                  codePoint -= 65536;
                  highSurrogate = (codePoint >> 10) + 55296;
                  lowSurrogate = codePoint % 1024 + 56320;
                  codeUnits.push(highSurrogate, lowSurrogate);
                }
                if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                  result += stringFromCharCode.apply(null, codeUnits);
                  codeUnits.length = 0;
                }
              }
              return result;
            };
            if (Object.defineProperty) {
              Object.defineProperty(String, "fromCodePoint", {
                value: fromCodePoint,
                configurable: true,
                writable: true
              });
            } else {
              String.fromCodePoint = fromCodePoint;
            }
          })();
        }
      })(typeof exports === "undefined" ? exports.sax = {} : exports);
    }
  });

  // node_modules/elementtree/lib/parsers/sax.js
  var require_sax3 = __commonJS({
    "node_modules/elementtree/lib/parsers/sax.js"(exports) {
      init_shim();
      var util = require_util2();
      var sax = require_sax2();
      var TreeBuilder = require_treebuilder().TreeBuilder;
      function XMLParser(target) {
        this.parser = sax.parser(true);
        this.target = target ? target : new TreeBuilder();
        this.parser.onopentag = this._handleOpenTag.bind(this);
        this.parser.ontext = this._handleText.bind(this);
        this.parser.oncdata = this._handleCdata.bind(this);
        this.parser.ondoctype = this._handleDoctype.bind(this);
        this.parser.oncomment = this._handleComment.bind(this);
        this.parser.onclosetag = this._handleCloseTag.bind(this);
        this.parser.onerror = this._handleError.bind(this);
      }
      XMLParser.prototype._handleOpenTag = function(tag) {
        this.target.start(tag.name, tag.attributes);
      };
      XMLParser.prototype._handleText = function(text5) {
        this.target.data(text5);
      };
      XMLParser.prototype._handleCdata = function(text5) {
        this.target.data(text5);
      };
      XMLParser.prototype._handleDoctype = function(text5) {
      };
      XMLParser.prototype._handleComment = function(comment) {
      };
      XMLParser.prototype._handleCloseTag = function(tag) {
        this.target.end(tag);
      };
      XMLParser.prototype._handleError = function(err) {
        throw err;
      };
      XMLParser.prototype.feed = function(chunk) {
        this.parser.write(chunk);
      };
      XMLParser.prototype.close = function() {
        this.parser.close();
        return this.target.close();
      };
      exports.XMLParser = XMLParser;
    }
  });

  // node_modules/elementtree/lib/parsers/index.js
  var require_parsers = __commonJS({
    "node_modules/elementtree/lib/parsers/index.js"(exports) {
      init_shim();
      exports.sax = require_sax3();
    }
  });

  // node_modules/elementtree/lib/parser.js
  var require_parser = __commonJS({
    "node_modules/elementtree/lib/parser.js"(exports) {
      init_shim();
      var util = require_util2();
      var parsers = require_parsers();
      function get_parser(name) {
        if (name === "sax") {
          return parsers.sax;
        } else {
          throw new Error("Invalid parser: " + name);
        }
      }
      exports.get_parser = get_parser;
    }
  });

  // node_modules/elementtree/lib/constants.js
  var require_constants = __commonJS({
    "node_modules/elementtree/lib/constants.js"(exports) {
      init_shim();
      var DEFAULT_PARSER = "sax";
      exports.DEFAULT_PARSER = DEFAULT_PARSER;
    }
  });

  // node_modules/elementtree/lib/elementtree.js
  var require_elementtree = __commonJS({
    "node_modules/elementtree/lib/elementtree.js"(exports) {
      init_shim();
      var sprintf = require_sprintf().sprintf;
      var utils = require_utils();
      var ElementPath = require_elementpath();
      var TreeBuilder = require_treebuilder().TreeBuilder;
      var get_parser = require_parser().get_parser;
      var constants = require_constants();
      var element_ids = 0;
      function Element(tag, attrib) {
        this._id = element_ids++;
        this.tag = tag;
        this.attrib = {};
        this.text = null;
        this.tail = null;
        this._children = [];
        if (attrib) {
          this.attrib = utils.merge(this.attrib, attrib);
        }
      }
      Element.prototype.toString = function() {
        return sprintf("<Element %s at %s>", this.tag, this._id);
      };
      Element.prototype.makeelement = function(tag, attrib) {
        return new Element(tag, attrib);
      };
      Element.prototype.len = function() {
        return this._children.length;
      };
      Element.prototype.getItem = function(index) {
        return this._children[index];
      };
      Element.prototype.setItem = function(index, element) {
        this._children[index] = element;
      };
      Element.prototype.delItem = function(index) {
        this._children.splice(index, 1);
      };
      Element.prototype.getSlice = function(start, stop) {
        return this._children.slice(start, stop);
      };
      Element.prototype.setSlice = function(start, stop, elements) {
        var i;
        var k = 0;
        for (i = start; i < stop; i++, k++) {
          this._children[i] = elements[k];
        }
      };
      Element.prototype.delSlice = function(start, stop) {
        this._children.splice(start, stop - start);
      };
      Element.prototype.append = function(element) {
        this._children.push(element);
      };
      Element.prototype.extend = function(elements) {
        this._children.concat(elements);
      };
      Element.prototype.insert = function(index, element) {
        this._children[index] = element;
      };
      Element.prototype.remove = function(element) {
        this._children = this._children.filter(function(e) {
          if (e._id === element._id) {
            return false;
          }
          return true;
        });
      };
      Element.prototype.getchildren = function() {
        return this._children;
      };
      Element.prototype.find = function(path) {
        return ElementPath.find(this, path);
      };
      Element.prototype.findtext = function(path, defvalue) {
        return ElementPath.findtext(this, path, defvalue);
      };
      Element.prototype.findall = function(path, defvalue) {
        return ElementPath.findall(this, path, defvalue);
      };
      Element.prototype.clear = function() {
        this.attrib = {};
        this._children = [];
        this.text = null;
        this.tail = null;
      };
      Element.prototype.get = function(key, defvalue) {
        if (this.attrib[key] !== void 0) {
          return this.attrib[key];
        } else {
          return defvalue;
        }
      };
      Element.prototype.set = function(key, value) {
        this.attrib[key] = value;
      };
      Element.prototype.keys = function() {
        return Object.keys(this.attrib);
      };
      Element.prototype.items = function() {
        return utils.items(this.attrib);
      };
      Element.prototype.iter = function(tag, callback) {
        var self2 = this;
        var i, child;
        if (tag === "*") {
          tag = null;
        }
        if (tag === null || this.tag === tag) {
          callback(self2);
        }
        for (i = 0; i < this._children.length; i++) {
          child = this._children[i];
          child.iter(tag, function(e) {
            callback(e);
          });
        }
      };
      Element.prototype.itertext = function(callback) {
        this.iter(null, function(e) {
          if (e.text) {
            callback(e.text);
          }
          if (e.tail) {
            callback(e.tail);
          }
        });
      };
      function SubElement(parent, tag, attrib) {
        var element = parent.makeelement(tag, attrib);
        parent.append(element);
        return element;
      }
      function Comment(text5) {
        var element = new Element(Comment);
        if (text5) {
          element.text = text5;
        }
        return element;
      }
      function CData(text5) {
        var element = new Element(CData);
        if (text5) {
          element.text = text5;
        }
        return element;
      }
      function ProcessingInstruction(target, text5) {
        var element = new Element(ProcessingInstruction);
        element.text = target;
        if (text5) {
          element.text = element.text + " " + text5;
        }
        return element;
      }
      function QName(text_or_uri, tag) {
        if (tag) {
          text_or_uri = sprintf("{%s}%s", text_or_uri, tag);
        }
        this.text = text_or_uri;
      }
      QName.prototype.toString = function() {
        return this.text;
      };
      function ElementTree(element) {
        this._root = element;
      }
      ElementTree.prototype.getroot = function() {
        return this._root;
      };
      ElementTree.prototype._setroot = function(element) {
        this._root = element;
      };
      ElementTree.prototype.parse = function(source, parser) {
        if (!parser) {
          parser = get_parser(constants.DEFAULT_PARSER);
          parser = new parser.XMLParser(new TreeBuilder());
        }
        parser.feed(source);
        this._root = parser.close();
        return this._root;
      };
      ElementTree.prototype.iter = function(tag, callback) {
        this._root.iter(tag, callback);
      };
      ElementTree.prototype.find = function(path) {
        return this._root.find(path);
      };
      ElementTree.prototype.findtext = function(path, defvalue) {
        return this._root.findtext(path, defvalue);
      };
      ElementTree.prototype.findall = function(path) {
        return this._root.findall(path);
      };
      ElementTree.prototype.write = function(options) {
        var sb = [];
        options = utils.merge({
          encoding: "utf-8",
          xml_declaration: null,
          default_namespace: null,
          method: "xml"
        }, options);
        if (options.xml_declaration !== false) {
          sb.push("<?xml version='1.0' encoding='" + options.encoding + "'?>\n");
        }
        if (options.method === "text") {
          _serialize_text(sb, self._root, encoding);
        } else {
          var qnames, namespaces, indent22, indent_string;
          var x = _namespaces(this._root, options.encoding, options.default_namespace);
          qnames = x[0];
          namespaces = x[1];
          if (options.hasOwnProperty("indent")) {
            indent22 = 0;
            indent_string = new Array(options.indent + 1).join(" ");
          } else {
            indent22 = false;
          }
          if (options.method === "xml") {
            _serialize_xml(function(data) {
              sb.push(data);
            }, this._root, options.encoding, qnames, namespaces, indent22, indent_string);
          } else {
            throw new Error("unknown serialization method " + options.method);
          }
        }
        return sb.join("");
      };
      var _namespace_map = {
        "http://www.w3.org/XML/1998/namespace": "xml",
        "http://www.w3.org/1999/xhtml": "html",
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#": "rdf",
        "http://schemas.xmlsoap.org/wsdl/": "wsdl",
        "http://www.w3.org/2001/XMLSchema": "xs",
        "http://www.w3.org/2001/XMLSchema-instance": "xsi",
        "http://purl.org/dc/elements/1.1/": "dc"
      };
      function register_namespace(prefix, uri) {
        if (/ns\d+$/.test(prefix)) {
          throw new Error("Prefix format reserved for internal use");
        }
        if (_namespace_map.hasOwnProperty(uri) && _namespace_map[uri] === prefix) {
          delete _namespace_map[uri];
        }
        _namespace_map[uri] = prefix;
      }
      function _escape(text5, encoding2, isAttribute, isText) {
        if (text5) {
          text5 = text5.toString();
          text5 = text5.replace(/&/g, "&amp;");
          text5 = text5.replace(/</g, "&lt;");
          text5 = text5.replace(/>/g, "&gt;");
          if (!isText) {
            text5 = text5.replace(/\n/g, "&#xA;");
            text5 = text5.replace(/\r/g, "&#xD;");
          }
          if (isAttribute) {
            text5 = text5.replace(/"/g, "&quot;");
          }
        }
        return text5;
      }
      function _escape_attrib(text5, encoding2) {
        return _escape(text5, encoding2, true);
      }
      function _escape_cdata(text5, encoding2) {
        return _escape(text5, encoding2, false);
      }
      function _escape_text(text5, encoding2) {
        return _escape(text5, encoding2, false, true);
      }
      function _namespaces(elem, encoding2, default_namespace) {
        var qnames = {};
        var namespaces = {};
        if (default_namespace) {
          namespaces[default_namespace] = "";
        }
        function encode(text5) {
          return text5;
        }
        function add_qname(qname) {
          if (qname[0] === "{") {
            var tmp = qname.substring(1).split("}", 2);
            var uri = tmp[0];
            var tag = tmp[1];
            var prefix = namespaces[uri];
            if (prefix === void 0) {
              prefix = _namespace_map[uri];
              if (prefix === void 0) {
                prefix = "ns" + Object.keys(namespaces).length;
              }
              if (prefix !== "xml") {
                namespaces[uri] = prefix;
              }
            }
            if (prefix) {
              qnames[qname] = sprintf("%s:%s", prefix, tag);
            } else {
              qnames[qname] = tag;
            }
          } else {
            if (default_namespace) {
              throw new Error("cannot use non-qualified names with default_namespace option");
            }
            qnames[qname] = qname;
          }
        }
        elem.iter(null, function(e) {
          var i;
          var tag = e.tag;
          var text5 = e.text;
          var items = e.items();
          if (tag instanceof QName && qnames[tag.text] === void 0) {
            add_qname(tag.text);
          } else if (typeof tag === "string") {
            add_qname(tag);
          } else if (tag !== null && tag !== Comment && tag !== CData && tag !== ProcessingInstruction) {
            throw new Error("Invalid tag type for serialization: " + tag);
          }
          if (text5 instanceof QName && qnames[text5.text] === void 0) {
            add_qname(text5.text);
          }
          items.forEach(function(item) {
            var key = item[0], value = item[1];
            if (key instanceof QName) {
              key = key.text;
            }
            if (qnames[key] === void 0) {
              add_qname(key);
            }
            if (value instanceof QName && qnames[value.text] === void 0) {
              add_qname(value.text);
            }
          });
        });
        return [qnames, namespaces];
      }
      function _serialize_xml(write, elem, encoding2, qnames, namespaces, indent22, indent_string) {
        var tag = elem.tag;
        var text5 = elem.text;
        var items;
        var i;
        var newlines = indent22 || indent22 === 0;
        write(Array(indent22 + 1).join(indent_string));
        if (tag === Comment) {
          write(sprintf("<!--%s-->", _escape_cdata(text5, encoding2)));
        } else if (tag === ProcessingInstruction) {
          write(sprintf("<?%s?>", _escape_cdata(text5, encoding2)));
        } else if (tag === CData) {
          text5 = text5 || "";
          write(sprintf("<![CDATA[%s]]>", text5));
        } else {
          tag = qnames[tag];
          if (tag === void 0) {
            if (text5) {
              write(_escape_text(text5, encoding2));
            }
            elem.iter(function(e) {
              _serialize_xml(write, e, encoding2, qnames, null, newlines ? indent22 + 1 : false, indent_string);
            });
          } else {
            write("<" + tag);
            items = elem.items();
            if (items || namespaces) {
              items.sort();
              items.forEach(function(item) {
                var k = item[0], v = item[1];
                if (k instanceof QName) {
                  k = k.text;
                }
                if (v instanceof QName) {
                  v = qnames[v.text];
                } else {
                  v = _escape_attrib(v, encoding2);
                }
                write(sprintf(' %s="%s"', qnames[k], v));
              });
              if (namespaces) {
                items = utils.items(namespaces);
                items.sort(function(a, b) {
                  return a[1] < b[1];
                });
                items.forEach(function(item) {
                  var k = item[1], v = item[0];
                  if (k) {
                    k = ":" + k;
                  }
                  write(sprintf(' xmlns%s="%s"', k, _escape_attrib(v, encoding2)));
                });
              }
            }
            if (text5 || elem.len()) {
              if (text5 && text5.toString().match(/^\s*$/)) {
                text5 = null;
              }
              write(">");
              if (!text5 && newlines) {
                write("\n");
              }
              if (text5) {
                write(_escape_text(text5, encoding2));
              }
              elem._children.forEach(function(e) {
                _serialize_xml(write, e, encoding2, qnames, null, newlines ? indent22 + 1 : false, indent_string);
              });
              if (!text5 && indent22) {
                write(Array(indent22 + 1).join(indent_string));
              }
              write("</" + tag + ">");
            } else {
              write(" />");
            }
          }
        }
        if (newlines) {
          write("\n");
        }
      }
      function parse(source, parser) {
        var tree = new ElementTree();
        tree.parse(source, parser);
        return tree;
      }
      function tostring2(element, options) {
        return new ElementTree(element).write(options);
      }
      exports.PI = ProcessingInstruction;
      exports.Comment = Comment;
      exports.CData = CData;
      exports.ProcessingInstruction = ProcessingInstruction;
      exports.SubElement = SubElement;
      exports.QName = QName;
      exports.ElementTree = ElementTree;
      exports.ElementPath = ElementPath;
      exports.Element = function(tag, attrib) {
        return new Element(tag, attrib);
      };
      exports.XML = function(data) {
        var et = new ElementTree();
        return et.parse(data);
      };
      exports.parse = parse;
      exports.register_namespace = register_namespace;
      exports.tostring = tostring2;
    }
  });

  // node_modules/rdfoo/dist/rdfoo/triple.js
  var require_triple = __commonJS({
    "node_modules/rdfoo/dist/rdfoo/triple.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromSPO = exports.objectString = exports.objectBool = exports.objectFloat = exports.objectInt = exports.objectUri = exports.predicateUri = exports.subjectUri = void 0;
      var node19 = require_node();
      var rdf_ext_1 = (init_rdf_ext(), __toCommonJS(rdf_ext_exports));
      function subjectUri(triple6) {
        if (triple6 === void 0)
          return void 0;
        return node19.toUri(triple6.subject);
      }
      exports.subjectUri = subjectUri;
      function predicateUri(triple6) {
        if (triple6 === void 0)
          return void 0;
        return node19.toUri(triple6.predicate);
      }
      exports.predicateUri = predicateUri;
      function objectUri(triple6) {
        if (triple6 === void 0)
          return void 0;
        return node19.toUri(triple6.object);
      }
      exports.objectUri = objectUri;
      function objectInt(triple6) {
        if (triple6 === void 0)
          return void 0;
        return node19.toInt(triple6.object);
      }
      exports.objectInt = objectInt;
      function objectFloat(triple6) {
        if (triple6 === void 0)
          return void 0;
        return node19.toFloat(triple6.object);
      }
      exports.objectFloat = objectFloat;
      function objectBool(triple6) {
        if (triple6 === void 0)
          return void 0;
        return node19.toBool(triple6.object);
      }
      exports.objectBool = objectBool;
      function objectString(triple6) {
        if (triple6 === void 0)
          return void 0;
        return node19.toString(triple6.object);
      }
      exports.objectString = objectString;
      function fromSPO(s, p, o) {
        return rdf_ext_1.default.quad(s, p, o);
      }
      exports.fromSPO = fromSPO;
    }
  });

  // node_modules/rdfoo/dist/rdfoo/serialize.js
  var require_serialize = __commonJS({
    "node_modules/rdfoo/dist/rdfoo/serialize.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var et = require_elementtree();
      var triple_1 = require_triple();
      var ElementTree = et.ElementTree;
      var Element = et.Element;
      var SubElement = et.SubElement;
      var QName = et.QName;
      function serialize(graph2, defaultPrefixes, isOwnershipRelation, preferredTypeNamespace) {
        let prefixes = new Map(defaultPrefixes);
        let prefixesUsed = /* @__PURE__ */ new Map();
        prefixesUsed.set("rdf", true);
        let subjectToElement = /* @__PURE__ */ new Map();
        let ownedElements = /* @__PURE__ */ new Set();
        for (let triple6 of graph2.match(null, "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", null)) {
          let subject = nodeToURI(triple6.subject);
          let type = nodeToURI(triple6.object);
          if (subjectToElement.has(subject))
            continue;
          let types = graph2.match(triple6.subject, "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", null).map(triple_1.objectUri).filter((s) => s !== void 0).map((s) => s);
          for (let type2 of types) {
            if (type2.indexOf(preferredTypeNamespace) === 0) {
              types = [type2];
              break;
            }
          }
          let subjectElem = Element(prefixify(types[0]), {
            [prefixify("http://www.w3.org/1999/02/22-rdf-syntax-ns#about")]: subject
          });
          subjectToElement.set(subject, subjectElem);
        }
        for (let triple6 of graph2.graph) {
          let s = nodeToURI(triple6.subject);
          let subjectElem = subjectToElement.get(s);
          if (!subjectElem) {
            subjectElem = Element("rdf:Description", {
              [prefixify("http://www.w3.org/1999/02/22-rdf-syntax-ns#about")]: s
            });
            subjectToElement.set(s, subjectElem);
          }
          let p = nodeToURI(triple6.predicate);
          if (p === "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
            continue;
          }
          if (isOwnershipRelation(triple6)) {
            let o = nodeToURI(triple6.object);
            let ownedElement = subjectToElement.get(o);
            if (ownedElement) {
              let ownershipElement = SubElement(subjectElem, prefixify(p));
              ownershipElement.append(ownedElement);
              ownedElements.add(o);
              continue;
            }
          }
          if (triple6.object.termType === "NamedNode") {
            SubElement(subjectElem, prefixify(p), {
              [prefixify("http://www.w3.org/1999/02/22-rdf-syntax-ns#resource")]: nodeToURI(triple6.object)
            });
            continue;
          }
          if (triple6.object.termType === "Literal") {
            let attr = {};
            let elem = SubElement(subjectElem, prefixify(p), attr);
            elem.text = triple6.object.value;
            continue;
          }
          throw new Error("Unknown termType " + triple6.object.termType);
        }
        let docAttr = {};
        for (let prefix of prefixes.keys()) {
          if (prefixesUsed.get(prefix) === true)
            docAttr["xmlns:" + prefix] = prefixes.get(prefix);
        }
        let root = Element(prefixify("http://www.w3.org/1999/02/22-rdf-syntax-ns#RDF"), docAttr);
        for (let subject of subjectToElement.keys()) {
          if (!ownedElements.has(subject))
            root.append(subjectToElement.get(subject));
        }
        let doc = new ElementTree(root);
        return doc.write({
          xml_declaration: true,
          indent: 2
        });
        function nodeToURI(node19) {
          if (node19.termType !== "NamedNode")
            throw new Error("expected NamedNode but found " + JSON.stringify(node19));
          if (typeof node19.value !== "string")
            throw new Error("value not a string?");
          return node19.value;
        }
        function prefixify(iri) {
          for (var prefix of prefixes.keys()) {
            var prefixIRI = prefixes.get(prefix);
            if (iri.indexOf(prefixIRI) === 0) {
              prefixesUsed.set(prefix, true);
              return prefix + ":" + iri.slice(prefixIRI.length);
            }
          }
          var fragmentStart = iri.lastIndexOf("#");
          if (fragmentStart === -1)
            fragmentStart = iri.lastIndexOf("/");
          if (fragmentStart === -1)
            return iri;
          var iriPrefix = iri.substr(0, fragmentStart + 1);
          for (var i = 0; ; ++i) {
            var prefixName = "ns" + i;
            if (prefixes.get(prefixName) === void 0) {
              prefixes.set(prefixName, iriPrefix);
              prefixesUsed.set(prefixName, true);
              return prefixName + ":" + iri.slice(iriPrefix.length);
            }
          }
        }
      }
      exports.default = serialize;
    }
  });

  // node_modules/promise-polyfill/Promise.js
  var require_Promise = __commonJS({
    "node_modules/promise-polyfill/Promise.js"(exports, module) {
      init_shim();
      (function() {
        var root;
        if (typeof window === "object" && window) {
          root = window;
        } else {
          root = _global;
        }
        if (typeof module !== "undefined" && module.exports) {
          module.exports = root.Promise ? root.Promise : Promise2;
        } else if (!root.Promise) {
          root.Promise = Promise2;
        }
        var asap = root.setImmediate || function(fn) {
          setTimeout(fn, 1);
        };
        function bind(fn, thisArg) {
          return function() {
            fn.apply(thisArg, arguments);
          };
        }
        var isArray = Array.isArray || function(value) {
          return Object.prototype.toString.call(value) === "[object Array]";
        };
        function Promise2(fn) {
          if (typeof this !== "object")
            throw new TypeError("Promises must be constructed via new");
          if (typeof fn !== "function")
            throw new TypeError("not a function");
          this._state = null;
          this._value = null;
          this._deferreds = [];
          doResolve(fn, bind(resolve, this), bind(reject, this));
        }
        function handle(deferred) {
          var me = this;
          if (this._state === null) {
            this._deferreds.push(deferred);
            return;
          }
          asap(function() {
            var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
            if (cb === null) {
              (me._state ? deferred.resolve : deferred.reject)(me._value);
              return;
            }
            var ret;
            try {
              ret = cb(me._value);
            } catch (e) {
              deferred.reject(e);
              return;
            }
            deferred.resolve(ret);
          });
        }
        function resolve(newValue) {
          try {
            if (newValue === this)
              throw new TypeError("A promise cannot be resolved with itself.");
            if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
              var then = newValue.then;
              if (typeof then === "function") {
                doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));
                return;
              }
            }
            this._state = true;
            this._value = newValue;
            finale.call(this);
          } catch (e) {
            reject.call(this, e);
          }
        }
        function reject(newValue) {
          this._state = false;
          this._value = newValue;
          finale.call(this);
        }
        function finale() {
          for (var i = 0, len = this._deferreds.length; i < len; i++) {
            handle.call(this, this._deferreds[i]);
          }
          this._deferreds = null;
        }
        function Handler(onFulfilled, onRejected, resolve2, reject2) {
          this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
          this.onRejected = typeof onRejected === "function" ? onRejected : null;
          this.resolve = resolve2;
          this.reject = reject2;
        }
        function doResolve(fn, onFulfilled, onRejected) {
          var done = false;
          try {
            fn(function(value) {
              if (done)
                return;
              done = true;
              onFulfilled(value);
            }, function(reason) {
              if (done)
                return;
              done = true;
              onRejected(reason);
            });
          } catch (ex) {
            if (done)
              return;
            done = true;
            onRejected(ex);
          }
        }
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          var me = this;
          return new Promise2(function(resolve2, reject2) {
            handle.call(me, new Handler(onFulfilled, onRejected, resolve2, reject2));
          });
        };
        Promise2.all = function() {
          var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);
          return new Promise2(function(resolve2, reject2) {
            if (args.length === 0)
              return resolve2([]);
            var remaining = args.length;
            function res(i2, val) {
              try {
                if (val && (typeof val === "object" || typeof val === "function")) {
                  var then = val.then;
                  if (typeof then === "function") {
                    then.call(val, function(val2) {
                      res(i2, val2);
                    }, reject2);
                    return;
                  }
                }
                args[i2] = val;
                if (--remaining === 0) {
                  resolve2(args);
                }
              } catch (ex) {
                reject2(ex);
              }
            }
            for (var i = 0; i < args.length; i++) {
              res(i, args[i]);
            }
          });
        };
        Promise2.resolve = function(value) {
          if (value && typeof value === "object" && value.constructor === Promise2) {
            return value;
          }
          return new Promise2(function(resolve2) {
            resolve2(value);
          });
        };
        Promise2.reject = function(value) {
          return new Promise2(function(resolve2, reject2) {
            reject2(value);
          });
        };
        Promise2.race = function(values) {
          return new Promise2(function(resolve2, reject2) {
            for (var i = 0, len = values.length; i < len; i++) {
              values[i].then(resolve2, reject2);
            }
          });
        };
      })();
    }
  });

  // node_modules/stream-to-string/index.js
  var require_stream_to_string = __commonJS({
    "node_modules/stream-to-string/index.js"(exports, module) {
      init_shim();
      var Promise2 = require_Promise();
      module.exports = function(stream, enc, cb) {
        if (typeof enc === "function") {
          cb = enc;
          enc = null;
        }
        cb = cb || function() {
        };
        var str = "";
        return new Promise2(function(resolve, reject) {
          stream.on("data", function(data) {
            str += typeof enc === "string" ? data.toString(enc) : data.toString();
          });
          stream.on("end", function() {
            resolve(str);
            cb(null, str);
          });
          stream.on("error", function(err) {
            reject(err);
            cb(err);
          });
        });
      };
    }
  });

  // node_modules/rdfoo/dist/rdfoo/Graph.js
  var require_Graph = __commonJS({
    "node_modules/rdfoo/dist/rdfoo/Graph.js"(exports) {
      "use strict";
      init_shim();
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var node19 = require_node();
      var shortid = require_shortid();
      var identifyFiletype_1 = require_identifyFiletype();
      var parseRDF_1 = require_parseRDF();
      var serialize_1 = require_serialize();
      var rdf_ext_1 = (init_rdf_ext(), __toCommonJS(rdf_ext_exports));
      var formats = require_formats();
      var streamToString = require_stream_to_string();
      var Graph23 = class {
        constructor(triples) {
          this.graph = triples ? rdf_ext_1.default.dataset(triples) : rdf_ext_1.default.dataset([]);
          this._globalWatchers = new Array();
          this._subjWatchers = /* @__PURE__ */ new Map();
          this.ignoreWatchers = false;
        }
        match(s, p, o) {
          if (s === void 0 || p === void 0 || o === void 0) {
            console.dir(arguments);
            throw new Error("one of s/p/o were undefined");
          }
          if (typeof p === "string")
            p = rdf_ext_1.default.namedNode(p);
          return Array.from(this.graph.match(s, p, o));
        }
        matchOne(s, p, o) {
          if (s === void 0 || p === void 0 || o === void 0)
            throw new Error("one of s/p/o were undefined");
          if (!s && !o) {
            console.dir({ s, p, o });
            throw new Error("matchOne with only a predicate?");
          }
          if (!p && !o) {
            console.dir({ s, p, o });
            throw new Error("matchOne with only a subject?");
          }
          if (!s && !p) {
            console.dir({ s, p, o });
            throw new Error("matchOne with only an object?");
          }
          const matches = this.match(s, p, o);
          if (matches.length > 1) {
            console.error("results:");
            console.dir(matches);
            throw new Error("Got more than one result for matchOne { " + [s, p, o].join(", ") + " }");
          }
          return matches[0];
        }
        hasMatch(s, p, o) {
          if (s === void 0 || p === void 0 || o === void 0)
            throw new Error("one of s/p/o were undefined");
          return this.match(s, p, o).length > 0;
        }
        addAll(other) {
          this.graph.addAll(other.graph);
        }
        get subjects() {
          var _a;
          return Object.keys(((_a = this.graph["_graphs"][""]) === null || _a === void 0 ? void 0 : _a.subjects) || []).map((s) => this.graph["_entities"][s]);
        }
        fireWatchers(subj) {
          if (this.ignoreWatchers)
            return;
          const watchers = this._subjWatchers.get(subj);
          if (watchers === void 0)
            return;
          watchers.forEach((cb) => {
            cb();
          });
        }
        fireGlobalWatchers() {
          if (this.ignoreWatchers)
            return;
          this._globalWatchers.forEach((cb) => cb());
        }
        insertTriple(s, p, o) {
          if (typeof p === "string")
            p = rdf_ext_1.default.namedNode(p);
          this.graph.add(rdf_ext_1.default.quad(s, p, o));
          this.touchSubject(s.value);
        }
        insertTriples(triples) {
          const w = /* @__PURE__ */ new Set();
          for (let t of triples) {
            let [s, p, o] = [t.subject, t.predicate, t.object];
            this.insertTriple(s, p, o);
            w.add(s.value);
          }
          w.forEach((uri) => {
            this.touchSubject(uri);
          });
        }
        touchSubject(subject) {
          this.fireWatchers(subject);
          this.fireGlobalWatchers();
        }
        insertProperties(subject, properties) {
          var triples = [];
          for (let property of Object.keys(properties)) {
            var value = properties[property];
            if (Array.isArray(value)) {
              value.forEach((value2) => {
                triples.push({
                  subject,
                  predicate: rdf_ext_1.default.namedNode(property),
                  object: value2
                });
              });
            } else {
              triples.push({
                subject,
                predicate: rdf_ext_1.default.namedNode(property),
                object: value
              });
            }
          }
          this.insertTriples(triples);
        }
        removeMatches(s, p, o) {
          if (s === void 0 || p === void 0 || o === void 0)
            throw new Error("one of s/p/o were undefined");
          if (typeof p === "string")
            p = rdf_ext_1.default.namedNode(p);
          const w = /* @__PURE__ */ new Set();
          const matches = this.match(s, p, o);
          matches.forEach((t) => {
            w.add(t.subject.value);
          });
          this.graph.deleteMatches(s, p, o);
          w.forEach((uri) => {
            this.touchSubject(uri);
          });
          this.fireGlobalWatchers();
        }
        generateURI(template) {
          var n = 1;
          for (; ; ) {
            var uri = template.split("$rand$").join(shortid.generate()).split("$^n$").join("" + n).split("$n$").join("_" + n).split("$n?$").join(n > 1 ? "_" + n : "");
            ++n;
            if (this.hasMatch(rdf_ext_1.default.namedNode(uri), null, null))
              continue;
            return uri;
          }
        }
        purgeSubject(s) {
          this.graph.deleteMatches(s, null, null);
          this.graph.deleteMatches(null, null, s);
        }
        replaceSubject(oldSubject, newSubject) {
          let newGraph = rdf_ext_1.default.dataset();
          for (let triple6 of this.graph) {
            newGraph.add(rdf_ext_1.default.quad(replace(triple6.subject), replace(triple6.predicate), replace(triple6.object)));
          }
          this.graph = newGraph;
          function replace(n) {
            if (n.termType !== "NamedNode")
              return n;
            if (n.value !== oldSubject.value)
              return n;
            return node19.createUriNode(newSubject.value);
          }
        }
        watchSubject(uri, cb) {
          const watchers = this._subjWatchers.get(uri);
          if (watchers === void 0) {
            this._subjWatchers.set(uri, [cb]);
          } else {
            watchers.push(cb);
          }
          return {
            unwatch: () => {
              const watchers2 = this._subjWatchers.get(uri);
              if (watchers2 !== void 0) {
                for (var i = 0; i < watchers2.length; ++i) {
                  if (watchers2[i] === cb) {
                    watchers2.splice(i, 1);
                    break;
                  }
                }
                if (watchers2.length === 0) {
                  this._subjWatchers.delete(uri);
                }
              }
            }
          };
        }
        watch(cb) {
          this._globalWatchers.push(cb);
          return {
            unwatch: () => {
              for (var i = 0; i < this._globalWatchers.length; ++i) {
                if (this._globalWatchers[i] === cb) {
                  this._globalWatchers.splice(i, 1);
                  break;
                }
              }
            }
          };
        }
        static loadString(data, defaultURIPrefix, mimeType) {
          return __awaiter(this, void 0, void 0, function* () {
            let graph2 = new Graph23();
            yield graph2.loadString(data, defaultURIPrefix, mimeType);
            return graph2;
          });
        }
        loadString(data, defaultURIPrefix, mimeType) {
          return __awaiter(this, void 0, void 0, function* () {
            let filetype = (0, identifyFiletype_1.default)(data, mimeType || null);
            if (filetype === null) {
              throw new Error("???");
            }
            yield (0, parseRDF_1.default)(this, data, filetype);
          });
        }
        startIgnoringWatchers() {
          this.ignoreWatchers = true;
        }
        stopIgnoringWatchers() {
          this.ignoreWatchers = false;
        }
        toArray() {
          return Array.from(this.graph);
        }
        clone() {
          return new Graph23(this.graph.clone());
        }
        serializeXML() {
          return (0, serialize_1.default)(this, /* @__PURE__ */ new Map(), () => false, "");
        }
        serializeN3() {
          return __awaiter(this, void 0, void 0, function* () {
            return yield streamToString(new (formats.serializers.get("text/n3")).Impl(this.graph.toStream()));
          });
        }
        serializeTurtle() {
          return __awaiter(this, void 0, void 0, function* () {
            return yield streamToString(new (formats.serializers.get("text/turtle")).Impl(this.graph.toStream()));
          });
        }
        serializeJSONLD() {
          return __awaiter(this, void 0, void 0, function* () {
            return yield streamToString(new (formats.serializers.get("application/ld+json")).Impl(this.graph.toStream()));
          });
        }
        filter(test) {
          return new Graph23(this.graph.filter(test));
        }
        map(fn) {
          return new Graph23(this.graph.map(fn));
        }
      };
      exports.default = Graph23;
    }
  });

  // node_modules/rdfoo/dist/rdfoo/Facade.js
  var require_Facade = __commonJS({
    "node_modules/rdfoo/dist/rdfoo/Facade.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var node19 = require_node();
      var rdf_ext_1 = (init_rdf_ext(), __toCommonJS(rdf_ext_exports));
      var Facade = class {
        constructor(graph2, subject) {
          this.graph = graph2;
          this.subject = subject;
        }
        get uri() {
          if (this.subject.termType === "NamedNode")
            return this.subject.value;
          else
            throw new Error("not a NamedNode");
        }
        getProperty(predicate) {
          var _a;
          return (_a = this.graph.matchOne(this.subject, predicate, null)) === null || _a === void 0 ? void 0 : _a.object;
        }
        getRequiredProperty(predicate) {
          let r = this.graph.matchOne(this.subject, predicate, null);
          if (!r) {
            throw new Error("missing property " + predicate);
          }
          return r.object;
        }
        getUriProperty(predicate) {
          var _a;
          return (_a = this.getProperty(predicate)) === null || _a === void 0 ? void 0 : _a.value;
        }
        getRequiredUriProperty(predicate) {
          var _a;
          if (typeof predicate === "string")
            predicate = rdf_ext_1.default.namedNode(predicate);
          const prop = (_a = this.getProperty(predicate)) === null || _a === void 0 ? void 0 : _a.value;
          if (prop === void 0)
            throw new Error("missing property " + predicate);
          return prop;
        }
        getStringProperty(predicate) {
          var _a;
          return (_a = this.getProperty(predicate)) === null || _a === void 0 ? void 0 : _a.value;
        }
        getRequiredStringProperty(predicate) {
          var _a;
          const prop = (_a = this.getProperty(predicate)) === null || _a === void 0 ? void 0 : _a.value;
          if (prop === void 0)
            throw new Error("missing property " + predicate);
          return prop;
        }
        getIntProperty(predicate) {
          var _a;
          let prop = (_a = this.getProperty(predicate)) === null || _a === void 0 ? void 0 : _a.value;
          if (prop === void 0)
            return void 0;
          return parseInt(prop);
        }
        getBoolProperty(predicate) {
          var _a;
          let prop = (_a = this.getProperty(predicate)) === null || _a === void 0 ? void 0 : _a.value;
          if (prop === void 0)
            return void 0;
          return prop === "true";
        }
        getFloatProperty(predicate) {
          var _a;
          let prop = (_a = this.getProperty(predicate)) === null || _a === void 0 ? void 0 : _a.value;
          if (prop === void 0)
            return void 0;
          return parseFloat(prop);
        }
        getProperties(predicate) {
          return this.graph.match(this.subject, predicate, null).map((t) => t.object);
        }
        getUriProperties(predicate) {
          return this.getProperties(predicate).map((prop) => prop.value).filter((el) => !!el);
        }
        getStringProperties(predicate) {
          return this.getProperties(predicate).map((prop) => prop.value).filter((el) => !!el);
        }
        setProperty(predicate, object) {
          this.graph.removeMatches(this.subject, predicate, null);
          if (object !== void 0)
            this.graph.insertTriple(this.subject, predicate, object);
        }
        insertProperty(predicate, object) {
          this.graph.insertTriple(this.subject, predicate, object);
        }
        insertProperties(properties) {
          this.graph.insertProperties(this.subject, properties);
        }
        deleteProperty(predicate) {
          this.graph.removeMatches(this.subject, predicate, null);
        }
        setUriProperty(predicate, value) {
          if (value === void 0) {
            this.deleteProperty(predicate);
          } else {
            this.setProperty(predicate, node19.createUriNode(value));
          }
        }
        insertUriProperty(predicate, value) {
          this.insertProperty(predicate, node19.createUriNode(value));
        }
        setStringProperty(predicate, value) {
          if (value === void 0) {
            this.deleteProperty(predicate);
          } else {
            this.setProperty(predicate, node19.createStringNode(value));
          }
        }
        setIntProperty(predicate, value) {
          if (value === void 0) {
            this.deleteProperty(predicate);
          } else {
            this.setProperty(predicate, node19.createIntNode(value));
          }
        }
        setBoolProperty(predicate, value) {
          if (value === void 0) {
            this.deleteProperty(predicate);
          } else {
            this.setProperty(predicate, node19.createBoolNode(value));
          }
        }
        setFloatProperty(predicate, value) {
          if (value === void 0) {
            this.deleteProperty(predicate);
          } else {
            this.setProperty(predicate, node19.createFloatNode(value));
          }
        }
        get objectType() {
          return this.getUriProperty("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
        }
        hasCorrectTypePredicate() {
          return this.objectType === this.facadeType;
        }
        watch(cb) {
          return this.graph.watchSubject(this.subject.value, cb);
        }
        destroy() {
          this.graph.removeMatches(null, null, this.subject);
          this.graph.removeMatches(this.subject, null, null);
        }
      };
      exports.default = Facade;
    }
  });

  // node_modules/rdfoo/dist/rdfoo/GraphView.js
  var require_GraphView = __commonJS({
    "node_modules/rdfoo/dist/rdfoo/GraphView.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var node19 = require_node();
      var GraphView6 = class {
        constructor(graph2) {
          this.graph = graph2;
        }
        uriToFacade(uri) {
          return this.subjectToFacade(node19.createUriNode(uri));
        }
      };
      exports.default = GraphView6;
    }
  });

  // node_modules/rdfoo/dist/rdfoo/GraphViewBasic.js
  var require_GraphViewBasic = __commonJS({
    "node_modules/rdfoo/dist/rdfoo/GraphViewBasic.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var GraphView_1 = require_GraphView();
      var triple6 = require_triple();
      var node19 = require_node();
      var rdf_ext_1 = (init_rdf_ext(), __toCommonJS(rdf_ext_exports));
      var GraphViewBasic = class extends GraphView_1.default {
        constructor(graph2) {
          super(graph2);
        }
        subjectToFacade(subject) {
          return void 0;
        }
        hasType(s, t) {
          return this.graph.hasMatch(s, "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", rdf_ext_1.default.namedNode(t));
        }
        instancesOfType(type) {
          if (typeof type === "string")
            type = node19.createUriNode(type);
          return this.graph.match(null, "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", type).map((t) => t.subject);
        }
        getType(uri) {
          const type = triple6.objectUri(this.graph.matchOne(uri, "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", null));
          return type;
        }
        getTypes(uri) {
          const types = this.graph.match(uri, "http://www.w3.org/1999/02/22-rdf-syntax-ns#type", null).map(triple6.objectUri);
          return types;
        }
      };
      exports.default = GraphViewBasic;
    }
  });

  // node_modules/rdfoo/dist/rdfoo/GraphViewHybrid.js
  var require_GraphViewHybrid = __commonJS({
    "node_modules/rdfoo/dist/rdfoo/GraphViewHybrid.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var GraphViewBasic_1 = require_GraphViewBasic();
      var GraphViewHybrid = class extends GraphViewBasic_1.default {
        constructor(graph2) {
          super(graph2);
          this.views = [];
        }
        addView(view) {
          this.views.push(view);
        }
        subjectToFacade(subject) {
          for (let d of this.views) {
            let f = d.subjectToFacade(subject);
            if (f !== void 0) {
              return f;
            }
          }
          return void 0;
        }
      };
      exports.default = GraphViewHybrid;
    }
  });

  // node_modules/rdfoo/dist/rdfoo/changeURIPrefix.js
  var require_changeURIPrefix = __commonJS({
    "node_modules/rdfoo/dist/rdfoo/changeURIPrefix.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var rdf_ext_1 = (init_rdf_ext(), __toCommonJS(rdf_ext_exports));
      var triple6 = require_triple();
      var node19 = require_node();
      function changeURIPrefix(graph2, topLevels, newPrefix) {
        let newGraph = rdf_ext_1.default.dataset([]);
        let prefixes = /* @__PURE__ */ new Set();
        let identityMap = /* @__PURE__ */ new Map();
        for (let triple7 of graph2.graph) {
          if (triple7.predicate.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
            if (topLevels.has(triple7.object.value)) {
              let subjectPrefix = prefix(triple7.subject.value);
              prefixes.add(subjectPrefix);
            }
          }
        }
        console.log("changeUriPrefix: prefixes are " + JSON.stringify(Array.from(prefixes)));
        console.log("changeUriPrefix: new prefix " + newPrefix);
        for (let triple7 of graph2.graph) {
          let subject = triple7.subject;
          let predicate = triple7.predicate;
          let object = triple7.object;
          let matched = false;
          for (let prefix2 of prefixes) {
            if (subject.value.indexOf(prefix2) === 0) {
              let newSubject = rdf_ext_1.default.namedNode(newPrefix + subject.value.slice(prefix2.length));
              identityMap.set(subject.value, newSubject.value);
              subject = newSubject;
              matched = true;
              break;
            }
          }
          if (!matched) {
            continue;
          }
          if (object.termType === "NamedNode") {
            for (let prefix2 of prefixes) {
              if (object.value.indexOf(prefix2) === 0) {
                let newObject = rdf_ext_1.default.namedNode(newPrefix + object.value.slice(prefix2.length));
                identityMap.set(object.value, newObject.value);
                object = newObject;
                break;
              }
            }
          }
          newGraph.add(rdf_ext_1.default.quad(subject, predicate, object));
        }
        console.dir(prefixes);
        graph2.graph = newGraph;
        return identityMap;
        function prefix(uri) {
          let hasNamespace = triple6.objectUri(graph2.matchOne(node19.createUriNode(uri), "http://sbols.org/v3#hasNamespace", null));
          if (hasNamespace) {
            return hasNamespace;
          }
          let n = 0;
          for (let i = uri.length - 1; i > 0; --i) {
            if (uri[i] === "/") {
              ++n;
              if (n === 2) {
                return uri.slice(0, i + 1);
              }
            }
          }
          throw new Error("cant get prefix");
        }
      }
      exports.default = changeURIPrefix;
    }
  });

  // node_modules/rdfoo/dist/index.js
  var require_dist = __commonJS({
    "node_modules/rdfoo/dist/index.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.literal = exports.namedNode = exports.rdf = exports.parseRDF = exports.Filetype = exports.identifyFiletype = exports.changeURIPrefix = exports.serialize = exports.triple = exports.node = exports.Facade = exports.GraphViewBasic = exports.GraphViewHybrid = exports.GraphView = exports.Graph = void 0;
      var Graph_1 = require_Graph();
      exports.Graph = Graph_1.default;
      var Facade_1 = require_Facade();
      exports.Facade = Facade_1.default;
      var GraphView_1 = require_GraphView();
      exports.GraphView = GraphView_1.default;
      var GraphViewHybrid_1 = require_GraphViewHybrid();
      exports.GraphViewHybrid = GraphViewHybrid_1.default;
      var GraphViewBasic_1 = require_GraphViewBasic();
      exports.GraphViewBasic = GraphViewBasic_1.default;
      var node19 = require_node();
      exports.node = node19;
      var triple6 = require_triple();
      exports.triple = triple6;
      var serialize_1 = require_serialize();
      exports.serialize = serialize_1.default;
      var changeURIPrefix_1 = require_changeURIPrefix();
      exports.changeURIPrefix = changeURIPrefix_1.default;
      var identifyFiletype_1 = require_identifyFiletype();
      exports.identifyFiletype = identifyFiletype_1.default;
      Object.defineProperty(exports, "Filetype", { enumerable: true, get: function() {
        return identifyFiletype_1.Filetype;
      } });
      var parseRDF_1 = require_parseRDF();
      exports.parseRDF = parseRDF_1.default;
      var rdf_ext_1 = (init_rdf_ext(), __toCommonJS(rdf_ext_exports));
      exports.rdf = rdf_ext_1.default;
      var namedNode = rdf_ext_1.default.namedNode;
      exports.namedNode = namedNode;
      var literal = rdf_ext_1.default.literal;
      exports.literal = literal;
    }
  });

  // node_modules/sboljs/node_modules/bioterms/dist/Prefixes.js
  var require_Prefixes = __commonJS({
    "node_modules/sboljs/node_modules/bioterms/dist/Prefixes.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.prefixify = exports.Prefixes = void 0;
      var Prefixes5;
      (function(Prefixes6) {
        Prefixes6.sbol1 = "http://sbols.org/v1#";
        Prefixes6.sbol2 = "http://sbols.org/v2#";
        Prefixes6.sbolx = "http://sboldata.org/sbolx#";
        Prefixes6.sbol3 = "http://sbols.org/v3#";
        Prefixes6.rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
        Prefixes6.visual = "http://wiki.synbiohub.org/wiki/Terms/visual#";
        Prefixes6.sequenceOntologyPurl = "http://purl.org/obo/owl/SO#";
        Prefixes6.sequenceOntologyIdentifiersOrg = "http://identifiers.org/so/";
        Prefixes6.go = "http://identifiers.org/go/";
        Prefixes6.dcterms = "http://purl.org/dc/terms/";
        Prefixes6.rdfs = "http://www.w3.org/2000/01/rdf-schema#";
        Prefixes6.svg = "http://www.w3.org/2000/svg#";
        Prefixes6.sbo = "http://identifiers.org/biomodels.sbo/";
        Prefixes6.sboNs = "https://identifiers.org/SBO:";
        Prefixes6.sybio = "http://www.sybio.ncl.ac.uk#";
        Prefixes6.prov = "http://www.w3.org/ns/prov#";
        Prefixes6.enrichment = "http://wiki.synbiohub.org/wiki/Terms/enrichment#";
        Prefixes6.measure = "http://www.ontology-of-units-of-measure.org/resource/om-2/";
      })(Prefixes5 = exports.Prefixes || (exports.Prefixes = {}));
      function prefixify(uri) {
        uri = "" + uri;
        for (var i = 0; i < keys.length; ++i) {
          const prefix = keys[i];
          const uriPrefix = Prefixes5[prefix];
          if (uri.indexOf(uriPrefix) === 0) {
            return prefix + ":" + uri.slice(uriPrefix.length);
          }
        }
        return uri;
      }
      exports.prefixify = prefixify;
      var keys = Object.keys(Prefixes5);
    }
  });

  // node_modules/sboljs/node_modules/bioterms/dist/Types.js
  var require_Types = __commonJS({
    "node_modules/sboljs/node_modules/bioterms/dist/Types.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Types = void 0;
      var Prefixes_1 = require_Prefixes();
      var Types9;
      (function(Types10) {
        let SBOL1;
        (function(SBOL12) {
          SBOL12.DnaComponent = Prefixes_1.Prefixes.sbol1 + "DnaComponent";
          SBOL12.DnaSequence = Prefixes_1.Prefixes.sbol1 + "DnaSequence";
          SBOL12.Collection = Prefixes_1.Prefixes.sbol1 + "Collection";
          SBOL12.SequenceAnnotation = Prefixes_1.Prefixes.sbol1 + "SequenceAnnotation";
        })(SBOL1 = Types10.SBOL1 || (Types10.SBOL1 = {}));
        let SBOL2;
        (function(SBOL22) {
          SBOL22.ModuleDefinition = Prefixes_1.Prefixes.sbol2 + "ModuleDefinition";
          SBOL22.ComponentDefinition = Prefixes_1.Prefixes.sbol2 + "ComponentDefinition";
          SBOL22.Module = Prefixes_1.Prefixes.sbol2 + "Module";
          SBOL22.Component = Prefixes_1.Prefixes.sbol2 + "Component";
          SBOL22.Range = Prefixes_1.Prefixes.sbol2 + "Range";
          SBOL22.Cut = Prefixes_1.Prefixes.sbol2 + "Cut";
          SBOL22.GenericLocation = Prefixes_1.Prefixes.sbol2 + "GenericLocation";
          SBOL22.SequenceAnnotation = Prefixes_1.Prefixes.sbol2 + "SequenceAnnotation";
          SBOL22.SequenceConstraint = Prefixes_1.Prefixes.sbol2 + "SequenceConstraint";
          SBOL22.Interaction = Prefixes_1.Prefixes.sbol2 + "Interaction";
          SBOL22.Participation = Prefixes_1.Prefixes.sbol2 + "Participation";
          SBOL22.Collection = Prefixes_1.Prefixes.sbol2 + "Collection";
          SBOL22.FunctionalComponent = Prefixes_1.Prefixes.sbol2 + "FunctionalComponent";
          SBOL22.Sequence = Prefixes_1.Prefixes.sbol2 + "Sequence";
          SBOL22.MapsTo = Prefixes_1.Prefixes.sbol2 + "MapsTo";
          SBOL22.Attachment = Prefixes_1.Prefixes.sbol2 + "Attachment";
          SBOL22.Model = Prefixes_1.Prefixes.sbol2 + "Model";
          SBOL22.Implementation = Prefixes_1.Prefixes.sbol2 + "Implementation";
          SBOL22.Experiment = Prefixes_1.Prefixes.sbol2 + "Experiment";
          SBOL22.ExperimentalData = Prefixes_1.Prefixes.sbol2 + "ExperimentalData";
          SBOL22.CombinatorialDerivation = Prefixes_1.Prefixes.sbol2 + "CombinatorialDerivation";
          SBOL22.VariableComponent = Prefixes_1.Prefixes.sbol2 + "VariableComponent";
        })(SBOL2 = Types10.SBOL2 || (Types10.SBOL2 = {}));
        let SBOLX;
        (function(SBOLX2) {
          SBOLX2.Component = Prefixes_1.Prefixes.sbolx + "Component";
          SBOLX2.SubComponent = Prefixes_1.Prefixes.sbolx + "SubComponent";
          SBOLX2.Range = Prefixes_1.Prefixes.sbolx + "Range";
          SBOLX2.Cut = Prefixes_1.Prefixes.sbolx + "Cut";
          SBOLX2.SequenceConstraint = Prefixes_1.Prefixes.sbolx + "SequenceConstraint";
          SBOLX2.Interaction = Prefixes_1.Prefixes.sbolx + "Interaction";
          SBOLX2.Participation = Prefixes_1.Prefixes.sbolx + "Participation";
          SBOLX2.Collection = Prefixes_1.Prefixes.sbolx + "Collection";
          SBOLX2.Sequence = Prefixes_1.Prefixes.sbolx + "Sequence";
          SBOLX2.OrientedLocation = Prefixes_1.Prefixes.sbolx + "OrientedLocation";
          SBOLX2.SequenceAnnotation = Prefixes_1.Prefixes.sbolx + "SequenceAnnotation";
          SBOLX2.Attachment = Prefixes_1.Prefixes.sbolx + "Attachment";
          SBOLX2.Model = Prefixes_1.Prefixes.sbolx + "Model";
          SBOLX2.Implementation = Prefixes_1.Prefixes.sbolx + "Implementation";
          SBOLX2.MapsTo = Prefixes_1.Prefixes.sbolx + "MapsTo";
          SBOLX2.Experiment = Prefixes_1.Prefixes.sbolx + "Experiment";
          SBOLX2.ExperimentalData = Prefixes_1.Prefixes.sbolx + "ExperimentalData";
        })(SBOLX = Types10.SBOLX || (Types10.SBOLX = {}));
        let SBOL3;
        (function(SBOL32) {
          SBOL32.Component = Prefixes_1.Prefixes.sbol3 + "Component";
          SBOL32.SubComponent = Prefixes_1.Prefixes.sbol3 + "SubComponent";
          SBOL32.Range = Prefixes_1.Prefixes.sbol3 + "Range";
          SBOL32.Cut = Prefixes_1.Prefixes.sbol3 + "Cut";
          SBOL32.EntireSequence = Prefixes_1.Prefixes.sbol3 + "EntireSequence";
          SBOL32.Constraint = Prefixes_1.Prefixes.sbol3 + "Constraint";
          SBOL32.Interaction = Prefixes_1.Prefixes.sbol3 + "Interaction";
          SBOL32.Participation = Prefixes_1.Prefixes.sbol3 + "Participation";
          SBOL32.Collection = Prefixes_1.Prefixes.sbol3 + "Collection";
          SBOL32.Sequence = Prefixes_1.Prefixes.sbol3 + "Sequence";
          SBOL32.OrientedLocation = Prefixes_1.Prefixes.sbol3 + "OrientedLocation";
          SBOL32.SequenceFeature = Prefixes_1.Prefixes.sbol3 + "SequenceFeature";
          SBOL32.Attachment = Prefixes_1.Prefixes.sbol3 + "Attachment";
          SBOL32.Model = Prefixes_1.Prefixes.sbol3 + "Model";
          SBOL32.Implementation = Prefixes_1.Prefixes.sbol3 + "Implementation";
          SBOL32.MapsTo = Prefixes_1.Prefixes.sbol3 + "MapsTo";
          SBOL32.Experiment = Prefixes_1.Prefixes.sbol3 + "Experiment";
          SBOL32.ExperimentalData = Prefixes_1.Prefixes.sbol3 + "ExperimentalData";
          SBOL32.Namespace = Prefixes_1.Prefixes.sbol3 + "Namespace";
          SBOL32.CombinatorialDerivation = Prefixes_1.Prefixes.sbol3 + "CombinatorialDerivation";
          SBOL32.VariableFeature = Prefixes_1.Prefixes.sbol3 + "VariableFeature";
          SBOL32.Interface = Prefixes_1.Prefixes.sbol3 + "Interface";
          SBOL32.LocalSubComponent = Prefixes_1.Prefixes.sbol3 + "LocalSubComponent";
          SBOL32.ExternallyDefined = Prefixes_1.Prefixes.sbol3 + "ExternallyDefined";
        })(SBOL3 = Types10.SBOL3 || (Types10.SBOL3 = {}));
        let Visual;
        (function(Visual2) {
          Visual2.ModuleDepiction = Prefixes_1.Prefixes.visual + "ModuleDepiction";
          Visual2.ComponentDepiction = Prefixes_1.Prefixes.visual + "ComponentDepiction";
          Visual2.Glyph = Prefixes_1.Prefixes.visual + "Glyph";
          Visual2.Label = Prefixes_1.Prefixes.visual + "Label";
        })(Visual = Types10.Visual || (Types10.Visual = {}));
        let SyBiOnt;
        (function(SyBiOnt2) {
          SyBiOnt2.Protein = Prefixes_1.Prefixes.sybio + "Protein";
          SyBiOnt2.InduciblePromoter = Prefixes_1.Prefixes.sybio + "InduciblePromoter";
          SyBiOnt2.Reaction = Prefixes_1.Prefixes.sybio + "Reaction";
          SyBiOnt2.ReactionParticipant = Prefixes_1.Prefixes.sybio + "ReactionParticipant";
          SyBiOnt2.Compound = Prefixes_1.Prefixes.sybio + "Compound";
        })(SyBiOnt = Types10.SyBiOnt || (Types10.SyBiOnt = {}));
        let Prov;
        (function(Prov2) {
          Prov2.Agent = Prefixes_1.Prefixes.prov + "Agent";
          Prov2.Association = Prefixes_1.Prefixes.prov + "Association";
          Prov2.Activity = Prefixes_1.Prefixes.prov + "Activity";
          Prov2.Usage = Prefixes_1.Prefixes.prov + "Usage";
          Prov2.Plan = Prefixes_1.Prefixes.prov + "Plan";
        })(Prov = Types10.Prov || (Types10.Prov = {}));
        let Enrichment;
        (function(Enrichment2) {
          Enrichment2.GeneProduct = Prefixes_1.Prefixes.enrichment + "GeneProduct";
        })(Enrichment = Types10.Enrichment || (Types10.Enrichment = {}));
        let Measure;
        (function(Measure_1) {
          Measure_1.Measure = Prefixes_1.Prefixes.measure + "Measure";
        })(Measure = Types10.Measure || (Types10.Measure = {}));
      })(Types9 = exports.Types || (exports.Types = {}));
    }
  });

  // node_modules/sboljs/node_modules/bioterms/dist/Predicates.js
  var require_Predicates = __commonJS({
    "node_modules/sboljs/node_modules/bioterms/dist/Predicates.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Predicates = void 0;
      var Prefixes_1 = require_Prefixes();
      var Predicates14;
      (function(Predicates15) {
        Predicates15.a = Prefixes_1.Prefixes.rdf + "type";
        let SBOL1;
        (function(SBOL12) {
          SBOL12.nucleotides = Prefixes_1.Prefixes.sbol1 + "nucleotides";
          SBOL12.subComponent = Prefixes_1.Prefixes.sbol1 + "subComponent";
          SBOL12.dnaSequence = Prefixes_1.Prefixes.sbol1 + "dnaSequence";
          SBOL12.bioStart = Prefixes_1.Prefixes.sbol1 + "bioStart";
          SBOL12.bioEnd = Prefixes_1.Prefixes.sbol1 + "bioEnd";
          SBOL12.displayId = Prefixes_1.Prefixes.sbol1 + "displayId";
          SBOL12.name = Prefixes_1.Prefixes.sbol1 + "name";
          SBOL12.description = Prefixes_1.Prefixes.sbol1 + "description";
          SBOL12.annotation = Prefixes_1.Prefixes.sbol1 + "annotation";
          SBOL12.strand = Prefixes_1.Prefixes.sbol1 + "strand";
          SBOL12.component = Prefixes_1.Prefixes.sbol1 + "component";
          SBOL12.precedes = Prefixes_1.Prefixes.sbol1 + "precedes";
        })(SBOL1 = Predicates15.SBOL1 || (Predicates15.SBOL1 = {}));
        let SBOL2;
        (function(SBOL22) {
          SBOL22.component = Prefixes_1.Prefixes.sbol2 + "component";
          SBOL22.module = Prefixes_1.Prefixes.sbol2 + "module";
          SBOL22.definition = Prefixes_1.Prefixes.sbol2 + "definition";
          SBOL22.functionalComponent = Prefixes_1.Prefixes.sbol2 + "functionalComponent";
          SBOL22.role = Prefixes_1.Prefixes.sbol2 + "role";
          SBOL22.location = Prefixes_1.Prefixes.sbol2 + "location";
          SBOL22.start = Prefixes_1.Prefixes.sbol2 + "start";
          SBOL22.end = Prefixes_1.Prefixes.sbol2 + "end";
          SBOL22.at = Prefixes_1.Prefixes.sbol2 + "at";
          SBOL22.sequenceAnnotation = Prefixes_1.Prefixes.sbol2 + "sequenceAnnotation";
          SBOL22.sequenceConstraint = Prefixes_1.Prefixes.sbol2 + "sequenceConstraint";
          SBOL22.orientation = Prefixes_1.Prefixes.sbol2 + "orientation";
          SBOL22.displayId = Prefixes_1.Prefixes.sbol2 + "displayId";
          SBOL22.version = Prefixes_1.Prefixes.sbol2 + "version";
          SBOL22.access = Prefixes_1.Prefixes.sbol2 + "access";
          SBOL22.mapsTo = Prefixes_1.Prefixes.sbol2 + "mapsTo";
          SBOL22.local = Prefixes_1.Prefixes.sbol2 + "local";
          SBOL22.remote = Prefixes_1.Prefixes.sbol2 + "remote";
          SBOL22.refinement = Prefixes_1.Prefixes.sbol2 + "refinement";
          SBOL22.interaction = Prefixes_1.Prefixes.sbol2 + "interaction";
          SBOL22.participation = Prefixes_1.Prefixes.sbol2 + "participation";
          SBOL22.participant = Prefixes_1.Prefixes.sbol2 + "participant";
          SBOL22.type = Prefixes_1.Prefixes.sbol2 + "type";
          SBOL22.sequence = Prefixes_1.Prefixes.sbol2 + "sequence";
          SBOL22.encoding = Prefixes_1.Prefixes.sbol2 + "encoding";
          SBOL22.elements = Prefixes_1.Prefixes.sbol2 + "elements";
          SBOL22.persistentIdentity = Prefixes_1.Prefixes.sbol2 + "persistentIdentity";
          SBOL22.restriction = Prefixes_1.Prefixes.sbol2 + "restriction";
          SBOL22.subject = Prefixes_1.Prefixes.sbol2 + "subject";
          SBOL22.object = Prefixes_1.Prefixes.sbol2 + "object";
          SBOL22.member = Prefixes_1.Prefixes.sbol2 + "member";
          SBOL22.model = Prefixes_1.Prefixes.sbol2 + "model";
          SBOL22.framework = Prefixes_1.Prefixes.sbol2 + "framework";
          SBOL22.language = Prefixes_1.Prefixes.sbol2 + "language";
          SBOL22.source = Prefixes_1.Prefixes.sbol2 + "source";
          SBOL22.attachment = Prefixes_1.Prefixes.sbol2 + "attachment";
          SBOL22.format = Prefixes_1.Prefixes.sbol2 + "format";
          SBOL22.size = Prefixes_1.Prefixes.sbol2 + "size";
          SBOL22.hash = Prefixes_1.Prefixes.sbol2 + "hash";
          SBOL22.built = Prefixes_1.Prefixes.sbol2 + "built";
          SBOL22.experimentalData = Prefixes_1.Prefixes.sbol2 + "experimentalData";
          SBOL22.sourceLocation = Prefixes_1.Prefixes.sbol2 + "sourceLocation";
          SBOL22.measure = Prefixes_1.Prefixes.sbol2 + "measure";
          SBOL22.template = Prefixes_1.Prefixes.sbol2 + "template";
          SBOL22.variableComponent = Prefixes_1.Prefixes.sbol2 + "variableComponent";
          SBOL22.strategy = Prefixes_1.Prefixes.sbol2 + "strategy";
          SBOL22.variable = Prefixes_1.Prefixes.sbol2 + "variable";
          SBOL22.variant = Prefixes_1.Prefixes.sbol2 + "variant";
          SBOL22.variantCollection = Prefixes_1.Prefixes.sbol2 + "variantCollection";
          SBOL22.variantDerivation = Prefixes_1.Prefixes.sbol2 + "variantDerivation";
        })(SBOL2 = Predicates15.SBOL2 || (Predicates15.SBOL2 = {}));
        let SBOLX;
        (function(SBOLX2) {
          SBOLX2.subComponent = Prefixes_1.Prefixes.sbolx + "subComponent";
          SBOLX2.instanceOf = Prefixes_1.Prefixes.sbolx + "instanceOf";
          SBOLX2.role = Prefixes_1.Prefixes.sbolx + "role";
          SBOLX2.location = Prefixes_1.Prefixes.sbolx + "location";
          SBOLX2.start = Prefixes_1.Prefixes.sbolx + "start";
          SBOLX2.end = Prefixes_1.Prefixes.sbolx + "end";
          SBOLX2.at = Prefixes_1.Prefixes.sbolx + "at";
          SBOLX2.sequenceAnnotation = Prefixes_1.Prefixes.sbolx + "sequenceAnnotation";
          SBOLX2.sequenceConstraint = Prefixes_1.Prefixes.sbolx + "sequenceConstraint";
          SBOLX2.orientation = Prefixes_1.Prefixes.sbolx + "orientation";
          SBOLX2.id = Prefixes_1.Prefixes.sbolx + "id";
          SBOLX2.version = Prefixes_1.Prefixes.sbolx + "version";
          SBOLX2.access = Prefixes_1.Prefixes.sbolx + "access";
          SBOLX2.mapsTo = Prefixes_1.Prefixes.sbolx + "mapsTo";
          SBOLX2.local = Prefixes_1.Prefixes.sbolx + "local";
          SBOLX2.remote = Prefixes_1.Prefixes.sbolx + "remote";
          SBOLX2.refinement = Prefixes_1.Prefixes.sbolx + "refinement";
          SBOLX2.interaction = Prefixes_1.Prefixes.sbolx + "interaction";
          SBOLX2.participation = Prefixes_1.Prefixes.sbolx + "participation";
          SBOLX2.participant = Prefixes_1.Prefixes.sbolx + "participant";
          SBOLX2.type = Prefixes_1.Prefixes.sbolx + "type";
          SBOLX2.sequence = Prefixes_1.Prefixes.sbolx + "sequence";
          SBOLX2.encoding = Prefixes_1.Prefixes.sbolx + "encoding";
          SBOLX2.elements = Prefixes_1.Prefixes.sbolx + "elements";
          SBOLX2.persistentIdentity = Prefixes_1.Prefixes.sbolx + "persistentIdentity";
          SBOLX2.restriction = Prefixes_1.Prefixes.sbolx + "restriction";
          SBOLX2.subject = Prefixes_1.Prefixes.sbolx + "subject";
          SBOLX2.object = Prefixes_1.Prefixes.sbolx + "object";
          SBOLX2.member = Prefixes_1.Prefixes.sbolx + "member";
          SBOLX2.model = Prefixes_1.Prefixes.sbolx + "model";
          SBOLX2.framework = Prefixes_1.Prefixes.sbolx + "framework";
          SBOLX2.language = Prefixes_1.Prefixes.sbolx + "language";
          SBOLX2.source = Prefixes_1.Prefixes.sbolx + "source";
          SBOLX2.attachment = Prefixes_1.Prefixes.sbolx + "attachment";
          SBOLX2.format = Prefixes_1.Prefixes.sbolx + "format";
          SBOLX2.size = Prefixes_1.Prefixes.sbolx + "size";
          SBOLX2.hash = Prefixes_1.Prefixes.sbolx + "hash";
          SBOLX2.built = Prefixes_1.Prefixes.sbolx + "built";
          SBOLX2.experimentalData = Prefixes_1.Prefixes.sbolx + "experimentalData";
          SBOLX2.sourceLocation = Prefixes_1.Prefixes.sbolx + "sourceLocation";
          SBOLX2.measure = Prefixes_1.Prefixes.sbolx + "measure";
        })(SBOLX = Predicates15.SBOLX || (Predicates15.SBOLX = {}));
        let SBOL3;
        (function(SBOL32) {
          SBOL32.instanceOf = Prefixes_1.Prefixes.sbol3 + "instanceOf";
          SBOL32.role = Prefixes_1.Prefixes.sbol3 + "role";
          SBOL32.hasLocation = Prefixes_1.Prefixes.sbol3 + "hasLocation";
          SBOL32.start = Prefixes_1.Prefixes.sbol3 + "start";
          SBOL32.end = Prefixes_1.Prefixes.sbol3 + "end";
          SBOL32.at = Prefixes_1.Prefixes.sbol3 + "at";
          SBOL32.hasFeature = Prefixes_1.Prefixes.sbol3 + "hasFeature";
          SBOL32.hasConstraint = Prefixes_1.Prefixes.sbol3 + "hasConstraint";
          SBOL32.orientation = Prefixes_1.Prefixes.sbol3 + "orientation";
          SBOL32.displayId = Prefixes_1.Prefixes.sbol3 + "displayId";
          SBOL32.name = Prefixes_1.Prefixes.sbol3 + "name";
          SBOL32.description = Prefixes_1.Prefixes.sbol3 + "description";
          SBOL32.access = Prefixes_1.Prefixes.sbol3 + "access";
          SBOL32.mapsTo = Prefixes_1.Prefixes.sbol3 + "mapsTo";
          SBOL32.local = Prefixes_1.Prefixes.sbol3 + "local";
          SBOL32.remote = Prefixes_1.Prefixes.sbol3 + "remote";
          SBOL32.refinement = Prefixes_1.Prefixes.sbol3 + "refinement";
          SBOL32.hasInteraction = Prefixes_1.Prefixes.sbol3 + "hasInteraction";
          SBOL32.hasInterface = Prefixes_1.Prefixes.sbol3 + "hasInterface";
          SBOL32.hasParticipation = Prefixes_1.Prefixes.sbol3 + "hasParticipation";
          SBOL32.participant = Prefixes_1.Prefixes.sbol3 + "participant";
          SBOL32.type = Prefixes_1.Prefixes.sbol3 + "type";
          SBOL32.hasSequence = Prefixes_1.Prefixes.sbol3 + "hasSequence";
          SBOL32.encoding = Prefixes_1.Prefixes.sbol3 + "encoding";
          SBOL32.elements = Prefixes_1.Prefixes.sbol3 + "elements";
          SBOL32.persistentIdentity = Prefixes_1.Prefixes.sbol3 + "persistentIdentity";
          SBOL32.restriction = Prefixes_1.Prefixes.sbol3 + "restriction";
          SBOL32.subject = Prefixes_1.Prefixes.sbol3 + "subject";
          SBOL32.object = Prefixes_1.Prefixes.sbol3 + "object";
          SBOL32.member = Prefixes_1.Prefixes.sbol3 + "member";
          SBOL32.hasModel = Prefixes_1.Prefixes.sbol3 + "hasModel";
          SBOL32.framework = Prefixes_1.Prefixes.sbol3 + "framework";
          SBOL32.language = Prefixes_1.Prefixes.sbol3 + "language";
          SBOL32.source = Prefixes_1.Prefixes.sbol3 + "source";
          SBOL32.hasAttachment = Prefixes_1.Prefixes.sbol3 + "hasAttachment";
          SBOL32.format = Prefixes_1.Prefixes.sbol3 + "format";
          SBOL32.size = Prefixes_1.Prefixes.sbol3 + "size";
          SBOL32.hash = Prefixes_1.Prefixes.sbol3 + "hash";
          SBOL32.built = Prefixes_1.Prefixes.sbol3 + "built";
          SBOL32.experimentalData = Prefixes_1.Prefixes.sbol3 + "experimentalData";
          SBOL32.sourceLocation = Prefixes_1.Prefixes.sbol3 + "sourceLocation";
          SBOL32.hasMeasure = Prefixes_1.Prefixes.sbol3 + "hasMeasure";
          SBOL32.hasNamespace = Prefixes_1.Prefixes.sbol3 + "hasNamespace";
          SBOL32.template = Prefixes_1.Prefixes.sbol3 + "template";
          SBOL32.hasVariableFeature = Prefixes_1.Prefixes.sbol3 + "hasVariableFeature";
          SBOL32.strategy = Prefixes_1.Prefixes.sbol3 + "strategy";
          SBOL32.variable = Prefixes_1.Prefixes.sbol3 + "variable";
          SBOL32.variant = Prefixes_1.Prefixes.sbol3 + "variant";
          SBOL32.variantCollection = Prefixes_1.Prefixes.sbol3 + "variantCollection";
          SBOL32.variantDerivation = Prefixes_1.Prefixes.sbol3 + "variantDerivation";
          SBOL32.variantMeasure = Prefixes_1.Prefixes.sbol3 + "variantMeasure";
          SBOL32.input = Prefixes_1.Prefixes.sbol3 + "input";
          SBOL32.output = Prefixes_1.Prefixes.sbol3 + "output";
          SBOL32.nondirectional = Prefixes_1.Prefixes.sbol3 + "nondirectional";
          SBOL32.definition = Prefixes_1.Prefixes.sbol3 + "definition";
        })(SBOL3 = Predicates15.SBOL3 || (Predicates15.SBOL3 = {}));
        let Dcterms;
        (function(Dcterms2) {
          Dcterms2.title = Prefixes_1.Prefixes.dcterms + "title";
          Dcterms2.description = Prefixes_1.Prefixes.dcterms + "description";
        })(Dcterms = Predicates15.Dcterms || (Predicates15.Dcterms = {}));
        let SVG;
        (function(SVG2) {
          SVG2.fontFamily = Prefixes_1.Prefixes.svg + "font-family";
          SVG2.fontSize = Prefixes_1.Prefixes.svg + "font-size";
          SVG2.fontStyle = Prefixes_1.Prefixes.svg + "font-style";
        })(SVG = Predicates15.SVG || (Predicates15.SVG = {}));
        let SyBiOnt;
        (function(SyBiOnt2) {
          SyBiOnt2.encodedBy = Prefixes_1.Prefixes.sybio + "encodedBy";
          SyBiOnt2.EC = Prefixes_1.Prefixes.sybio + "EC";
          SyBiOnt2.isBalanced = Prefixes_1.Prefixes.sybio + "isBalanced";
          SyBiOnt2.isReactionClass = Prefixes_1.Prefixes.sybio + "isReactionClass";
          SyBiOnt2.inPolymerization = Prefixes_1.Prefixes.sybio + "inPolymerization";
          SyBiOnt2.inTransport = Prefixes_1.Prefixes.sybio + "inTransport";
          SyBiOnt2.reactionDirection = Prefixes_1.Prefixes.sybio + "reactionDirection";
          SyBiOnt2.hasReactionParticipant = Prefixes_1.Prefixes.sybio + "hasReactionParticipant";
          SyBiOnt2.referencesCompound = Prefixes_1.Prefixes.sybio + "referencesCompound";
          SyBiOnt2.reactionSide = Prefixes_1.Prefixes.sybio + "reactionSide";
          SyBiOnt2.reactionSummary = Prefixes_1.Prefixes.sybio + "reactionSummary";
          SyBiOnt2.stoicRatio = Prefixes_1.Prefixes.sybio + "stoichiometricRatio";
          SyBiOnt2.compoundCharge = Prefixes_1.Prefixes.sybio + "compoundCharge";
          SyBiOnt2.compoundFormula = Prefixes_1.Prefixes.sybio + "compoundFormula";
          SyBiOnt2.compoundMass = Prefixes_1.Prefixes.sybio + "compoundMass";
          SyBiOnt2.compoundSmilesFormula = Prefixes_1.Prefixes.sybio + "compoundSmilesFormula";
          SyBiOnt2.interactsWith = Prefixes_1.Prefixes.sybio + "interactsWith";
          SyBiOnt2.taxId = Prefixes_1.Prefixes.sybio + "taxId";
        })(SyBiOnt = Predicates15.SyBiOnt || (Predicates15.SyBiOnt = {}));
        let Prov;
        (function(Prov2) {
          Prov2.wasDerivedFrom = Prefixes_1.Prefixes.prov + "wasDerivedFrom";
          Prov2.wasGeneratedBy = Prefixes_1.Prefixes.prov + "wasGeneratedBy";
          Prov2.qualifiedAssociation = Prefixes_1.Prefixes.prov + "qualifiedAssociation";
          Prov2.qualifiedUsage = Prefixes_1.Prefixes.prov + "qualifiedUsage";
          Prov2.startedAtTime = Prefixes_1.Prefixes.prov + "startedAtTime";
          Prov2.endedAtTime = Prefixes_1.Prefixes.prov + "endedAtTime";
          Prov2.wasInformedBy = Prefixes_1.Prefixes.prov + "wasInformedBy";
          Prov2.agent = Prefixes_1.Prefixes.prov + "agent";
          Prov2.entity = Prefixes_1.Prefixes.prov + "entity";
          Prov2.hadRole = Prefixes_1.Prefixes.prov + "hadRole";
          Prov2.hadPlan = Prefixes_1.Prefixes.prov + "hadPlan";
        })(Prov = Predicates15.Prov || (Predicates15.Prov = {}));
        let Enrichment;
        (function(Enrichment2) {
          Enrichment2.hint = Prefixes_1.Prefixes.enrichment + "hint";
          Enrichment2.orfStart = Prefixes_1.Prefixes.enrichment + "orfStart";
          Enrichment2.orfEnd = Prefixes_1.Prefixes.enrichment + "orfEnd";
        })(Enrichment = Predicates15.Enrichment || (Predicates15.Enrichment = {}));
        let Measure;
        (function(Measure2) {
          Measure2.hasNumericalValue = Prefixes_1.Prefixes.measure + "hasNumericalValue";
          Measure2.hasUnit = Prefixes_1.Prefixes.measure + "hasUnit";
        })(Measure = Predicates15.Measure || (Predicates15.Measure = {}));
      })(Predicates14 = exports.Predicates || (exports.Predicates = {}));
    }
  });

  // node_modules/sboljs/node_modules/bioterms/dist/Specifiers.js
  var require_Specifiers = __commonJS({
    "node_modules/sboljs/node_modules/bioterms/dist/Specifiers.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Specifiers = void 0;
      var Prefixes_1 = require_Prefixes();
      var Specifiers2;
      (function(Specifiers3) {
        let SBOL2;
        (function(SBOL22) {
          let Orientation;
          (function(Orientation2) {
            Orientation2.Inline = Prefixes_1.Prefixes.sbol2 + "inline";
            Orientation2.ReverseComplement = Prefixes_1.Prefixes.sbol2 + "reverseComplement";
          })(Orientation = SBOL22.Orientation || (SBOL22.Orientation = {}));
          let Direction;
          (function(Direction2) {
            Direction2.Input = Prefixes_1.Prefixes.sbol2 + "in";
            Direction2.Output = Prefixes_1.Prefixes.sbol2 + "out";
            Direction2.InputAndOutput = Prefixes_1.Prefixes.sbol2 + "inout";
            Direction2.None = Prefixes_1.Prefixes.sbol2 + "none";
          })(Direction = SBOL22.Direction || (SBOL22.Direction = {}));
          let Access;
          (function(Access2) {
            Access2.PublicAccess = Prefixes_1.Prefixes.sbol2 + "public";
            Access2.PrivateAccess = Prefixes_1.Prefixes.sbol2 + "private";
          })(Access = SBOL22.Access || (SBOL22.Access = {}));
          let Type;
          (function(Type2) {
            Type2.DNA = Prefixes_1.Prefixes.sboNs + "0000251";
            Type2.RNA = Prefixes_1.Prefixes.sboNs + "0000250";
            Type2.Protein = Prefixes_1.Prefixes.sboNs + "0000252";
            Type2.SmallMolecule = Prefixes_1.Prefixes.sboNs + "0000247";
            Type2.Complex = Prefixes_1.Prefixes.sboNs + "0000253";
            Type2.Effector = "http://identifiers.org/chebi/CHEBI:35224";
            Type2.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000988";
          })(Type = SBOL22.Type || (SBOL22.Type = {}));
          let SequenceEncoding;
          (function(SequenceEncoding2) {
            SequenceEncoding2.NucleicAcid = "https://identifiers.org/edam:format_1207";
            SequenceEncoding2.RNA = "https://identifiers.org/edam:format_1207";
            SequenceEncoding2.AminoAcid = "https://identifiers.org/edam:format_1208";
          })(SequenceEncoding = SBOL22.SequenceEncoding || (SBOL22.SequenceEncoding = {}));
          let SequenceConstraint;
          (function(SequenceConstraint2) {
            SequenceConstraint2.Precedes = Prefixes_1.Prefixes.sbol2 + "precedes";
            SequenceConstraint2.OppositeOrientationAs = Prefixes_1.Prefixes.sbol2 + "oppositeOrientationAs";
          })(SequenceConstraint = SBOL22.SequenceConstraint || (SBOL22.SequenceConstraint = {}));
          let ProvRole;
          (function(ProvRole2) {
            ProvRole2.Design = Prefixes_1.Prefixes.sbol2 + "design";
            ProvRole2.Build = Prefixes_1.Prefixes.sbol2 + "build";
            ProvRole2.Test = Prefixes_1.Prefixes.sbol2 + "test";
            ProvRole2.Learn = Prefixes_1.Prefixes.sbol2 + "learn";
          })(ProvRole = SBOL22.ProvRole || (SBOL22.ProvRole = {}));
          let MapsToRefinement;
          (function(MapsToRefinement2) {
            MapsToRefinement2.UseLocal = Prefixes_1.Prefixes.sbol2 + "useLocal";
            MapsToRefinement2.UseRemote = Prefixes_1.Prefixes.sbol2 + "useRemote";
          })(MapsToRefinement = SBOL22.MapsToRefinement || (SBOL22.MapsToRefinement = {}));
        })(SBOL2 = Specifiers3.SBOL2 || (Specifiers3.SBOL2 = {}));
        let SBOLX;
        (function(SBOLX2) {
          let Orientation;
          (function(Orientation2) {
            Orientation2.Inline = Prefixes_1.Prefixes.sbolx + "inline";
            Orientation2.ReverseComplement = Prefixes_1.Prefixes.sbolx + "reverseComplement";
          })(Orientation = SBOLX2.Orientation || (SBOLX2.Orientation = {}));
          let Direction;
          (function(Direction2) {
            Direction2.Input = Prefixes_1.Prefixes.sbolx + "in";
            Direction2.Output = Prefixes_1.Prefixes.sbolx + "out";
            Direction2.InputAndOutput = Prefixes_1.Prefixes.sbolx + "inout";
            Direction2.None = Prefixes_1.Prefixes.sbolx + "none";
          })(Direction = SBOLX2.Direction || (SBOLX2.Direction = {}));
          let Access;
          (function(Access2) {
            Access2.PublicAccess = Prefixes_1.Prefixes.sbolx + "public";
            Access2.PrivateAccess = Prefixes_1.Prefixes.sbolx + "private";
          })(Access = SBOLX2.Access || (SBOLX2.Access = {}));
          let Type;
          (function(Type2) {
            Type2.DNA = "http://www.biopax.org/release/biopax-level3.owl#DnaRegion";
            Type2.RNA = "http://www.biopax.org/release/biopax-level3.owl#RnaRegion";
            Type2.Protein = "http://www.biopax.org/release/biopax-level3.owl#Protein";
            Type2.SmallMolecule = "http://www.biopax.org/release/biopax-level3.owl#SmallMolecule";
            Type2.Complex = "http://www.biopax.org/release/biopax-level3.owl#Complex";
            Type2.Effector = "http://identifiers.org/chebi/CHEBI:35224";
            Type2.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000988";
          })(Type = SBOLX2.Type || (SBOLX2.Type = {}));
          let SequenceEncoding;
          (function(SequenceEncoding2) {
            SequenceEncoding2.NucleicAcid = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.RNA = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.AminoAcid = "http://www.chem.qmul.ac.uk/iupac/AminoAcid/";
          })(SequenceEncoding = SBOLX2.SequenceEncoding || (SBOLX2.SequenceEncoding = {}));
          let SequenceConstraint;
          (function(SequenceConstraint2) {
            SequenceConstraint2.Precedes = Prefixes_1.Prefixes.sbolx + "precedes";
            SequenceConstraint2.OppositeOrientationAs = Prefixes_1.Prefixes.sbolx + "oppositeOrientationAs";
          })(SequenceConstraint = SBOLX2.SequenceConstraint || (SBOLX2.SequenceConstraint = {}));
          let ProvRole;
          (function(ProvRole2) {
            ProvRole2.Design = Prefixes_1.Prefixes.sbolx + "design";
            ProvRole2.Build = Prefixes_1.Prefixes.sbolx + "build";
            ProvRole2.Test = Prefixes_1.Prefixes.sbolx + "test";
            ProvRole2.Learn = Prefixes_1.Prefixes.sbolx + "learn";
          })(ProvRole = SBOLX2.ProvRole || (SBOLX2.ProvRole = {}));
          let MapsToRefinement;
          (function(MapsToRefinement2) {
            MapsToRefinement2.UseLocal = Prefixes_1.Prefixes.sbolx + "useLocal";
            MapsToRefinement2.UseRemote = Prefixes_1.Prefixes.sbolx + "useRemote";
          })(MapsToRefinement = SBOLX2.MapsToRefinement || (SBOLX2.MapsToRefinement = {}));
        })(SBOLX = Specifiers3.SBOLX || (Specifiers3.SBOLX = {}));
        let SBOL3;
        (function(SBOL32) {
          let Orientation;
          (function(Orientation2) {
            Orientation2.Inline = Prefixes_1.Prefixes.sbol3 + "inline";
            Orientation2.ReverseComplement = Prefixes_1.Prefixes.sbol3 + "reverseComplement";
          })(Orientation = SBOL32.Orientation || (SBOL32.Orientation = {}));
          let Direction;
          (function(Direction2) {
            Direction2.Input = Prefixes_1.Prefixes.sbol3 + "in";
            Direction2.Output = Prefixes_1.Prefixes.sbol3 + "out";
            Direction2.InputAndOutput = Prefixes_1.Prefixes.sbol3 + "inout";
            Direction2.None = Prefixes_1.Prefixes.sbol3 + "none";
          })(Direction = SBOL32.Direction || (SBOL32.Direction = {}));
          let Access;
          (function(Access2) {
            Access2.PublicAccess = Prefixes_1.Prefixes.sbol3 + "public";
            Access2.PrivateAccess = Prefixes_1.Prefixes.sbol3 + "private";
          })(Access = SBOL32.Access || (SBOL32.Access = {}));
          let Type;
          (function(Type2) {
            Type2.DNA = "http://www.biopax.org/release/biopax-level3.owl#DnaRegion";
            Type2.RNA = "http://www.biopax.org/release/biopax-level3.owl#RnaRegion";
            Type2.Protein = "http://www.biopax.org/release/biopax-level3.owl#Protein";
            Type2.SmallMolecule = "http://www.biopax.org/release/biopax-level3.owl#SmallMolecule";
            Type2.Complex = "http://www.biopax.org/release/biopax-level3.owl#Complex";
            Type2.Effector = "http://identifiers.org/chebi/CHEBI:35224";
            Type2.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000988";
          })(Type = SBOL32.Type || (SBOL32.Type = {}));
          let SequenceEncoding;
          (function(SequenceEncoding2) {
            SequenceEncoding2.NucleicAcid = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.RNA = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.AminoAcid = "http://www.chem.qmul.ac.uk/iupac/AminoAcid/";
          })(SequenceEncoding = SBOL32.SequenceEncoding || (SBOL32.SequenceEncoding = {}));
          let Constraint;
          (function(Constraint2) {
            Constraint2.Precedes = Prefixes_1.Prefixes.sbol3 + "precedes";
            Constraint2.OppositeOrientationAs = Prefixes_1.Prefixes.sbol3 + "oppositeOrientationAs";
          })(Constraint = SBOL32.Constraint || (SBOL32.Constraint = {}));
          let ProvRole;
          (function(ProvRole2) {
            ProvRole2.Design = Prefixes_1.Prefixes.sbol3 + "design";
            ProvRole2.Build = Prefixes_1.Prefixes.sbol3 + "build";
            ProvRole2.Test = Prefixes_1.Prefixes.sbol3 + "test";
            ProvRole2.Learn = Prefixes_1.Prefixes.sbol3 + "learn";
          })(ProvRole = SBOL32.ProvRole || (SBOL32.ProvRole = {}));
          let MapsToRefinement;
          (function(MapsToRefinement2) {
            MapsToRefinement2.UseLocal = Prefixes_1.Prefixes.sbol3 + "useLocal";
            MapsToRefinement2.UseRemote = Prefixes_1.Prefixes.sbol3 + "useRemote";
          })(MapsToRefinement = SBOL32.MapsToRefinement || (SBOL32.MapsToRefinement = {}));
        })(SBOL3 = Specifiers3.SBOL3 || (Specifiers3.SBOL3 = {}));
        let Visual;
        (function(Visual2) {
          Visual2.Blackbox = Prefixes_1.Prefixes.visual + "blackbox";
          Visual2.Whitebox = Prefixes_1.Prefixes.visual + "whitebox";
          Visual2.Float = Prefixes_1.Prefixes.visual + "float";
          Visual2.Backbone = Prefixes_1.Prefixes.visual + "backbone";
          Visual2.Forward = Prefixes_1.Prefixes.visual + "forward";
          Visual2.Reverse = Prefixes_1.Prefixes.visual + "reverse";
          Visual2.Expandable = Prefixes_1.Prefixes.visual + "expandable";
          Visual2.NotExpandable = Prefixes_1.Prefixes.visual + "notExpandable";
          Visual2.AnchorTop = Prefixes_1.Prefixes.visual + "anchorTop";
          Visual2.AnchorMid = Prefixes_1.Prefixes.visual + "anchorMid";
          Visual2.AnchorBottom = Prefixes_1.Prefixes.visual + "anchorBottom";
        })(Visual = Specifiers3.Visual || (Specifiers3.Visual = {}));
        let SO;
        (function(SO2) {
          SO2.CDS = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000316";
          SO2.Promoter = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000167";
          SO2.RBS = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000139";
          SO2.RestrictionSite = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001687";
          SO2.Terminator = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000141";
          SO2.OriginOfReplication = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000296";
          SO2.OriginOfTransfer = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000724";
          SO2.PlasmidBackbone = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000755";
          SO2.EngineeredRegion = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000804";
        })(SO = Specifiers3.SO || (Specifiers3.SO = {}));
        let SBO;
        (function(SBO2) {
          SBO2.Inhibition = Prefixes_1.Prefixes.sbo + "SBO:0000169";
          SBO2.Inhibitor = Prefixes_1.Prefixes.sbo + "SBO:0000020";
          SBO2.Inhibited = Prefixes_1.Prefixes.sbo + "SBO:0000642";
          SBO2.Stimulation = Prefixes_1.Prefixes.sbo + "SBO:0000170";
          SBO2.Stimulator = Prefixes_1.Prefixes.sbo + "SBO:0000459";
          SBO2.Stimulated = Prefixes_1.Prefixes.sbo + "SBO:0000643";
          SBO2.GeneticProduction = Prefixes_1.Prefixes.sbo + "SBO:0000589";
          SBO2.Product = Prefixes_1.Prefixes.sbo + "SBO:0000011";
          SBO2.Modifier = Prefixes_1.Prefixes.sbo + "SBO:0000019";
          SBO2.Promoter = Prefixes_1.Prefixes.sbo + "SBO:0000598";
          SBO2.Control = Prefixes_1.Prefixes.sbo + "SBO:0000168";
        })(SBO = Specifiers3.SBO || (Specifiers3.SBO = {}));
        let GO;
        (function(GO2) {
          GO2.ProteinDepolymerization = Prefixes_1.Prefixes.go + "GO:0051261";
          GO2.CovalentChromatinModification = Prefixes_1.Prefixes.go + "GO:0016569";
          GO2.ProteinProcessing = Prefixes_1.Prefixes.go + "GO:0016485";
          GO2.ProteinBinding = Prefixes_1.Prefixes.go + "GO:0005515";
          GO2.CatalyticActivity = Prefixes_1.Prefixes.go + "GO:0003824";
        })(GO = Specifiers3.GO || (Specifiers3.GO = {}));
        let SyBiOnt;
        (function(SyBiOnt2) {
          SyBiOnt2.Bidirectional = Prefixes_1.Prefixes.sybio + "Bidirectional";
          SyBiOnt2.LeftToRight = Prefixes_1.Prefixes.sybio + "LeftToRight";
          SyBiOnt2.RightToLeft = Prefixes_1.Prefixes.sybio + "RightToLeft";
          SyBiOnt2.UndefinedDirection = Prefixes_1.Prefixes.sybio + "UndefinedDirection";
          SyBiOnt2.LeftSide = Prefixes_1.Prefixes.sybio + "LeftSide";
          SyBiOnt2.RightSide = Prefixes_1.Prefixes.sybio + "RightSide";
        })(SyBiOnt = Specifiers3.SyBiOnt || (Specifiers3.SyBiOnt = {}));
      })(Specifiers2 = exports.Specifiers || (exports.Specifiers = {}));
    }
  });

  // node_modules/sboljs/node_modules/bioterms/dist/sequenceOntology.js
  var require_sequenceOntology = __commonJS({
    "node_modules/sboljs/node_modules/bioterms/dist/sequenceOntology.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sequenceOntology = exports.uriToName = void 0;
      function uriToName(uri) {
        let temp = uri.split("/");
        let id = temp.pop();
        let entry = sequenceOntology.so[id];
        if (!entry)
          return void 0;
        let name = entry["name"];
        return name;
      }
      exports.uriToName = uriToName;
      var sequenceOntology;
      (function(sequenceOntology2) {
        sequenceOntology2.so = {
          "SO:0000000": {
            "name": "Sequence_Ontology"
          },
          "SO:0000001": {
            "name": "region",
            "def": "A sequence_feature with an extent greater than zero. A nucleotide region is composed of bases and a polypeptide region is composed of amino acids. [SO:ke]"
          },
          "SO:0000002": {
            "name": "sequence_secondary_structure",
            "def": "A folded sequence. [SO:ke]"
          },
          "SO:0000003": {
            "name": "G_quartet",
            "def": "G-quartets are unusual nucleic acid structures consisting of a planar arrangement where each guanine is hydrogen bonded by hoogsteen pairing to another guanine in the quartet. [http://www.ncbi.nlm.nih.gov/pubmed/7919797?dopt=Abstract]"
          },
          "SO:0000004": {
            "name": "interior_coding_exon"
          },
          "SO:0000005": {
            "name": "satellite_DNA",
            "def": "The many tandem repeats (identical or related) of a short basic repeating unit; many have a base composition or other property different from the genome average that allows them to be separated from the bulk (main band) genomic DNA. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000006": {
            "name": "PCR_product",
            "def": "A region amplified by a PCR reaction. [SO:ke]"
          },
          "SO:0000007": {
            "name": "read_pair",
            "def": "One of a pair of sequencing reads in which the two members of the pair are related by originating at either end of a clone insert. [SO:ls]"
          },
          "SO:0000008": {
            "name": "gene_sensu_your_favorite_organism"
          },
          "SO:0000009": {
            "name": "gene_class"
          },
          "SO:0000010": {
            "name": "protein_coding"
          },
          "SO:0000011": {
            "name": "non_protein_coding"
          },
          "SO:0000012": {
            "name": "scRNA_primary_transcript",
            "def": "The primary transcript of any one of several small cytoplasmic RNA molecules present in the cytoplasm and sometimes nucleus of a Eukaryote. [http://www.ebi.ac.uk/embl/WebFeat/align/scRNA_s.html]"
          },
          "SO:0000013": {
            "name": "scRNA",
            "def": "A small non coding RNA sequence, present in the cytoplasm. [SO:ke]"
          },
          "SO:0000014": {
            "name": "INR_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters required for the correct positioning of the polymerase for the start of transcription. Overlaps the TSS. The mammalian consensus sequence is YYAN(T|A)YY; the Drosophila consensus sequence is TCA(G|T)t(T|C). In each the A is at position +1 with respect to the TSS. Functionally similar to the TATA box element. [PMID:12651739, PMID:16858867]"
          },
          "SO:0000015": {
            "name": "DPE_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters; Positioned from +28 to +32 with respect to the TSS (+1). Experimental results suggest that the DPE acts in conjunction with the INR_motif to provide a binding site for TFIID in the absence of a TATA box to mediate transcription of TATA-less promoters. Consensus sequence (A|G)G(A|T)(C|T)(G|A|C). [PMID:12651739:12537576, PMID:16858867]"
          },
          "SO:0000016": {
            "name": "BREu_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, located immediately upstream of some TATA box elements at -37 to -32 with respect to the TSS (+1). Consensus sequence is (G|C)(G|C)(G|A)CGCC. Binds TFIIB. [PMID:12651739, PMID:16858867]"
          },
          "SO:0000017": {
            "name": "PSE_motif",
            "def": "A sequence element characteristic of the promoters of snRNA genes transcribed by RNA polymerase II or by RNA polymerase III. Located between -45 and -60 relative to the TSS. The human PSE_motif consensus sequence is TCACCNTNA(C|G)TNAAAAG(T|G). [PMID:12651739]"
          },
          "SO:0000018": {
            "name": "linkage_group",
            "def": "A group of loci that can be grouped in a linear order representing the different degrees of linkage among the genes concerned. [ISBN:038752046]"
          },
          "SO:0000020": {
            "name": "RNA_internal_loop",
            "def": "A region of double stranded RNA where the bases do not conform to WC base pairing. The loop is closed on both sides by canonical base pairing. If the interruption to base pairing occurs on one strand only, it is known as a bulge. [SO:ke]"
          },
          "SO:0000021": {
            "name": "asymmetric_RNA_internal_loop",
            "def": "An internal RNA loop where one of the strands includes more bases than the corresponding region on the other strand. [SO:ke]"
          },
          "SO:0000022": {
            "name": "A_minor_RNA_motif",
            "def": "A region forming a motif, composed of adenines, where the minor groove edges are inserted into the minor groove of another helix. [SO:ke]"
          },
          "SO:0000023": {
            "name": "K_turn_RNA_motif",
            "def": "The kink turn (K-turn) is an RNA structural motif that creates a sharp (~120 degree) bend between two continuous helices. [SO:ke]"
          },
          "SO:0000024": {
            "name": "sarcin_like_RNA_motif",
            "def": "A loop in ribosomal RNA containing the sites of attack for ricin and sarcin. [http://www.ncbi.nlm.nih.gov/pubmed/7897662]"
          },
          "SO:0000025": {
            "name": "symmetric_RNA_internal_loop",
            "def": "An internal RNA loop where the extent of the loop on both stands is the same size. [SO:ke]"
          },
          "SO:0000026": {
            "name": "RNA_junction_loop"
          },
          "SO:0000027": {
            "name": "RNA_hook_turn"
          },
          "SO:0000028": {
            "name": "base_pair"
          },
          "SO:0000029": {
            "name": "WC_base_pair",
            "def": "The canonical base pair, where two bases interact via WC edges, with glycosidic bonds oriented cis relative to the axis of orientation. [PMID:12177293]"
          },
          "SO:0000030": {
            "name": "sugar_edge_base_pair",
            "def": "A type of non-canonical base-pairing. [PMID:12177293]"
          },
          "SO:0000031": {
            "name": "aptamer",
            "def": "DNA or RNA molecules that have been selected from random pools based on their ability to bind other molecules. [http://aptamer.icmb.utexas.edu]"
          },
          "SO:0000032": {
            "name": "DNA_aptamer",
            "def": "DNA molecules that have been selected from random pools based on their ability to bind other molecules. [http:aptamer.icmb.utexas.edu]"
          },
          "SO:0000033": {
            "name": "RNA_aptamer",
            "def": "RNA molecules that have been selected from random pools based on their ability to bind other molecules. [http://aptamer.icmb.utexas.edu]"
          },
          "SO:0000034": {
            "name": "morpholino_oligo",
            "def": "Morpholino oligos are synthesized from four different Morpholino subunits, each of which contains one of the four genetic bases (A, C, G, T) linked to a 6-membered morpholine ring. Eighteen to 25 subunits of these four subunit types are joined in a specific order by non-ionic phosphorodiamidate intersubunit linkages to give a Morpholino. [http://www.gene-tools.com/]"
          },
          "SO:0000035": {
            "name": "riboswitch",
            "def": "A riboswitch is a part of an mRNA that can act as a direct sensor of small molecules to control their own expression. A riboswitch is a cis element in the 5' end of an mRNA, that acts as a direct sensor of metabolites. [PMID:2820954]"
          },
          "SO:0000036": {
            "name": "matrix_attachment_site",
            "def": "A DNA region that is required for the binding of chromatin to the nuclear matrix. [SO:ma]"
          },
          "SO:0000037": {
            "name": "locus_control_region",
            "def": "A DNA region that includes DNAse hypersensitive sites located 5' to a gene that confers the high-level, position-independent, and copy number-dependent expression to that gene. [SO:ma]"
          },
          "SO:0000038": {
            "name": "match_set",
            "def": "A collection of match parts. [SO:ke]"
          },
          "SO:0000039": {
            "name": "match_part",
            "def": "A part of a match, for example an hsp from blast is a match_part. [SO:ke]"
          },
          "SO:0000040": {
            "name": "genomic_clone",
            "def": "A clone of a DNA region of a genome. [SO:ma]"
          },
          "SO:0000041": {
            "name": "sequence_operation",
            "def": "An operation that can be applied to a sequence, that results in a change. [SO:ke]"
          },
          "SO:0000042": {
            "name": "pseudogene_attribute",
            "def": "An attribute of a pseudogene (SO:0000336). [SO:ma]"
          },
          "SO:0000043": {
            "name": "processed_pseudogene",
            "def": "A pseudogene where by an mRNA was retrotransposed. The mRNA sequence is transcribed back into the genome, lacking introns and promoters, but often including a polyA tail. [SO:xp]"
          },
          "SO:0000044": {
            "name": "pseudogene_by_unequal_crossing_over",
            "def": "A pseudogene caused by unequal crossing over at recombination. [SO:ke]"
          },
          "SO:0000045": {
            "name": "delete",
            "def": "To remove a subsection of sequence. [SO:ke]"
          },
          "SO:0000046": {
            "name": "insert",
            "def": "To insert a subsection of sequence. [SO:ke]"
          },
          "SO:0000047": {
            "name": "invert",
            "def": "To invert a subsection of sequence. [SO:ke]"
          },
          "SO:0000048": {
            "name": "substitute",
            "def": "To substitute a subsection of sequence for another. [SO:ke]"
          },
          "SO:0000049": {
            "name": "translocate",
            "def": "To translocate a subsection of sequence. [SO:ke]"
          },
          "SO:0000050": {
            "name": "gene_part",
            "def": "A part of a gene, that has no other route in the ontology back to region. This concept is necessary for logical inference as these parts must have the properties of region. It also allows us to associate all the parts of genes with a gene. [SO:ke]"
          },
          "SO:0000051": {
            "name": "probe",
            "def": "A DNA sequence used experimentally to detect the presence or absence of a complementary nucleic acid. [SO:ma]"
          },
          "SO:0000052": {
            "name": "assortment_derived_deficiency"
          },
          "SO:0000053": {
            "name": "sequence_variant_affecting_regulatory_region",
            "def": "A sequence_variant_effect which changes the regulatory region of a gene. [SO:ke]"
          },
          "SO:0000054": {
            "name": "aneuploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number. [SO:ke]"
          },
          "SO:0000055": {
            "name": "hyperploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number as extra chromosomes are present. [SO:ke]"
          },
          "SO:0000056": {
            "name": "hypoploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number as some chromosomes are missing. [SO:ke]"
          },
          "SO:0000057": {
            "name": "operator",
            "def": "A regulatory element of an operon to which activators or repressors bind thereby effecting translation of genes in that operon. [SO:ma]"
          },
          "SO:0000058": {
            "name": "assortment_derived_aneuploid"
          },
          "SO:0000059": {
            "name": "nuclease_binding_site",
            "def": "A binding site that, of a nucleotide molecule, that interacts selectively and non-covalently with polypeptide residues of a nuclease. [SO:cb]"
          },
          "SO:0000060": {
            "name": "compound_chromosome_arm"
          },
          "SO:0000061": {
            "name": "restriction_enzyme_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues of a restriction enzyme. [SO:cb]"
          },
          "SO:0000062": {
            "name": "deficient_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby a translocation in which one of the four broken ends loses a segment before re-joining. [FB:reference_manual]"
          },
          "SO:0000063": {
            "name": "deficient_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a translocation in which one of the four broken ends loses a segment before re-joining. [SO:ke]"
          },
          "SO:0000064": {
            "name": "gene_by_transcript_attribute"
          },
          "SO:0000065": {
            "name": "free_chromosome_arm",
            "def": "A chromosome structure variation whereby an arm exists as an individual chromosome element. [SO:ke]"
          },
          "SO:0000066": {
            "name": "gene_by_polyadenylation_attribute"
          },
          "SO:0000067": {
            "name": "gene_to_gene_feature"
          },
          "SO:0000068": {
            "name": "overlapping",
            "def": "An attribute describing a gene that has a sequence that overlaps the sequence of another gene. [SO:ke]"
          },
          "SO:0000069": {
            "name": "inside_intron",
            "def": "An attribute to describe a gene when it is located within the intron of another gene. [SO:ke]"
          },
          "SO:0000070": {
            "name": "inside_intron_antiparallel",
            "def": "An attribute to describe a gene when it is located within the intron of another gene and on the opposite strand. [SO:ke]"
          },
          "SO:0000071": {
            "name": "inside_intron_parallel",
            "def": "An attribute to describe a gene when it is located within the intron of another gene and on the same strand. [SO:ke]"
          },
          "SO:0000072": {
            "name": "end_overlapping_gene"
          },
          "SO:0000073": {
            "name": "five_prime_three_prime_overlap",
            "def": "An attribute to describe a gene when the five prime region overlaps with another gene's 3' region. [SO:ke]"
          },
          "SO:0000074": {
            "name": "five_prime_five_prime_overlap",
            "def": "An attribute to describe a gene when the five prime region overlaps with another gene's five prime region. [SO:ke]"
          },
          "SO:0000075": {
            "name": "three_prime_three_prime_overlap",
            "def": "An attribute to describe a gene when the 3' region overlaps with another gene's 3' region. [SO:ke]"
          },
          "SO:0000076": {
            "name": "three_prime_five_prime_overlap",
            "def": "An attribute to describe a gene when the 3' region overlaps with another gene's 5' region. [SO:ke]"
          },
          "SO:0000077": {
            "name": "antisense",
            "def": "A region sequence that is complementary to a sequence of messenger RNA. [SO:ke]"
          },
          "SO:0000078": {
            "name": "polycistronic_transcript",
            "def": "A transcript that is polycistronic. [SO:xp]"
          },
          "SO:0000079": {
            "name": "dicistronic_transcript",
            "def": "A transcript that is dicistronic. [SO:ke]"
          },
          "SO:0000080": {
            "name": "operon_member"
          },
          "SO:0000081": {
            "name": "gene_array_member"
          },
          "SO:0000082": {
            "name": "processed_transcript_attribute"
          },
          "SO:0000083": {
            "name": "macronuclear_sequence"
          },
          "SO:0000084": {
            "name": "micronuclear_sequence"
          },
          "SO:0000085": {
            "name": "gene_by_genome_location"
          },
          "SO:0000086": {
            "name": "gene_by_organelle_of_genome"
          },
          "SO:0000087": {
            "name": "nuclear_gene",
            "def": "A gene from nuclear sequence. [SO:xp]"
          },
          "SO:0000088": {
            "name": "mt_gene",
            "def": "A gene located in mitochondrial sequence. [SO:xp]"
          },
          "SO:0000089": {
            "name": "kinetoplast_gene",
            "def": "A gene located in kinetoplast sequence. [SO:xp]"
          },
          "SO:0000090": {
            "name": "plastid_gene",
            "def": "A gene from plastid sequence. [SO:xp]"
          },
          "SO:0000091": {
            "name": "apicoplast_gene",
            "def": "A gene from apicoplast sequence. [SO:xp]"
          },
          "SO:0000092": {
            "name": "ct_gene",
            "def": "A gene from chloroplast sequence. [SO:xp]"
          },
          "SO:0000093": {
            "name": "chromoplast_gene",
            "def": "A gene from chromoplast_sequence. [SO:xp]"
          },
          "SO:0000094": {
            "name": "cyanelle_gene",
            "def": "A gene from cyanelle sequence. [SO:xp]"
          },
          "SO:0000095": {
            "name": "leucoplast_gene",
            "def": "A plastid gene from leucoplast sequence. [SO:xp]"
          },
          "SO:0000096": {
            "name": "proplastid_gene",
            "def": "A gene from proplastid sequence. [SO:ke]"
          },
          "SO:0000097": {
            "name": "nucleomorph_gene",
            "def": "A gene from nucleomorph sequence. [SO:xp]"
          },
          "SO:0000098": {
            "name": "plasmid_gene",
            "def": "A gene from plasmid sequence. [SO:xp]"
          },
          "SO:0000099": {
            "name": "proviral_gene",
            "def": "A gene from proviral sequence. [SO:xp]"
          },
          "SO:0000100": {
            "name": "endogenous_retroviral_gene",
            "def": "A proviral gene with origin endogenous retrovirus. [SO:xp]"
          },
          "SO:0000101": {
            "name": "transposable_element",
            "def": "A transposon or insertion sequence. An element that can insert in a variety of DNA sequences. [http://www.sci.sdsu.edu/~smaloy/Glossary/T.html]"
          },
          "SO:0000102": {
            "name": "expressed_sequence_match",
            "def": "A match to an EST or cDNA sequence. [SO:ke]"
          },
          "SO:0000103": {
            "name": "clone_insert_end",
            "def": "The end of the clone insert. [SO:ke]"
          },
          "SO:0000104": {
            "name": "polypeptide",
            "def": "A sequence of amino acids linked by peptide bonds which may lack appreciable tertiary structure and may not be liable to irreversible denaturation. [SO:ma]"
          },
          "SO:0000105": {
            "name": "chromosome_arm",
            "def": "A region of the chromosome between the centromere and the telomere. Human chromosomes have two arms, the p arm (short) and the q arm (long) which are separated from each other by the centromere. [http://www.medterms.com/script/main/art.asp?articlekey=5152]"
          },
          "SO:0000106": {
            "name": "non_capped_primary_transcript"
          },
          "SO:0000107": {
            "name": "sequencing_primer"
          },
          "SO:0000108": {
            "name": "mRNA_with_frameshift",
            "def": "An mRNA with a frameshift. [SO:xp]"
          },
          "SO:0000109": {
            "name": "sequence_variant_obs",
            "def": "A sequence_variant is a non exact copy of a sequence_feature or genome exhibiting one or more sequence_alteration. [SO:ke]"
          },
          "SO:0000110": {
            "name": "sequence_feature",
            "def": "Any extent of continuous biological sequence. [LAMHDI:mb, SO:ke]"
          },
          "SO:0000111": {
            "name": "transposable_element_gene",
            "def": "A gene encoded within a transposable element. For example gag, int, env and pol are the transposable element genes of the TY element in yeast. [SO:ke]"
          },
          "SO:0000112": {
            "name": "primer",
            "def": "An oligo to which new deoxyribonucleotides can be added by DNA polymerase. [SO:ke]"
          },
          "SO:0000113": {
            "name": "proviral_region",
            "def": "A viral sequence which has integrated into a host genome. [SO:ke]"
          },
          "SO:0000114": {
            "name": "methylated_cytosine",
            "def": "A methylated deoxy-cytosine. [SO:ke]"
          },
          "SO:0000115": {
            "name": "transcript_feature"
          },
          "SO:0000116": {
            "name": "edited",
            "def": "An attribute describing a sequence that is modified by editing. [SO:ke]"
          },
          "SO:0000117": {
            "name": "transcript_with_readthrough_stop_codon"
          },
          "SO:0000118": {
            "name": "transcript_with_translational_frameshift",
            "def": "A transcript with a translational frameshift. [SO:xp]"
          },
          "SO:0000119": {
            "name": "regulated",
            "def": "An attribute to describe a sequence that is regulated. [SO:ke]"
          },
          "SO:0000120": {
            "name": "protein_coding_primary_transcript",
            "def": "A primary transcript that, at least in part, encodes one or more proteins. [SO:ke]"
          },
          "SO:0000121": {
            "name": "forward_primer",
            "def": "A single stranded oligo used for polymerase chain reaction. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
          },
          "SO:0000122": {
            "name": "RNA_sequence_secondary_structure",
            "def": "A folded RNA sequence. [SO:ke]"
          },
          "SO:0000123": {
            "name": "transcriptionally_regulated",
            "def": "An attribute describing a gene that is regulated at transcription. [SO:ma]"
          },
          "SO:0000124": {
            "name": "transcriptionally_constitutive",
            "def": "Expressed in relatively constant amounts without regard to cellular environmental conditions such as the concentration of a particular substrate. [SO:ke]"
          },
          "SO:0000125": {
            "name": "transcriptionally_induced",
            "def": "An inducer molecule is required for transcription to occur. [SO:ke]"
          },
          "SO:0000126": {
            "name": "transcriptionally_repressed",
            "def": "A repressor molecule is required for transcription to stop. [SO:ke]"
          },
          "SO:0000127": {
            "name": "silenced_gene",
            "def": "A gene that is silenced. [SO:xp]"
          },
          "SO:0000128": {
            "name": "gene_silenced_by_DNA_modification",
            "def": "A gene that is silenced by DNA modification. [SO:xp]"
          },
          "SO:0000129": {
            "name": "gene_silenced_by_DNA_methylation",
            "def": "A gene that is silenced by DNA methylation. [SO:xp]"
          },
          "SO:0000130": {
            "name": "post_translationally_regulated",
            "def": "An attribute describing a gene that is regulated after it has been translated. [SO:ke]"
          },
          "SO:0000131": {
            "name": "translationally_regulated",
            "def": "An attribute describing a gene that is regulated as it is translated. [SO:ke]"
          },
          "SO:0000132": {
            "name": "reverse_primer",
            "def": "A single stranded oligo used for polymerase chain reaction. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
          },
          "SO:0000133": {
            "name": "epigenetically_modified",
            "def": "This attribute describes a gene where heritable changes other than those in the DNA sequence occur. These changes include: modification to the DNA (such as DNA methylation, the covalent modification of cytosine), and post-translational modification of histones. [SO:ke]"
          },
          "SO:0000134": {
            "name": "genomically_imprinted",
            "def": "Imprinted genes are epigenetically modified genes that are expressed monoallelically according to their parent of origin. [SO:ke]"
          },
          "SO:0000135": {
            "name": "maternally_imprinted",
            "def": "The maternal copy of the gene is modified, rendering it transcriptionally silent. [SO:ke]"
          },
          "SO:0000136": {
            "name": "paternally_imprinted",
            "def": "The paternal copy of the gene is modified, rendering it transcriptionally silent. [SO:ke]"
          },
          "SO:0000137": {
            "name": "allelically_excluded",
            "def": "Allelic exclusion is a process occurring in diploid organisms, where a gene is inactivated and not expressed in that cell. [SO:ke]"
          },
          "SO:0000138": {
            "name": "gene_rearranged_at_DNA_level",
            "def": "An epigenetically modified gene, rearranged at the DNA level. [SO:xp]"
          },
          "SO:0000139": {
            "name": "ribosome_entry_site",
            "def": "Region in mRNA where ribosome assembles. [SO:ke]"
          },
          "SO:0000140": {
            "name": "attenuator",
            "def": "A sequence segment located within the five prime end of an mRNA that causes premature termination of translation. [SO:as]"
          },
          "SO:0000141": {
            "name": "terminator",
            "def": "The sequence of DNA located either at the end of the transcript that causes RNA polymerase to terminate transcription. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000142": {
            "name": "DNA_sequence_secondary_structure",
            "def": "A folded DNA sequence. [SO:ke]"
          },
          "SO:0000143": {
            "name": "assembly_component",
            "def": "A region of known length which may be used to manufacture a longer region. [SO:ke]"
          },
          "SO:0000144": {
            "name": "primary_transcript_attribute"
          },
          "SO:0000145": {
            "name": "recoded_codon",
            "def": "A codon that has been redefined at translation. The redefinition may be as a result of translational bypass, translational frameshifting or stop codon readthrough. [SO:xp]"
          },
          "SO:0000146": {
            "name": "capped",
            "def": "An attribute describing when a sequence, usually an mRNA is capped by the addition of a modified guanine nucleotide at the 5' end. [SO:ke]"
          },
          "SO:0000147": {
            "name": "exon",
            "def": "A region of the transcript sequence within a gene which is not removed from the primary RNA transcript by RNA splicing. [SO:ke]"
          },
          "SO:0000148": {
            "name": "supercontig",
            "def": "One or more contigs that have been ordered and oriented using end-read information. Contains gaps that are filled with N's. [SO:ls]"
          },
          "SO:0000149": {
            "name": "contig",
            "def": "A contiguous sequence derived from sequence assembly. Has no gaps, but may contain N's from unavailable bases. [SO:ls]"
          },
          "SO:0000150": {
            "name": "read",
            "def": "A sequence obtained from a single sequencing experiment. Typically a read is produced when a base calling program interprets information from a chromatogram trace file produced from a sequencing machine. [SO:rd]"
          },
          "SO:0000151": {
            "name": "clone",
            "def": "A piece of DNA that has been inserted in a vector so that it can be propagated in a host bacterium or some other organism. [SO:ke]"
          },
          "SO:0000152": {
            "name": "YAC",
            "def": "Yeast Artificial Chromosome, a vector constructed from the telomeric, centromeric, and replication origin sequences needed for replication in yeast cells. [SO:ma]"
          },
          "SO:0000153": {
            "name": "BAC",
            "def": "Bacterial Artificial Chromosome, a cloning vector that can be propagated as mini-chromosomes in a bacterial host. [SO:ma]"
          },
          "SO:0000154": {
            "name": "PAC",
            "def": "The P1-derived artificial chromosome are DNA constructs that are derived from the DNA of P1 bacteriophage. They can carry large amounts (about 100-300 kilobases) of other sequences for a variety of bioengineering purposes. It is one type of vector used to clone DNA fragments (100- to 300-kb insert size; average, 150 kb) in Escherichia coli cells. [http://en.wikipedia.org/wiki/P1-derived_artificial_chromosome]"
          },
          "SO:0000155": {
            "name": "plasmid",
            "def": "A self replicating, using the hosts cellular machinery, often circular nucleic acid molecule that is distinct from a chromosome in the organism. [SO:ma]"
          },
          "SO:0000156": {
            "name": "cosmid",
            "def": "A cloning vector that is a hybrid of lambda phages and a plasmid that can be propagated as a plasmid or packaged as a phage,since they retain the lambda cos sites. [SO:ma]"
          },
          "SO:0000157": {
            "name": "phagemid",
            "def": "A plasmid which carries within its sequence a bacteriophage replication origin. When the host bacterium is infected with \\helper\\ phage, a phagemid is replicated along with the phage DNA and packaged into phage capsids. [SO:ma]"
          },
          "SO:0000158": {
            "name": "fosmid",
            "def": "A cloning vector that utilizes the E. coli F factor. [SO:ma]"
          },
          "SO:0000159": {
            "name": "deletion",
            "def": "The point at which one or more contiguous nucleotides were excised. [SO:ke]"
          },
          "SO:0000160": {
            "name": "lambda_clone",
            "def": "A linear clone derived from lambda bacteriophage. The genes involved in the lysogenic pathway are removed from the from the viral DNA. Up to 25 kb of foreign DNA can then be inserted into the lambda genome. [ISBN:0-1767-2380-8]"
          },
          "SO:0000161": {
            "name": "methylated_adenine",
            "def": "A modified  base in which adenine has been methylated. [SO:ke]"
          },
          "SO:0000162": {
            "name": "splice_site",
            "def": "Consensus region of primary transcript bordering junction of splicing. A region that overlaps exactly 2 base and adjacent_to splice_junction. [SO:cjm, SO:ke]"
          },
          "SO:0000163": {
            "name": "five_prime_cis_splice_site",
            "def": "Intronic 2 bp region bordering the exon, at the 5' edge of the intron. A splice_site that is downstream_adjacent_to exon and starts intron. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html, SO:cjm, SO:ke]"
          },
          "SO:0000164": {
            "name": "three_prime_cis_splice_site",
            "def": "Intronic 2 bp region bordering the exon, at the 3' edge of the intron. A splice_site that is upstream_adjacent_to exon and finishes intron. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html, SO:cjm, SO:ke]"
          },
          "SO:0000165": {
            "name": "enhancer",
            "def": "A cis-acting sequence that increases the utilization of (some) eukaryotic promoters, and can function in either orientation and in any location (upstream or downstream) relative to the promoter. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000166": {
            "name": "enhancer_bound_by_factor",
            "def": "An enhancer bound by a factor. [SO:xp]"
          },
          "SO:0000167": {
            "name": "promoter",
            "def": "A regulatory_region composed of the TSS(s) and binding sites for TF_complexes of the basal transcription machinery. [SO:regcreative]"
          },
          "SO:0000168": {
            "name": "restriction_enzyme_cut_site",
            "def": "A specific nucleotide sequence of DNA at or near which a particular restriction enzyme cuts the DNA. [SO:ma]"
          },
          "SO:0000169": {
            "name": "RNApol_I_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase I binds, to begin transcription. [SO:ke]"
          },
          "SO:0000170": {
            "name": "RNApol_II_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase II binds, to begin transcription. [SO:ke]"
          },
          "SO:0000171": {
            "name": "RNApol_III_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase III binds, to begin transcription. [SO:ke]"
          },
          "SO:0000172": {
            "name": "CAAT_signal",
            "def": "Part of a conserved sequence located about 75-bp upstream of the start point of eukaryotic transcription units which may be involved in RNA polymerase binding; consensus=GG(C|T)CAATCT. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000173": {
            "name": "GC_rich_promoter_region",
            "def": "A conserved GC-rich region located upstream of the start point of eukaryotic transcription units which may occur in multiple copies or in either orientation; consensus=GGGCGG. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000174": {
            "name": "TATA_box",
            "def": "A conserved AT-rich septamer found about 25-bp before the start point of many eukaryotic RNA polymerase II transcript units; may be involved in positioning the enzyme for correct initiation; consensus=TATA(A|T)A(A|T). [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, PMID:16858867]"
          },
          "SO:0000175": {
            "name": "minus_10_signal",
            "def": "A conserved region about 10-bp upstream of the start point of bacterial transcription units which may be involved in binding RNA polymerase; consensus=TAtAaT. This region is associated with sigma factor 70. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000176": {
            "name": "minus_35_signal",
            "def": "A conserved hexamer about 35-bp upstream of the start point of bacterial transcription units; consensus=TTGACa or TGTTGACA. This region is associated with sigma factor 70. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000177": {
            "name": "cross_genome_match",
            "def": "A nucleotide match against a sequence from another organism. [SO:ma]"
          },
          "SO:0000178": {
            "name": "operon",
            "def": "A group of contiguous genes transcribed as a single (polycistronic) mRNA from a single regulatory region. [SO:ma]"
          },
          "SO:0000179": {
            "name": "clone_insert_start",
            "def": "The start of the clone insert. [SO:ke]"
          },
          "SO:0000180": {
            "name": "retrotransposon",
            "def": "A transposable element that is incorporated into a chromosome by a mechanism that requires reverse transcriptase. [http://www.dddmag.com/Glossary.aspx#r]"
          },
          "SO:0000181": {
            "name": "translated_nucleotide_match",
            "def": "A match against a translated sequence. [SO:ke]"
          },
          "SO:0000182": {
            "name": "DNA_transposon",
            "def": "A transposon where the mechanism of transposition is via a DNA intermediate. [SO:ke]"
          },
          "SO:0000183": {
            "name": "non_transcribed_region",
            "def": "A region of the gene which is not transcribed. [SO:ke]"
          },
          "SO:0000184": {
            "name": "U2_intron",
            "def": "A major type of spliceosomal intron spliced by the U2 spliceosome, that includes U1, U2, U4/U6 and U5 snRNAs. [PMID:9428511]"
          },
          "SO:0000185": {
            "name": "primary_transcript",
            "def": "A transcript that in its initial state requires modification to be functional. [SO:ma]"
          },
          "SO:0000186": {
            "name": "LTR_retrotransposon",
            "def": "A retrotransposon flanked by long terminal repeat sequences. [SO:ke]"
          },
          "SO:0000187": {
            "name": "repeat_family",
            "def": "A group of characterized repeat sequences. [SO:ke]"
          },
          "SO:0000188": {
            "name": "intron",
            "def": "A region of a primary transcript that is transcribed, but removed from within the transcript by splicing together the sequences (exons) on either side of it. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000189": {
            "name": "non_LTR_retrotransposon",
            "def": "A retrotransposon without long terminal repeat sequences. [SO:ke]"
          },
          "SO:0000190": {
            "name": "five_prime_intron"
          },
          "SO:0000191": {
            "name": "interior_intron"
          },
          "SO:0000192": {
            "name": "three_prime_intron"
          },
          "SO:0000193": {
            "name": "RFLP_fragment",
            "def": "A DNA fragment used as a reagent to detect the polymorphic genomic loci by hybridizing against the genomic DNA digested with a given restriction enzyme. [GOC:pj]"
          },
          "SO:0000194": {
            "name": "LINE_element",
            "def": "A dispersed repeat family with many copies, each from 1 to 6 kb long. New elements are generated by retroposition of a transcribed copy. Typically the LINE contains 2 ORF's one of which is reverse transcriptase, and 3'and 5' direct repeats. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html]"
          },
          "SO:0000195": {
            "name": "coding_exon",
            "def": "An exon whereby at least one base is part of a codon (here, 'codon' is inclusive of the stop_codon). [SO:ke]"
          },
          "SO:0000196": {
            "name": "five_prime_coding_exon_coding_region",
            "def": "The sequence of the five_prime_coding_exon that codes for protein. [SO:cjm]"
          },
          "SO:0000197": {
            "name": "three_prime_coding_exon_coding_region",
            "def": "The sequence of the three_prime_coding_exon that codes for protein. [SO:cjm]"
          },
          "SO:0000198": {
            "name": "noncoding_exon",
            "def": "An exon that does not contain any codons. [SO:ke]"
          },
          "SO:0000199": {
            "name": "translocation",
            "def": "A region of nucleotide sequence that has translocated to a new position. The observed adjacency of two previously separated regions. [NCBI:th, SO:ke]"
          },
          "SO:0000200": {
            "name": "five_prime_coding_exon",
            "def": "The 5' most coding exon. [SO:ke]"
          },
          "SO:0000201": {
            "name": "interior_exon",
            "def": "An exon that is bounded by 5' and 3' splice sites. [PMID:10373547]"
          },
          "SO:0000202": {
            "name": "three_prime_coding_exon",
            "def": "The coding exon that is most 3-prime on a given transcript. [SO:ma]"
          },
          "SO:0000203": {
            "name": "UTR",
            "def": "Messenger RNA sequences that are untranslated and lie five prime or three prime to sequences which are translated. [SO:ke]"
          },
          "SO:0000204": {
            "name": "five_prime_UTR",
            "def": "A region at the 5' end of a mature transcript (preceding the initiation codon) that is not translated into a protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000205": {
            "name": "three_prime_UTR",
            "def": "A region at the 3' end of a mature transcript (following the stop codon) that is not translated into a protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000206": {
            "name": "SINE_element",
            "def": "A repetitive element, a few hundred base pairs long, that is dispersed throughout the genome. A common human SINE is the Alu element. [SO:ke]"
          },
          "SO:0000207": {
            "name": "simple_sequence_length_variation"
          },
          "SO:0000208": {
            "name": "terminal_inverted_repeat_element",
            "def": "A DNA transposable element defined as having termini with perfect, or nearly perfect short inverted repeats, generally 10 - 40 nucleotides long. [http://www.genetics.org/cgi/reprint/156/4/1983.pdf]"
          },
          "SO:0000209": {
            "name": "rRNA_primary_transcript",
            "def": "A primary transcript encoding a ribosomal RNA. [SO:ke]"
          },
          "SO:0000210": {
            "name": "tRNA_primary_transcript",
            "def": "A primary transcript encoding a transfer RNA (SO:0000253). [SO:ke]"
          },
          "SO:0000211": {
            "name": "alanine_tRNA_primary_transcript",
            "def": "A primary transcript encoding alanyl tRNA. [SO:ke]"
          },
          "SO:0000212": {
            "name": "arginine_tRNA_primary_transcript",
            "def": "A primary transcript encoding arginyl tRNA (SO:0000255). [SO:ke]"
          },
          "SO:0000213": {
            "name": "asparagine_tRNA_primary_transcript",
            "def": "A primary transcript encoding asparaginyl tRNA (SO:0000256). [SO:ke]"
          },
          "SO:0000214": {
            "name": "aspartic_acid_tRNA_primary_transcript",
            "def": "A primary transcript encoding aspartyl tRNA (SO:0000257). [SO:ke]"
          },
          "SO:0000215": {
            "name": "cysteine_tRNA_primary_transcript",
            "def": "A primary transcript encoding cysteinyl tRNA (SO:0000258). [SO:ke]"
          },
          "SO:0000216": {
            "name": "glutamic_acid_tRNA_primary_transcript",
            "def": "A primary transcript encoding glutaminyl tRNA (SO:0000260). [SO:ke]"
          },
          "SO:0000217": {
            "name": "glutamine_tRNA_primary_transcript",
            "def": "A primary transcript encoding glutamyl tRNA (SO:0000260). [SO:ke]"
          },
          "SO:0000218": {
            "name": "glycine_tRNA_primary_transcript",
            "def": "A primary transcript encoding glycyl tRNA (SO:0000263). [SO:ke]"
          },
          "SO:0000219": {
            "name": "histidine_tRNA_primary_transcript",
            "def": "A primary transcript encoding histidyl tRNA (SO:0000262). [SO:ke]"
          },
          "SO:0000220": {
            "name": "isoleucine_tRNA_primary_transcript",
            "def": "A primary transcript encoding isoleucyl tRNA (SO:0000263). [SO:ke]"
          },
          "SO:0000221": {
            "name": "leucine_tRNA_primary_transcript",
            "def": "A primary transcript encoding leucyl tRNA (SO:0000264). [SO:ke]"
          },
          "SO:0000222": {
            "name": "lysine_tRNA_primary_transcript",
            "def": "A primary transcript encoding lysyl tRNA (SO:0000265). [SO:ke]"
          },
          "SO:0000223": {
            "name": "methionine_tRNA_primary_transcript",
            "def": "A primary transcript encoding methionyl tRNA (SO:0000266). [SO:ke]"
          },
          "SO:0000224": {
            "name": "phenylalanine_tRNA_primary_transcript",
            "def": "A primary transcript encoding phenylalanyl tRNA (SO:0000267). [SO:ke]"
          },
          "SO:0000225": {
            "name": "proline_tRNA_primary_transcript",
            "def": "A primary transcript encoding prolyl tRNA (SO:0000268). [SO:ke]"
          },
          "SO:0000226": {
            "name": "serine_tRNA_primary_transcript",
            "def": "A primary transcript encoding seryl tRNA (SO:000269). [SO:ke]"
          },
          "SO:0000227": {
            "name": "threonine_tRNA_primary_transcript",
            "def": "A primary transcript encoding threonyl tRNA (SO:000270). [SO:ke]"
          },
          "SO:0000228": {
            "name": "tryptophan_tRNA_primary_transcript",
            "def": "A primary transcript encoding tryptophanyl tRNA (SO:000271). [SO:ke]"
          },
          "SO:0000229": {
            "name": "tyrosine_tRNA_primary_transcript",
            "def": "A primary transcript encoding tyrosyl tRNA (SO:000272). [SO:ke]"
          },
          "SO:0000230": {
            "name": "valine_tRNA_primary_transcript",
            "def": "A primary transcript encoding valyl tRNA (SO:000273). [SO:ke]"
          },
          "SO:0000231": {
            "name": "snRNA_primary_transcript",
            "def": "A primary transcript encoding a small nuclear RNA (SO:0000274). [SO:ke]"
          },
          "SO:0000232": {
            "name": "snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar mRNA (SO:0000275). [SO:ke]"
          },
          "SO:0000233": {
            "name": "mature_transcript",
            "def": "A transcript which has undergone the necessary modifications, if any, for its function. In eukaryotes this includes, for example, processing of introns, cleavage, base modification, and modifications to the 5' and/or the 3' ends, other than addition of bases. In bacteria functional mRNAs are usually not modified. [SO:ke]"
          },
          "SO:0000234": {
            "name": "mRNA",
            "def": "Messenger RNA is the intermediate molecule between DNA and protein. It includes UTR and coding sequences. It does not contain introns. [SO:ma]"
          },
          "SO:0000235": {
            "name": "TF_binding_site",
            "def": "A region of a nucleotide molecule that binds a Transcription Factor or Transcription Factor complex [GO:0005667]. [SO:ke]"
          },
          "SO:0000236": {
            "name": "ORF",
            "def": "The in-frame interval between the stop codons of a reading frame which when read as sequential triplets, has the potential of encoding a sequential string of amino acids. TER(NNN)nTER. [SGD:rb, SO:ma]"
          },
          "SO:0000237": {
            "name": "transcript_attribute"
          },
          "SO:0000238": {
            "name": "foldback_element",
            "def": "A transposable element with extensive secondary structure, characterized by large modular imperfect long inverted repeats. [http://www.genetics.org/cgi/reprint/156/4/1983.pdf]"
          },
          "SO:0000239": {
            "name": "flanking_region",
            "def": "The sequences extending on either side of a specific region. [SO:ke]"
          },
          "SO:0000240": {
            "name": "chromosome_variation"
          },
          "SO:0000241": {
            "name": "internal_UTR",
            "def": "A UTR bordered by the terminal and initial codons of two CDSs in a polycistronic transcript. Every UTR is either 5', 3' or internal. [SO:cjm]"
          },
          "SO:0000242": {
            "name": "untranslated_region_polycistronic_mRNA",
            "def": "The untranslated sequence separating the 'cistrons' of multicistronic mRNA. [SO:ke]"
          },
          "SO:0000243": {
            "name": "internal_ribosome_entry_site",
            "def": "Sequence element that recruits a ribosomal subunit to internal mRNA for translation initiation. [SO:ke]"
          },
          "SO:0000244": {
            "name": "four_cutter_restriction_site"
          },
          "SO:0000245": {
            "name": "mRNA_by_polyadenylation_status"
          },
          "SO:0000246": {
            "name": "polyadenylated",
            "def": "A attribute describing the addition of a poly A tail to the 3' end of a mRNA molecule. [SO:ke]"
          },
          "SO:0000247": {
            "name": "mRNA_not_polyadenylated"
          },
          "SO:0000248": {
            "name": "sequence_length_variation"
          },
          "SO:0000249": {
            "name": "six_cutter_restriction_site"
          },
          "SO:0000250": {
            "name": "modified_RNA_base_feature",
            "def": "A post_transcriptionally modified base. [SO:ke]"
          },
          "SO:0000251": {
            "name": "eight_cutter_restriction_site"
          },
          "SO:0000252": {
            "name": "rRNA",
            "def": "RNA that comprises part of a ribosome, and that can provide both structural scaffolding and catalytic activity. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, ISBN:0198506732]"
          },
          "SO:0000253": {
            "name": "tRNA",
            "def": "Transfer RNA (tRNA) molecules are approximately 80 nucleotides in length. Their secondary structure includes four short double-helical elements and three loops (D, anti-codon, and T loops). Further hydrogen bonds mediate the characteristic L-shaped molecular structure. Transfer RNAs have two regions of fundamental functional importance: the anti-codon, which is responsible for specific mRNA codon recognition, and the 3' end, to which the tRNA's corresponding amino acid is attached (by aminoacyl-tRNA synthetases). Transfer RNAs cope with the degeneracy of the genetic code in two manners: having more than one tRNA (with a specific anti-codon) for a particular amino acid; and 'wobble' base-pairing, i.e. permitting non-standard base-pairing at the 3rd anti-codon position. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00005, ISBN:0198506732]"
          },
          "SO:0000254": {
            "name": "alanyl_tRNA",
            "def": "A tRNA sequence that has an alanine anticodon, and a 3' alanine binding region. [SO:ke]"
          },
          "SO:0000255": {
            "name": "rRNA_small_subunit_primary_transcript",
            "def": "A primary transcript encoding a small ribosomal subunit RNA. [SO:ke]"
          },
          "SO:0000256": {
            "name": "asparaginyl_tRNA",
            "def": "A tRNA sequence that has an asparagine anticodon, and a 3' asparagine binding region. [SO:ke]"
          },
          "SO:0000257": {
            "name": "aspartyl_tRNA",
            "def": "A tRNA sequence that has an aspartic acid anticodon, and a 3' aspartic acid binding region. [SO:ke]"
          },
          "SO:0000258": {
            "name": "cysteinyl_tRNA",
            "def": "A tRNA sequence that has a cysteine anticodon, and a 3' cysteine binding region. [SO:ke]"
          },
          "SO:0000259": {
            "name": "glutaminyl_tRNA",
            "def": "A tRNA sequence that has a glutamine anticodon, and a 3' glutamine binding region. [SO:ke]"
          },
          "SO:0000260": {
            "name": "glutamyl_tRNA",
            "def": "A tRNA sequence that has a glutamic acid anticodon, and a 3' glutamic acid binding region. [SO:ke]"
          },
          "SO:0000261": {
            "name": "glycyl_tRNA",
            "def": "A tRNA sequence that has a glycine anticodon, and a 3' glycine binding region. [SO:ke]"
          },
          "SO:0000262": {
            "name": "histidyl_tRNA",
            "def": "A tRNA sequence that has a histidine anticodon, and a 3' histidine binding region. [SO:ke]"
          },
          "SO:0000263": {
            "name": "isoleucyl_tRNA",
            "def": "A tRNA sequence that has an isoleucine anticodon, and a 3' isoleucine binding region. [SO:ke]"
          },
          "SO:0000264": {
            "name": "leucyl_tRNA",
            "def": "A tRNA sequence that has a leucine anticodon, and a 3' leucine binding region. [SO:ke]"
          },
          "SO:0000265": {
            "name": "lysyl_tRNA",
            "def": "A tRNA sequence that has a lysine anticodon, and a 3' lysine binding region. [SO:ke]"
          },
          "SO:0000266": {
            "name": "methionyl_tRNA",
            "def": "A tRNA sequence that has a methionine anticodon, and a 3' methionine binding region. [SO:ke]"
          },
          "SO:0000267": {
            "name": "phenylalanyl_tRNA",
            "def": "A tRNA sequence that has a phenylalanine anticodon, and a 3' phenylalanine binding region. [SO:ke]"
          },
          "SO:0000268": {
            "name": "prolyl_tRNA",
            "def": "A tRNA sequence that has a proline anticodon, and a 3' proline binding region. [SO:ke]"
          },
          "SO:0000269": {
            "name": "seryl_tRNA",
            "def": "A tRNA sequence that has a serine anticodon, and a 3' serine binding region. [SO:ke]"
          },
          "SO:0000270": {
            "name": "threonyl_tRNA",
            "def": "A tRNA sequence that has a threonine anticodon, and a 3' threonine binding region. [SO:ke]"
          },
          "SO:0000271": {
            "name": "tryptophanyl_tRNA",
            "def": "A tRNA sequence that has a tryptophan anticodon, and a 3' tryptophan binding region. [SO:ke]"
          },
          "SO:0000272": {
            "name": "tyrosyl_tRNA",
            "def": "A tRNA sequence that has a tyrosine anticodon, and a 3' tyrosine binding region. [SO:ke]"
          },
          "SO:0000273": {
            "name": "valyl_tRNA",
            "def": "A tRNA sequence that has a valine anticodon, and a 3' valine binding region. [SO:ke]"
          },
          "SO:0000274": {
            "name": "snRNA",
            "def": "A small nuclear RNA molecule involved in pre-mRNA splicing and processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, PMID:11733745, WB:ems]"
          },
          "SO:0000275": {
            "name": "snoRNA",
            "def": "A snoRNA (small nucleolar RNA) is any one of a class of small RNAs that are associated with the eukaryotic nucleus as components of small nucleolar ribonucleoproteins. They participate in the processing or modifications of many RNAs, mostly ribosomal RNAs (rRNAs) though snoRNAs are also known to target other classes of RNA, including spliceosomal RNAs, tRNAs, and mRNAs via a stretch of sequence that is complementary to a sequence in the targeted RNA. [GOC:kgc]"
          },
          "SO:0000276": {
            "name": "miRNA",
            "def": "Small, ~22-nt, RNA molecule that is the endogenous transcript of a miRNA gene (or the product of other non coding RNA genes. Micro RNAs are produced from precursor molecules (SO:0000647) that can form local hairpin structures, which ordinarily are processed (usually via the Dicer pathway) such that a single miRNA molecule accumulates from one arm of a hairpin precursor molecule. Micro RNAs may trigger the cleavage of their target molecules or act as translational repressors. [PMID:11081512, PMID:12592000]"
          },
          "SO:0000277": {
            "name": "bound_by_factor",
            "def": "An attribute describing a sequence that is bound by another molecule. [SO:ke]"
          },
          "SO:0000278": {
            "name": "transcript_bound_by_nucleic_acid",
            "def": "A transcript that is bound by a nucleic acid. [SO:xp]"
          },
          "SO:0000279": {
            "name": "transcript_bound_by_protein",
            "def": "A transcript that is bound by a protein. [SO:xp]"
          },
          "SO:0000280": {
            "name": "engineered_gene",
            "def": "A gene that is engineered. [SO:xp]"
          },
          "SO:0000281": {
            "name": "engineered_foreign_gene",
            "def": "A gene that is engineered and foreign. [SO:xp]"
          },
          "SO:0000282": {
            "name": "mRNA_with_minus_1_frameshift",
            "def": "An mRNA with a minus 1 frameshift. [SO:xp]"
          },
          "SO:0000283": {
            "name": "engineered_foreign_transposable_element_gene",
            "def": "A transposable_element that is engineered and foreign. [SO:xp]"
          },
          "SO:0000284": {
            "name": "type_I_enzyme_restriction_site",
            "def": "The recognition site is bipartite and interrupted. [http://www.promega.com]"
          },
          "SO:0000285": {
            "name": "foreign_gene",
            "def": "A gene that is foreign. [SO:xp]"
          },
          "SO:0000286": {
            "name": "long_terminal_repeat",
            "def": "A sequence directly repeated at both ends of a defined sequence, of the sort typically found in retroviruses. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000287": {
            "name": "fusion_gene",
            "def": "A gene that is a fusion. [SO:xp]"
          },
          "SO:0000288": {
            "name": "engineered_fusion_gene",
            "def": "A fusion gene that is engineered. [SO:xp]"
          },
          "SO:0000289": {
            "name": "microsatellite",
            "def": "A repeat_region containing repeat_units of 2 to 10 bp repeated in tandem. [http://www.informatics.jax.org/silver/glossary.shtml, NCBI:th]"
          },
          "SO:0000290": {
            "name": "dinucleotide_repeat_microsatellite_feature"
          },
          "SO:0000291": {
            "name": "trinucleotide_repeat_microsatellite_feature"
          },
          "SO:0000292": {
            "name": "repetitive_element"
          },
          "SO:0000293": {
            "name": "engineered_foreign_repetitive_element",
            "def": "A repetitive element that is engineered and foreign. [SO:xp]"
          },
          "SO:0000294": {
            "name": "inverted_repeat",
            "def": "The sequence is complementarily repeated on the opposite strand. It is a palindrome, and it may, or may not be hyphenated. Examples: GCTGATCAGC, or GCTGA-----TCAGC. [SO:ke]"
          },
          "SO:0000295": {
            "name": "U12_intron",
            "def": "A type of spliceosomal intron spliced by the U12 spliceosome, that includes U11, U12, U4atac/U6atac and U5 snRNAs. [PMID:9428511]"
          },
          "SO:0000296": {
            "name": "origin_of_replication",
            "def": "The origin of replication; starting site for duplication of a nucleic acid molecule to give two identical copies. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000297": {
            "name": "D_loop",
            "def": "Displacement loop; a region within mitochondrial DNA in which a short stretch of RNA is paired with one strand of DNA, displacing the original partner DNA strand in this region; also used to describe the displacement of a region of one strand of duplex DNA by a single stranded invader in the reaction catalyzed by RecA protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000298": {
            "name": "recombination_feature"
          },
          "SO:0000299": {
            "name": "specific_recombination_site"
          },
          "SO:0000300": {
            "name": "recombination_feature_of_rearranged_gene"
          },
          "SO:0000301": {
            "name": "vertebrate_immune_system_gene_recombination_feature"
          },
          "SO:0000302": {
            "name": "J_gene_recombination_feature",
            "def": "Recombination signal including J-heptamer, J-spacer and J-nonamer in 5' of J-region of a J-gene or J-sequence. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000303": {
            "name": "clip",
            "def": "Part of the primary transcript that is clipped off during processing. [SO:ke]"
          },
          "SO:0000304": {
            "name": "type_II_enzyme_restriction_site",
            "def": "The recognition site is either palindromic, partially palindromic or an interrupted palindrome. Cleavage occurs within the recognition site. [http://www.promega.com]"
          },
          "SO:0000305": {
            "name": "modified_DNA_base",
            "def": "A modified nucleotide, i.e. a nucleotide other than A, T, C. G. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000306": {
            "name": "methylated_DNA_base_feature",
            "def": "A nucleotide modified by methylation. [SO:ke]"
          },
          "SO:0000307": {
            "name": "CpG_island",
            "def": "Regions of a few hundred to a few thousand bases in vertebrate genomes that are relatively GC and CpG rich; they are typically unmethylated and often found near the 5' ends of genes. [SO:rd]"
          },
          "SO:0000308": {
            "name": "sequence_feature_locating_method"
          },
          "SO:0000309": {
            "name": "computed_feature"
          },
          "SO:0000310": {
            "name": "predicted_ab_initio_computation"
          },
          "SO:0000311": {
            "name": "computed_feature_by_similarity",
            "def": ". [SO:ma]"
          },
          "SO:0000312": {
            "name": "experimentally_determined",
            "def": "Attribute to describe a feature that has been experimentally verified. [SO:ke]"
          },
          "SO:0000313": {
            "name": "stem_loop",
            "def": "A double-helical region of nucleic acid formed by base-pairing between adjacent (inverted) complementary sequences. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000314": {
            "name": "direct_repeat",
            "def": "A repeat where the same sequence is repeated in the same direction. Example: GCTGA-followed by-GCTGA. [SO:ke]"
          },
          "SO:0000315": {
            "name": "TSS",
            "def": "The first base where RNA polymerase begins to synthesize the RNA transcript. [SO:ke]"
          },
          "SO:0000316": {
            "name": "CDS",
            "def": "A contiguous sequence which begins with, and includes, a start codon and ends with, and includes, a stop codon. [SO:ma]"
          },
          "SO:0000317": {
            "name": "cDNA_clone",
            "def": "Complementary DNA; A piece of DNA copied from an mRNA and spliced into a vector for propagation in a suitable host. [http://seqcore.brcf.med.umich.edu/doc/educ/dnapr/mbglossary/mbgloss.html]"
          },
          "SO:0000318": {
            "name": "start_codon",
            "def": "First codon to be translated by a ribosome. [SO:ke]"
          },
          "SO:0000319": {
            "name": "stop_codon",
            "def": "In mRNA, a set of three nucleotides that indicates the end of information for protein synthesis. [SO:ke]"
          },
          "SO:0000320": {
            "name": "intronic_splice_enhancer",
            "def": "Sequences within the intron that modulate splice site selection for some introns. [SO:ke]"
          },
          "SO:0000321": {
            "name": "mRNA_with_plus_1_frameshift",
            "def": "An mRNA with a plus 1 frameshift. [SO:ke]"
          },
          "SO:0000322": {
            "name": "nuclease_hypersensitive_site"
          },
          "SO:0000323": {
            "name": "coding_start",
            "def": "The first base to be translated into protein. [SO:ke]"
          },
          "SO:0000324": {
            "name": "tag",
            "def": "A nucleotide sequence that may be used to identify a larger sequence. [SO:ke]"
          },
          "SO:0000325": {
            "name": "rRNA_large_subunit_primary_transcript",
            "def": "A primary transcript encoding a large ribosomal subunit RNA. [SO:ke]"
          },
          "SO:0000326": {
            "name": "SAGE_tag",
            "def": "A short diagnostic sequence tag, serial analysis of gene expression (SAGE), that allows the quantitative and simultaneous analysis of a large number of transcripts. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=7570003&dopt=Abstract]"
          },
          "SO:0000327": {
            "name": "coding_end",
            "def": "The last base to be translated into protein. It does not include the stop codon. [SO:ke]"
          },
          "SO:0000328": {
            "name": "microarray_oligo"
          },
          "SO:0000329": {
            "name": "mRNA_with_plus_2_frameshift",
            "def": "An mRNA with a plus 2 frameshift. [SO:xp]"
          },
          "SO:0000330": {
            "name": "conserved_region",
            "def": "Region of sequence similarity by descent from a common ancestor. [SO:ke]"
          },
          "SO:0000331": {
            "name": "STS",
            "def": "Short (typically a few hundred base pairs) DNA sequence that has a single occurrence in a genome and whose location and base sequence are known. [http://www.biospace.com]"
          },
          "SO:0000332": {
            "name": "coding_conserved_region",
            "def": "Coding region of sequence similarity by descent from a common ancestor. [SO:ke]"
          },
          "SO:0000333": {
            "name": "exon_junction",
            "def": "The boundary between two exons in a processed transcript. [SO:ke]"
          },
          "SO:0000334": {
            "name": "nc_conserved_region",
            "def": "Non-coding region of sequence similarity by descent from a common ancestor. [SO:ke]"
          },
          "SO:0000335": {
            "name": "mRNA_with_minus_2_frameshift",
            "def": "A mRNA with a minus 2 frameshift. [SO:ke]"
          },
          "SO:0000336": {
            "name": "pseudogene",
            "def": "A sequence that closely resembles a known functional gene, at another locus within a genome, that is non-functional as a consequence of (usually several) mutations that prevent either its transcription or translation (or both). In general, pseudogenes result from either reverse transcription of a transcript of their \\normal\\ paralog (SO:0000043) (in which case the pseudogene typically lacks introns and includes a poly(A) tail) or from recombination (SO:0000044) (in which case the pseudogene is typically a tandem duplication of its \\normal\\ paralog). [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html]"
          },
          "SO:0000337": {
            "name": "RNAi_reagent",
            "def": "A double stranded RNA duplex, at least 20bp long, used experimentally to inhibit gene function by RNA interference. [SO:rd]"
          },
          "SO:0000338": {
            "name": "MITE",
            "def": "A highly repetitive and short (100-500 base pair) transposable element with terminal inverted repeats (TIR) and target site duplication (TSD). MITEs do not encode proteins. [http://www.pnas.org/cgi/content/full/97/18/10083]"
          },
          "SO:0000339": {
            "name": "recombination_hotspot",
            "def": "A region in a genome which promotes recombination. [SO:rd]"
          },
          "SO:0000340": {
            "name": "chromosome",
            "def": "Structural unit composed of a nucleic acid molecule which controls its own replication through the interaction of specific proteins at one or more origins of replication. [SO:ma]"
          },
          "SO:0000341": {
            "name": "chromosome_band",
            "def": "A cytologically distinguishable feature of a chromosome, often made visible by staining, and usually alternating light and dark. [SO:ma]"
          },
          "SO:0000342": {
            "name": "site_specific_recombination_target_region"
          },
          "SO:0000343": {
            "name": "match",
            "def": "A region of sequence, aligned to another sequence with some statistical significance, using an algorithm such as BLAST or SIM4. [SO:ke]"
          },
          "SO:0000344": {
            "name": "splice_enhancer",
            "def": "Region of a transcript that regulates splicing. [SO:ke]"
          },
          "SO:0000345": {
            "name": "EST",
            "def": "A tag produced from a single sequencing read from a cDNA clone or PCR product; typically a few hundred base pairs long. [SO:ke]"
          },
          "SO:0000346": {
            "name": "loxP_site"
          },
          "SO:0000347": {
            "name": "nucleotide_match",
            "def": "A match against a nucleotide sequence. [SO:ke]"
          },
          "SO:0000348": {
            "name": "nucleic_acid",
            "def": "An attribute describing a sequence consisting of nucleobases bound to repeating units. The forms found in nature are deoxyribonucleic acid (DNA), where the repeating units are 2-deoxy-D-ribose rings connected to a phosphate backbone, and ribonucleic acid (RNA), where the repeating units are D-ribose rings connected to a phosphate backbone. [CHEBI:33696, RSC:cb]"
          },
          "SO:0000349": {
            "name": "protein_match",
            "def": "A match against a protein sequence. [SO:ke]"
          },
          "SO:0000350": {
            "name": "FRT_site",
            "def": "An inversion site found on the Saccharomyces cerevisiae 2 micron plasmid. [SO:ma]"
          },
          "SO:0000351": {
            "name": "synthetic_sequence",
            "def": "An attribute to decide a sequence of nucleotides, nucleotide analogs, or amino acids that has been designed by an experimenter and which may, or may not, correspond with any natural sequence. [SO:ma]"
          },
          "SO:0000352": {
            "name": "DNA",
            "def": "An attribute describing a sequence consisting of nucleobases bound to a repeating unit made of a 2-deoxy-D-ribose ring connected to a phosphate backbone. [RSC:cb]"
          },
          "SO:0000353": {
            "name": "sequence_assembly",
            "def": "A sequence of nucleotides that has been algorithmically derived from an alignment of two or more different sequences. [SO:ma]"
          },
          "SO:0000354": {
            "name": "group_1_intron_homing_endonuclease_target_region",
            "def": "A region of intronic nucleotide sequence targeted by a nuclease enzyme. [SO:ke]"
          },
          "SO:0000355": {
            "name": "haplotype_block",
            "def": "A region of the genome which is co-inherited as the result of the lack of historic recombination within it. [SO:ma]"
          },
          "SO:0000356": {
            "name": "RNA",
            "def": "An attribute describing a sequence consisting of nucleobases bound to a repeating unit made of a D-ribose ring connected to a phosphate backbone. [RSC:cb]"
          },
          "SO:0000357": {
            "name": "flanked",
            "def": "An attribute describing a region that is bounded either side by a particular kind of region. [SO:ke]"
          },
          "SO:0000359": {
            "name": "floxed",
            "def": "An attribute describing sequence that is flanked by Lox-P sites. [SO:ke]"
          },
          "SO:0000360": {
            "name": "codon",
            "def": "A set of (usually) three nucleotide bases in a DNA or RNA sequence, which together code for a unique amino acid or the termination of translation and are contained within the CDS. [http://www.everythingbio.com/glos/definition.php?word=codon, SO:ke]"
          },
          "SO:0000361": {
            "name": "FRT_flanked",
            "def": "An attribute to describe sequence that is flanked by the FLP recombinase recognition site, FRT. [SO:ke]"
          },
          "SO:0000362": {
            "name": "invalidated_by_chimeric_cDNA",
            "def": "A cDNA clone constructed from more than one mRNA. Usually an experimental artifact. [SO:ma]"
          },
          "SO:0000363": {
            "name": "floxed_gene",
            "def": "A transgene that is floxed. [SO:xp]"
          },
          "SO:0000364": {
            "name": "transposable_element_flanking_region",
            "def": "The region of sequence surrounding a transposable element. [SO:ke]"
          },
          "SO:0000365": {
            "name": "integron",
            "def": "A region encoding an integrase which acts at a site adjacent to it (attI_site) to insert DNA which must include but is not limited to an attC_site. [SO:as]"
          },
          "SO:0000366": {
            "name": "insertion_site",
            "def": "The junction where an insertion occurred. [SO:ke]"
          },
          "SO:0000367": {
            "name": "attI_site",
            "def": "A region within an integron, adjacent to an integrase, at which site specific recombination involving an attC_site takes place. [SO:as]"
          },
          "SO:0000368": {
            "name": "transposable_element_insertion_site",
            "def": "The junction in a genome where a transposable_element has inserted. [SO:ke]"
          },
          "SO:0000369": {
            "name": "integrase_coding_region"
          },
          "SO:0000370": {
            "name": "small_regulatory_ncRNA",
            "def": "A non-coding RNA, usually with a specific secondary structure, that acts to regulate gene expression. [SO:ma]"
          },
          "SO:0000371": {
            "name": "conjugative_transposon",
            "def": "A transposon that encodes function required for conjugation. [http://www.sci.sdsu.edu/~smaloy/Glossary/C.html]"
          },
          "SO:0000372": {
            "name": "enzymatic_RNA",
            "def": "An RNA sequence that has catalytic activity with or without an associated ribonucleoprotein. [RSC:cb]"
          },
          "SO:0000373": {
            "name": "recombinationally_inverted_gene",
            "def": "A recombinationally rearranged gene by inversion. [SO:xp]"
          },
          "SO:0000374": {
            "name": "ribozyme",
            "def": "An RNA with catalytic activity. [SO:ma]"
          },
          "SO:0000375": {
            "name": "rRNA_5_8S",
            "def": "5_8S ribosomal RNA (5. 8S rRNA) is a component of the large subunit of the eukaryotic ribosome. It is transcribed by RNA polymerase I as part of the 45S precursor that also contains 18S and 28S rRNA. Functionally, it is thought that 5.8S rRNA may be involved in ribosome translocation. It is also known to form covalent linkage to the p53 tumour suppressor protein. 5_8S rRNA is also found in archaea. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00002]"
          },
          "SO:0000376": {
            "name": "RNA_6S",
            "def": "A small (184-nt in E. coli) RNA that forms a hairpin type structure. 6S RNA associates with RNA polymerase in a highly specific manner. 6S RNA represses expression from a sigma70-dependent promoter during stationary phase. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00013]"
          },
          "SO:0000377": {
            "name": "CsrB_RsmB_RNA",
            "def": "An enterobacterial RNA that binds the CsrA protein. The CsrB RNAs contain a conserved motif CAGGXXG that is found in up to 18 copies and has been suggested to bind CsrA. The Csr regulatory system has a strong negative regulatory effect on glycogen biosynthesis, glyconeogenesis and glycogen catabolism and a positive regulatory effect on glycolysis. In other bacteria such as Erwinia caratovara the RsmA protein has been shown to regulate the production of virulence determinants, such extracellular enzymes. RsmA binds to RsmB regulatory RNA which is also a member of this family. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00018]"
          },
          "SO:0000378": {
            "name": "DsrA_RNA",
            "def": "DsrA RNA regulates both transcription, by overcoming transcriptional silencing by the nucleoid-associated H-NS protein, and translation, by promoting efficient translation of the stress sigma factor, RpoS. These two activities of DsrA can be separated by mutation: the first of three stem-loops of the 85 nucleotide RNA is necessary for RpoS translation but not for anti-H-NS action, while the second stem-loop is essential for antisilencing and less critical for RpoS translation. The third stem-loop, which behaves as a transcription terminator, can be substituted by the trp transcription terminator without loss of either DsrA function. The sequence of the first stem-loop of DsrA is complementary with the upstream leader portion of RpoS messenger RNA, suggesting that pairing of DsrA with the RpoS message might be important for translational regulation. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00014]"
          },
          "SO:0000379": {
            "name": "GcvB_RNA",
            "def": "A small untranslated RNA involved in expression of the dipeptide and oligopeptide transport systems in Escherichia coli. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00022]"
          },
          "SO:0000380": {
            "name": "hammerhead_ribozyme",
            "def": "A small catalytic RNA motif that catalyzes self-cleavage reaction. Its name comes from its secondary structure which resembles a carpenter's hammer. The hammerhead ribozyme is involved in the replication of some viroid and some satellite RNAs. [PMID:2436805]"
          },
          "SO:0000381": {
            "name": "group_IIA_intron"
          },
          "SO:0000382": {
            "name": "group_IIB_intron"
          },
          "SO:0000383": {
            "name": "MicF_RNA",
            "def": "A non-translated 93 nt antisense RNA that binds its target ompF mRNA and regulates ompF expression by inhibiting translation and inducing degradation of the message. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00033]"
          },
          "SO:0000384": {
            "name": "OxyS_RNA",
            "def": "A small untranslated RNA which is induced in response to oxidative stress in Escherichia coli. Acts as a global regulator to activate or repress the expression of as many as 40 genes, including the fhlA-encoded transcriptional activator and the rpoS-encoded sigma(s) subunit of RNA polymerase. OxyS is bound by the Hfq protein, that increases the OxyS RNA interaction with its target messages. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00035]"
          },
          "SO:0000385": {
            "name": "RNase_MRP_RNA",
            "def": "The RNA molecule essential for the catalytic activity of RNase MRP, an enzymatically active ribonucleoprotein with two distinct roles in eukaryotes. In mitochondria it plays a direct role in the initiation of mitochondrial DNA replication. In the nucleus it is involved in precursor rRNA processing, where it cleaves the internal transcribed spacer 1 between 18S and 5.8S rRNAs. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00030]"
          },
          "SO:0000386": {
            "name": "RNase_P_RNA",
            "def": "The RNA component of Ribonuclease P (RNase P), a ubiquitous endoribonuclease, found in archaea, bacteria and eukarya as well as chloroplasts and mitochondria. Its best characterized activity is the generation of mature 5 prime ends of tRNAs by cleaving the 5 prime leader elements of precursor-tRNAs. Cellular RNase Ps are ribonucleoproteins. RNA from bacterial RNase Ps retains its catalytic activity in the absence of the protein subunit, i.e. it is a ribozyme. Isolated eukaryotic and archaeal RNase P RNA has not been shown to retain its catalytic function, but is still essential for the catalytic activity of the holoenzyme. Although the archaeal and eukaryotic holoenzymes have a much greater protein content than the bacterial ones, the RNA cores from all the three lineages are homologous. Helices corresponding to P1, P2, P3, P4, and P10/11 are common to all cellular RNase P RNAs. Yet, there is considerable sequence variation, particularly among the eukaryotic RNAs. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00010]"
          },
          "SO:0000387": {
            "name": "RprA_RNA",
            "def": "Translational regulation of the stationary phase sigma factor RpoS is mediated by the formation of a double-stranded RNA stem-loop structure in the upstream region of the rpoS messenger RNA, occluding the translation initiation site. Clones carrying rprA (RpoS regulator RNA) increased the translation of RpoS. The rprA gene encodes a 106 nucleotide regulatory RNA. As with DsrA Rfam:RF00014, RprA is predicted to form three stem-loops. Thus, at least two small RNAs, DsrA and RprA, participate in the positive regulation of RpoS translation. Unlike DsrA, RprA does not have an extensive region of complementarity to the RpoS leader, leaving its mechanism of action unclear. RprA is non-essential. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00034]"
          },
          "SO:0000388": {
            "name": "RRE_RNA",
            "def": "The Rev response element (RRE) is encoded within the HIV-env gene. Rev is an essential regulatory protein of HIV that binds an internal loop of the RRE leading, encouraging further Rev-RRE binding. This RNP complex is critical for mRNA export and hence for expression of the HIV structural proteins. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00036]"
          },
          "SO:0000389": {
            "name": "spot_42_RNA",
            "def": "A 109-nucleotide RNA of E. coli that seems to have a regulatory role on the galactose operon. Changes in Spot 42 levels are implicated in affecting DNA polymerase I levels. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00021]"
          },
          "SO:0000390": {
            "name": "telomerase_RNA",
            "def": "The RNA component of telomerase, a reverse transcriptase that synthesizes telomeric DNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00025]"
          },
          "SO:0000391": {
            "name": "U1_snRNA",
            "def": "U1 is a small nuclear RNA (snRNA) component of the spliceosome (involved in pre-mRNA splicing). Its 5' end forms complementary base pairs with the 5' splice junction, thus defining the 5' donor site of an intron. There are significant differences in sequence and secondary structure between metazoan and yeast U1 snRNAs, the latter being much longer (568 nucleotides as compared to 164 nucleotides in human). Nevertheless, secondary structure predictions suggest that all U1 snRNAs share a 'common core' consisting of helices I, II, the proximal region of III, and IV. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00003]"
          },
          "SO:0000392": {
            "name": "U2_snRNA",
            "def": "U2 is a small nuclear RNA (snRNA) component of the spliceosome (involved in pre-mRNA splicing). Complementary binding between U2 snRNA (in an area lying towards the 5' end but 3' to hairpin I) and the branchpoint sequence (BPS) of the intron results in the bulging out of an unpaired adenine, on the BPS, which initiates a nucleophilic attack at the intronic 5' splice site, thus starting the first of two transesterification reactions that mediate splicing. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00004]"
          },
          "SO:0000393": {
            "name": "U4_snRNA",
            "def": "U4 small nuclear RNA (U4 snRNA) is a component of the major U2-dependent spliceosome. It forms a duplex with U6, and with each splicing round, it is displaced from U6 (and the spliceosome) in an ATP-dependent manner, allowing U6 to refold and create the active site for splicing catalysis. A recycling process involving protein Prp24 re-anneals U4 and U6. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00015]"
          },
          "SO:0000394": {
            "name": "U4atac_snRNA",
            "def": "An snRNA required for the splicing of the minor U12-dependent class of eukaryotic nuclear introns. It forms a base paired complex with U6atac_snRNA (SO:0000397). [PMID:=12409455]"
          },
          "SO:0000395": {
            "name": "U5_snRNA",
            "def": "U5 RNA is a component of both types of known spliceosome. The precise function of this molecule is unknown, though it is known that the 5' loop is required for splice site selection and p220 binding, and that both the 3' stem-loop and the Sm site are important for Sm protein binding and cap methylation. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00020]"
          },
          "SO:0000396": {
            "name": "U6_snRNA",
            "def": "U6 snRNA is a component of the spliceosome which is involved in splicing pre-mRNA. The putative secondary structure consensus base pairing is confined to a short 5' stem loop, but U6 snRNA is thought to form extensive base-pair interactions with U4 snRNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00015]"
          },
          "SO:0000397": {
            "name": "U6atac_snRNA",
            "def": "U6atac_snRNA is an snRNA required for the splicing of the minor U12-dependent class of eukaryotic nuclear introns. It forms a base paired complex with U4atac_snRNA (SO:0000394). [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=retrieve&db=pubmed&list_uids=12409455&dopt=Abstract]"
          },
          "SO:0000398": {
            "name": "U11_snRNA",
            "def": "U11 snRNA plays a role in splicing of the minor U12-dependent class of eukaryotic nuclear introns, similar to U1 snRNA in the major class spliceosome it base pairs to the conserved 5' splice site sequence. [PMID:9622129]"
          },
          "SO:0000399": {
            "name": "U12_snRNA",
            "def": "The U12 small nuclear (snRNA), together with U4atac/U6atac, U5, and U11 snRNAs and associated proteins, forms a spliceosome that cleaves a divergent class of low-abundance pre-mRNA introns. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00007]"
          },
          "SO:0000400": {
            "name": "sequence_attribute",
            "def": "An attribute describes a quality of sequence. [SO:ke]"
          },
          "SO:0000401": {
            "name": "gene_attribute"
          },
          "SO:0000402": {
            "name": "enhancer_attribute"
          },
          "SO:0000403": {
            "name": "U14_snoRNA",
            "def": "U14 small nucleolar RNA (U14 snoRNA) is required for early cleavages of eukaryotic precursor rRNAs. In yeasts, this molecule possess a stem-loop region (known as the Y-domain) which is essential for function. A similar structure, but with a different consensus sequence, is found in plants, but is absent in vertebrates. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00016, PMID:2551119]"
          },
          "SO:0000404": {
            "name": "vault_RNA",
            "def": "A family of RNAs are found as part of the enigmatic vault ribonucleoprotein complex. The complex consists of a major vault protein (MVP), two minor vault proteins (VPARP and TEP1), and several small untranslated RNA molecules. It has been suggested that the vault complex is involved in drug resistance. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00006]"
          },
          "SO:0000405": {
            "name": "Y_RNA",
            "def": "Y RNAs are components of the Ro ribonucleoprotein particle (Ro RNP), in association with Ro60 and La proteins. The Y RNAs and Ro60 and La proteins are well conserved, but the function of the Ro RNP is not known. In humans the RNA component can be one of four small RNAs: hY1, hY3, hY4 and hY5. These small RNAs are predicted to fold into a conserved secondary structure containing three stem structures. The largest of the four, hY1, contains an additional hairpin. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00019]"
          },
          "SO:0000406": {
            "name": "twintron",
            "def": "An intron within an intron. Twintrons are group II or III introns, into which another group II or III intron has been transposed. [PMID:1899376, PMID:7823908]"
          },
          "SO:0000407": {
            "name": "rRNA_18S",
            "def": "A large polynucleotide in eukaryotes, which functions as the small subunit of the ribosome. [SO:ke]"
          },
          "SO:0000408": {
            "name": "site",
            "def": "The interbase position where something (eg an aberration) occurred. [SO:ke]"
          },
          "SO:0000409": {
            "name": "binding_site",
            "def": "A biological_region of sequence that, in the molecule, interacts selectively and non-covalently with other molecules. A region on the surface of a molecule that may interact with another molecule. When applied to polypeptides: Amino acids involved in binding or interactions. It can also apply to an amino acid bond which is represented by the positions of the two flanking amino acids. [EBIBS:GAR, SO:ke]"
          },
          "SO:0000410": {
            "name": "protein_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with polypeptide molecules. [SO:ke]"
          },
          "SO:0000411": {
            "name": "rescue_region",
            "def": "A region that rescues. [SO:xp]"
          },
          "SO:0000412": {
            "name": "restriction_fragment",
            "def": "A region of polynucleotide sequence produced by digestion with a restriction endonuclease. [SO:ke]"
          },
          "SO:0000413": {
            "name": "sequence_difference",
            "def": "A region where the sequence differs from that of a specified sequence. [SO:ke]"
          },
          "SO:0000414": {
            "name": "invalidated_by_genomic_contamination",
            "def": "An attribute to describe a feature that is invalidated due to genomic contamination. [SO:ke]"
          },
          "SO:0000415": {
            "name": "invalidated_by_genomic_polyA_primed_cDNA",
            "def": "An attribute to describe a feature that is invalidated due to polyA priming. [SO:ke]"
          },
          "SO:0000416": {
            "name": "invalidated_by_partial_processing",
            "def": "An attribute to describe a feature that is invalidated due to partial processing. [SO:ke]"
          },
          "SO:0000417": {
            "name": "polypeptide_domain",
            "def": "A structurally or functionally defined protein region. In proteins with multiple domains, the combination of the domains determines the function of the protein. A region which has been shown to recur throughout evolution. [EBIBS:GAR]"
          },
          "SO:0000418": {
            "name": "signal_peptide",
            "def": "The signal_peptide is a short region of the peptide located at the N-terminus that directs the protein to be secreted or part of membrane components. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000419": {
            "name": "mature_protein_region",
            "def": "The polypeptide sequence that remains when the cleaved peptide regions have been cleaved from the immature peptide. [EBIBS:GAR, http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, SO:cb]"
          },
          "SO:0000420": {
            "name": "five_prime_terminal_inverted_repeat"
          },
          "SO:0000421": {
            "name": "three_prime_terminal_inverted_repeat"
          },
          "SO:0000422": {
            "name": "U5_LTR_region"
          },
          "SO:0000423": {
            "name": "R_LTR_region"
          },
          "SO:0000424": {
            "name": "U3_LTR_region"
          },
          "SO:0000425": {
            "name": "five_prime_LTR"
          },
          "SO:0000426": {
            "name": "three_prime_LTR"
          },
          "SO:0000427": {
            "name": "R_five_prime_LTR_region"
          },
          "SO:0000428": {
            "name": "U5_five_prime_LTR_region"
          },
          "SO:0000429": {
            "name": "U3_five_prime_LTR_region"
          },
          "SO:0000430": {
            "name": "R_three_prime_LTR_region"
          },
          "SO:0000431": {
            "name": "U3_three_prime_LTR_region"
          },
          "SO:0000432": {
            "name": "U5_three_prime_LTR_region"
          },
          "SO:0000433": {
            "name": "non_LTR_retrotransposon_polymeric_tract",
            "def": "A polymeric tract, such as poly(dA), within a non_LTR_retrotransposon. [SO:ke]"
          },
          "SO:0000434": {
            "name": "target_site_duplication",
            "def": "A sequence of the target DNA that is duplicated when a transposable element or phage inserts; usually found at each end the insertion. [http://www.koko.gov.my/CocoaBioTech/Glossaryt.html]"
          },
          "SO:0000435": {
            "name": "RR_tract",
            "def": "A polypurine tract within an LTR_retrotransposon. [SO:ke]"
          },
          "SO:0000436": {
            "name": "ARS",
            "def": "A sequence that can autonomously replicate, as a plasmid, when transformed into a bacterial host. [SO:ma]"
          },
          "SO:0000437": {
            "name": "assortment_derived_duplication"
          },
          "SO:0000438": {
            "name": "gene_not_polyadenylated"
          },
          "SO:0000439": {
            "name": "inverted_ring_chromosome"
          },
          "SO:0000440": {
            "name": "vector_replicon",
            "def": "A replicon that has been modified to act as a vector for foreign sequence. [SO:ma]"
          },
          "SO:0000441": {
            "name": "ss_oligo",
            "def": "A single stranded oligonucleotide. [SO:ke]"
          },
          "SO:0000442": {
            "name": "ds_oligo",
            "def": "A double stranded oligonucleotide. [SO:ke]"
          },
          "SO:0000443": {
            "name": "polymer_attribute",
            "def": "An attribute to describe the kind of biological sequence. [SO:ke]"
          },
          "SO:0000444": {
            "name": "three_prime_noncoding_exon",
            "def": "Non-coding exon in the 3' UTR. [SO:ke]"
          },
          "SO:0000445": {
            "name": "five_prime_noncoding_exon",
            "def": "Non-coding exon in the 5' UTR. [SO:ke]"
          },
          "SO:0000446": {
            "name": "UTR_intron",
            "def": "Intron located in the untranslated region. [SO:ke]"
          },
          "SO:0000447": {
            "name": "five_prime_UTR_intron",
            "def": "An intron located in the 5' UTR. [SO:ke]"
          },
          "SO:0000448": {
            "name": "three_prime_UTR_intron",
            "def": "An intron located in the 3' UTR. [SO:ke]"
          },
          "SO:0000449": {
            "name": "random_sequence",
            "def": "A sequence of nucleotides or amino acids which, by design, has a \\random\\ order of components, given a predetermined input frequency of these components. [SO:ma]"
          },
          "SO:0000450": {
            "name": "interband",
            "def": "A light region between two darkly staining bands in a polytene chromosome. [SO:ma]"
          },
          "SO:0000451": {
            "name": "gene_with_polyadenylated_mRNA",
            "def": "A gene that encodes a polyadenylated mRNA. [SO:xp]"
          },
          "SO:0000452": {
            "name": "transgene_attribute"
          },
          "SO:0000453": {
            "name": "chromosomal_transposition",
            "def": "A chromosome structure variant whereby a region of a chromosome has been transferred to another position. Among interchromosomal rearrangements, the term transposition is reserved for that class in which the telomeres of the chromosomes involved are coupled (that is to say, form the two ends of a single DNA molecule) as in wild-type. [FB:reference_manual, SO:ke]"
          },
          "SO:0000454": {
            "name": "rasiRNA",
            "def": "A 17-28-nt, small interfering RNA derived from transcripts of repetitive elements. [http://www.developmentalcell.com/content/article/abstract?uid=PIIS1534580703002284]"
          },
          "SO:0000455": {
            "name": "gene_with_mRNA_with_frameshift",
            "def": "A gene that encodes an mRNA with a frameshift. [SO:xp]"
          },
          "SO:0000456": {
            "name": "recombinationally_rearranged_gene",
            "def": "A gene that is recombinationally rearranged. [SO:ke]"
          },
          "SO:0000457": {
            "name": "interchromosomal_duplication",
            "def": "A chromosome duplication involving an insertion from another chromosome. [SO:ke]"
          },
          "SO:0000458": {
            "name": "D_gene_segment",
            "def": "Germline genomic DNA including D-region with 5' UTR and 3' UTR, also designated as D-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000459": {
            "name": "gene_with_trans_spliced_transcript",
            "def": "A gene with a transcript that is trans-spliced. [SO:xp]"
          },
          "SO:0000460": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_segment"
          },
          "SO:0000461": {
            "name": "inversion_derived_bipartite_deficiency",
            "def": "A chromosomal deletion whereby a chromosome generated by recombination between two inversions; has a deficiency at each end of the inversion. [FB:km]"
          },
          "SO:0000462": {
            "name": "pseudogenic_region",
            "def": "A non-functional descendant of a functional entity. [SO:cjm]"
          },
          "SO:0000463": {
            "name": "encodes_alternately_spliced_transcripts",
            "def": "A gene that encodes more than one transcript. [SO:ke]"
          },
          "SO:0000464": {
            "name": "decayed_exon",
            "def": "A non-functional descendant of an exon. [SO:ke]"
          },
          "SO:0000465": {
            "name": "inversion_derived_deficiency_plus_duplication",
            "def": "A chromosome deletion whereby a chromosome is generated by recombination between two inversions; there is a deficiency at one end of the inversion and a duplication at the other end of the inversion. [FB:km]"
          },
          "SO:0000466": {
            "name": "V_gene_segment",
            "def": "Germline genomic DNA including L-part1, V-intron and V-exon, with the 5' UTR and 3' UTR. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000467": {
            "name": "post_translationally_regulated_by_protein_stability",
            "def": "An attribute describing a gene sequence where the resulting protein is regulated by the stability of the resulting protein. [SO:ke]"
          },
          "SO:0000468": {
            "name": "golden_path_fragment",
            "def": "One of the pieces of sequence that make up a golden path. [SO:rd]"
          },
          "SO:0000469": {
            "name": "post_translationally_regulated_by_protein_modification",
            "def": "An attribute describing a gene sequence where the resulting protein is modified to regulate it. [SO:ke]"
          },
          "SO:0000470": {
            "name": "J_gene_segment",
            "def": "Germline genomic DNA of an immunoglobulin/T-cell receptor gene including J-region with 5' UTR (SO:0000204) and 3' UTR (SO:0000205), also designated as J-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000471": {
            "name": "autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation. [SO:ke]"
          },
          "SO:0000472": {
            "name": "tiling_path",
            "def": "A set of regions which overlap with minimal polymorphism to form a linear sequence. [SO:cjm]"
          },
          "SO:0000473": {
            "name": "negatively_autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation where it decreases transcription. [SO:ke]"
          },
          "SO:0000474": {
            "name": "tiling_path_fragment",
            "def": "A piece of sequence that makes up a tiling_path (SO:0000472). [SO:ke]"
          },
          "SO:0000475": {
            "name": "positively_autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation, where it increases transcription. [SO:ke]"
          },
          "SO:0000476": {
            "name": "contig_read",
            "def": "A DNA sequencer read which is part of a contig. [SO:ke]"
          },
          "SO:0000477": {
            "name": "polycistronic_gene",
            "def": "A gene that is polycistronic. [SO:ke]"
          },
          "SO:0000478": {
            "name": "C_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene including C-region (and introns if present) with 5' UTR (SO:0000204) and 3' UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000479": {
            "name": "trans_spliced_transcript",
            "def": "A transcript that is trans-spliced. [SO:xp]"
          },
          "SO:0000480": {
            "name": "tiling_path_clone",
            "def": "A clone which is part of a tiling path. A tiling path is a set of sequencing substrates, typically clones, which have been selected in order to efficiently cover a region of the genome in preparation for sequencing and assembly. [SO:ke]"
          },
          "SO:0000481": {
            "name": "terminal_inverted_repeat",
            "def": "An inverted repeat (SO:0000294) occurring at the termini of a DNA transposon. [SO:ke]"
          },
          "SO:0000482": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_gene_cluster"
          },
          "SO:0000483": {
            "name": "nc_primary_transcript",
            "def": "A primary transcript that is never translated into a protein. [SO:ke]"
          },
          "SO:0000484": {
            "name": "three_prime_coding_exon_noncoding_region",
            "def": "The sequence of the 3' exon that is not coding. [SO:ke]"
          },
          "SO:0000485": {
            "name": "DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one DJ-gene, and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000486": {
            "name": "five_prime_coding_exon_noncoding_region",
            "def": "The sequence of the 5' exon preceding the start codon. [SO:ke]"
          },
          "SO:0000487": {
            "name": "VDJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000488": {
            "name": "VDJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000489": {
            "name": "VJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000490": {
            "name": "VJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000491": {
            "name": "VJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000492": {
            "name": "D_gene_recombination_feature"
          },
          "SO:0000493": {
            "name": "three_prime_D_heptamer",
            "def": "7 nucleotide recombination site like CACAGTG, part of a 3' D-recombination signal sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000494": {
            "name": "three_prime_D_nonamer",
            "def": "A 9 nucleotide recombination site (e.g. ACAAAAACC), part of a 3' D-recombination signal sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000495": {
            "name": "three_prime_D_spacer",
            "def": "A 12 or 23 nucleotide spacer between the 3'D-HEPTAMER and 3'D-NONAMER of a 3'D-RS. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000496": {
            "name": "five_prime_D_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACTGTG), part of a 5' D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000497": {
            "name": "five_prime_D_nonamer",
            "def": "9 nucleotide recombination site (e.g. GGTTTTTGT), part of a five_prime_D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000498": {
            "name": "five_prime_D_spacer",
            "def": "12 or 23 nucleotide spacer between the 5' D-heptamer (SO:0000496) and 5' D-nonamer (SO:0000497) of a 5' D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000499": {
            "name": "virtual_sequence",
            "def": "A continuous piece of sequence similar to the 'virtual contig' concept of the Ensembl database. [SO:ke]"
          },
          "SO:0000500": {
            "name": "Hoogsteen_base_pair",
            "def": "A type of non-canonical base-pairing. This is less energetically favourable than watson crick base pairing. Hoogsteen GC base pairs only have two hydrogen bonds. [PMID:12177293]"
          },
          "SO:0000501": {
            "name": "reverse_Hoogsteen_base_pair",
            "def": "A type of non-canonical base-pairing. [SO:ke]"
          },
          "SO:0000502": {
            "name": "transcribed_region",
            "def": "A region of sequence that is transcribed. This region may cover the transcript of a gene, it may emcompas the sequence covered by all of the transcripts of a alternately spliced gene, or it may cover the region transcribed by a polycistronic transcript. A gene may have 1 or more transcribed regions and a transcribed_region may belong to one or more genes. [SO:ke]"
          },
          "SO:0000503": {
            "name": "alternately_spliced_gene_encodeing_one_transcript"
          },
          "SO:0000504": {
            "name": "D_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000505": {
            "name": "D_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene and one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000506": {
            "name": "D_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000507": {
            "name": "pseudogenic_exon",
            "def": "A non functional descendant of an exon, part of a pseudogene. [SO:ke]"
          },
          "SO:0000508": {
            "name": "D_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene, and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000509": {
            "name": "D_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one D-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000510": {
            "name": "VD_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in partially rearranged genomic DNA including L-part1, V-intron and V-D-exon, with the 5' UTR (SO:0000204) and 3' UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000511": {
            "name": "J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000512": {
            "name": "inversion_derived_deficiency_plus_aneuploid",
            "def": "A chromosomal deletion whereby a chromosome generated by recombination between two inversions; has a deficiency at one end and presumed to have a deficiency or duplication at the other end of the inversion. [FB:km]"
          },
          "SO:0000513": {
            "name": "J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000514": {
            "name": "J_nonamer",
            "def": "9 nucleotide recombination site (e.g. GGTTTTTGT), part of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000515": {
            "name": "J_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACAGTG), part of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000516": {
            "name": "pseudogenic_transcript",
            "def": "A non functional descendant of a transcript, part of a pseudogene. [SO:ke]"
          },
          "SO:0000517": {
            "name": "J_spacer",
            "def": "12 or 23 nucleotide spacer between the J-nonamer and the J-heptamer of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000518": {
            "name": "V_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000519": {
            "name": "V_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000520": {
            "name": "V_VDJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000521": {
            "name": "V_VDJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one VDJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000522": {
            "name": "V_VDJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000523": {
            "name": "V_VJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000524": {
            "name": "V_VJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one VJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000525": {
            "name": "V_VJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000526": {
            "name": "V_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one V-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000527": {
            "name": "V_D_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000528": {
            "name": "V_D_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000529": {
            "name": "V_D_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000530": {
            "name": "V_D_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000531": {
            "name": "V_D_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one D-gene and one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000532": {
            "name": "V_D_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one D-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000533": {
            "name": "V_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACAGTG), part of V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000534": {
            "name": "V_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000535": {
            "name": "V_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000536": {
            "name": "V_nonamer",
            "def": "9 nucleotide recombination site (e.g. ACAAAAACC), part of V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000537": {
            "name": "V_spacer",
            "def": "12 or 23 nucleotide spacer between the V-heptamer and the V-nonamer of a V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000538": {
            "name": "V_gene_recombination_feature",
            "def": "Recombination signal including V-heptamer, V-spacer and V-nonamer in 3' of V-region of a V-gene or V-sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000539": {
            "name": "DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000540": {
            "name": "DJ_J_C_cluster",
            "def": "Genomic DNA in rearranged configuration including at least one D-J-GENE, one J-GENE and one C-GENE. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000541": {
            "name": "VDJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000542": {
            "name": "V_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000543": {
            "name": "alternately_spliced_gene_encoding_greater_than_one_transcript"
          },
          "SO:0000544": {
            "name": "helitron",
            "def": "A rolling circle transposon. Autonomous helitrons encode a 5'-to-3' DNA helicase and nuclease/ligase similar to those encoded by known rolling-circle replicons. [http://www.pnas.org/cgi/content/full/100/11/6569]"
          },
          "SO:0000545": {
            "name": "recoding_pseudoknot",
            "def": "The pseudoknots involved in recoding are unique in that, as they play their role as a structure, they are immediately unfolded and their now linear sequence serves as a template for decoding. [http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=33937]"
          },
          "SO:0000546": {
            "name": "designed_sequence"
          },
          "SO:0000547": {
            "name": "inversion_derived_bipartite_duplication",
            "def": "A chromosome generated by recombination between two inversions; there is a duplication at each end of the inversion. [FB:km]"
          },
          "SO:0000548": {
            "name": "gene_with_edited_transcript",
            "def": "A gene that encodes a transcript that is edited. [SO:xp]"
          },
          "SO:0000549": {
            "name": "inversion_derived_duplication_plus_aneuploid",
            "def": "A chromosome generated by recombination between two inversions; has a duplication at one end and presumed to have a deficiency or duplication at the other end of the inversion. [FB:km]"
          },
          "SO:0000550": {
            "name": "aneuploid_chromosome",
            "def": "A chromosome structural variation whereby either a chromosome exists in addition to the normal chromosome complement or is lacking. [SO:ke]"
          },
          "SO:0000551": {
            "name": "polyA_signal_sequence",
            "def": "The recognition sequence necessary for endonuclease cleavage of an RNA transcript that is followed by polyadenylation; consensus=AATAAA. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000552": {
            "name": "Shine_Dalgarno_sequence",
            "def": "A region in the 5' UTR that pairs with the 16S rRNA during formation of the preinitiation complex. [SO:jh]"
          },
          "SO:0000553": {
            "name": "polyA_site",
            "def": "The site on an RNA transcript to which will be added adenine residues by post-transcriptional polyadenylation. The boundary between the UTR and the polyA sequence. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000554": {
            "name": "assortment_derived_deficiency_plus_duplication"
          },
          "SO:0000555": {
            "name": "five_prime_clip",
            "def": "5' most region of a precursor transcript that is clipped off during processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000556": {
            "name": "five_prime_D_recombination_signal_sequence",
            "def": "Recombination signal of an immunoglobulin/T-cell receptor gene, including the 5' D-nonamer (SO:0000497), 5' D-spacer (SO:0000498), and 5' D-heptamer (SO:0000396) in 5' of the D-region of a D-gene, or in 5' of the D-region of DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000557": {
            "name": "three_prime_clip",
            "def": "3'-most region of a precursor transcript that is clipped off during processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000558": {
            "name": "C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene including more than one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000559": {
            "name": "D_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one D-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000560": {
            "name": "D_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one D-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000561": {
            "name": "heptamer_of_recombination_feature_of_vertebrate_immune_system_gene",
            "def": "Seven nucleotide recombination site (e.g. CACAGTG), part of V-gene, D-gene or J-gene recombination feature of an immunoglobulin or T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000562": {
            "name": "nonamer_of_recombination_feature_of_vertebrate_immune_system_gene"
          },
          "SO:0000563": {
            "name": "vertebrate_immune_system_gene_recombination_spacer"
          },
          "SO:0000564": {
            "name": "V_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000565": {
            "name": "V_VDJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000566": {
            "name": "V_VJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000567": {
            "name": "inversion_derived_aneuploid_chromosome",
            "def": "A chromosome may be generated by recombination between two inversions; presumed to have a deficiency or duplication at each end of the inversion. [FB:km]"
          },
          "SO:0000568": {
            "name": "bidirectional_promoter",
            "def": "An unregulated promoter that allows continuous expression. [SO:ke]"
          },
          "SO:0000569": {
            "name": "retrotransposed",
            "def": "An attribute of a feature that occurred as the product of a reverse transcriptase mediated event. [SO:ke]"
          },
          "SO:0000570": {
            "name": "three_prime_D_recombination_signal_sequence",
            "def": "Recombination signal of an immunoglobulin/T-cell receptor gene, including the 3' D-heptamer (SO:0000493), 3' D-spacer, and 3' D-nonamer (SO:0000494) in 3' of the D-region of a D-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000571": {
            "name": "miRNA_encoding"
          },
          "SO:0000572": {
            "name": "DJ_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in partially rearranged genomic DNA including D-J-region with 5' UTR and 3' UTR, also designated as D-J-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000573": {
            "name": "rRNA_encoding"
          },
          "SO:0000574": {
            "name": "VDJ_gene_segment",
            "def": "Rearranged genomic DNA of immunoglobulin/T-cell receptor gene including L-part1, V-intron and V-D-J-exon, with the 5'UTR (SO:0000204) and 3'UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000575": {
            "name": "scRNA_encoding"
          },
          "SO:0000576": {
            "name": "VJ_gene_segment",
            "def": "Rearranged genomic DNA of immunoglobulin/T-cell receptor gene including L-part1, V-intron and V-J-exon, with the 5'UTR (SO:0000204) and 3'UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000577": {
            "name": "centromere",
            "def": "A region of chromosome where the spindle fibers attach during mitosis and meiosis. [SO:ke]"
          },
          "SO:0000578": {
            "name": "snoRNA_encoding"
          },
          "SO:0000579": {
            "name": "edited_transcript_feature",
            "def": "A locatable feature on a transcript that is edited. [SO:ma]"
          },
          "SO:0000580": {
            "name": "methylation_guide_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a methylation guide small nucleolar RNA. [SO:ke]"
          },
          "SO:0000581": {
            "name": "cap",
            "def": "A structure consisting of a 7-methylguanosine in 5'-5' triphosphate linkage with the first nucleotide of an mRNA. It is added post-transcriptionally, and is not encoded in the DNA. [http://seqcore.brcf.med.umich.edu/doc/educ/dnapr/mbglossary/mbgloss.html]"
          },
          "SO:0000582": {
            "name": "rRNA_cleavage_snoRNA_primary_transcript",
            "def": "A primary transcript encoding an rRNA cleavage snoRNA. [SO:ke]"
          },
          "SO:0000583": {
            "name": "pre_edited_region",
            "def": "The region of a transcript that will be edited. [http://dna.kdna.ucla.edu/rna/index.aspx]"
          },
          "SO:0000584": {
            "name": "tmRNA",
            "def": "A tmRNA liberates a mRNA from a stalled ribosome. To accomplish this part of the tmRNA is used as a reading frame that ends in a translation stop signal. The broken mRNA is replaced in the ribosome by the tmRNA and translation of the tmRNA leads to addition of a proteolysis tag to the incomplete protein enabling recognition by a protease. Recently a number of permuted tmRNAs genes have been found encoded in two parts. TmRNAs have been identified in eubacteria and some chloroplasts but are absent from archeal and Eukaryote nuclear genomes. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00023]"
          },
          "SO:0000585": {
            "name": "C_D_box_snoRNA_encoding"
          },
          "SO:0000586": {
            "name": "tmRNA_primary_transcript",
            "def": "A primary transcript encoding a tmRNA (SO:0000584). [SO:ke]"
          },
          "SO:0000587": {
            "name": "group_I_intron",
            "def": "Group I catalytic introns are large self-splicing ribozymes. They catalyze their own excision from mRNA, tRNA and rRNA precursors in a wide range of organisms. The core secondary structure consists of 9 paired regions (P1-P9). These fold to essentially two domains, the P4-P6 domain (formed from the stacking of P5, P4, P6 and P6a helices) and the P3-P9 domain (formed from the P8, P3, P7 and P9 helices). Group I catalytic introns often have long ORFs inserted in loop regions. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00028]"
          },
          "SO:0000588": {
            "name": "autocatalytically_spliced_intron",
            "def": "A self spliced intron. [SO:ke]"
          },
          "SO:0000589": {
            "name": "SRP_RNA_primary_transcript",
            "def": "A primary transcript encoding a signal recognition particle RNA. [SO:ke]"
          },
          "SO:0000590": {
            "name": "SRP_RNA",
            "def": "The signal recognition particle (SRP) is a universally conserved ribonucleoprotein. It is involved in the co-translational targeting of proteins to membranes. The eukaryotic SRP consists of a 300-nucleotide 7S RNA and six proteins: SRPs 72, 68, 54, 19, 14, and 9. Archaeal SRP consists of a 7S RNA and homologues of the eukaryotic SRP19 and SRP54 proteins. In most eubacteria, the SRP consists of a 4.5S RNA and the Ffh protein (a homologue of the eukaryotic SRP54 protein). Eukaryotic and archaeal 7S RNAs have very similar secondary structures, with eight helical elements. These fold into the Alu and S domains, separated by a long linker region. Eubacterial SRP is generally a simpler structure, with the M domain of Ffh bound to a region of the 4.5S RNA that corresponds to helix 8 of the eukaryotic and archaeal SRP S domain. Some Gram-positive bacteria (e.g. Bacillus subtilis), however, have a larger SRP RNA that also has an Alu domain. The Alu domain is thought to mediate the peptide chain elongation retardation function of the SRP. The universally conserved helix which interacts with the SRP54/Ffh M domain mediates signal sequence recognition. In eukaryotes and archaea, the SRP19-helix 6 complex is thought to be involved in SRP assembly and stabilizes helix 8 for SRP54 binding. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00017]"
          },
          "SO:0000591": {
            "name": "pseudoknot",
            "def": "A tertiary structure in RNA where nucleotides in a loop form base pairs with a region of RNA downstream of the loop. [RSC:cb]"
          },
          "SO:0000592": {
            "name": "H_pseudoknot",
            "def": "A pseudoknot which contains two stems and at least two loops. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=10334330&dopt=Abstract]"
          },
          "SO:0000593": {
            "name": "C_D_box_snoRNA",
            "def": "Most box C/D snoRNAs also contain long (>10 nt) sequences complementary to rRNA. Boxes C and D, as well as boxes C' and D', are usually located in close proximity, and form a structure known as the box C/D motif. This motif is important for snoRNA stability, processing, nucleolar targeting and function. A small number of box C/D snoRNAs are involved in rRNA processing; most, however, are known or predicted to serve as guide RNAs in ribose methylation of rRNA. Targeting involves direct base pairing of the snoRNA at the rRNA site to be modified and selection of a rRNA nucleotide a fixed distance from box D or D'. [http://www.bio.umass.edu/biochem/rna-sequence/Yeast_snoRNA_Database/snoRNA_DataBase.html]"
          },
          "SO:0000594": {
            "name": "H_ACA_box_snoRNA",
            "def": "Members of the box H/ACA family contain an ACA triplet, exactly 3 nt upstream from the 3' end and an H-box in a hinge region that links two structurally similar functional domains of the molecule. Both boxes are important for snoRNA biosynthesis and function. A few box H/ACA snoRNAs are involved in rRNA processing; most others are known or predicted to participate in selection of uridine nucleosides in rRNA to be converted to pseudouridines. Site selection is mediated by direct base pairing of the snoRNA with rRNA through one or both targeting domains. [http://www.bio.umass.edu/biochem/rna-sequence/Yeast_snoRNA_Database/snoRNA_DataBase.html]"
          },
          "SO:0000595": {
            "name": "C_D_box_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar RNA of the box C/D family. [SO:ke]"
          },
          "SO:0000596": {
            "name": "H_ACA_box_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar RNA of the box H/ACA family. [SO:ke]"
          },
          "SO:0000597": {
            "name": "transcript_edited_by_U_insertion/deletion",
            "def": "The insertion and deletion of uridine (U) residues, usually within coding regions of mRNA transcripts of cryptogenes in the mitochondrial genome of kinetoplastid protozoa. [http://www.rna.ucla.edu/index.html]"
          },
          "SO:0000598": {
            "name": "edited_by_C_insertion_and_dinucleotide_insertion"
          },
          "SO:0000599": {
            "name": "edited_by_C_to_U_substitution"
          },
          "SO:0000600": {
            "name": "edited_by_A_to_I_substitution"
          },
          "SO:0000601": {
            "name": "edited_by_G_addition"
          },
          "SO:0000602": {
            "name": "guide_RNA",
            "def": "A short 3'-uridylated RNA that can form a duplex (except for its post-transcriptionally added oligo_U tail (SO:0000609)) with a stretch of mature edited mRNA. [http://www.rna.ucla.edu/index.html]"
          },
          "SO:0000603": {
            "name": "group_II_intron",
            "def": "Group II introns are found in rRNA, tRNA and mRNA of organelles in fungi, plants and protists, and also in mRNA in bacteria. They are large self-splicing ribozymes and have 6 structural domains (usually designated dI to dVI). A subset of group II introns also encode essential splicing proteins in intronic ORFs. The length of these introns can therefore be up to 3kb. Splicing occurs in almost identical fashion to nuclear pre-mRNA splicing with two transesterification steps. The 2' hydroxyl of a bulged adenosine in domain VI attacks the 5' splice site, followed by nucleophilic attack on the 3' splice site by the 3' OH of the upstream exon. Protein machinery is required for splicing in vivo, and long range intron to intron and intron-exon interactions are important for splice site positioning. Group II introns are further sub-classified into groups IIA and IIB which differ in splice site consensus, distance of bulged A from 3' splice site, some tertiary interactions, and intronic ORF phylogeny. [http://www.sanger.ac.uk/Software/Rfam/browse/index.shtml]"
          },
          "SO:0000604": {
            "name": "editing_block",
            "def": "Edited mRNA sequence mediated by a single guide RNA (SO:0000602). [http://dna.kdna.ucla.edu/rna/index.aspx]"
          },
          "SO:0000605": {
            "name": "intergenic_region",
            "def": "A region containing or overlapping no genes that is bounded on either side by a gene, or bounded by a gene and the end of the chromosome. [SO:cjm]"
          },
          "SO:0000606": {
            "name": "editing_domain",
            "def": "Edited mRNA sequence mediated by two or more overlapping guide RNAs (SO:0000602). [http://dna.kdna.ucla.edu/rna/index.aspx]"
          },
          "SO:0000607": {
            "name": "unedited_region",
            "def": "The region of an edited transcript that will not be edited. [http://dna.kdna.ucla.edu/rna/index.aspx]"
          },
          "SO:0000608": {
            "name": "H_ACA_box_snoRNA_encoding"
          },
          "SO:0000609": {
            "name": "oligo_U_tail",
            "def": "The string of non-encoded U's at the 3' end of a guide RNA (SO:0000602). [http://www.rna.ucla.edu/]"
          },
          "SO:0000610": {
            "name": "polyA_sequence",
            "def": "Sequence of about 100 nucleotides of A added to the 3' end of most eukaryotic mRNAs. [SO:ke]"
          },
          "SO:0000611": {
            "name": "branch_site",
            "def": "A pyrimidine rich sequence near the 3' end of an intron to which the 5'end becomes covalently bound during nuclear splicing. The resulting structure resembles a lariat. [SO:ke]"
          },
          "SO:0000612": {
            "name": "polypyrimidine_tract",
            "def": "The polypyrimidine tract is one of the cis-acting sequence elements directing intron removal in pre-mRNA splicing. [http://nar.oupjournals.org/cgi/content/full/25/4/888]"
          },
          "SO:0000613": {
            "name": "bacterial_RNApol_promoter",
            "def": "A DNA sequence to which bacterial RNA polymerase binds, to begin transcription. [SO:ke]"
          },
          "SO:0000614": {
            "name": "bacterial_terminator",
            "def": "A terminator signal for bacterial transcription. [SO:ke]"
          },
          "SO:0000615": {
            "name": "terminator_of_type_2_RNApol_III_promoter",
            "def": "A terminator signal for RNA polymerase III transcription. [SO:ke]"
          },
          "SO:0000616": {
            "name": "transcription_end_site",
            "def": "The base where transcription ends. [SO:ke]"
          },
          "SO:0000617": {
            "name": "RNApol_III_promoter_type_1"
          },
          "SO:0000618": {
            "name": "RNApol_III_promoter_type_2"
          },
          "SO:0000619": {
            "name": "A_box",
            "def": "A variably distant linear promoter region recognized by TFIIIC, with consensus sequence TGGCnnAGTGG. [SO:ke]"
          },
          "SO:0000620": {
            "name": "B_box",
            "def": "A variably distant linear promoter region recognized by TFIIIC, with consensus sequence AGGTTCCAnnCC. [SO:ke]"
          },
          "SO:0000621": {
            "name": "RNApol_III_promoter_type_3"
          },
          "SO:0000622": {
            "name": "C_box",
            "def": "An RNA polymerase III type 1 promoter with consensus sequence CAnnCCn. [SO:ke]"
          },
          "SO:0000623": {
            "name": "snRNA_encoding"
          },
          "SO:0000624": {
            "name": "telomere",
            "def": "A specific structure at the end of a linear chromosome, required for the integrity and maintenance of the end. [SO:ma]"
          },
          "SO:0000625": {
            "name": "silencer",
            "def": "A regulatory region which upon binding of transcription factors, suppress the transcription of the gene or genes they control. [SO:ke]"
          },
          "SO:0000626": {
            "name": "chromosomal_regulatory_element"
          },
          "SO:0000627": {
            "name": "insulator",
            "def": "A transcriptional cis regulatory region that when located between a CM and a gene's promoter prevents the CRM from modulating that genes expression. [SO:regcreative]"
          },
          "SO:0000628": {
            "name": "chromosomal_structural_element"
          },
          "SO:0000629": {
            "name": "five_prime_open_reading_frame"
          },
          "SO:0000630": {
            "name": "upstream_AUG_codon",
            "def": "A start codon upstream of the ORF. [SO:ke]"
          },
          "SO:0000631": {
            "name": "polycistronic_primary_transcript",
            "def": "A primary transcript encoding for more than one gene product. [SO:ke]"
          },
          "SO:0000632": {
            "name": "monocistronic_primary_transcript",
            "def": "A primary transcript encoding for one gene product. [SO:ke]"
          },
          "SO:0000633": {
            "name": "monocistronic_mRNA",
            "def": "An mRNA with either a single protein product, or for which the regions encoding all its protein products overlap. [SO:rd]"
          },
          "SO:0000634": {
            "name": "polycistronic_mRNA",
            "def": "An mRNA that encodes multiple proteins from at least two non-overlapping regions. [SO:rd]"
          },
          "SO:0000635": {
            "name": "mini_exon_donor_RNA",
            "def": "A primary transcript that donates the spliced leader to other mRNA. [SO:ke]"
          },
          "SO:0000636": {
            "name": "spliced_leader_RNA"
          },
          "SO:0000637": {
            "name": "engineered_plasmid",
            "def": "A plasmid that is engineered. [SO:xp]"
          },
          "SO:0000638": {
            "name": "transcribed_spacer_region",
            "def": "Part of an rRNA transcription unit that is transcribed but discarded during maturation, not giving rise to any part of rRNA. [http://oregonstate.edu/instruction/bb492/general/glossary.html]"
          },
          "SO:0000639": {
            "name": "internal_transcribed_spacer_region",
            "def": "Non-coding regions of DNA sequence that separate genes coding for the 28S, 5.8S, and 18S ribosomal RNAs. [SO:ke]"
          },
          "SO:0000640": {
            "name": "external_transcribed_spacer_region",
            "def": "Non-coding regions of DNA that precede the sequence that codes for the ribosomal RNA. [SO:ke]"
          },
          "SO:0000641": {
            "name": "tetranucleotide_repeat_microsatellite_feature"
          },
          "SO:0000642": {
            "name": "SRP_RNA_encoding"
          },
          "SO:0000643": {
            "name": "minisatellite",
            "def": "A repeat region containing tandemly repeated sequences having a unit length of 10 to 40 bp. [http://www.informatics.jax.org/silver/glossary.shtml]"
          },
          "SO:0000644": {
            "name": "antisense_RNA",
            "def": "Antisense RNA is RNA that is transcribed from the coding, rather than the template, strand of DNA. It is therefore complementary to mRNA. [SO:ke]"
          },
          "SO:0000645": {
            "name": "antisense_primary_transcript",
            "def": "The reverse complement of the primary transcript. [SO:ke]"
          },
          "SO:0000646": {
            "name": "siRNA",
            "def": "A small RNA molecule that is the product of a longer exogenous or endogenous dsRNA, which is either a bimolecular duplex or very long hairpin, processed (via the Dicer pathway) such that numerous siRNAs accumulate from both strands of the dsRNA. SRNAs trigger the cleavage of their target molecules. [PMID:12592000]"
          },
          "SO:0000647": {
            "name": "miRNA_primary_transcript",
            "def": "A primary transcript encoding a micro RNA. [SO:ke]"
          },
          "SO:0000650": {
            "name": "small_subunit_rRNA",
            "def": "Ribosomal RNA transcript that structures the small subunit of the ribosome. [SO:ke]"
          },
          "SO:0000651": {
            "name": "large_subunit_rRNA",
            "def": "Ribosomal RNA transcript that structures the large subunit of the ribosome. [SO:ke]"
          },
          "SO:0000652": {
            "name": "rRNA_5S",
            "def": "5S ribosomal RNA (5S rRNA) is a component of the large ribosomal subunit in both prokaryotes and eukaryotes. In eukaryotes, it is synthesised by RNA polymerase III (the other eukaryotic rRNAs are cleaved from a 45S precursor synthesised by RNA polymerase I). In Xenopus oocytes, it has been shown that fingers 4-7 of the nine-zinc finger transcription factor TFIIIA can bind to the central region of 5S RNA. Thus, in addition to positively regulating 5S rRNA transcription, TFIIIA also stabilizes 5S rRNA until it is required for transcription. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00001]"
          },
          "SO:0000653": {
            "name": "rRNA_28S",
            "def": "A component of the large ribosomal subunit. [SO:ke]"
          },
          "SO:0000654": {
            "name": "maxicircle_gene",
            "def": "A mitochondrial gene located in a maxicircle. [SO:xp]"
          },
          "SO:0000655": {
            "name": "ncRNA",
            "def": "An RNA transcript that does not encode for a protein rather the RNA molecule is the gene product. [SO:ke]"
          },
          "SO:0000656": {
            "name": "stRNA_encoding"
          },
          "SO:0000657": {
            "name": "repeat_region",
            "def": "A region of sequence containing one or more repeat units. [SO:ke]"
          },
          "SO:0000658": {
            "name": "dispersed_repeat",
            "def": "A repeat that is located at dispersed sites in the genome. [SO:ke]"
          },
          "SO:0000659": {
            "name": "tmRNA_encoding"
          },
          "SO:0000660": {
            "name": "DNA_invertase_target_sequence"
          },
          "SO:0000661": {
            "name": "intron_attribute"
          },
          "SO:0000662": {
            "name": "spliceosomal_intron",
            "def": "An intron which is spliced by the spliceosome. [SO:ke]"
          },
          "SO:0000663": {
            "name": "tRNA_encoding"
          },
          "SO:0000664": {
            "name": "introgressed_chromosome_region"
          },
          "SO:0000665": {
            "name": "monocistronic_transcript",
            "def": "A transcript that is monocistronic. [SO:xp]"
          },
          "SO:0000666": {
            "name": "mobile_intron",
            "def": "An intron (mitochondrial, chloroplast, nuclear or prokaryotic) that encodes a double strand sequence specific endonuclease allowing for mobility. [SO:ke]"
          },
          "SO:0000667": {
            "name": "insertion",
            "def": "The sequence of one or more nucleotides added between two adjacent nucleotides in the sequence. [SO:ke]"
          },
          "SO:0000668": {
            "name": "EST_match",
            "def": "A match against an EST sequence. [SO:ke]"
          },
          "SO:0000669": {
            "name": "sequence_rearrangement_feature"
          },
          "SO:0000670": {
            "name": "chromosome_breakage_sequence",
            "def": "A sequence within the micronuclear DNA of ciliates at which chromosome breakage and telomere addition occurs during nuclear differentiation. [SO:ma]"
          },
          "SO:0000671": {
            "name": "internal_eliminated_sequence",
            "def": "A sequence eliminated from the genome of ciliates during nuclear differentiation. [SO:ma]"
          },
          "SO:0000672": {
            "name": "macronucleus_destined_segment",
            "def": "A sequence that is conserved, although rearranged relative to the micronucleus, in the macronucleus of a ciliate genome. [SO:ma]"
          },
          "SO:0000673": {
            "name": "transcript",
            "def": "An RNA synthesized on a DNA or RNA template by an RNA polymerase. [SO:ma]"
          },
          "SO:0000674": {
            "name": "non_canonical_splice_site",
            "def": "A splice site where the donor and acceptor sites differ from the canonical form. [SO:ke]"
          },
          "SO:0000675": {
            "name": "canonical_splice_site",
            "def": "The major class of splice site with dinucleotides GT and AG for donor and acceptor sites, respectively. [SO:ke]"
          },
          "SO:0000676": {
            "name": "canonical_three_prime_splice_site",
            "def": "The canonical 3' splice site has the sequence \\AG\\. [SO:ke]"
          },
          "SO:0000677": {
            "name": "canonical_five_prime_splice_site",
            "def": "The canonical 5' splice site has the sequence \\GT\\. [SO:ke]"
          },
          "SO:0000678": {
            "name": "non_canonical_three_prime_splice_site",
            "def": "A 3' splice site that does not have the sequence \\AG\\. [SO:ke]"
          },
          "SO:0000679": {
            "name": "non_canonical_five_prime_splice_site",
            "def": "A 5' splice site which does not have the sequence \\GT\\. [SO:ke]"
          },
          "SO:0000680": {
            "name": "non_canonical_start_codon",
            "def": "A start codon that is not the usual AUG sequence. [SO:ke]"
          },
          "SO:0000681": {
            "name": "aberrant_processed_transcript",
            "def": "A transcript that has been processed \\incorrectly\\, for example by the failure of splicing of one or more exons. [SO:ke]"
          },
          "SO:0000682": {
            "name": "splicing_feature"
          },
          "SO:0000683": {
            "name": "exonic_splice_enhancer",
            "def": "Exonic splicing enhancers (ESEs) facilitate exon definition by assisting in the recruitment of splicing factors to the adjacent intron. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=12403462&dopt=Abstract]"
          },
          "SO:0000684": {
            "name": "nuclease_sensitive_site",
            "def": "A region of nucleotide sequence targeted by a nuclease enzyme. [SO:ma]"
          },
          "SO:0000685": {
            "name": "DNAseI_hypersensitive_site"
          },
          "SO:0000686": {
            "name": "translocation_element",
            "def": "A chromosomal translocation whereby the chromosomes carrying non-homologous centromeres may be recovered independently. These chromosomes are described as translocation elements. This occurs for some translocations, particularly but not exclusively, reciprocal translocations. [SO:ma]"
          },
          "SO:0000687": {
            "name": "deletion_junction",
            "def": "The space between two bases in a sequence which marks the position where a deletion has occurred. [SO:ke]"
          },
          "SO:0000688": {
            "name": "golden_path",
            "def": "A set of subregions selected from sequence contigs which when concatenated form a nonredundant linear sequence. [SO:ls]"
          },
          "SO:0000689": {
            "name": "cDNA_match",
            "def": "A match against cDNA sequence. [SO:ke]"
          },
          "SO:0000690": {
            "name": "gene_with_polycistronic_transcript",
            "def": "A gene that encodes a polycistronic transcript. [SO:xp]"
          },
          "SO:0000691": {
            "name": "cleaved_initiator_methionine",
            "def": "The initiator methionine that has been cleaved from a mature polypeptide sequence. [EBIBS:GAR]"
          },
          "SO:0000692": {
            "name": "gene_with_dicistronic_transcript",
            "def": "A gene that encodes a dicistronic transcript. [SO:xp]"
          },
          "SO:0000693": {
            "name": "gene_with_recoded_mRNA",
            "def": "A gene that encodes an mRNA that is recoded. [SO:xp]"
          },
          "SO:0000694": {
            "name": "SNP",
            "def": "SNPs are single base pair positions in genomic DNA at which different sequence alternatives exist in normal individuals in some population(s), wherein the least frequent variant has an abundance of 1% or greater. [SO:cb]"
          },
          "SO:0000695": {
            "name": "reagent",
            "def": "A sequence used in experiment. [SO:ke]"
          },
          "SO:0000696": {
            "name": "oligo",
            "def": "A short oligonucleotide sequence, of length on the order of 10's of bases; either single or double stranded. [SO:ma]"
          },
          "SO:0000697": {
            "name": "gene_with_stop_codon_read_through",
            "def": "A gene that encodes a transcript with stop codon readthrough. [SO:xp]"
          },
          "SO:0000698": {
            "name": "gene_with_stop_codon_redefined_as_pyrrolysine",
            "def": "A gene encoding an mRNA that has the stop codon redefined as pyrrolysine. [SO:xp]"
          },
          "SO:0000699": {
            "name": "junction",
            "def": "A sequence_feature with an extent of zero. [SO:ke]"
          },
          "SO:0000700": {
            "name": "remark",
            "def": "A comment about the sequence. [SO:ke]"
          },
          "SO:0000701": {
            "name": "possible_base_call_error",
            "def": "A region of sequence where the validity of the base calling is questionable. [SO:ke]"
          },
          "SO:0000702": {
            "name": "possible_assembly_error",
            "def": "A region of sequence where there may have been an error in the assembly. [SO:ke]"
          },
          "SO:0000703": {
            "name": "experimental_result_region",
            "def": "A region of sequence implicated in an experimental result. [SO:ke]"
          },
          "SO:0000704": {
            "name": "gene",
            "def": "A region (or regions) that includes all of the sequence elements necessary to encode a functional transcript. A gene may include regulatory regions, transcribed regions and/or other functional sequence regions. [SO:immuno_workshop]"
          },
          "SO:0000705": {
            "name": "tandem_repeat",
            "def": "Two or more adjacent copies of a region (of length greater than 1). [SO:ke]"
          },
          "SO:0000706": {
            "name": "trans_splice_acceptor_site",
            "def": "The 3' splice site of the acceptor primary transcript. [SO:ke]"
          },
          "SO:0000707": {
            "name": "trans_splice_donor_site",
            "def": "The 5' five prime splice site region of the donor RNA. [SO:ke]"
          },
          "SO:0000708": {
            "name": "SL1_acceptor_site",
            "def": "A trans_splicing_acceptor_site which appends the 22nt SL1 RNA leader sequence to the 5' end of most mRNAs. [SO:nlw]"
          },
          "SO:0000709": {
            "name": "SL2_acceptor_site",
            "def": "A trans_splicing_acceptor_site which appends the 22nt SL2 RNA leader sequence to the 5' end of mRNAs. SL2 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0000710": {
            "name": "gene_with_stop_codon_redefined_as_selenocysteine",
            "def": "A gene encoding an mRNA that has the stop codon redefined as selenocysteine. [SO:xp]"
          },
          "SO:0000711": {
            "name": "gene_with_mRNA_recoded_by_translational_bypass",
            "def": "A gene with mRNA recoded by translational bypass. [SO:xp]"
          },
          "SO:0000712": {
            "name": "gene_with_transcript_with_translational_frameshift",
            "def": "A gene encoding a transcript that has a translational frameshift. [SO:xp]"
          },
          "SO:0000713": {
            "name": "DNA_motif",
            "def": "A motif that is active in the DNA form of the sequence. [SO:ke]"
          },
          "SO:0000714": {
            "name": "nucleotide_motif",
            "def": "A region of nucleotide sequence corresponding to a known motif. [SO:ke]"
          },
          "SO:0000715": {
            "name": "RNA_motif",
            "def": "A motif that is active in RNA sequence. [SO:ke]"
          },
          "SO:0000716": {
            "name": "dicistronic_mRNA",
            "def": "An mRNA that has the quality dicistronic. [SO:ke]"
          },
          "SO:0000717": {
            "name": "reading_frame",
            "def": "A nucleic acid sequence that when read as sequential triplets, has the potential of encoding a sequential string of amino acids. It need not contain the start or stop codon. [SGD:rb]"
          },
          "SO:0000718": {
            "name": "blocked_reading_frame",
            "def": "A reading_frame that is interrupted by one or more stop codons; usually identified through inter-genomic sequence comparisons. [SGD:rb]"
          },
          "SO:0000719": {
            "name": "ultracontig",
            "def": "An ordered and oriented set of scaffolds based on somewhat weaker sets of inferential evidence such as one set of mate pair reads together with supporting evidence from ESTs or location of markers from SNP or microsatellite maps, or cytogenetic localization of contained markers. [FB:WG]"
          },
          "SO:0000720": {
            "name": "foreign_transposable_element",
            "def": "A transposable element that is foreign. [SO:ke]"
          },
          "SO:0000721": {
            "name": "gene_with_dicistronic_primary_transcript",
            "def": "A gene that encodes a dicistronic primary transcript. [SO:xp]"
          },
          "SO:0000722": {
            "name": "gene_with_dicistronic_mRNA",
            "def": "A gene that encodes a polycistronic mRNA. [SO:xp]"
          },
          "SO:0000723": {
            "name": "iDNA",
            "def": "Genomic sequence removed from the genome, as a normal event, by a process of recombination. [SO:ma]"
          },
          "SO:0000724": {
            "name": "oriT",
            "def": "A region of a DNA molecule where transfer is initiated during the process of conjugation or mobilization. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000725": {
            "name": "transit_peptide",
            "def": "The transit_peptide is a short region at the N-terminus of the peptide that directs the protein to an organelle (chloroplast, mitochondrion, microbody or cyanelle). [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000726": {
            "name": "repeat_unit",
            "def": "The simplest repeated component of a repeat region. A single repeat. [SO:ke]"
          },
          "SO:0000727": {
            "name": "CRM",
            "def": "A regulatory region where transcription factor binding sites clustered to regulate various aspects of transcription activities. (CRMs can be located a few kb to hundred kb upstream of the basal promoter, in the coding sequence, within introns, or in the downstream 3'UTR sequences, as well as on different chromosome). A single gene can be regulated by multiple CRMs to give precise control of its spatial and temporal expression. CRMs function as nodes in large, intertwined regulatory network. [PMID:19660565, SO:SG]"
          },
          "SO:0000728": {
            "name": "intein",
            "def": "A region of a peptide that is able to excise itself and rejoin the remaining portions with a peptide bond. [SO:ke]"
          },
          "SO:0000729": {
            "name": "intein_containing",
            "def": "An attribute of protein-coding genes where the initial protein product contains an intein. [SO:ke]"
          },
          "SO:0000730": {
            "name": "gap",
            "def": "A gap in the sequence of known length. The unknown bases are filled in with N's. [SO:ke]"
          },
          "SO:0000731": {
            "name": "fragmentary",
            "def": "An attribute to describe a feature that is incomplete. [SO:ke]"
          },
          "SO:0000732": {
            "name": "predicted",
            "def": "An attribute describing an unverified region. [SO:ke]"
          },
          "SO:0000733": {
            "name": "feature_attribute",
            "def": "An attribute describing a located_sequence_feature. [SO:ke]"
          },
          "SO:0000734": {
            "name": "exemplar_mRNA",
            "def": "An exemplar is a representative cDNA sequence for each gene. The exemplar approach is a method that usually involves some initial clustering into gene groups and the subsequent selection of a representative from each gene group. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
          },
          "SO:0000735": {
            "name": "sequence_location"
          },
          "SO:0000736": {
            "name": "organelle_sequence"
          },
          "SO:0000737": {
            "name": "mitochondrial_sequence"
          },
          "SO:0000738": {
            "name": "nuclear_sequence"
          },
          "SO:0000739": {
            "name": "nucleomorphic_sequence"
          },
          "SO:0000740": {
            "name": "plastid_sequence"
          },
          "SO:0000741": {
            "name": "kinetoplast",
            "def": "A kinetoplast is an interlocked network of thousands of minicircles and tens of maxicircles, located near the base of the flagellum of some protozoan species. [PMID:8395055]"
          },
          "SO:0000742": {
            "name": "maxicircle",
            "def": "A maxicircle is a replicon, part of a kinetoplast, that contains open reading frames and replicates via a rolling circle method. [PMID:8395055]"
          },
          "SO:0000743": {
            "name": "apicoplast_sequence"
          },
          "SO:0000744": {
            "name": "chromoplast_sequence"
          },
          "SO:0000745": {
            "name": "chloroplast_sequence"
          },
          "SO:0000746": {
            "name": "cyanelle_sequence"
          },
          "SO:0000747": {
            "name": "leucoplast_sequence"
          },
          "SO:0000748": {
            "name": "proplastid_sequence"
          },
          "SO:0000749": {
            "name": "plasmid_location"
          },
          "SO:0000750": {
            "name": "amplification_origin",
            "def": "An origin_of_replication that is used for the amplification of a chromosomal nucleic acid sequence. [SO:ma]"
          },
          "SO:0000751": {
            "name": "proviral_location"
          },
          "SO:0000752": {
            "name": "gene_group_regulatory_region"
          },
          "SO:0000753": {
            "name": "clone_insert",
            "def": "The region of sequence that has been inserted and is being propagated by the clone. [SO:ke]"
          },
          "SO:0000754": {
            "name": "lambda_vector",
            "def": "The lambda bacteriophage is the vector for the linear lambda clone. The genes involved in the lysogenic pathway are removed from the from the viral DNA. Up to 25 kb of foreign DNA can then be inserted into the lambda genome. [ISBN:0-1767-2380-8]"
          },
          "SO:0000755": {
            "name": "plasmid_vector"
          },
          "SO:0000756": {
            "name": "cDNA",
            "def": "DNA synthesized by reverse transcriptase using RNA as a template. [SO:ma]"
          },
          "SO:0000757": {
            "name": "single_stranded_cDNA"
          },
          "SO:0000758": {
            "name": "double_stranded_cDNA"
          },
          "SO:0000759": {
            "name": "plasmid_clone"
          },
          "SO:0000760": {
            "name": "YAC_clone"
          },
          "SO:0000761": {
            "name": "phagemid_clone"
          },
          "SO:0000762": {
            "name": "PAC_clone"
          },
          "SO:0000763": {
            "name": "fosmid_clone"
          },
          "SO:0000764": {
            "name": "BAC_clone"
          },
          "SO:0000765": {
            "name": "cosmid_clone"
          },
          "SO:0000766": {
            "name": "pyrrolysyl_tRNA",
            "def": "A tRNA sequence that has a pyrrolysine anticodon, and a 3' pyrrolysine binding region. [SO:ke]"
          },
          "SO:0000767": {
            "name": "clone_insert_start"
          },
          "SO:0000768": {
            "name": "episome",
            "def": "A plasmid that may integrate with a chromosome. [SO:ma]"
          },
          "SO:0000769": {
            "name": "tmRNA_coding_piece",
            "def": "The region of a two-piece tmRNA that bears the reading frame encoding the proteolysis tag. The tmRNA gene undergoes circular permutation in some groups of bacteria. Processing of the transcripts from such a gene leaves the mature tmRNA in two pieces, base-paired together. [doi:10.1093/nar/gkh795, Indiana:kw, issn:1362-4962]"
          },
          "SO:0000770": {
            "name": "tmRNA_acceptor_piece",
            "def": "The acceptor region of a two-piece tmRNA that when mature is charged at its 3' end with alanine. The tmRNA gene undergoes circular permutation in some groups of bacteria; processing of the transcripts from such a gene leaves the mature tmRNA in two pieces, base-paired together. [doi:10.1093/nar/gkh795, Indiana:kw]"
          },
          "SO:0000771": {
            "name": "QTL",
            "def": "A quantitative trait locus (QTL) is a polymorphic locus which contains alleles that differentially affect the expression of a continuously distributed phenotypic trait. Usually it is a marker described by statistical association to quantitative variation in the particular phenotypic trait that is thought to be controlled by the cumulative action of alleles at multiple loci. [http://rgd.mcw.edu/tu/qtls/]"
          },
          "SO:0000772": {
            "name": "genomic_island",
            "def": "A genomic island is an integrated mobile genetic element, characterized by size (over 10 Kb). It that has features that suggest a foreign origin. These can include nucleotide distribution (oligonucleotides signature, CG content etc.) that differs from the bulk of the chromosome and/or genes suggesting DNA mobility. [Phigo:at, SO:ke]"
          },
          "SO:0000773": {
            "name": "pathogenic_island",
            "def": "Mobile genetic elements that contribute to rapid changes in virulence potential. They are present on the genomes of pathogenic strains but absent from the genomes of non pathogenic members of the same or related species. [SO:ke]"
          },
          "SO:0000774": {
            "name": "metabolic_island",
            "def": "A transmissible element containing genes involved in metabolism, analogous to the pathogenicity islands of gram negative bacteria. [SO:ke]"
          },
          "SO:0000775": {
            "name": "adaptive_island",
            "def": "An adaptive island is a genomic island that provides an adaptive advantage to the host. [SO:ke]"
          },
          "SO:0000776": {
            "name": "symbiosis_island",
            "def": "A transmissible element containing genes involved in symbiosis, analogous to the pathogenicity islands of gram negative bacteria. [SO:ke]"
          },
          "SO:0000777": {
            "name": "pseudogenic_rRNA",
            "def": "A non functional descendant of an rRNA. [SO:ke]"
          },
          "SO:0000778": {
            "name": "pseudogenic_tRNA",
            "def": "A non functional descendent of a tRNA. [SO:ke]"
          },
          "SO:0000779": {
            "name": "engineered_episome",
            "def": "An episome that is engineered. [SO:xp]"
          },
          "SO:0000780": {
            "name": "transposable_element_attribute"
          },
          "SO:0000781": {
            "name": "transgenic",
            "def": "Attribute describing sequence that has been integrated with foreign sequence. [SO:ke]"
          },
          "SO:0000782": {
            "name": "natural",
            "def": "An attribute describing a feature that occurs in nature. [SO:ke]"
          },
          "SO:0000783": {
            "name": "engineered",
            "def": "An attribute to describe a region that was modified in vitro. [SO:ke]"
          },
          "SO:0000784": {
            "name": "foreign",
            "def": "An attribute to describe a region from another species. [SO:ke]"
          },
          "SO:0000785": {
            "name": "cloned_region"
          },
          "SO:0000786": {
            "name": "reagent_attribute"
          },
          "SO:0000787": {
            "name": "clone_attribute"
          },
          "SO:0000788": {
            "name": "cloned"
          },
          "SO:0000789": {
            "name": "validated",
            "def": "An attribute to describe a feature that has been proven. [SO:ke]"
          },
          "SO:0000790": {
            "name": "invalidated",
            "def": "An attribute describing a feature that is invalidated. [SO:ke]"
          },
          "SO:0000791": {
            "name": "cloned_genomic"
          },
          "SO:0000792": {
            "name": "cloned_cDNA"
          },
          "SO:0000793": {
            "name": "engineered_DNA"
          },
          "SO:0000794": {
            "name": "engineered_rescue_region",
            "def": "A rescue region that is engineered. [SO:xp]"
          },
          "SO:0000795": {
            "name": "rescue_mini_gene",
            "def": "A mini_gene that rescues. [SO:xp]"
          },
          "SO:0000796": {
            "name": "transgenic_transposable_element",
            "def": "TE that has been modified in vitro, including insertion of DNA derived from a source other than the originating TE. [FB:mc]"
          },
          "SO:0000797": {
            "name": "natural_transposable_element",
            "def": "TE that exists (or existed) in nature. [FB:mc]"
          },
          "SO:0000798": {
            "name": "engineered_transposable_element",
            "def": "TE that has been modified by manipulations in vitro. [FB:mc]"
          },
          "SO:0000799": {
            "name": "engineered_foreign_transposable_element",
            "def": "A transposable_element that is engineered and foreign. [FB:mc]"
          },
          "SO:0000800": {
            "name": "assortment_derived_duplication",
            "def": "A multi-chromosome duplication aberration generated by reassortment of other aberration components. [FB:gm]"
          },
          "SO:0000801": {
            "name": "assortment_derived_deficiency_plus_duplication",
            "def": "A multi-chromosome aberration generated by reassortment of other aberration components; presumed to have a deficiency and a duplication. [FB:gm]"
          },
          "SO:0000802": {
            "name": "assortment_derived_deficiency",
            "def": "A multi-chromosome deficiency aberration generated by reassortment of other aberration components. [FB:gm]"
          },
          "SO:0000803": {
            "name": "assortment_derived_aneuploid",
            "def": "A multi-chromosome aberration generated by reassortment of other aberration components; presumed to have a deficiency or a duplication. [FB:gm]"
          },
          "SO:0000804": {
            "name": "engineered_region",
            "def": "A region that is engineered. [SO:xp]"
          },
          "SO:0000805": {
            "name": "engineered_foreign_region",
            "def": "A region that is engineered and foreign. [SO:xp]"
          },
          "SO:0000806": {
            "name": "fusion"
          },
          "SO:0000807": {
            "name": "engineered_tag",
            "def": "A tag that is engineered. [SO:xp]"
          },
          "SO:0000808": {
            "name": "validated_cDNA_clone",
            "def": "A cDNA clone that has been validated. [SO:xp]"
          },
          "SO:0000809": {
            "name": "invalidated_cDNA_clone",
            "def": "A cDNA clone that is invalid. [SO:xp]"
          },
          "SO:0000810": {
            "name": "chimeric_cDNA_clone",
            "def": "A cDNA clone invalidated because it is chimeric. [SO:xp]"
          },
          "SO:0000811": {
            "name": "genomically_contaminated_cDNA_clone",
            "def": "A cDNA clone invalidated by genomic contamination. [SO:xp]"
          },
          "SO:0000812": {
            "name": "polyA_primed_cDNA_clone",
            "def": "A cDNA clone invalidated by polyA priming. [SO:xp]"
          },
          "SO:0000813": {
            "name": "partially_processed_cDNA_clone",
            "def": "A cDNA invalidated clone by partial processing. [SO:xp]"
          },
          "SO:0000814": {
            "name": "rescue",
            "def": "An attribute describing a region's ability, when introduced to a mutant organism, to re-establish (rescue) a phenotype. [SO:ke]"
          },
          "SO:0000815": {
            "name": "mini_gene",
            "def": "By definition, minigenes are short open-reading frames (ORF), usually encoding approximately 9 to 20 amino acids, which are expressed in vivo (as distinct from being synthesized as peptide or protein ex vivo and subsequently injected). The in vivo synthesis confers a distinct advantage: the expressed sequences can enter both antigen presentation pathways, MHC I (inducing CD8+ T- cells, which are usually cytotoxic T-lymphocytes (CTL)) and MHC II (inducing CD4+ T-cells, usually 'T-helpers' (Th)); and can encounter B-cells, inducing antibody responses. Three main vector approaches have been used to deliver minigenes: viral vectors, bacterial vectors and plasmid DNA. [PMID:15992143]"
          },
          "SO:0000816": {
            "name": "rescue_gene",
            "def": "A gene that rescues. [SO:xp]"
          },
          "SO:0000817": {
            "name": "wild_type",
            "def": "An attribute describing sequence with the genotype found in nature and/or standard laboratory stock. [SO:ke]"
          },
          "SO:0000818": {
            "name": "wild_type_rescue_gene",
            "def": "A gene that rescues. [SO:xp]"
          },
          "SO:0000819": {
            "name": "mitochondrial_chromosome",
            "def": "A chromosome originating in a mitochondria. [SO:xp]"
          },
          "SO:0000820": {
            "name": "chloroplast_chromosome",
            "def": "A chromosome originating in a chloroplast. [SO:xp]"
          },
          "SO:0000821": {
            "name": "chromoplast_chromosome",
            "def": "A chromosome originating in a chromoplast. [SO:xp]"
          },
          "SO:0000822": {
            "name": "cyanelle_chromosome",
            "def": "A chromosome originating in a cyanelle. [SO:xp]"
          },
          "SO:0000823": {
            "name": "leucoplast_chromosome",
            "def": "A chromosome with origin in a leucoplast. [SO:xp]"
          },
          "SO:0000824": {
            "name": "macronuclear_chromosome",
            "def": "A chromosome originating in a macronucleus. [SO:xp]"
          },
          "SO:0000825": {
            "name": "micronuclear_chromosome",
            "def": "A chromosome originating in a micronucleus. [SO:xp]"
          },
          "SO:0000828": {
            "name": "nuclear_chromosome",
            "def": "A chromosome originating in a nucleus. [SO:xp]"
          },
          "SO:0000829": {
            "name": "nucleomorphic_chromosome",
            "def": "A chromosome originating in a nucleomorph. [SO:xp]"
          },
          "SO:0000830": {
            "name": "chromosome_part",
            "def": "A region of a chromosome. [SO:ke]"
          },
          "SO:0000831": {
            "name": "gene_member_region",
            "def": "A region of a gene. [SO:ke]"
          },
          "SO:0000832": {
            "name": "promoter_region",
            "def": "A region of sequence which is part of a promoter. [SO:ke]"
          },
          "SO:0000833": {
            "name": "transcript_region",
            "def": "A region of a transcript. [SO:ke]"
          },
          "SO:0000834": {
            "name": "mature_transcript_region",
            "def": "A region of a mature transcript. [SO:ke]"
          },
          "SO:0000835": {
            "name": "primary_transcript_region",
            "def": "A part of a primary transcript. [SO:ke]"
          },
          "SO:0000836": {
            "name": "mRNA_region",
            "def": "A region of an mRNA. [SO:cb]"
          },
          "SO:0000837": {
            "name": "UTR_region",
            "def": "A region of UTR. [SO:ke]"
          },
          "SO:0000838": {
            "name": "rRNA_primary_transcript_region",
            "def": "A region of an rRNA primary transcript. [SO:ke]"
          },
          "SO:0000839": {
            "name": "polypeptide_region",
            "def": "Biological sequence region that can be assigned to a specific subsequence of a polypeptide. [SO:GAR, SO:ke]"
          },
          "SO:0000840": {
            "name": "repeat_component",
            "def": "A region of a repeated sequence. [SO:ke]"
          },
          "SO:0000841": {
            "name": "spliceosomal_intron_region",
            "def": "A region within an intron. [SO:ke]"
          },
          "SO:0000842": {
            "name": "gene_component_region"
          },
          "SO:0000843": {
            "name": "bacterial_RNApol_promoter_region",
            "def": "A region which is part of a bacterial RNA polymerase promoter. [SO:ke]"
          },
          "SO:0000844": {
            "name": "RNApol_II_promoter_region",
            "def": "A region of sequence which is a promoter for RNA polymerase II. [SO:ke]"
          },
          "SO:0000845": {
            "name": "RNApol_III_promoter_type_1_region",
            "def": "A region of sequence which is a promoter for RNA polymerase III type 1. [SO:ke]"
          },
          "SO:0000846": {
            "name": "RNApol_III_promoter_type_2_region",
            "def": "A region of sequence which is a promoter for RNA polymerase III type 2. [SO:ke]"
          },
          "SO:0000847": {
            "name": "tmRNA_region",
            "def": "A region of a tmRNA. [SO:cb]"
          },
          "SO:0000848": {
            "name": "LTR_component"
          },
          "SO:0000849": {
            "name": "three_prime_LTR_component"
          },
          "SO:0000850": {
            "name": "five_prime_LTR_component"
          },
          "SO:0000851": {
            "name": "CDS_region",
            "def": "A region of a CDS. [SO:cb]"
          },
          "SO:0000852": {
            "name": "exon_region",
            "def": "A region of an exon. [RSC:cb]"
          },
          "SO:0000853": {
            "name": "homologous_region",
            "def": "A region that is homologous to another region. [SO:ke]"
          },
          "SO:0000854": {
            "name": "paralogous_region",
            "def": "A homologous_region that is paralogous to another region. [SO:ke]"
          },
          "SO:0000855": {
            "name": "orthologous_region",
            "def": "A homologous_region that is orthologous to another region. [SO:ke]"
          },
          "SO:0000856": {
            "name": "conserved"
          },
          "SO:0000857": {
            "name": "homologous",
            "def": "Similarity due to common ancestry. [SO:ke]"
          },
          "SO:0000858": {
            "name": "orthologous",
            "def": "An attribute describing a kind of homology where divergence occurred after a speciation event. [SO:ke]"
          },
          "SO:0000859": {
            "name": "paralogous",
            "def": "An attribute describing a kind of homology where divergence occurred after a duplication event. [SO:ke]"
          },
          "SO:0000860": {
            "name": "syntenic",
            "def": "Attribute describing sequence regions occurring in same order on chromosome of different species. [SO:ke]"
          },
          "SO:0000861": {
            "name": "capped_primary_transcript",
            "def": "A primary transcript that is capped. [SO:xp]"
          },
          "SO:0000862": {
            "name": "capped_mRNA",
            "def": "An mRNA that is capped. [SO:xp]"
          },
          "SO:0000863": {
            "name": "mRNA_attribute",
            "def": "An attribute describing an mRNA feature. [SO:ke]"
          },
          "SO:0000864": {
            "name": "exemplar",
            "def": "An attribute describing a sequence is representative of a class of similar sequences. [SO:ke]"
          },
          "SO:0000865": {
            "name": "frameshift",
            "def": "An attribute describing a sequence that contains a mutation involving the deletion or insertion of one or more bases, where this number is not divisible by 3. [SO:ke]"
          },
          "SO:0000866": {
            "name": "minus_1_frameshift",
            "def": "A frameshift caused by deleting one base. [SO:ke]"
          },
          "SO:0000867": {
            "name": "minus_2_frameshift",
            "def": "A frameshift caused by deleting two bases. [SO:ke]"
          },
          "SO:0000868": {
            "name": "plus_1_frameshift",
            "def": "A frameshift caused by inserting one base. [SO:ke]"
          },
          "SO:0000869": {
            "name": "plus_2_framshift",
            "def": "A frameshift caused by inserting two bases. [SO:ke]"
          },
          "SO:0000870": {
            "name": "trans_spliced",
            "def": "An attribute describing transcript sequence that is created by splicing exons from diferent genes. [SO:ke]"
          },
          "SO:0000871": {
            "name": "polyadenylated_mRNA",
            "def": "An mRNA that is polyadenylated. [SO:xp]"
          },
          "SO:0000872": {
            "name": "trans_spliced_mRNA",
            "def": "An mRNA that is trans-spliced. [SO:xp]"
          },
          "SO:0000873": {
            "name": "edited_transcript",
            "def": "A transcript that is edited. [SO:ke]"
          },
          "SO:0000874": {
            "name": "edited_transcript_by_A_to_I_substitution",
            "def": "A transcript that has been edited by A to I substitution. [SO:ke]"
          },
          "SO:0000875": {
            "name": "bound_by_protein",
            "def": "An attribute describing a sequence that is bound by a protein. [SO:ke]"
          },
          "SO:0000876": {
            "name": "bound_by_nucleic_acid",
            "def": "An attribute describing a sequence that is bound by a nucleic acid. [SO:ke]"
          },
          "SO:0000877": {
            "name": "alternatively_spliced",
            "def": "An attribute describing a situation where a gene may encode for more than 1 transcript. [SO:ke]"
          },
          "SO:0000878": {
            "name": "monocistronic",
            "def": "An attribute describing a sequence that contains the code for one gene product. [SO:ke]"
          },
          "SO:0000879": {
            "name": "dicistronic",
            "def": "An attribute describing a sequence that contains the code for two gene products. [SO:ke]"
          },
          "SO:0000880": {
            "name": "polycistronic",
            "def": "An attribute describing a sequence that contains the code for more than one gene product. [SO:ke]"
          },
          "SO:0000881": {
            "name": "recoded",
            "def": "An attribute describing an mRNA sequence that has been reprogrammed at translation, causing localized alterations. [SO:ke]"
          },
          "SO:0000882": {
            "name": "codon_redefined",
            "def": "An attribute describing the alteration of codon meaning. [SO:ke]"
          },
          "SO:0000883": {
            "name": "stop_codon_read_through",
            "def": "A stop codon redefined to be a new amino acid. [SO:ke]"
          },
          "SO:0000884": {
            "name": "stop_codon_redefined_as_pyrrolysine",
            "def": "A stop codon redefined to be the new amino acid, pyrrolysine. [SO:ke]"
          },
          "SO:0000885": {
            "name": "stop_codon_redefined_as_selenocysteine",
            "def": "A stop codon redefined to be the new amino acid, selenocysteine. [SO:ke]"
          },
          "SO:0000886": {
            "name": "recoded_by_translational_bypass",
            "def": "Recoded mRNA where a block of nucleotides is not translated. [SO:ke]"
          },
          "SO:0000887": {
            "name": "translationally_frameshifted",
            "def": "Recoding by frameshifting a particular site. [SO:ke]"
          },
          "SO:0000888": {
            "name": "maternally_imprinted_gene",
            "def": "A gene that is maternally_imprinted. [SO:xp]"
          },
          "SO:0000889": {
            "name": "paternally_imprinted_gene",
            "def": "A gene that is paternally imprinted. [SO:xp]"
          },
          "SO:0000890": {
            "name": "post_translationally_regulated_gene",
            "def": "A gene that is post translationally regulated. [SO:xp]"
          },
          "SO:0000891": {
            "name": "negatively_autoregulated_gene",
            "def": "A gene that is negatively autoreguated. [SO:xp]"
          },
          "SO:0000892": {
            "name": "positively_autoregulated_gene",
            "def": "A gene that is positively autoregulated. [SO:xp]"
          },
          "SO:0000893": {
            "name": "silenced",
            "def": "An attribute describing an epigenetic process where a gene is inactivated at transcriptional or translational level. [SO:ke]"
          },
          "SO:0000894": {
            "name": "silenced_by_DNA_modification",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by DNA modifications, resulting in repression of transcription. [SO:ke]"
          },
          "SO:0000895": {
            "name": "silenced_by_DNA_methylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by DNA methylation, resulting in repression of transcription. [SO:ke]"
          },
          "SO:0000896": {
            "name": "translationally_regulated_gene",
            "def": "A gene that is translationally regulated. [SO:xp]"
          },
          "SO:0000897": {
            "name": "allelically_excluded_gene",
            "def": "A gene that is allelically_excluded. [SO:xp]"
          },
          "SO:0000898": {
            "name": "epigenetically_modified_gene",
            "def": "A gene that is epigenetically modified. [SO:ke]"
          },
          "SO:0000899": {
            "name": "nuclear_mitochondrial",
            "def": "An attribute describing a nuclear pseudogene of a mitochndrial gene. [SO:ke]"
          },
          "SO:0000900": {
            "name": "processed",
            "def": "An attribute describing a pseudogene where by an mRNA was retrotransposed. The mRNA sequence is transcribed back into the genome, lacking introns and promotors, but often including a polyA tail. [SO:ke]"
          },
          "SO:0000901": {
            "name": "unequally_crossed_over",
            "def": "An attribute describing a pseudogene that was created by tandem duplication and unequal crossing over during recombination. [SO:ke]"
          },
          "SO:0000902": {
            "name": "transgene",
            "def": "A transgene is a gene that has been transferred naturally or by any of a number of genetic engineering techniques from one organism to another. [SO:xp]"
          },
          "SO:0000903": {
            "name": "endogenous_retroviral_sequence"
          },
          "SO:0000904": {
            "name": "rearranged_at_DNA_level",
            "def": "An attribute to describe the sequence of a feature, where the DNA is rearranged. [SO:ke]"
          },
          "SO:0000905": {
            "name": "status",
            "def": "An attribute describing the status of a feature, based on the available evidence. [SO:ke]"
          },
          "SO:0000906": {
            "name": "independently_known",
            "def": "Attribute to describe a feature that is independently known - not predicted. [SO:ke]"
          },
          "SO:0000907": {
            "name": "supported_by_sequence_similarity",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity techniques. [SO:ke]"
          },
          "SO:0000908": {
            "name": "supported_by_domain_match",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity of a known domain. [SO:ke]"
          },
          "SO:0000909": {
            "name": "supported_by_EST_or_cDNA",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity to EST or cDNA data. [SO:ke]"
          },
          "SO:0000910": {
            "name": "orphan"
          },
          "SO:0000911": {
            "name": "predicted_by_ab_initio_computation",
            "def": "An attribute describing a feature that is predicted by a computer program that did not rely on sequence similarity. [SO:ke]"
          },
          "SO:0000912": {
            "name": "asx_turn",
            "def": "A motif of three consecutive residues and one H-bond in which: residue(i) is Aspartate or Asparagine (Asx), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2). [http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0000913": {
            "name": "cloned_cDNA_insert",
            "def": "A clone insert made from cDNA. [SO:xp]"
          },
          "SO:0000914": {
            "name": "cloned_genomic_insert",
            "def": "A clone insert made from genomic DNA. [SO:xp]"
          },
          "SO:0000915": {
            "name": "engineered_insert",
            "def": "A clone insert that is engineered. [SO:xp]"
          },
          "SO:0000916": {
            "name": "edit_operation"
          },
          "SO:0000917": {
            "name": "insert_U",
            "def": "An edit to insert a U. [SO:ke]"
          },
          "SO:0000918": {
            "name": "delete_U",
            "def": "An edit to delete a uridine. [SO:ke]"
          },
          "SO:0000919": {
            "name": "substitute_A_to_I",
            "def": "An edit to substitute an I for an A. [SO:ke]"
          },
          "SO:0000920": {
            "name": "insert_C",
            "def": "An edit to insert a cytidine. [SO:ke]"
          },
          "SO:0000921": {
            "name": "insert_dinucleotide",
            "def": "An edit to insert a dinucleotide. [SO:ke]"
          },
          "SO:0000922": {
            "name": "substitute_C_to_U",
            "def": "An edit to substitute an U for a C. [SO:ke]"
          },
          "SO:0000923": {
            "name": "insert_G",
            "def": "An edit to insert a G. [SO:ke]"
          },
          "SO:0000924": {
            "name": "insert_GC",
            "def": "An edit to insert a GC dinucleotide. [SO:ke]"
          },
          "SO:0000925": {
            "name": "insert_GU",
            "def": "An edit to insert a GU dinucleotide. [SO:ke]"
          },
          "SO:0000926": {
            "name": "insert_CU",
            "def": "An edit to insert a CU dinucleotide. [SO:ke]"
          },
          "SO:0000927": {
            "name": "insert_AU",
            "def": "An edit to insert a AU dinucleotide. [SO:ke]"
          },
          "SO:0000928": {
            "name": "insert_AA",
            "def": "An edit to insert a AA dinucleotide. [SO:ke]"
          },
          "SO:0000929": {
            "name": "edited_mRNA",
            "def": "An mRNA that is edited. [SO:xp]"
          },
          "SO:0000930": {
            "name": "guide_RNA_region",
            "def": "A region of guide RNA. [SO:ma]"
          },
          "SO:0000931": {
            "name": "anchor_region",
            "def": "A region of a guide_RNA that base-pairs to a target mRNA. [SO:jk]"
          },
          "SO:0000932": {
            "name": "pre_edited_mRNA"
          },
          "SO:0000933": {
            "name": "intermediate",
            "def": "An attribute to describe a feature between stages of processing. [SO:ke]"
          },
          "SO:0000934": {
            "name": "miRNA_target_site",
            "def": "A miRNA target site is a binding site where the molecule is a micro RNA. [FB:cds]"
          },
          "SO:0000935": {
            "name": "edited_CDS",
            "def": "A CDS that is edited. [SO:xp]"
          },
          "SO:0000936": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_rearranged_segment"
          },
          "SO:0000937": {
            "name": "vertebrate_immune_system_feature"
          },
          "SO:0000938": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_rearranged_gene_cluster"
          },
          "SO:0000939": {
            "name": "vertebrate_immune_system_gene_recombination_signal_feature"
          },
          "SO:0000940": {
            "name": "recombinationally_rearranged"
          },
          "SO:0000941": {
            "name": "recombinationally_rearranged_vertebrate_immune_system_gene",
            "def": "A recombinationally rearranged gene of the vertebrate immune system. [SO:xp]"
          },
          "SO:0000942": {
            "name": "attP_site",
            "def": "An integration/excision site of a phage chromosome at which a recombinase acts to insert the phage DNA at a cognate integration/excision site on a bacterial chromosome. [SO:as]"
          },
          "SO:0000943": {
            "name": "attB_site",
            "def": "An integration/excision site of a bacterial chromosome at which a recombinase acts to insert foreign DNA containing a cognate integration/excision site. [SO:as]"
          },
          "SO:0000944": {
            "name": "attL_site",
            "def": "A region that results from recombination between attP_site and attB_site, composed of the 5' portion of attB_site and the 3' portion of attP_site. [SO:as]"
          },
          "SO:0000945": {
            "name": "attR_site",
            "def": "A region that results from recombination between attP_site and attB_site, composed of the 5' portion of attP_site and the 3' portion of attB_site. [SO:as]"
          },
          "SO:0000946": {
            "name": "integration_excision_site",
            "def": "A region specifically recognised by a recombinase, which inserts or removes another region marked by a distinct cognate integration/excision site. [SO:as]"
          },
          "SO:0000947": {
            "name": "resolution_site",
            "def": "A region specifically recognized by a recombinase, which separates a physically contiguous circle of DNA into two physically separate circles. [SO:as]"
          },
          "SO:0000948": {
            "name": "inversion_site",
            "def": "A region specifically recognised by a recombinase, which inverts the region flanked by a pair of sites. [SO:ma]"
          },
          "SO:0000949": {
            "name": "dif_site",
            "def": "A site at which replicated bacterial circular chromosomes are decatenated by site specific resolvase. [SO:as]"
          },
          "SO:0000950": {
            "name": "attC_site",
            "def": "An attC site is a sequence required for the integration of a DNA of an integron. [SO:as]"
          },
          "SO:0000951": {
            "name": "eukaryotic_terminator"
          },
          "SO:0000952": {
            "name": "oriV",
            "def": "An origin of vegetative replication in plasmids and phages. [SO:as]"
          },
          "SO:0000953": {
            "name": "oriC",
            "def": "An origin of bacterial chromosome replication. [SO:as]"
          },
          "SO:0000954": {
            "name": "DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, DNA molecule. [SO:ma]"
          },
          "SO:0000955": {
            "name": "double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded DNA molecule. [SO:ma]"
          },
          "SO:0000956": {
            "name": "single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded DNA molecule. [SO:ma]"
          },
          "SO:0000957": {
            "name": "linear_double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, linear DNA molecule. [SO:ma]"
          },
          "SO:0000958": {
            "name": "circular_double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, circular DNA molecule. [SO:ma]"
          },
          "SO:0000959": {
            "name": "linear_single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, linear DNA molecule. [SO:ma]"
          },
          "SO:0000960": {
            "name": "circular_single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, circular DNA molecule. [SO:ma]"
          },
          "SO:0000961": {
            "name": "RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, RNA molecule. [SO:ma]"
          },
          "SO:0000962": {
            "name": "single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded RNA molecule. [SO:ma]"
          },
          "SO:0000963": {
            "name": "linear_single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, linear RNA molecule. [SO:ma]"
          },
          "SO:0000964": {
            "name": "linear_double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, linear RNA molecule. [SO:ma]"
          },
          "SO:0000965": {
            "name": "double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded RNA molecule. [SO:ma]"
          },
          "SO:0000966": {
            "name": "circular_single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, circular DNA molecule. [SO:ma]"
          },
          "SO:0000967": {
            "name": "circular_double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, circular RNA molecule. [SO:ma]"
          },
          "SO:0000968": {
            "name": "sequence_replication_mode"
          },
          "SO:0000969": {
            "name": "rolling_circle"
          },
          "SO:0000970": {
            "name": "theta_replication"
          },
          "SO:0000971": {
            "name": "DNA_replication_mode"
          },
          "SO:0000972": {
            "name": "RNA_replication_mode"
          },
          "SO:0000973": {
            "name": "insertion_sequence",
            "def": "A terminal_inverted_repeat_element that is bacterial and only encodes the functions required for its transposition between these inverted repeats. [SO:as]"
          },
          "SO:0000975": {
            "name": "minicircle_gene"
          },
          "SO:0000976": {
            "name": "cryptic",
            "def": "A feature_attribute describing a feature that is not manifest under normal conditions. [SO:ke]"
          },
          "SO:0000977": {
            "name": "anchor_binding_site"
          },
          "SO:0000978": {
            "name": "template_region",
            "def": "A region of a guide_RNA that specifies the insertions and deletions of bases in the editing of a target mRNA. [SO:jk]"
          },
          "SO:0000979": {
            "name": "gRNA_encoding",
            "def": "A non-protein_coding gene that encodes a guide_RNA. [SO:ma]"
          },
          "SO:0000980": {
            "name": "minicircle",
            "def": "A minicircle is a replicon, part of a kinetoplast, that encodes for guide RNAs. [PMID:8395055]"
          },
          "SO:0000981": {
            "name": "rho_dependent_bacterial_terminator"
          },
          "SO:0000982": {
            "name": "rho_independent_bacterial_terminator"
          },
          "SO:0000983": {
            "name": "strand_attribute"
          },
          "SO:0000984": {
            "name": "single"
          },
          "SO:0000985": {
            "name": "double"
          },
          "SO:0000986": {
            "name": "topology_attribute"
          },
          "SO:0000987": {
            "name": "linear",
            "def": "A quality of a nucleotide polymer that has a 3'-terminal residue and a 5'-terminal residue. [SO:cb]"
          },
          "SO:0000988": {
            "name": "circular",
            "def": "A quality of a nucleotide polymer that has no terminal nucleotide residues. [SO:cb]"
          },
          "SO:0000989": {
            "name": "class_II_RNA",
            "def": "Small non-coding RNA (59-60 nt long) containing 5' and 3' ends that are predicted to come together to form a stem structure. Identified in the social amoeba Dictyostelium discoideum and localized in the cytoplasm. [PMID:15333696]"
          },
          "SO:0000990": {
            "name": "class_I_RNA",
            "def": "Small non-coding RNA (55-65 nt long) containing highly conserved 5' and 3' ends (16 and 8 nt, respectively) that are predicted to come together to form a stem structure. Identified in the social amoeba Dictyostelium discoideum and localized in the cytoplasm. [PMID:15333696]"
          },
          "SO:0000991": {
            "name": "genomic_DNA"
          },
          "SO:0000992": {
            "name": "BAC_cloned_genomic_insert"
          },
          "SO:0000993": {
            "name": "consensus"
          },
          "SO:0000994": {
            "name": "consensus_region"
          },
          "SO:0000995": {
            "name": "consensus_mRNA"
          },
          "SO:0000996": {
            "name": "predicted_gene"
          },
          "SO:0000997": {
            "name": "gene_fragment"
          },
          "SO:0000998": {
            "name": "recursive_splice_site",
            "def": "A recursive splice site is a splice site which subdivides a large intron. Recursive splicing is a mechanism that splices large introns by sub dividing the intron at non exonic elements and alternate exons. [http://www.genetics.org/cgi/content/full/170/2/661]"
          },
          "SO:0000999": {
            "name": "BAC_end",
            "def": "A region of sequence from the end of a BAC clone that may provide a highly specific marker. [SO:ke]"
          },
          "SO:0001000": {
            "name": "rRNA_16S",
            "def": "A large polynucleotide in Bacteria and Archaea, which functions as the small subunit of the ribosome. [SO:ke]"
          },
          "SO:0001001": {
            "name": "rRNA_23S",
            "def": "A large polynucleotide in Bacteria and Archaea, which functions as the large subunit of the ribosome. [SO:ke]"
          },
          "SO:0001002": {
            "name": "rRNA_25S",
            "def": "A large polynucleotide which functions as part of the large subunit of the ribosome in some eukaryotes. [RSC:cb]"
          },
          "SO:0001003": {
            "name": "solo_LTR",
            "def": "A recombination product between the 2 LTR of the same element. [SO:ke]"
          },
          "SO:0001004": {
            "name": "low_complexity"
          },
          "SO:0001005": {
            "name": "low_complexity_region"
          },
          "SO:0001006": {
            "name": "prophage",
            "def": "A phage genome after it has established in the host genome in a latent/immune state either as a plasmid or as an integrated \\island\\. [GOC:jl]"
          },
          "SO:0001007": {
            "name": "cryptic_prophage",
            "def": "A remnant of an integrated prophage in the host genome or an \\island\\ in the host genome that includes phage like-genes. [GOC:jl]"
          },
          "SO:0001008": {
            "name": "tetraloop",
            "def": "A base-paired stem with loop of 4 non-hydrogen bonded nucleotides. [SO:ke]"
          },
          "SO:0001009": {
            "name": "DNA_constraint_sequence",
            "def": "A double-stranded DNA used to control macromolecular structure and function. [http:/www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=search&db=pubmed&term=SILVERMAN+SK[au\\]&dispmax=50]"
          },
          "SO:0001010": {
            "name": "i_motif",
            "def": "A cytosine rich domain whereby strands associate both inter- and intramolecularly at moderately acidic pH. [PMID:9753739]"
          },
          "SO:0001011": {
            "name": "PNA_oligo",
            "def": "Peptide nucleic acid, is a chemical not known to occur naturally but is artificially synthesized and used in some biological research and medical treatments. The PNA backbone is composed of repeating N-(2-aminoethyl)-glycine units linked by peptide bonds. The purine and pyrimidine bases are linked to the backbone by methylene carbonyl bonds. [SO:ke]"
          },
          "SO:0001012": {
            "name": "DNAzyme",
            "def": "A DNA sequence with catalytic activity. [SO:cb]"
          },
          "SO:0001013": {
            "name": "MNP",
            "def": "A multiple nucleotide polymorphism with alleles of common length > 1, for example AAA/TTT. [http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs=rs2067431]"
          },
          "SO:0001014": {
            "name": "intron_domain"
          },
          "SO:0001015": {
            "name": "wobble_base_pair",
            "def": "A type of non-canonical base pairing, most commonly between G and U, which is important for the secondary structure of RNAs. It has similar thermodynamic stability to the Watson-Crick pairing. Wobble base pairs only have two hydrogen bonds. Other wobble base pair possibilities are I-A, I-U and I-C. [PMID:11256617]"
          },
          "SO:0001016": {
            "name": "internal_guide_sequence",
            "def": "A purine-rich sequence in the group I introns which determines the locations of the splice sites in group I intron splicing and has catalytic activity. [SO:cb]"
          },
          "SO:0001017": {
            "name": "silent_mutation",
            "def": "A sequence variant that does not affect protein function. Silent mutations may occur in genic ( CDS, UTR, intron etc) and intergenic regions. Silent mutations may have affects on processes such as splicing and regulation. [SO:ke]"
          },
          "SO:0001018": {
            "name": "epitope",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with antibodies, B cells or T cells. [http://en.wikipedia.org/wiki/Epitope, SO:cb]"
          },
          "SO:0001019": {
            "name": "copy_number_variation",
            "def": "A variation that increases or decreases the copy number of a given region. [SO:ke]"
          },
          "SO:0001020": {
            "name": "sequence_variant_affecting_copy_number"
          },
          "SO:0001021": {
            "name": "chromosome_breakpoint"
          },
          "SO:0001022": {
            "name": "inversion_breakpoint",
            "def": "The point within a chromosome where an inversion begins or ends. [SO:cb]"
          },
          "SO:0001023": {
            "name": "allele",
            "def": "An allele is one of a set of coexisting sequence variants of a gene. [SO:immuno_workshop]"
          },
          "SO:0001024": {
            "name": "haplotype",
            "def": "A haplotype is one of a set of coexisting sequence variants of a haplotype block. [SO:immuno_workshop]"
          },
          "SO:0001025": {
            "name": "polymorphic_sequence_variant",
            "def": "A sequence variant that is segregating in one or more natural populations of a species. [SO:immuno_workshop]"
          },
          "SO:0001026": {
            "name": "genome",
            "def": "A genome is the sum of genetic material within a cell or virion. [SO:immuno_workshop]"
          },
          "SO:0001027": {
            "name": "genotype",
            "def": "A genotype is a variant genome, complete or incomplete. [SO:immuno_workshop]"
          },
          "SO:0001028": {
            "name": "diplotype",
            "def": "A diplotype is a pair of haplotypes from a given individual. It is a genotype where the phase is known. [SO:immuno_workshop]"
          },
          "SO:0001029": {
            "name": "direction_attribute"
          },
          "SO:0001030": {
            "name": "forward",
            "def": "Forward is an attribute of the feature, where the feature is in the 5' to 3' direction. [SO:ke]"
          },
          "SO:0001031": {
            "name": "reverse",
            "def": "Reverse is an attribute of the feature, where the feature is in the 3' to 5' direction. Again could be applied to primer. [SO:ke]"
          },
          "SO:0001032": {
            "name": "mitochondrial_DNA"
          },
          "SO:0001033": {
            "name": "chloroplast_DNA"
          },
          "SO:0001034": {
            "name": "miRtron",
            "def": "A de-branched intron which mimics the structure of pre-miRNA and enters the miRNA processing pathway without Drosha mediated cleavage. [PMID:17589500, SO:ma]"
          },
          "SO:0001035": {
            "name": "piRNA",
            "def": "A small non coding RNA, part of a silencing system that prevents the spreading of selfish genetic elements. [SO:ke]"
          },
          "SO:0001036": {
            "name": "arginyl_tRNA",
            "def": "A tRNA sequence that has an arginine anticodon, and a 3' arginine binding region. [SO:ke]"
          },
          "SO:0001037": {
            "name": "mobile_genetic_element",
            "def": "A nucleotide region with either intra-genome or intracellular mobility, of varying length, which often carry the information necessary for transfer and recombination with the host genome. [PMID:14681355]"
          },
          "SO:0001038": {
            "name": "extrachromosomal_mobile_genetic_element",
            "def": "An MGE that is not integrated into the host chromosome. [SO:ke]"
          },
          "SO:0001039": {
            "name": "integrated_mobile_genetic_element",
            "def": "An MGE that is integrated into the host chromosome. [SO:ke]"
          },
          "SO:0001040": {
            "name": "integrated_plasmid",
            "def": "A plasmid sequence that is integrated within the host chromosome. [SO:ke]"
          },
          "SO:0001041": {
            "name": "viral_sequence",
            "def": "The region of nucleotide sequence of a virus, a submicroscopic particle that replicates by infecting a host cell. [SO:ke]"
          },
          "SO:0001042": {
            "name": "phage_sequence",
            "def": "The nucleotide sequence of a virus that infects bacteria. [SO:ke]"
          },
          "SO:0001043": {
            "name": "attCtn_site",
            "def": "An attachment site located on a conjugative transposon and used for site-specific integration of a conjugative transposon. [Phigo:at]"
          },
          "SO:0001044": {
            "name": "nuclear_mt_pseudogene",
            "def": "A nuclear pseudogene of either coding or non-coding mitochondria derived sequence. [SO:xp]"
          },
          "SO:0001045": {
            "name": "cointegrated_plasmid",
            "def": "A MGE region consisting of two fused plasmids resulting from a replicative transposition event. [phigo:at]"
          },
          "SO:0001046": {
            "name": "IRLinv_site",
            "def": "Component of the inversion site located at the left of a region susceptible to site-specific inversion. [Phigo:at]"
          },
          "SO:0001047": {
            "name": "IRRinv_site",
            "def": "Component of the inversion site located at the right of a region susceptible to site-specific inversion. [Phigo:at]"
          },
          "SO:0001048": {
            "name": "inversion_site_part",
            "def": "A region located within an inversion site. [SO:ke]"
          },
          "SO:0001049": {
            "name": "defective_conjugative_transposon",
            "def": "An island that contains genes for integration/excision and the gene and site for the initiation of intercellular transfer by conjugation. It can be complemented for transfer by a conjugative transposon. [Phigo:ariane]"
          },
          "SO:0001050": {
            "name": "repeat_fragment",
            "def": "A portion of a repeat, interrupted by the insertion of another element. [SO:ke]"
          },
          "SO:0001051": {
            "name": "nested_region"
          },
          "SO:0001052": {
            "name": "nested_repeat"
          },
          "SO:0001053": {
            "name": "nested_transposon"
          },
          "SO:0001054": {
            "name": "transposon_fragment",
            "def": "A portion of a transposon, interrupted by the insertion of another element. [SO:ke]"
          },
          "SO:0001055": {
            "name": "transcriptional_cis_regulatory_region",
            "def": "A regulatory_region that modulates the transcription of a gene or genes. [PMID:9679020, SO:regcreative]"
          },
          "SO:0001056": {
            "name": "splicing_regulatory_region",
            "def": "A regulatory_region that modulates splicing. [SO:ke]"
          },
          "SO:0001057": {
            "name": "enhanceosome"
          },
          "SO:0001058": {
            "name": "promoter_targeting_sequence",
            "def": "A transcriptional_cis_regulatory_region that restricts the activity of a CRM to a single promoter and which functions only when both itself and an insulator are located between the CRM and the promoter. [SO:regcreative]"
          },
          "SO:0001059": {
            "name": "sequence_alteration",
            "def": "A sequence_alteration is a sequence_feature whose extent is the deviation from another sequence. [SO:ke]"
          },
          "SO:0001060": {
            "name": "sequence_variant",
            "def": "A sequence_variant is a non exact copy of a sequence_feature or genome exhibiting one or more sequence_alteration. [SO:ke]"
          },
          "SO:0001061": {
            "name": "propeptide_cleavage_site",
            "def": "The propeptide_cleavage_site is the arginine/lysine boundary on a propeptide where cleavage occurs. [EBIBS:GAR]"
          },
          "SO:0001062": {
            "name": "propeptide",
            "def": "Part of a peptide chain which is cleaved off during the formation of the mature protein. [EBIBS:GAR]"
          },
          "SO:0001063": {
            "name": "immature_peptide_region",
            "def": "An immature_peptide_region is the extent of the peptide after it has been translated and before any processing occurs. [EBIBS:GAR]"
          },
          "SO:0001064": {
            "name": "active_peptide",
            "def": "Active peptides are proteins which are biologically active, released from a precursor molecule. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001066": {
            "name": "compositionally_biased_region_of_peptide",
            "def": "Polypeptide region that is rich in a particular amino acid or homopolymeric and greater than three residues in length. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001067": {
            "name": "polypeptide_motif",
            "def": "A sequence motif is a short (up to 20 amino acids) region of biological interest. Such motifs, although they are too short to constitute functional domains, share sequence similarities and are conserved in different proteins. They display a common function (protein-binding, subcellular location etc.). [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001068": {
            "name": "polypeptide_repeat",
            "def": "A polypeptide_repeat is a single copy of an internal sequence repetition. [EBIBS:GAR]"
          },
          "SO:0001070": {
            "name": "polypeptide_structural_region",
            "def": "Region of polypeptide with a given structural property. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001071": {
            "name": "membrane_structure",
            "def": "Arrangement of the polypeptide with respect to the lipid bilayer. [EBIBS:GAR]"
          },
          "SO:0001072": {
            "name": "extramembrane_polypeptide_region",
            "def": "Polypeptide region that is localized outside of a lipid bilayer. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001073": {
            "name": "cytoplasmic_polypeptide_region",
            "def": "Polypeptide region that is localized inside the cytoplasm. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001074": {
            "name": "non_cytoplasmic_polypeptide_region",
            "def": "Polypeptide region that is localized outside of a lipid bilayer and outside of the cytoplasm. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001075": {
            "name": "intramembrane_polypeptide_region",
            "def": "Polypeptide region present in the lipid bilayer. [EBIBS:GAR]"
          },
          "SO:0001076": {
            "name": "membrane_peptide_loop",
            "def": "Polypeptide region localized within the lipid bilayer where both ends traverse the same membrane. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001077": {
            "name": "transmembrane_polypeptide_region",
            "def": "Polypeptide region traversing the lipid bilayer. [EBIBS:GAR, UniProt:curator_manual]"
          },
          "SO:0001078": {
            "name": "polypeptide_secondary_structure",
            "def": "A region of peptide with secondary structure has hydrogen bonding along the peptide chain that causes a defined conformation of the chain. [EBIBS:GAR]"
          },
          "SO:0001079": {
            "name": "polypeptide_structural_motif",
            "def": "Motif is a three-dimensional structural element within the chain, which appears also in a variety of other molecules. Unlike a domain, a motif does not need to form a stable globular unit. [EBIBS:GAR]"
          },
          "SO:0001080": {
            "name": "coiled_coil",
            "def": "A coiled coil is a structural motif in proteins, in which alpha-helices are coiled together like the strands of a rope. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001081": {
            "name": "helix_turn_helix",
            "def": "A motif comprising two helices separated by a turn. [EBIBS:GAR]"
          },
          "SO:0001082": {
            "name": "polypeptide_sequencing_information",
            "def": "Incompatibility in the sequence due to some experimental problem. [EBIBS:GAR]"
          },
          "SO:0001083": {
            "name": "non_adjacent_residues",
            "def": "Indicates that two consecutive residues in a fragment sequence are not consecutive in the full-length protein and that there are a number of unsequenced residues between them. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001084": {
            "name": "non_terminal_residue",
            "def": "The residue at an extremity of the sequence is not the terminal residue. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001085": {
            "name": "sequence_conflict",
            "def": "Different sources report differing sequences. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001086": {
            "name": "sequence_uncertainty",
            "def": "Describes the positions in a sequence where the authors are unsure about the sequence assignment. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001087": {
            "name": "cross_link",
            "def": "Posttranslationally formed amino acid bonds. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001088": {
            "name": "disulfide_bond",
            "def": "The covalent bond between sulfur atoms that binds two peptide chains or different parts of one peptide chain and is a structural determinant in many protein molecules. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001089": {
            "name": "post_translationally_modified_region",
            "def": "A region where a transformation occurs in a protein after it has been synthesized. This which may regulate, stabilize, crosslink or introduce new chemical functionalities in the protein. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001090": {
            "name": "covalent_binding_site",
            "def": "Binding involving a covalent bond. [EBIBS:GAR]"
          },
          "SO:0001091": {
            "name": "non_covalent_binding_site",
            "def": "Binding site for any chemical group (co-enzyme, prosthetic group, etc.). [EBIBS:GAR]"
          },
          "SO:0001092": {
            "name": "polypeptide_metal_contact",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with metal ions. [EBIBS:GAR, SO:cb, UniProt:curation_manual]"
          },
          "SO:0001093": {
            "name": "protein_protein_contact",
            "def": "A binding site that, in the protein molecule, interacts selectively and non-covalently with polypeptide residues. [EBIBS:GAR, UniProt:Curation_manual]"
          },
          "SO:0001094": {
            "name": "polypeptide_calcium_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with calcium ions. [EBIBS:GAR]"
          },
          "SO:0001095": {
            "name": "polypeptide_cobalt_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with cobalt ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001096": {
            "name": "polypeptide_copper_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with copper ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001097": {
            "name": "polypeptide_iron_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with iron ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001098": {
            "name": "polypeptide_magnesium_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with magnesium ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001099": {
            "name": "polypeptide_manganese_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with manganese ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001100": {
            "name": "polypeptide_molybdenum_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with molybdenum ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001101": {
            "name": "polypeptide_nickel_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with nickel ions. [EBIBS:GAR]"
          },
          "SO:0001102": {
            "name": "polypeptide_tungsten_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with tungsten ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001103": {
            "name": "polypeptide_zinc_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with zinc ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001104": {
            "name": "catalytic_residue",
            "def": "Amino acid involved in the activity of an enzyme. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001105": {
            "name": "polypeptide_ligand_contact",
            "def": "Residues which interact with a ligand. [EBIBS:GAR]"
          },
          "SO:0001106": {
            "name": "asx_motif",
            "def": "A motif of five consecutive residues and two H-bonds in which: Residue(i) is Aspartate or Asparagine (Asx), side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2) or (i+3), main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+3) or (i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001107": {
            "name": "beta_bulge",
            "def": "A motif of three residues within a beta-sheet in which the main chains of two consecutive residues are H-bonded to that of the third, and in which the dihedral angles are as follows: Residue(i): -140 degrees < phi(l) -20 degrees , -90 degrees < psi(l) < 40 degrees. Residue (i+1): -180 degrees < phi < -25 degrees or +120 degrees < phi < +180 degrees, +40 degrees < psi < +180 degrees or -180 degrees < psi < -120 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001108": {
            "name": "beta_bulge_loop",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds. Beta bulge loops often occur at the loop ends of beta-hairpins. [EBIBS:GAR, Http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001109": {
            "name": "beta_bulge_loop_five",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds in which: the main-chain NH of residue(i) is H-bonded to the main-chain CO of residue(i+4), the main-chain CO of residue i is H-bonded to the main-chain NH of residue(i+3), these loops have an RL nest at residues i+2 and i+3. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001110": {
            "name": "beta_bulge_loop_six",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds in which: the main-chain NH of residue(i) is H-bonded to the main-chain CO of residue(i+5), the main-chain CO of residue i is H-bonded to the main-chain NH of residue(i+4), these loops have an RL nest at residues i+3 and i+4. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001111": {
            "name": "beta_strand",
            "def": "A beta strand describes a single length of polypeptide chain that forms part of a beta sheet. A single continuous stretch of amino acids adopting an extended conformation of hydrogen bonds between the N-O and the C=O of another part of the peptide. This forms a secondary protein structure in which two or more extended polypeptide regions are hydrogen-bonded to one another in a planar array. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001112": {
            "name": "antiparallel_beta_strand",
            "def": "A peptide region which hydrogen bonded to another region of peptide running in the oposite direction (one running N-terminal to C-terminal and one running C-terminal to N-terminal). Hydrogen bonding occurs between every other C=O from one strand to every other N-H on the adjacent strand. In this case, if two atoms C-alpha (i) and C-alpha (j) are adjacent in two hydrogen-bonded beta strands, then they form two mutual backbone hydrogen bonds to each other's flanking peptide groups; this is known as a close pair of hydrogen bonds. The peptide backbone dihedral angles (phi, psi) are about (-140 degrees, 135 degrees) in antiparallel sheets. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001113": {
            "name": "parallel_beta_strand",
            "def": "A peptide region which hydrogen bonded to another region of peptide running in the oposite direction (both running N-terminal to C-terminal). This orientation is slightly less stable because it introduces nonplanarity in the inter-strand hydrogen bonding pattern. Hydrogen bonding occurs between every other C=O from one strand to every other N-H on the adjacent strand. In this case, if two atoms C-alpha (i)and C-alpha (j) are adjacent in two hydrogen-bonded beta strands, then they do not hydrogen bond to each other; rather, one residue forms hydrogen bonds to the residues that flank the other (but not vice versa). For example, residue i may form hydrogen bonds to residues j - 1 and j + 1; this is known as a wide pair of hydrogen bonds. By contrast, residue j may hydrogen-bond to different residues altogether, or to none at all. The dihedral angles (phi, psi) are about (-120 degrees, 115 degrees) in parallel sheets. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001114": {
            "name": "peptide_helix",
            "def": "A helix is a secondary_structure conformation where the peptide backbone forms a coil. [EBIBS:GAR]"
          },
          "SO:0001115": {
            "name": "left_handed_peptide_helix",
            "def": "A left handed helix is a region of peptide where the coiled conformation turns in an anticlockwise, left handed screw. [EBIBS:GAR]"
          },
          "SO:0001116": {
            "name": "right_handed_peptide_helix",
            "def": "A right handed helix is a region of peptide where the coiled conformation turns in a clockwise, right handed screw. [EBIBS:GAR]"
          },
          "SO:0001117": {
            "name": "alpha_helix",
            "def": "The helix has 3.6 residues per turn which corresponds to a translation of 1.5 angstroms (= 0.15 nm) along the helical axis. Every backbone N-H group donates a hydrogen bond to the backbone C=O group of the amino acid four residues earlier. [EBIBS:GAR]"
          },
          "SO:0001118": {
            "name": "pi_helix",
            "def": "The pi helix has 4.1 residues per turn and a translation of 1.15  (=0.115 nm) along the helical axis. The N-H group of an amino acid forms a hydrogen bond with the C=O group of the amino acid five residues earlier. [EBIBS:GAR]"
          },
          "SO:0001119": {
            "name": "three_ten_helix",
            "def": "The 3-10 helix has 3 residues per turn with a translation of 2.0 angstroms (=0.2 nm) along the helical axis. The N-H group of an amino acid forms a hydrogen bond with the C=O group of the amino acid three residues earlier. [EBIBS:GAR]"
          },
          "SO:0001120": {
            "name": "polypeptide_nest_motif",
            "def": "A motif of two consecutive residues with dihedral angles. Nest should not have Proline as any residue. Nests frequently occur as parts of other motifs such as Schellman loops. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001121": {
            "name": "polypeptide_nest_left_right_motif",
            "def": "A motif of two consecutive residues with dihedral angles: Residue(i): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001122": {
            "name": "polypeptide_nest_right_left_motif",
            "def": "A motif of two consecutive residues with dihedral angles: Residue(i): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001123": {
            "name": "schellmann_loop",
            "def": "A motif of six or seven consecutive residues that contains two H-bonds. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001124": {
            "name": "schellmann_loop_seven",
            "def": "Wild type: A motif of seven consecutive residues that contains two H-bonds in which: the main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+6), the main-chain CO of residue(i+1) is H-bonded to the main-chain NH of residue(i+5). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001125": {
            "name": "schellmann_loop_six",
            "def": "Common Type: A motif of six consecutive residues that contains two H-bonds in which: the main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+5) the main-chain CO of residue(i+1) is H-bonded to the main-chain NH of residue(i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001126": {
            "name": "serine_threonine_motif",
            "def": "A motif of five consecutive residues and two hydrogen bonds in which: residue(i) is Serine (S) or Threonine (T), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2) or (i+3) , the main-chain CO group of residue(i) is H-bonded to the main-chain NH of residue(i+3) or (i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001127": {
            "name": "serine_threonine_staple_motif",
            "def": "A motif of four or five consecutive residues and one H-bond in which: residue(i) is Serine (S) or Threonine (T), the side-chain OH of residue(i) is H-bonded to the main-chain CO of residue(i3) or (i4), Phi angles of residues(i1), (i2) and (i3) are negative. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001128": {
            "name": "polypeptide_turn_motif",
            "def": "A reversal in the direction of the backbone of a protein that is stabilized by hydrogen bond between backbone NH and CO groups, involving no more than 4 amino acid residues. [EBIBS:GAR, uniprot:feature_type]"
          },
          "SO:0001129": {
            "name": "asx_turn_left_handed_type_one",
            "def": "Left handed type I (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, -90 degrees < psi +120 degrees < +40 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001130": {
            "name": "asx_turn_left_handed_type_two",
            "def": "Left handed type II (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, +80 degrees < psi +120 degrees < +180 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001131": {
            "name": "asx_turn_right_handed_type_two",
            "def": "Right handed type II (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, +80 degrees < psi +120 degrees < +180 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001132": {
            "name": "asx_turn_right_handed_type_one",
            "def": "Right handed type I (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, -90 degrees < psi +120 degrees < +40 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001133": {
            "name": "beta_turn",
            "def": "A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles of the second and third residues, which are the basis for sub-categorization. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001134": {
            "name": "beta_turn_left_handed_type_one",
            "def": "Left handed type I:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles:- Residue(i+1): -140 degrees > phi > -20 degrees, -90 degrees > psi > +40 degrees. Residue(i+2): -140 degrees > phi > -20 degrees, -90 degrees > psi > +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001135": {
            "name": "beta_turn_left_handed_type_two",
            "def": "Left handed type II: A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees > phi > -20 degrees, +80 degrees > psi > +180 degrees. Residue(i+2): +20 degrees > phi > +140 degrees, -40 degrees > psi > +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001136": {
            "name": "beta_turn_right_handed_type_one",
            "def": "Right handed type I:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. Residue(i+2): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001137": {
            "name": "beta_turn_right_handed_type_two",
            "def": "Right handed type II:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees < phi < -20 degrees, +80 degrees < psi < +180 degrees. Residue(i+2): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001138": {
            "name": "gamma_turn",
            "def": "Gamma turns, defined for 3 residues i,( i+1),( i+2) if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001139": {
            "name": "gamma_turn_classic",
            "def": "Gamma turns, defined for 3 residues i, i+1, i+2 if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees: phi(i+1)=75.0 - psi(i+1)=-64.0. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001140": {
            "name": "gamma_turn_inverse",
            "def": "Gamma turns, defined for 3 residues i, i+1, i+2 if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees: phi(i+1)=-79.0 - psi(i+1)=69.0. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001141": {
            "name": "serine_threonine_turn",
            "def": "A motif of three consecutive residues and one H-bond in which: residue(i) is Serine (S) or Threonine (T), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001142": {
            "name": "st_turn_left_handed_type_one",
            "def": "The peptide twists in an anticlockwise, left handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, -90 degrees psi +120 degrees < +40 degrees, residue(i+1): -140 degrees < phi < -20 degrees, -90 < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001143": {
            "name": "st_turn_left_handed_type_two",
            "def": "The peptide twists in an anticlockwise, left handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, +80 degrees psi +120 degrees < +180 degrees, residue(i+1): +20 degrees < phi < +140 degrees, -40 < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001144": {
            "name": "st_turn_right_handed_type_one",
            "def": "The peptide twists in an clockwise, right handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, -90 degrees psi +120 degrees < +40 degrees, residue(i+1): -140 degrees < phi < -20 degrees, -90 < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001145": {
            "name": "st_turn_right_handed_type_two",
            "def": "The peptide twists in an clockwise, right handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, +80 degrees psi +120 degrees < +180 degrees, residue(i+1): +20 degrees < phi < +140 degrees, -40 < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001146": {
            "name": "polypeptide_variation_site",
            "def": "A site of sequence variation (alteration). Alternative sequence due to naturally occurring events such as polymorphisms and alternative splicing or experimental methods such as site directed mutagenesis. [EBIBS:GAR, SO:ke]"
          },
          "SO:0001147": {
            "name": "natural_variant_site",
            "def": "Describes the natural sequence variants due to polymorphisms, disease-associated mutations, RNA editing and variations between strains, isolates or cultivars. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001148": {
            "name": "mutated_variant_site",
            "def": "Site which has been experimentally altered. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001149": {
            "name": "alternate_sequence_site",
            "def": "Description of sequence variants produced by alternative splicing, alternative promoter usage, alternative initiation and ribosomal frameshifting. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001150": {
            "name": "beta_turn_type_six",
            "def": "A motif of four consecutive peptide resides of type VIa or type VIb and where the i+2 residue is cis-proline. [SO:cb]"
          },
          "SO:0001151": {
            "name": "beta_turn_type_six_a",
            "def": "A motif of four consecutive peptide residues, of which the i+2 residue is proline, and that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -60 degrees, psi ~ 120 degrees. Residue(i+2): phi ~ -90 degrees, psi ~ 0 degrees. [PMID:2371257, SO:cb]"
          },
          "SO:0001152": {
            "name": "beta_turn_type_six_a_one"
          },
          "SO:0001153": {
            "name": "beta_turn_type_six_a_two"
          },
          "SO:0001154": {
            "name": "beta_turn_type_six_b",
            "def": "A motif of four consecutive peptide residues, of which the i+2 residue is proline, and that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -120 degrees, psi ~ 120 degrees. Residue(i+2): phi ~ -60 degrees, psi ~ 0 degrees. [PMID:2371257, SO:cb]"
          },
          "SO:0001155": {
            "name": "beta_turn_type_eight",
            "def": "A motif of four consecutive peptide residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -60 degrees, psi ~ -30 degrees. Residue(i+2): phi ~ -120 degrees, psi ~ 120 degrees. [PMID:2371257, SO:cb]"
          },
          "SO:0001156": {
            "name": "DRE_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -10 and -60 relative to the TSS. Consensus sequence is WATCGATW. [PMID:12537576]"
          },
          "SO:0001157": {
            "name": "DMv4_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, located immediately upstream of some TATA box elements with respect to the TSS (+1). Consensus sequence is YGGTCACACTR. Marked spatial preference within core promoter; tend to occur near the TSS, although not as tightly as INR (SO:0000014). [PMID:16827941:12537576]"
          },
          "SO:0001158": {
            "name": "E_box_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -60 and +1 relative to the TSS. Consensus sequence is AWCAGCTGWT. Tends to co-occur with DMv2 (SO:0001161). Tends to not occur with DPE motif (SO:0000015). [PMID:12537576:16827941]"
          },
          "SO:0001159": {
            "name": "DMv5_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -50 and -10 relative to the TSS. Consensus sequence is KTYRGTATWTTT. Tends to co-occur with DMv4 (SO:0001157) . Tends to not occur with DPE motif (SO:0000015) or MTE (SO:0001162). [PMID:12537576:16827941]"
          },
          "SO:0001160": {
            "name": "DMv3_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -30 and +15 relative to the TSS. Consensus sequence is KNNCAKCNCTRNY. Tends to co-occur with DMv2 (SO:0001161). Tends to not occur with DPE motif (SO:0000015) or MTE (0001162). [PMID:12537576:16827941]"
          },
          "SO:0001161": {
            "name": "DMv2_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -60 and -45 relative to the TSS. Consensus sequence is MKSYGGCARCGSYSS. Tends to co-occur with DMv3 (SO:0001160). Tends to not occur with DPE motif (SO:0000015) or MTE (SO:0001162). [PMID:12537576:16827941]"
          },
          "SO:0001162": {
            "name": "MTE",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between +20 and +30 relative to the TSS. Consensus sequence is CSARCSSAACGS. Tends to co-occur with INR motif (SO:0000014). Tends to not occur with DPE motif (SO:0000015) or DMv5 (SO:0001159). [PMID:12537576:15231738, PMID:16858867]"
          },
          "SO:0001163": {
            "name": "INR1_motif",
            "def": "A promoter motif with consensus sequence TCATTCG. [PMID:16827941]"
          },
          "SO:0001164": {
            "name": "DPE1_motif",
            "def": "A promoter motif with consensus sequence CGGACGT. [PMID:16827941]"
          },
          "SO:0001165": {
            "name": "DMv1_motif",
            "def": "A promoter motif with consensus sequence CARCCCT. [PMID:16827941]"
          },
          "SO:0001166": {
            "name": "GAGA_motif",
            "def": "A non directional promoter motif with consensus sequence GAGAGCG. [PMID:16827941]"
          },
          "SO:0001167": {
            "name": "NDM2_motif",
            "def": "A non directional promoter motif with consensus CGMYGYCR. [PMID:16827941]"
          },
          "SO:0001168": {
            "name": "NDM3_motif",
            "def": "A non directional promoter motif with consensus sequence GAAAGCT. [PMID:16827941]"
          },
          "SO:0001169": {
            "name": "ds_RNA_viral_sequence",
            "def": "A ds_RNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as double stranded RNA. [SO:ke]"
          },
          "SO:0001170": {
            "name": "polinton",
            "def": "A kind of DNA transposon that populates the genomes of protists, fungi, and animals, characterized by a unique set of proteins necessary for their transposition, including a protein-primed DNA polymerase B, retroviral integrase, cysteine protease, and ATPase. Polintons are characterized by 6-bp target site duplications, terminal-inverted repeats that are several hundred nucleotides long, and 5'-AG and TC-3' termini. Polintons exist as autonomous and nonautonomous elements. [PMID:16537396]"
          },
          "SO:0001171": {
            "name": "rRNA_21S",
            "def": "A component of the large ribosomal subunit in mitochondrial rRNA. [RSC:cb]"
          },
          "SO:0001172": {
            "name": "tRNA_region",
            "def": "A region of a tRNA. [RSC:cb]"
          },
          "SO:0001173": {
            "name": "anticodon_loop",
            "def": "A sequence of seven nucleotide bases in tRNA which contains the anticodon. It has the sequence 5'-pyrimidine-purine-anticodon-modified purine-any base-3. [ISBN:0716719207]"
          },
          "SO:0001174": {
            "name": "anticodon",
            "def": "A sequence of three nucleotide bases in tRNA which recognizes a codon in mRNA. [RSC:cb]"
          },
          "SO:0001175": {
            "name": "CCA_tail",
            "def": "Base sequence at the 3' end of a tRNA. The 3'-hydroxyl group on the terminal adenosine is the attachment point for the amino acid. [ISBN:0716719207]"
          },
          "SO:0001176": {
            "name": "DHU_loop",
            "def": "Non-base-paired sequence of nucleotide bases in tRNA. It contains several dihydrouracil residues. [ISBN:071671920]"
          },
          "SO:0001177": {
            "name": "T_loop",
            "def": "Non-base-paired sequence of three nucleotide bases in tRNA. It has sequence T-Psi-C. [ISBN:0716719207]"
          },
          "SO:0001178": {
            "name": "pyrrolysine_tRNA_primary_transcript",
            "def": "A primary transcript encoding pyrrolysyl tRNA (SO:0000766). [RSC:cb]"
          },
          "SO:0001179": {
            "name": "U3_snoRNA",
            "def": "U3 snoRNA is a member of the box C/D class of small nucleolar RNAs. The U3 snoRNA secondary structure is characterised by a small 5' domain (with boxes A and A'), and a larger 3' domain (with boxes B, C, C', and D), the two domains being linked by a single-stranded hinge. Boxes B and C form the B/C motif, which appears to be exclusive to U3 snoRNAs, and boxes C' and D form the C'/D motif. The latter is functionally similar to the C/D motifs found in other snoRNAs. The 5' domain and the hinge region act as a pre-rRNA-binding domain. The 3' domain has conserved protein-binding sites. Both the box B/C and box C'/D motifs are sufficient for nuclear retention of U3 snoRNA. The box C'/D motif is also necessary for nucleolar localization, stability and hypermethylation of U3 snoRNA. Both box B/C and C'/D motifs are involved in specific protein interactions and are necessary for the rRNA processing functions of U3 snoRNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00012]"
          },
          "SO:0001180": {
            "name": "AU_rich_element",
            "def": "A cis-acting element found in the 3' UTR of some mRNA which is rich in AUUUA pentamers. Messenger RNAs bearing multiple AU-rich elements are often unstable. [PMID:7892223]"
          },
          "SO:0001181": {
            "name": "Bruno_response_element",
            "def": "A cis-acting element found in the 3' UTR of some mRNA which is bound by the Drosophila Bruno protein and its homologs. [PMID:10893231]"
          },
          "SO:0001182": {
            "name": "iron_responsive_element",
            "def": "A regulatory sequence found in the 5' and 3' UTRs of many mRNAs which encode iron-binding proteins. It has a hairpin structure and is recognized by trans-acting proteins known as iron-regulatory proteins. [PMID:3198610, PMID:8710843]"
          },
          "SO:0001183": {
            "name": "morpholino_backbone",
            "def": "An attribute describing a sequence composed of nucleobases bound to a morpholino backbone. A morpholino backbone consists of morpholine (CHEBI:34856) rings connected by phosphorodiamidate linkages. [RSC:cb]"
          },
          "SO:0001184": {
            "name": "PNA",
            "def": "An attribute describing a sequence composed of peptide nucleic acid (CHEBI:48021), a chemical consisting of nucleobases bound to a backbone composed of repeating N-(2-aminoethyl)-glycine units linked by peptide bonds. The purine and pyrimidine bases are linked to the backbone by methylene carbonyl bonds. [RSC:cb]"
          },
          "SO:0001185": {
            "name": "enzymatic",
            "def": "An attribute describing the sequence of a transcript that has catalytic activity with or without an associated ribonucleoprotein. [RSC:cb]"
          },
          "SO:0001186": {
            "name": "ribozymic",
            "def": "An attribute describing the sequence of a transcript that has catalytic activity even without an associated ribonucleoprotein. [RSC:cb]"
          },
          "SO:0001187": {
            "name": "pseudouridylation_guide_snoRNA",
            "def": "A snoRNA that specifies the site of pseudouridylation in an RNA molecule by base pairing with a short sequence around the target residue. [GOC:mah, PMID:12457565]"
          },
          "SO:0001188": {
            "name": "LNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of 'locked' deoxyribose rings connected to a phosphate backbone. The deoxyribose unit's conformation is 'locked' by a 2'-C,4'-C-oxymethylene link. [CHEBI:48010]"
          },
          "SO:0001189": {
            "name": "LNA_oligo",
            "def": "An oligo composed of LNA residues. [RSC:cb]"
          },
          "SO:0001190": {
            "name": "TNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of threose rings connected to a phosphate backbone. [CHEBI:48019]"
          },
          "SO:0001191": {
            "name": "TNA_oligo",
            "def": "An oligo composed of TNA residues. [RSC:cb]"
          },
          "SO:0001192": {
            "name": "GNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of an acyclic three-carbon propylene glycol connected to a phosphate backbone. It has two enantiomeric forms, (R)-GNA and (S)-GNA. [CHEBI:48015]"
          },
          "SO:0001193": {
            "name": "GNA_oligo",
            "def": "An oligo composed of GNA residues. [RSC:cb]"
          },
          "SO:0001194": {
            "name": "R_GNA",
            "def": "An attribute describing a GNA sequence in the (R)-GNA enantiomer. [CHEBI:48016]"
          },
          "SO:0001195": {
            "name": "R_GNA_oligo",
            "def": "An oligo composed of (R)-GNA residues. [RSC:cb]"
          },
          "SO:0001196": {
            "name": "S_GNA",
            "def": "An attribute describing a GNA sequence in the (S)-GNA enantiomer. [CHEBI:48017]"
          },
          "SO:0001197": {
            "name": "S_GNA_oligo",
            "def": "An oligo composed of (S)-GNA residues. [RSC:cb]"
          },
          "SO:0001198": {
            "name": "ds_DNA_viral_sequence",
            "def": "A ds_DNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as double stranded DNA. [SO:ke]"
          },
          "SO:0001199": {
            "name": "ss_RNA_viral_sequence",
            "def": "A ss_RNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as single stranded RNA. [SO:ke]"
          },
          "SO:0001200": {
            "name": "negative_sense_ssRNA_viral_sequence",
            "def": "A negative_sense_RNA_viral_sequence is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus that is complementary to mRNA and must be converted to positive sense RNA by RNA polymerase before translation. [SO:ke]"
          },
          "SO:0001201": {
            "name": "positive_sense_ssRNA_viral_sequence",
            "def": "A positive_sense_RNA_viral_sequence is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus that can be immediately translated by the host. [SO:ke]"
          },
          "SO:0001202": {
            "name": "ambisense_ssRNA_viral_sequence",
            "def": "A ambisense_RNA_virus is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus with both messenger and anti messenger polarity. [SO:ke]"
          },
          "SO:0001203": {
            "name": "RNA_polymerase_promoter",
            "def": "A region (DNA) to which RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001204": {
            "name": "Phage_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which Bacteriophage RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001205": {
            "name": "SP6_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which the SP6 RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001206": {
            "name": "T3_RNA_Polymerase_Promoter",
            "def": "A DNA sequence to which the T3 RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001207": {
            "name": "T7_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which the T7 RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001208": {
            "name": "five_prime_EST",
            "def": "An EST read from the 5' end of a transcript that usually codes for a protein. These regions tend to be conserved across species and do not change much within a gene family. [http://www.ncbi.nlm.nih.gov/About/primer/est.html]"
          },
          "SO:0001209": {
            "name": "three_prime_EST",
            "def": "An EST read from the 3' end of a transcript. They are more likely to fall within non-coding, or untranslated regions(UTRs). [http://www.ncbi.nlm.nih.gov/About/primer/est.html]"
          },
          "SO:0001210": {
            "name": "translational_frameshift",
            "def": "The region of mRNA (not divisible by 3 bases) that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
          },
          "SO:0001211": {
            "name": "plus_1_translational_frameshift",
            "def": "The region of mRNA 1 base long that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
          },
          "SO:0001212": {
            "name": "plus_2_translational_frameshift",
            "def": "The region of mRNA 2 bases long that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
          },
          "SO:0001213": {
            "name": "group_III_intron",
            "def": "Group III introns are introns found in the mRNA of the plastids of euglenoid protists. They are spliced by a two step transesterification with bulged adenosine as initiating nucleophile. [PMID:11377794]"
          },
          "SO:0001214": {
            "name": "noncoding_region_of_exon",
            "def": "The maximal intersection of exon and UTR. [SO:ke]"
          },
          "SO:0001215": {
            "name": "coding_region_of_exon",
            "def": "The region of an exon that encodes for protein sequence. [SO:ke]"
          },
          "SO:0001216": {
            "name": "endonuclease_spliced_intron",
            "def": "An intron that spliced via endonucleolytic cleavage and ligation rather than transesterification. [SO:ke]"
          },
          "SO:0001217": {
            "name": "protein_coding_gene"
          },
          "SO:0001218": {
            "name": "transgenic_insertion",
            "def": "An insertion that derives from another organism, via the use of recombinant DNA technology. [SO:bm]"
          },
          "SO:0001219": {
            "name": "retrogene"
          },
          "SO:0001220": {
            "name": "silenced_by_RNA_interference",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by RNA interference. [RSC:cb]"
          },
          "SO:0001221": {
            "name": "silenced_by_histone_modification",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone modification. [RSC:cb]"
          },
          "SO:0001222": {
            "name": "silenced_by_histone_methylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone methylation. [RSC:cb]"
          },
          "SO:0001223": {
            "name": "silenced_by_histone_deacetylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone deacetylation. [RSC:cb]"
          },
          "SO:0001224": {
            "name": "gene_silenced_by_RNA_interference",
            "def": "A gene that is silenced by RNA interference. [SO:xp]"
          },
          "SO:0001225": {
            "name": "gene_silenced_by_histone_modification",
            "def": "A gene that is silenced by histone modification. [SO:xp]"
          },
          "SO:0001226": {
            "name": "gene_silenced_by_histone_methylation",
            "def": "A gene that is silenced by histone methylation. [SO:xp]"
          },
          "SO:0001227": {
            "name": "gene_silenced_by_histone_deacetylation",
            "def": "A gene that is silenced by histone deacetylation. [SO:xp]"
          },
          "SO:0001228": {
            "name": "dihydrouridine",
            "def": "A modified RNA base in which the 5,6-dihydrouracil is bound to the ribose ring. [RSC:cb]"
          },
          "SO:0001229": {
            "name": "pseudouridine",
            "def": "A modified RNA base in which the 5- position of the uracil is bound to the ribose ring instead of the 4- position. [RSC:cb]"
          },
          "SO:0001230": {
            "name": "inosine",
            "def": "A modified RNA base in which hypoxanthine is bound to the ribose ring. [http://library.med.utah.edu/RNAmods/, RSC:cb]"
          },
          "SO:0001231": {
            "name": "seven_methylguanine",
            "def": "A modified RNA base in which guanine is methylated at the 7- position. [RSC:cb]"
          },
          "SO:0001232": {
            "name": "ribothymidine",
            "def": "A modified RNA base in which thymine is bound to the ribose ring. [RSC:cb]"
          },
          "SO:0001233": {
            "name": "methylinosine",
            "def": "A modified RNA base in which methylhypoxanthine is bound to the ribose ring. [RSC:cb]"
          },
          "SO:0001234": {
            "name": "mobile",
            "def": "An attribute describing a feature that has either intra-genome or intracellular mobility. [RSC:cb]"
          },
          "SO:0001235": {
            "name": "replicon",
            "def": "A region containing at least one unique origin of replication and a unique termination site. [ISBN:0716719207]"
          },
          "SO:0001236": {
            "name": "base",
            "def": "A base is a sequence feature that corresponds to a single unit of a nucleotide polymer. [SO:ke]"
          },
          "SO:0001237": {
            "name": "amino_acid",
            "def": "A sequence feature that corresponds to a single amino acid residue in a polypeptide. [RSC:cb]"
          },
          "SO:0001238": {
            "name": "major_TSS"
          },
          "SO:0001239": {
            "name": "minor_TSS"
          },
          "SO:0001240": {
            "name": "TSS_region",
            "def": "The region of a gene from the 5' most TSS to the 3' TSS. [BBOP:nw]"
          },
          "SO:0001241": {
            "name": "encodes_alternate_transcription_start_sites"
          },
          "SO:0001243": {
            "name": "miRNA_primary_transcript_region",
            "def": "A part of an miRNA primary_transcript. [SO:ke]"
          },
          "SO:0001244": {
            "name": "pre_miRNA",
            "def": "The 60-70 nucleotide region remain after Drosha processing of the primary transcript, that folds back upon itself to form a hairpin structure. [SO:ke]"
          },
          "SO:0001245": {
            "name": "miRNA_stem",
            "def": "The stem of the hairpin loop formed by folding of the pre-miRNA. [SO:ke]"
          },
          "SO:0001246": {
            "name": "miRNA_loop",
            "def": "The loop of the hairpin loop formed by folding of the pre-miRNA. [SO:ke]"
          },
          "SO:0001247": {
            "name": "synthetic_oligo",
            "def": "An oligo composed of synthetic nucleotides. [SO:ke]"
          },
          "SO:0001248": {
            "name": "assembly",
            "def": "A region of the genome of known length that is composed by ordering and aligning two or more different regions. [SO:ke]"
          },
          "SO:0001249": {
            "name": "fragment_assembly",
            "def": "A fragment assembly is a genome assembly that orders overlapping fragments of the genome based on landmark sequences. The base pair distance between the landmarks is known allowing additivity of lengths. [SO:ke]"
          },
          "SO:0001250": {
            "name": "fingerprint_map",
            "def": "A fingerprint_map is a physical map composed of restriction fragments. [SO:ke]"
          },
          "SO:0001251": {
            "name": "STS_map",
            "def": "An STS map is a physical map organized by the unique STS landmarks. [SO:ke]"
          },
          "SO:0001252": {
            "name": "RH_map",
            "def": "A radiation hybrid map is a physical map. [SO:ke]"
          },
          "SO:0001253": {
            "name": "sonicate_fragment",
            "def": "A DNA fragment generated by sonication. Sonication is a technique used to sheer DNA into smaller fragments. [SO:ke]"
          },
          "SO:0001254": {
            "name": "polyploid",
            "def": "A kind of chromosome variation where the chromosome complement is an exact multiple of the haploid number and is greater than the diploid number. [SO:ke]"
          },
          "SO:0001255": {
            "name": "autopolyploid",
            "def": "A polyploid where the multiple chromosome set was derived from the same organism. [SO:ke]"
          },
          "SO:0001256": {
            "name": "allopolyploid",
            "def": "A polyploid where the multiple chromosome set was derived from a different organism. [SO:ke]"
          },
          "SO:0001257": {
            "name": "homing_endonuclease_binding_site",
            "def": "The binding site (recognition site) of a homing endonuclease. The binding site is typically large. [SO:ke]"
          },
          "SO:0001258": {
            "name": "octamer_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters with sequence ATTGCAT that binds Pou-domain transcription factors. [GOC:dh, PMID:3095662]"
          },
          "SO:0001259": {
            "name": "apicoplast_chromosome",
            "def": "A chromosome originating in an apicoplast. [SO:xp]"
          },
          "SO:0001260": {
            "name": "sequence_collection",
            "def": "A collection of discontinuous sequences. [SO:ke]"
          },
          "SO:0001261": {
            "name": "overlapping_feature_set",
            "def": "A continuous region of sequence composed of the overlapping of multiple sequence_features, which ultimately provides evidence for another sequence_feature. [SO:ke]"
          },
          "SO:0001262": {
            "name": "overlapping_EST_set",
            "def": "A continous experimental result region extending the length of multiple overlapping EST's. [SO:ke]"
          },
          "SO:0001263": {
            "name": "ncRNA_gene"
          },
          "SO:0001264": {
            "name": "gRNA_gene"
          },
          "SO:0001265": {
            "name": "miRNA_gene"
          },
          "SO:0001266": {
            "name": "scRNA_gene"
          },
          "SO:0001267": {
            "name": "snoRNA_gene"
          },
          "SO:0001268": {
            "name": "snRNA_gene"
          },
          "SO:0001269": {
            "name": "SRP_RNA_gene"
          },
          "SO:0001271": {
            "name": "tmRNA_gene"
          },
          "SO:0001272": {
            "name": "tRNA_gene"
          },
          "SO:0001273": {
            "name": "modified_adenosine",
            "def": "A modified adenine is an adenine base feature that has been altered. [SO:ke]"
          },
          "SO:0001274": {
            "name": "modified_inosine",
            "def": "A modified inosine is an inosine base feature that has been altered. [SO:ke]"
          },
          "SO:0001275": {
            "name": "modified_cytidine",
            "def": "A modified cytidine is a cytidine base feature which has been altered. [SO:ke]"
          },
          "SO:0001276": {
            "name": "modified_guanosine"
          },
          "SO:0001277": {
            "name": "modified_uridine"
          },
          "SO:0001278": {
            "name": "one_methylinosine",
            "def": "1-methylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001279": {
            "name": "one_two_prime_O_dimethylinosine",
            "def": "1,2'-O-dimethylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001280": {
            "name": "two_prime_O_methylinosine",
            "def": "2'-O-methylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001281": {
            "name": "three_methylcytidine",
            "def": "3-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001282": {
            "name": "five_methylcytidine",
            "def": "5-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001283": {
            "name": "two_prime_O_methylcytidine",
            "def": "2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001284": {
            "name": "two_thiocytidine",
            "def": "2-thiocytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001285": {
            "name": "N4_acetylcytidine",
            "def": "N4-acetylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001286": {
            "name": "five_formylcytidine",
            "def": "5-formylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001287": {
            "name": "five_two_prime_O_dimethylcytidine",
            "def": "5,2'-O-dimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001288": {
            "name": "N4_acetyl_2_prime_O_methylcytidine",
            "def": "N4-acetyl-2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001289": {
            "name": "lysidine",
            "def": "Lysidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001290": {
            "name": "N4_methylcytidine",
            "def": "N4-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001291": {
            "name": "N4_2_prime_O_dimethylcytidine",
            "def": "N4,2'-O-dimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001292": {
            "name": "five_hydroxymethylcytidine",
            "def": "5-hydroxymethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001293": {
            "name": "five_formyl_two_prime_O_methylcytidine",
            "def": "5-formyl-2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001294": {
            "name": "N4_N4_2_prime_O_trimethylcytidine",
            "def": "N4_N4_2_prime_O_trimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001295": {
            "name": "one_methyladenosine",
            "def": "1_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001296": {
            "name": "two_methyladenosine",
            "def": "2_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001297": {
            "name": "N6_methyladenosine",
            "def": "N6_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001298": {
            "name": "two_prime_O_methyladenosine",
            "def": "2prime_O_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001299": {
            "name": "two_methylthio_N6_methyladenosine",
            "def": "2_methylthio_N6_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001300": {
            "name": "N6_isopentenyladenosine",
            "def": "N6_isopentenyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001301": {
            "name": "two_methylthio_N6_isopentenyladenosine",
            "def": "2_methylthio_N6_isopentenyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001302": {
            "name": "N6_cis_hydroxyisopentenyl_adenosine",
            "def": "N6_cis_hydroxyisopentenyl_adenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001303": {
            "name": "two_methylthio_N6_cis_hydroxyisopentenyl_adenosine",
            "def": "2_methylthio_N6_cis_hydroxyisopentenyl_adenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001304": {
            "name": "N6_glycinylcarbamoyladenosine",
            "def": "N6_glycinylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001305": {
            "name": "N6_threonylcarbamoyladenosine",
            "def": "N6_threonylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001306": {
            "name": "two_methylthio_N6_threonyl_carbamoyladenosine",
            "def": "2_methylthio_N6_threonyl_carbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001307": {
            "name": "N6_methyl_N6_threonylcarbamoyladenosine",
            "def": "N6_methyl_N6_threonylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001308": {
            "name": "N6_hydroxynorvalylcarbamoyladenosine",
            "def": "N6_hydroxynorvalylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001309": {
            "name": "two_methylthio_N6_hydroxynorvalyl_carbamoyladenosine",
            "def": "2_methylthio_N6_hydroxynorvalyl_carbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001310": {
            "name": "two_prime_O_ribosyladenosine_phosphate",
            "def": "2prime_O_ribosyladenosine_phosphate is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001311": {
            "name": "N6_N6_dimethyladenosine",
            "def": "N6_N6_dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001312": {
            "name": "N6_2_prime_O_dimethyladenosine",
            "def": "N6_2prime_O_dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001313": {
            "name": "N6_N6_2_prime_O_trimethyladenosine",
            "def": "N6_N6_2prime_O_trimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001314": {
            "name": "one_two_prime_O_dimethyladenosine",
            "def": "1,2'-O-dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001315": {
            "name": "N6_acetyladenosine",
            "def": "N6_acetyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001316": {
            "name": "seven_deazaguanosine",
            "def": "7-deazaguanosine is a modified guanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001317": {
            "name": "queuosine",
            "def": "Queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001318": {
            "name": "epoxyqueuosine",
            "def": "Epoxyqueuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001319": {
            "name": "galactosyl_queuosine",
            "def": "Galactosyl_queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001320": {
            "name": "mannosyl_queuosine",
            "def": "Mannosyl_queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001321": {
            "name": "seven_cyano_seven_deazaguanosine",
            "def": "7_cyano_7_deazaguanosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001322": {
            "name": "seven_aminomethyl_seven_deazaguanosine",
            "def": "7_aminomethyl_7_deazaguanosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001323": {
            "name": "archaeosine",
            "def": "Archaeosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001324": {
            "name": "one_methylguanosine",
            "def": "1_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001325": {
            "name": "N2_methylguanosine",
            "def": "N2_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001326": {
            "name": "seven_methylguanosine",
            "def": "7_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001327": {
            "name": "two_prime_O_methylguanosine",
            "def": "2prime_O_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001328": {
            "name": "N2_N2_dimethylguanosine",
            "def": "N2_N2_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001329": {
            "name": "N2_2_prime_O_dimethylguanosine",
            "def": "N2_2prime_O_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001330": {
            "name": "N2_N2_2_prime_O_trimethylguanosine",
            "def": "N2_N2_2prime_O_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001331": {
            "name": "two_prime_O_ribosylguanosine_phosphate",
            "def": "2prime_O_ribosylguanosine_phosphate is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001332": {
            "name": "wybutosine",
            "def": "Wybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001333": {
            "name": "peroxywybutosine",
            "def": "Peroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001334": {
            "name": "hydroxywybutosine",
            "def": "Hydroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001335": {
            "name": "undermodified_hydroxywybutosine",
            "def": "Undermodified_hydroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001336": {
            "name": "wyosine",
            "def": "Wyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001337": {
            "name": "methylwyosine",
            "def": "Methylwyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001338": {
            "name": "N2_7_dimethylguanosine",
            "def": "N2_7_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001339": {
            "name": "N2_N2_7_trimethylguanosine",
            "def": "N2_N2_7_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001340": {
            "name": "one_two_prime_O_dimethylguanosine",
            "def": "1_2prime_O_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001341": {
            "name": "four_demethylwyosine",
            "def": "4_demethylwyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001342": {
            "name": "isowyosine",
            "def": "Isowyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001343": {
            "name": "N2_7_2prirme_O_trimethylguanosine",
            "def": "N2_7_2prirme_O_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001344": {
            "name": "five_methyluridine",
            "def": "5_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001345": {
            "name": "two_prime_O_methyluridine",
            "def": "2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001346": {
            "name": "five_two_prime_O_dimethyluridine",
            "def": "5_2_prime_O_dimethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001347": {
            "name": "one_methylpseudouridine",
            "def": "1_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001348": {
            "name": "two_prime_O_methylpseudouridine",
            "def": "2prime_O_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001349": {
            "name": "two_thiouridine",
            "def": "2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001350": {
            "name": "four_thiouridine",
            "def": "4_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001351": {
            "name": "five_methyl_2_thiouridine",
            "def": "5_methyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001352": {
            "name": "two_thio_two_prime_O_methyluridine",
            "def": "2_thio_2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001353": {
            "name": "three_three_amino_three_carboxypropyl_uridine",
            "def": "3_3_amino_3_carboxypropyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001354": {
            "name": "five_hydroxyuridine",
            "def": "5_hydroxyuridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001355": {
            "name": "five_methoxyuridine",
            "def": "5_methoxyuridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001356": {
            "name": "uridine_five_oxyacetic_acid",
            "def": "Uridine_5_oxyacetic_acid is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001357": {
            "name": "uridine_five_oxyacetic_acid_methyl_ester",
            "def": "Uridine_5_oxyacetic_acid_methyl_ester is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001358": {
            "name": "five_carboxyhydroxymethyl_uridine",
            "def": "5_carboxyhydroxymethyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001359": {
            "name": "five_carboxyhydroxymethyl_uridine_methyl_ester",
            "def": "5_carboxyhydroxymethyl_uridine_methyl_ester is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001360": {
            "name": "five_methoxycarbonylmethyluridine",
            "def": "Five_methoxycarbonylmethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001361": {
            "name": "five_methoxycarbonylmethyl_two_prime_O_methyluridine",
            "def": "Five_methoxycarbonylmethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001362": {
            "name": "five_methoxycarbonylmethyl_two_thiouridine",
            "def": "5_methoxycarbonylmethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001363": {
            "name": "five_aminomethyl_two_thiouridine",
            "def": "5_aminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001364": {
            "name": "five_methylaminomethyluridine",
            "def": "5_methylaminomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001365": {
            "name": "five_methylaminomethyl_two_thiouridine",
            "def": "5_methylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001366": {
            "name": "five_methylaminomethyl_two_selenouridine",
            "def": "5_methylaminomethyl_2_selenouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001367": {
            "name": "five_carbamoylmethyluridine",
            "def": "5_carbamoylmethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001368": {
            "name": "five_carbamoylmethyl_two_prime_O_methyluridine",
            "def": "5_carbamoylmethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001369": {
            "name": "five_carboxymethylaminomethyluridine",
            "def": "5_carboxymethylaminomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001370": {
            "name": "five_carboxymethylaminomethyl_two_prime_O_methyluridine",
            "def": "5_carboxymethylaminomethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001371": {
            "name": "five_carboxymethylaminomethyl_two_thiouridine",
            "def": "5_carboxymethylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001372": {
            "name": "three_methyluridine",
            "def": "3_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001373": {
            "name": "one_methyl_three_three_amino_three_carboxypropyl_pseudouridine",
            "def": "1_methyl_3_3_amino_3_carboxypropyl_pseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001374": {
            "name": "five_carboxymethyluridine",
            "def": "5_carboxymethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001375": {
            "name": "three_two_prime_O_dimethyluridine",
            "def": "3_2prime_O_dimethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001376": {
            "name": "five_methyldihydrouridine",
            "def": "5_methyldihydrouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001377": {
            "name": "three_methylpseudouridine",
            "def": "3_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001378": {
            "name": "five_taurinomethyluridine",
            "def": "5_taurinomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001379": {
            "name": "five_taurinomethyl_two_thiouridine",
            "def": "5_taurinomethyl_2_thiouridineis a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001380": {
            "name": "five_isopentenylaminomethyl_uridine",
            "def": "5_isopentenylaminomethyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001381": {
            "name": "five_isopentenylaminomethyl_two_thiouridine",
            "def": "5_isopentenylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001382": {
            "name": "five_isopentenylaminomethyl_two_prime_O_methyluridine",
            "def": "5_isopentenylaminomethyl_2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001383": {
            "name": "histone_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues of a histone. [SO:ke]"
          },
          "SO:0001384": {
            "name": "CDS_fragment"
          },
          "SO:0001385": {
            "name": "modified_amino_acid_feature",
            "def": "A post translationally modified amino acid feature. [SO:ke]"
          },
          "SO:0001386": {
            "name": "modified_glycine",
            "def": "A post translationally modified glycine amino acid feature. [SO:ke]"
          },
          "SO:0001387": {
            "name": "modified_L_alanine",
            "def": "A post translationally modified alanine amino acid feature. [SO:ke]"
          },
          "SO:0001388": {
            "name": "modified_L_asparagine",
            "def": "A post translationally modified asparagine amino acid feature. [SO:ke]"
          },
          "SO:0001389": {
            "name": "modified_L_aspartic_acid",
            "def": "A post translationally modified aspartic acid amino acid feature. [SO:ke]"
          },
          "SO:0001390": {
            "name": "modified_L_cysteine",
            "def": "A post translationally modified cysteine amino acid feature. [SO:ke]"
          },
          "SO:0001391": {
            "name": "modified_L_glutamic_acid"
          },
          "SO:0001392": {
            "name": "modified_L_threonine",
            "def": "A post translationally modified threonine amino acid feature. [SO:ke]"
          },
          "SO:0001393": {
            "name": "modified_L_tryptophan",
            "def": "A post translationally modified tryptophan amino acid feature. [SO:ke]"
          },
          "SO:0001394": {
            "name": "modified_L_glutamine",
            "def": "A post translationally modified glutamine amino acid feature. [SO:ke]"
          },
          "SO:0001395": {
            "name": "modified_L_methionine",
            "def": "A post translationally modified methionine amino acid feature. [SO:ke]"
          },
          "SO:0001396": {
            "name": "modified_L_isoleucine",
            "def": "A post translationally modified isoleucine amino acid feature. [SO:ke]"
          },
          "SO:0001397": {
            "name": "modified_L_phenylalanine",
            "def": "A post translationally modified phenylalanine amino acid feature. [SO:ke]"
          },
          "SO:0001398": {
            "name": "modified_L_histidine",
            "def": "A post translationally modified histidine amino acid feature. [SO:ke]"
          },
          "SO:0001399": {
            "name": "modified_L_serine",
            "def": "A post translationally modified serine amino acid feature. [SO:ke]"
          },
          "SO:0001400": {
            "name": "modified_L_lysine",
            "def": "A post translationally modified lysine amino acid feature. [SO:ke]"
          },
          "SO:0001401": {
            "name": "modified_L_leucine",
            "def": "A post translationally modified leucine amino acid feature. [SO:ke]"
          },
          "SO:0001402": {
            "name": "modified_L_selenocysteine",
            "def": "A post translationally modified selenocysteine amino acid feature. [SO:ke]"
          },
          "SO:0001403": {
            "name": "modified_L_valine",
            "def": "A post translationally modified valine amino acid feature. [SO:ke]"
          },
          "SO:0001404": {
            "name": "modified_L_proline",
            "def": "A post translationally modified proline amino acid feature. [SO:ke]"
          },
          "SO:0001405": {
            "name": "modified_L_tyrosine",
            "def": "A post translationally modified tyrosine amino acid feature. [SO:ke]"
          },
          "SO:0001406": {
            "name": "modified_L_arginine",
            "def": "A post translationally modified arginine amino acid feature. [SO:ke]"
          },
          "SO:0001407": {
            "name": "peptidyl",
            "def": "An attribute describing the nature of a proteinaceous polymer, where by the amino acid units are joined by peptide bonds. [SO:ke]"
          },
          "SO:0001408": {
            "name": "cleaved_for_gpi_anchor_region",
            "def": "The C-terminal residues of a polypeptide which are exchanged for a GPI-anchor. [EBI:rh]"
          },
          "SO:0001409": {
            "name": "biomaterial_region",
            "def": "A region which is intended for use in an experiment. [SO:cb]"
          },
          "SO:0001410": {
            "name": "experimental_feature",
            "def": "A region which is the result of some arbitrary experimental procedure. The procedure may be carried out with biological material or inside a computer. [SO:cb]"
          },
          "SO:0001411": {
            "name": "biological_region",
            "def": "A region defined by its disposition to be involved in a biological process. [SO:cb]"
          },
          "SO:0001412": {
            "name": "topologically_defined_region",
            "def": "A region that is defined according to its relations with other regions within the same sequence. [SO:cb]"
          },
          "SO:0001413": {
            "name": "translocation_breakpoint",
            "def": "The point within a chromosome where a translocation begins or ends. [SO:cb]"
          },
          "SO:0001414": {
            "name": "insertion_breakpoint",
            "def": "The point within a chromosome where a insertion begins or ends. [SO:cb]"
          },
          "SO:0001415": {
            "name": "deletion_breakpoint",
            "def": "The point within a chromosome where a deletion begins or ends. [SO:cb]"
          },
          "SO:0001416": {
            "name": "five_prime_flanking_region",
            "def": "A flanking region located five prime of a specific region. [SO:chado]"
          },
          "SO:0001417": {
            "name": "three_prime_flanking_region",
            "def": "A flanking region located three prime of a specific region. [SO:chado]"
          },
          "SO:0001418": {
            "name": "transcribed_fragment",
            "def": "An experimental region, defined by a tiling array experiment to be transcribed at some level. [SO:ke]"
          },
          "SO:0001419": {
            "name": "cis_splice_site",
            "def": "Intronic 2 bp region bordering exon. A splice_site that adjacent_to exon and overlaps intron. [SO:cjm, SO:ke]"
          },
          "SO:0001420": {
            "name": "trans_splice_site",
            "def": "Primary transcript region bordering trans-splice junction. [SO:ke]"
          },
          "SO:0001421": {
            "name": "splice_junction",
            "def": "The boundary between an intron and an exon. [SO:ke]"
          },
          "SO:0001422": {
            "name": "conformational_switch",
            "def": "A region of a polypeptide, involved in the transition from one conformational state to another. [SO:ke]"
          },
          "SO:0001423": {
            "name": "dye_terminator_read",
            "def": "A read produced by the dye terminator method of sequencing. [SO:ke]"
          },
          "SO:0001424": {
            "name": "pyrosequenced_read",
            "def": "A read produced by pyrosequencing technology. [SO:ke]"
          },
          "SO:0001425": {
            "name": "ligation_based_read",
            "def": "A read produced by ligation based sequencing technologies. [SO:ke]"
          },
          "SO:0001426": {
            "name": "polymerase_synthesis_read",
            "def": "A read produced by the polymerase based sequence by synthesis method. [SO:ke]"
          },
          "SO:0001427": {
            "name": "cis_regulatory_frameshift_element",
            "def": "A structural region in an RNA molecule which promotes ribosomal frameshifting of cis coding sequence. [RFAM:jd]"
          },
          "SO:0001428": {
            "name": "expressed_sequence_assembly",
            "def": "A sequence assembly derived from expressed sequences. [SO:ke]"
          },
          "SO:0001429": {
            "name": "DNA_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with DNA. [SO:ke]"
          },
          "SO:0001431": {
            "name": "cryptic_gene",
            "def": "A gene that is not transcribed under normal conditions and is not critical to normal cellular functioning. [SO:ke]"
          },
          "SO:0001432": {
            "name": "sequence_variant_affecting_polyadenylation"
          },
          "SO:0001433": {
            "name": "three_prime_RACE_clone",
            "def": "A three prime RACE (Rapid Amplification of cDNA Ends) clone is a cDNA clone copied from the 3' end of an mRNA (using a poly-dT primer to capture the polyA tail and a gene-specific or randomly primed 5' primer), and spliced into a vector for propagation in a suitable host. [modENCODE:nlw]"
          },
          "SO:0001434": {
            "name": "cassette_pseudogene",
            "def": "A cassette pseudogene is a kind of gene in an inactive form which may recombine at a telomeric locus to form a functional copy. [SO:ke]"
          },
          "SO:0001435": {
            "name": "alanine"
          },
          "SO:0001436": {
            "name": "valine"
          },
          "SO:0001437": {
            "name": "leucine"
          },
          "SO:0001438": {
            "name": "isoleucine"
          },
          "SO:0001439": {
            "name": "proline"
          },
          "SO:0001440": {
            "name": "tryptophan"
          },
          "SO:0001441": {
            "name": "phenylalanine"
          },
          "SO:0001442": {
            "name": "methionine"
          },
          "SO:0001443": {
            "name": "glycine"
          },
          "SO:0001444": {
            "name": "serine"
          },
          "SO:0001445": {
            "name": "threonine"
          },
          "SO:0001446": {
            "name": "tyrosine"
          },
          "SO:0001447": {
            "name": "cysteine"
          },
          "SO:0001448": {
            "name": "glutamine"
          },
          "SO:0001449": {
            "name": "asparagine"
          },
          "SO:0001450": {
            "name": "lysine"
          },
          "SO:0001451": {
            "name": "arginine"
          },
          "SO:0001452": {
            "name": "histidine"
          },
          "SO:0001453": {
            "name": "aspartic_acid"
          },
          "SO:0001454": {
            "name": "glutamic_acid"
          },
          "SO:0001455": {
            "name": "selenocysteine"
          },
          "SO:0001456": {
            "name": "pyrrolysine"
          },
          "SO:0001457": {
            "name": "transcribed_cluster",
            "def": "A region defined by a set of transcribed sequences from the same gene or expressed pseudogene. [SO:ke]"
          },
          "SO:0001458": {
            "name": "unigene_cluster",
            "def": "A kind of transcribed_cluster defined by a set of transcribed sequences from the a unique gene. [SO:ke]"
          },
          "SO:0001459": {
            "name": "CRISPR",
            "def": "Clustered Palindromic Repeats interspersed with bacteriophage derived spacer sequences. [RFAM:jd]"
          },
          "SO:0001460": {
            "name": "insulator_binding_site",
            "def": "A binding site that, in an insulator region of a nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
          },
          "SO:0001461": {
            "name": "enhancer_binding_site",
            "def": "A binding site that, in the enhancer region of a nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
          },
          "SO:0001462": {
            "name": "contig_collection",
            "def": "A collection of contigs. [SO:ke]"
          },
          "SO:0001463": {
            "name": "lincRNA",
            "def": "A multiexonic non-coding RNA transcribed by RNA polymerase II. [PMID:19182780, SO:ke]"
          },
          "SO:0001464": {
            "name": "UST",
            "def": "An EST spanning part or all of the untranslated regions of a protein-coding transcript. [SO:nlw]"
          },
          "SO:0001465": {
            "name": "three_prime_UST",
            "def": "A UST located in the 3'UTR of a protein-coding transcript. [SO:nlw]"
          },
          "SO:0001466": {
            "name": "five_prime_UST",
            "def": "An UST located in the 5'UTR of a protein-coding transcript. [SO:nlw]"
          },
          "SO:0001467": {
            "name": "RST",
            "def": "A tag produced from a single sequencing read from a RACE product; typically a few hundred base pairs long. [SO:nlw]"
          },
          "SO:0001468": {
            "name": "three_prime_RST",
            "def": "A tag produced from a single sequencing read from a 3'-RACE product; typically a few hundred base pairs long. [SO:nlw]"
          },
          "SO:0001469": {
            "name": "five_prime_RST",
            "def": "A tag produced from a single sequencing read from a 5'-RACE product; typically a few hundred base pairs long. [SO:nlw]"
          },
          "SO:0001470": {
            "name": "UST_match",
            "def": "A match against an UST sequence. [SO:nlw]"
          },
          "SO:0001471": {
            "name": "RST_match",
            "def": "A match against an RST sequence. [SO:nlw]"
          },
          "SO:0001472": {
            "name": "primer_match",
            "def": "A nucleotide match to a primer sequence. [SO:nlw]"
          },
          "SO:0001473": {
            "name": "miRNA_antiguide",
            "def": "A region of the pri miRNA that base pairs with the guide to form the hairpin. [SO:ke]"
          },
          "SO:0001474": {
            "name": "trans_splice_junction",
            "def": "The boundary between the spliced leader and the first exon of the mRNA. [SO:ke]"
          },
          "SO:0001475": {
            "name": "outron",
            "def": "A region of a primary transcript, that is removed via trans splicing. [PMID:16401417, SO:ke]"
          },
          "SO:0001476": {
            "name": "natural_plasmid",
            "def": "A plasmid that occurs naturally. [SO:xp]"
          },
          "SO:0001477": {
            "name": "gene_trap_construct",
            "def": "A gene trap construct is a type of engineered plasmid which is designed to integrate into a genome and produce a fusion transcript between exons of the gene into which it inserts and a reporter element in the construct. Gene traps contain a splice acceptor, do not contain promoter elements for the reporter, and are mutagenic. Gene traps may be bicistronic with the second cassette containing a promoter driving an a selectable marker. [ZFIN:dh]"
          },
          "SO:0001478": {
            "name": "promoter_trap_construct",
            "def": "A promoter trap construct is a type of engineered plasmid which is designed to integrate into a genome and express a reporter when inserted in close proximity to a promoter element. Promoter traps typically do not contain promoter elements and are mutagenic. [ZFIN:dh]"
          },
          "SO:0001479": {
            "name": "enhancer_trap_construct",
            "def": "An enhancer trap construct is a type of engineered plasmid which is designed to integrate into a genome and express a reporter when the expression from a basic minimal promoter is enhanced by genomic enhancer elements. Enhancer traps contain promoter elements and are not usually mutagenic. [ZFIN:dh]"
          },
          "SO:0001480": {
            "name": "PAC_end",
            "def": "A region of sequence from the end of a PAC clone that may provide a highly specific marker. [ZFIN:mh]"
          },
          "SO:0001481": {
            "name": "RAPD",
            "def": "RAPD is a 'PCR product' where a sequence variant is identified through the use of PCR with random primers. [ZFIN:mh]"
          },
          "SO:0001482": {
            "name": "shadow_enhancer"
          },
          "SO:0001483": {
            "name": "SNV",
            "def": "SNVs are single nucleotide positions in genomic DNA at which different sequence alternatives exist. [SO:bm]"
          },
          "SO:0001484": {
            "name": "X_element_combinatorial_repeat",
            "def": "An X element combinatorial repeat is a repeat region located between the X element and the telomere or adjacent Y' element. [http://www.yeastgenome.org/help/glossary.html]"
          },
          "SO:0001485": {
            "name": "Y_prime_element",
            "def": "A Y' element is a repeat region (SO:0000657) located adjacent to telomeric repeats or X element combinatorial repeats, either as a single copy or tandem repeat of two to four copies. [http:http://www.yeastgenome.org/help/glossary.html]"
          },
          "SO:0001486": {
            "name": "standard_draft",
            "def": "The status of a whole genome sequence, where the data is minimally filtered or un-filtered, from any number of sequencing platforms, and is assembled into contigs. Genome sequence of this quality may harbour regions of poor quality and can be relatively incomplete. [DOI:10.1126]"
          },
          "SO:0001487": {
            "name": "high_quality_draft",
            "def": "The status of a whole genome sequence, where overall coverage represents at least 90 percent of the genome. [DOI:10.1126]"
          },
          "SO:0001488": {
            "name": "improved_high_quality_draft",
            "def": "The status of a whole genome sequence, where additional work has been performed, using either manual or automated methods, such as gap resolution. [DOI:10.1126]"
          },
          "SO:0001489": {
            "name": "annotation_directed_improved_draft",
            "def": "The status of a whole genome sequence,where annotation, and verification of coding regions has occurred. [DOI:10.1126]"
          },
          "SO:0001490": {
            "name": "noncontiguous_finished",
            "def": "The status of a whole genome sequence, where the assembly is high quality, closure approaches have been successful for most gaps, misassemblies and low quality regions. [DOI:10.1126]"
          },
          "SO:0001491": {
            "name": "finished_genome",
            "def": "The status of a whole genome sequence, with less than 1 error per 100,000 base pairs. [DOI:10.1126]"
          },
          "SO:0001492": {
            "name": "intronic_regulatory_region",
            "def": "A regulatory region that is part of an intron. [SO:ke]"
          },
          "SO:0001493": {
            "name": "centromere_DNA_Element_I",
            "def": "A centromere DNA Element I (CDEI) is a conserved region, part of the centromere, consisting of a consensus region composed of 8-11bp which enables binding by the centromere binding factor 1(Cbf1p). [PMID:11222754]"
          },
          "SO:0001494": {
            "name": "centromere_DNA_Element_II",
            "def": "A centromere DNA Element II (CDEII) is part a conserved region of the centromere, consisting of a consensus region that is AT-rich and ~ 75-100 bp in length. [PMID:11222754]"
          },
          "SO:0001495": {
            "name": "centromere_DNA_Element_III",
            "def": "A centromere DNA Element I (CDEI) is a conserved region, part of the centromere, consisting of a consensus region that consists of a 25-bp which enables binding by the centromere DNA binding factor 3 (CBF3) complex. [PMID:11222754]"
          },
          "SO:0001496": {
            "name": "telomeric_repeat",
            "def": "The telomeric repeat is a repeat region, part of the chromosome, which in yeast, is a G-rich terminal sequence of the form (TG(1-3))n or more precisely ((TG)(1-6)TG(2-3))n. [PMID:8720065]"
          },
          "SO:0001497": {
            "name": "X_element",
            "def": "The X element is a conserved region, of the telomere, of ~475 bp that contains an ARS sequence and in most cases an Abf1p binding site. [http://www.yeastgenome.org/help/glossary.html#xelemcoresequence, PMID:7785338, PMID:8005434]"
          },
          "SO:0001498": {
            "name": "YAC_end",
            "def": "A region of sequence from the end of a YAC clone that may provide a highly specific marker. [SO:ke]"
          },
          "SO:0001499": {
            "name": "whole_genome_sequence_status",
            "def": "The status of whole genome sequence. [DOI:10.1126]"
          },
          "SO:0001500": {
            "name": "heritable_phenotypic_marker",
            "def": "A biological_region characterized as a single heritable trait in a phenotype screen. The heritable phenotype may be mapped to a chromosome but generally has not been characterized to a specific gene locus. [JAX:hdene]"
          },
          "SO:0001501": {
            "name": "peptide_collection",
            "def": "A collection of peptide sequences. [BBOP:nlw]"
          },
          "SO:0001502": {
            "name": "high_identity_region",
            "def": "An experimental feature with high sequence identity to another sequence. [SO:ke]"
          },
          "SO:0001503": {
            "name": "processed_transcript",
            "def": "A transcript for which no open reading frame has been identified and for which no other function has been determined. [MGI:hdeen]"
          },
          "SO:0001504": {
            "name": "assortment_derived_variation",
            "def": "A chromosome variation derived from an event during meiosis. [SO:ke]"
          },
          "SO:0001505": {
            "name": "reference_genome",
            "def": "A collection of sequences (often chromosomes) taken as the standard for a given organism and genome assembly. [SO:ke]"
          },
          "SO:0001506": {
            "name": "variant_genome",
            "def": "A collection of sequences (often chromosomes) of an individual. [SO:ke]"
          },
          "SO:0001507": {
            "name": "variant_collection",
            "def": "A collection of one or more sequences of an individual. [SO:ke]"
          },
          "SO:0001508": {
            "name": "alteration_attribute"
          },
          "SO:0001509": {
            "name": "chromosomal_variation_attribute"
          },
          "SO:0001510": {
            "name": "intrachromosomal"
          },
          "SO:0001511": {
            "name": "interchromosomal"
          },
          "SO:0001512": {
            "name": "insertion_attribute",
            "def": "A quality of a chromosomal insertion,. [SO:ke]"
          },
          "SO:0001513": {
            "name": "tandem"
          },
          "SO:0001514": {
            "name": "direct",
            "def": "A quality of an insertion where the insert is not in a cytologically inverted orientation. [SO:ke]"
          },
          "SO:0001515": {
            "name": "inverted",
            "def": "A quality of an insertion where the insert is in a cytologically inverted orientation. [SO:ke]"
          },
          "SO:0001516": {
            "name": "free",
            "def": "The quality of a duplication where the new region exists independently of the original. [SO:ke]"
          },
          "SO:0001517": {
            "name": "inversion_attribute"
          },
          "SO:0001518": {
            "name": "pericentric"
          },
          "SO:0001519": {
            "name": "paracentric"
          },
          "SO:0001520": {
            "name": "translocaton_attribute"
          },
          "SO:0001521": {
            "name": "reciprocal"
          },
          "SO:0001522": {
            "name": "insertional"
          },
          "SO:0001523": {
            "name": "duplication_attribute"
          },
          "SO:0001524": {
            "name": "chromosomally_aberrant_genome"
          },
          "SO:0001525": {
            "name": "assembly_error_correction",
            "def": "A region of sequence where the final nucleotide assignment differs from the original assembly due to an improvement that replaces a mistake. [SO:ke]"
          },
          "SO:0001526": {
            "name": "base_call_error_correction",
            "def": "A region of sequence where the final nucleotide assignment is different from that given by the base caller due to an improvement that replaces a mistake. [SO:ke]"
          },
          "SO:0001527": {
            "name": "peptide_localization_signal",
            "def": "A region of peptide sequence used to target the polypeptide molecule to a specific organelle. [SO:ke]"
          },
          "SO:0001528": {
            "name": "nuclear_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the nucleus. [SO:ke]"
          },
          "SO:0001529": {
            "name": "endosomal_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the endosome. [SO:ke]"
          },
          "SO:0001530": {
            "name": "lysosomal_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the lysosome. [SO:ke]"
          },
          "SO:0001531": {
            "name": "nuclear_export_signal",
            "def": "A polypeptide region that targets a polypeptide to he cytoplasm. [SO:ke]"
          },
          "SO:0001532": {
            "name": "recombination_signal_sequence",
            "def": "A region recognized by a recombinase. [SO:ke]"
          },
          "SO:0001533": {
            "name": "cryptic_splice_site",
            "def": "A splice site that is in part of the transcript not normally spliced. They occur via mutation or transcriptional error. [SO:ke]"
          },
          "SO:0001534": {
            "name": "nuclear_rim_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the nuclear rim. [SO:ke]"
          },
          "SO:0001535": {
            "name": "p_element",
            "def": "A P_element is a DNA transposon responsible for hybrid dysgenesis. [SO:ke]"
          },
          "SO:0001536": {
            "name": "functional_variant",
            "def": "A sequence variant in which the function of a gene product is altered with respect to a reference. [SO:ke]"
          },
          "SO:0001537": {
            "name": "structural_variant",
            "def": "A sequence variant that changes one or more sequence features. [SO:ke]"
          },
          "SO:0001538": {
            "name": "transcript_function_variant",
            "def": "A sequence variant which alters the functioning of a transcript with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001539": {
            "name": "translational_product_function_variant",
            "def": "A sequence variant that affects the functioning of a translational product with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001540": {
            "name": "level_of_transcript_variant",
            "def": "A sequence variant which alters the level of a transcript. [SO:ke]"
          },
          "SO:0001541": {
            "name": "decreased_transcript_level_variant",
            "def": "A sequence variant that increases the level of mature, spliced and processed RNA with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001542": {
            "name": "increased_transcript_level_variant",
            "def": "A sequence variant that increases the level of mature, spliced and processed RNA with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001543": {
            "name": "transcript_processing_variant",
            "def": "A sequence variant that affects the post transcriptional processing of a transcript with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001544": {
            "name": "editing_variant",
            "def": "A transcript processing variant whereby the process of editing is disrupted with respect to the reference. [SO:ke]"
          },
          "SO:0001545": {
            "name": "polyadenylation_variant",
            "def": "A sequence variant that changes polyadenylation with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001546": {
            "name": "transcript_stability_variant",
            "def": "A variant that changes the stability of a transcript with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001547": {
            "name": "decreased_transcript_stability_variant",
            "def": "A sequence variant that decreases transcript stability with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001548": {
            "name": "increased_transcript_stability_variant",
            "def": "A sequence variant that increases transcript stability with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001549": {
            "name": "transcription_variant",
            "def": "A variant that changes alters the transcription of a transcript with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001550": {
            "name": "rate_of_transcription_variant",
            "def": "A sequence variant that changes the rate of transcription with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001551": {
            "name": "increased_transcription_rate_variant",
            "def": "A sequence variant that increases the rate of transcription with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001552": {
            "name": "decreased_transcription_rate_variant",
            "def": "A sequence variant that decreases the rate of transcription with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001553": {
            "name": "translational_product_level_variant",
            "def": "A functional variant that changes the translational product level with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001554": {
            "name": "polypeptide_function_variant",
            "def": "A sequence variant which changes polypeptide functioning with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001555": {
            "name": "decreased_translational_product_level",
            "def": "A sequence variant which decreases the translational product level with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001556": {
            "name": "increased_translational_product_level",
            "def": "A sequence variant which increases the translational product level with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001557": {
            "name": "polypeptide_gain_of_function_variant",
            "def": "A sequence variant which causes gain of polypeptide function with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001558": {
            "name": "polypeptide_localization_variant",
            "def": "A sequence variant which changes the localization of a polypeptide with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001559": {
            "name": "polypeptide_loss_of_function_variant",
            "def": "A sequence variant that causes the loss of a polypeptide function with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001560": {
            "name": "inactive_ligand_binding_site",
            "def": "A sequence variant that causes the inactivation of a ligand binding site with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001561": {
            "name": "polypeptide_partial_loss_of_function",
            "def": "A sequence variant that causes some but not all loss of polypeptide function with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001562": {
            "name": "polypeptide_post_translational_processing_variant",
            "def": "A sequence variant that causes a change in post translational processing of the peptide with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001563": {
            "name": "copy_number_change",
            "def": "A sequence variant where copies of a feature (CNV) are either increased or decreased. [SO:ke]"
          },
          "SO:0001564": {
            "name": "gene_variant",
            "def": "A sequence variant where the structure of the gene is changed. [SO:ke]"
          },
          "SO:0001565": {
            "name": "gene_fusion",
            "def": "A sequence variant whereby a two genes have become joined. [SO:ke]"
          },
          "SO:0001566": {
            "name": "regulatory_region_variant",
            "def": "A sequence variant located within a regulatory region. [SO:ke]"
          },
          "SO:0001567": {
            "name": "stop_retained_variant",
            "def": "A sequence variant where at least one base in the terminator codon is changed, but the terminator remains. [SO:ke]"
          },
          "SO:0001568": {
            "name": "splicing_variant",
            "def": "A sequence variant that changes the process of splicing. [SO:ke]"
          },
          "SO:0001569": {
            "name": "cryptic_splice_site_variant",
            "def": "A sequence variant causing a new (functional) splice site. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:0001570": {
            "name": "cryptic_splice_acceptor",
            "def": "A sequence variant whereby a new splice site is created due to the activation of a new acceptor. [SO:ke]"
          },
          "SO:0001571": {
            "name": "cryptic_splice_donor",
            "def": "A sequence variant whereby a new splice site is created due to the activation of a new donor. [SO:ke]"
          },
          "SO:0001572": {
            "name": "exon_loss_variant",
            "def": "A sequence variant whereby an exon is lost from the transcript. [SO:ke]"
          },
          "SO:0001573": {
            "name": "intron_gain_variant",
            "def": "A sequence variant whereby an intron is gained by the processed transcript; usually a result of an alteration of the donor or acceptor. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:0001574": {
            "name": "splice_acceptor_variant",
            "def": "A splice variant that changes the 2 base region at the 3' end of an intron. [SO:ke]"
          },
          "SO:0001575": {
            "name": "splice_donor_variant",
            "def": "A splice variant that changes the 2 base pair region at the 5' end of an intron. [SO:ke]"
          },
          "SO:0001576": {
            "name": "transcript_variant",
            "def": "A sequence variant that changes the structure of the transcript. [SO:ke]"
          },
          "SO:0001577": {
            "name": "complex_transcript_variant",
            "def": "A transcript variant with a complex INDEL- Insertion or deletion that spans an exon/intron border or a coding sequence/UTR border. [http://ensembl.org/info/docs/variation/index.html]"
          },
          "SO:0001578": {
            "name": "stop_lost",
            "def": "A sequence variant where at least one base of the terminator codon (stop) is changed, resulting in an elongated transcript. [SO:ke]"
          },
          "SO:0001579": {
            "name": "transcript_sequence_variant"
          },
          "SO:0001580": {
            "name": "coding_sequence_variant",
            "def": "A sequence variant that changes the coding sequence. [SO:ke]"
          },
          "SO:0001582": {
            "name": "initiator_codon_variant",
            "def": "A codon variant that changes at least one base of the first codon of a transcript. [SO:ke]"
          },
          "SO:0001583": {
            "name": "missense_variant",
            "def": "A sequence variant, that changes one or more bases, resulting in a different amino acid sequence but where the length is preserved. [EBI:fc, EBI:gr, SO:ke]"
          },
          "SO:0001585": {
            "name": "conservative_missense_variant",
            "def": "A sequence variant whereby at least one base of a codon is changed resulting in a codon that encodes for a different but similar amino acid. These variants may or may not be deleterious. [SO:ke]"
          },
          "SO:0001586": {
            "name": "non_conservative_missense_variant",
            "def": "A sequence variant whereby at least one base of a codon is changed resulting in a codon that encodes for an amino acid with different biochemical properties. [SO:ke]"
          },
          "SO:0001587": {
            "name": "stop_gained",
            "def": "A sequence variant whereby at least one base of a codon is changed, resulting in a premature stop codon, leading to a shortened transcript. [SO:ke]"
          },
          "SO:0001589": {
            "name": "frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, because the number of nucleotides inserted or deleted is not a multiple of three. [SO:ke]"
          },
          "SO:0001590": {
            "name": "terminator_codon_variant",
            "def": "A sequence variant whereby at least one of the bases in the terminator codon is changed. [SO:ke]"
          },
          "SO:0001591": {
            "name": "frame_restoring_variant",
            "def": "A sequence variant that reverts the sequence of a previous frameshift mutation back to the initial frame. [SO:ke]"
          },
          "SO:0001592": {
            "name": "minus_1_frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, by shifting one base ahead. [http://arjournals.annualreviews.org/doi/pdf/10.1146/annurev.ge.08.120174.001535]"
          },
          "SO:0001593": {
            "name": "minus_2_frameshift_variant"
          },
          "SO:0001594": {
            "name": "plus_1_frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, by shifting one base backward. [http://arjournals.annualreviews.org/doi/pdf/10.1146/annurev.ge.08.120174.001535]"
          },
          "SO:0001595": {
            "name": "plus_2_frameshift_variant"
          },
          "SO:0001596": {
            "name": "transcript_secondary_structure_variant",
            "def": "A sequence variant within a transcript that changes the secondary structure of the RNA product. [SO:ke]"
          },
          "SO:0001597": {
            "name": "compensatory_transcript_secondary_structure_variant",
            "def": "A secondary structure variant that compensate for the change made by a previous variant. [SO:ke]"
          },
          "SO:0001598": {
            "name": "translational_product_structure_variant",
            "def": "A sequence variant within the transcript that changes the structure of the translational product. [SO:ke]"
          },
          "SO:0001599": {
            "name": "3D_polypeptide_structure_variant",
            "def": "A sequence variant that changes the resulting polypeptide structure. [SO:ke]"
          },
          "SO:0001600": {
            "name": "complex_3D_structural_variant",
            "def": "A sequence variant that changes the resulting polypeptide structure. [SO:ke]"
          },
          "SO:0001601": {
            "name": "conformational_change_variant",
            "def": "A sequence variant in the CDS region that causes a conformational change in the resulting polypeptide sequence. [SO:ke]"
          },
          "SO:0001602": {
            "name": "complex_change_of_translational_product_variant"
          },
          "SO:0001603": {
            "name": "polypeptide_sequence_variant",
            "def": "A sequence variant with in the CDS that causes a change in the resulting polypeptide sequence. [SO:ke]"
          },
          "SO:0001604": {
            "name": "amino_acid_deletion",
            "def": "A sequence variant within a CDS resulting in the loss of an amino acid from the resulting polypeptide. [SO:ke]"
          },
          "SO:0001605": {
            "name": "amino_acid_insertion",
            "def": "A sequence variant within a CDS resulting in the gain of an amino acid to the resulting polypeptide. [SO:ke]"
          },
          "SO:0001606": {
            "name": "amino_acid_substitution",
            "def": "A sequence variant of a codon resulting in the substitution of one amino acid for another in the resulting polypeptide. [SO:ke]"
          },
          "SO:0001607": {
            "name": "conservative_amino_acid_substitution",
            "def": "A sequence variant of a codon causing the substitution of a similar amino acid for another in the resulting polypeptide. [SO:ke]"
          },
          "SO:0001608": {
            "name": "non_conservative_amino_acid_substitution",
            "def": "A sequence variant of a codon causing the substitution of a non conservative amino acid for another in the resulting polypeptide. [SO:ke]"
          },
          "SO:0001609": {
            "name": "elongated_polypeptide",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence. [SO:ke]"
          },
          "SO:0001610": {
            "name": "elongated_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
          },
          "SO:0001611": {
            "name": "elongated_polypeptide_N_terminal",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
          },
          "SO:0001612": {
            "name": "elongated_in_frame_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes in frame elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
          },
          "SO:0001613": {
            "name": "elongated_out_of_frame_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes out of frame elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
          },
          "SO:0001614": {
            "name": "elongated_in_frame_polypeptide_N_terminal_elongation",
            "def": "A sequence variant with in the CDS that causes in frame elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
          },
          "SO:0001615": {
            "name": "elongated_out_of_frame_polypeptide_N_terminal",
            "def": "A sequence variant with in the CDS that causes out of frame elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
          },
          "SO:0001616": {
            "name": "polypeptide_fusion",
            "def": "A sequence variant that causes a fusion of two polypeptide sequences. [SO:ke]"
          },
          "SO:0001617": {
            "name": "polypeptide_truncation",
            "def": "A sequence variant of the CD that causes a truncation of the resulting polypeptide. [SO:ke]"
          },
          "SO:0001618": {
            "name": "inactive_catalytic_site",
            "def": "A sequence variant that causes the inactivation of a catalytic site with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001619": {
            "name": "non_coding_transcript_variant",
            "def": "A transcript variant of a non coding RNA gene. [SO:ke]"
          },
          "SO:0001620": {
            "name": "mature_miRNA_variant",
            "def": "A transcript variant located with the sequence of the mature miRNA. [SO:ke]"
          },
          "SO:0001621": {
            "name": "NMD_transcript_variant",
            "def": "A variant in a transcript that is the target of NMD. [SO:ke]"
          },
          "SO:0001622": {
            "name": "UTR_variant",
            "def": "A transcript variant that is located within the UTR. [SO:ke]"
          },
          "SO:0001623": {
            "name": "5_prime_UTR_variant",
            "def": "A UTR variant of the 5' UTR. [SO:ke]"
          },
          "SO:0001624": {
            "name": "3_prime_UTR_variant",
            "def": "A UTR variant of the 3' UTR. [SO:ke]"
          },
          "SO:0001626": {
            "name": "incomplete_terminal_codon_variant",
            "def": "A sequence variant where at least one base of the final codon of an incompletely annotated transcript is changed. [SO:ke]"
          },
          "SO:0001627": {
            "name": "intron_variant",
            "def": "A transcript variant occurring within an intron. [SO:ke]"
          },
          "SO:0001628": {
            "name": "intergenic_variant",
            "def": "A sequence variant located in the intergenic region, between genes. [SO:ke]"
          },
          "SO:0001629": {
            "name": "splice_site_variant",
            "def": "A sequence variant that changes the first two or last two bases of an intron, or the 5th base from the start of the intron in the orientation of the transcript. [http://ensembl.org/info/docs/variation/index.html]"
          },
          "SO:0001630": {
            "name": "splice_region_variant",
            "def": "A sequence variant in which a change has occurred within the region of the splice site, either within 1-3 bases of the exon or 3-8 bases of the intron. [http://ensembl.org/info/docs/variation/index.html]"
          },
          "SO:0001631": {
            "name": "upstream_gene_variant",
            "def": "A sequence variant located 5' of a gene. [SO:ke]"
          },
          "SO:0001632": {
            "name": "downstream_gene_variant",
            "def": "A sequence variant located 3' of a gene. [SO:ke]"
          },
          "SO:0001633": {
            "name": "5KB_downstream_variant",
            "def": "A sequence variant located within 5 KB of the end of a gene. [SO:ke]"
          },
          "SO:0001634": {
            "name": "500B_downstream_variant",
            "def": "A sequence variant located within a half KB of the end of a gene. [SO:ke]"
          },
          "SO:0001635": {
            "name": "5KB_upstream_variant",
            "def": "A sequence variant located within 5KB 5' of a gene. [SO:ke]"
          },
          "SO:0001636": {
            "name": "2KB_upstream_variant",
            "def": "A sequence variant located within 2KB 5' of a gene. [SO:ke]"
          },
          "SO:0001637": {
            "name": "rRNA_gene",
            "def": "A gene that encodes for ribosomal RNA. [SO:ke]"
          },
          "SO:0001638": {
            "name": "piRNA_gene",
            "def": "A gene that encodes for an piwi associated RNA. [SO:ke]"
          },
          "SO:0001639": {
            "name": "RNase_P_RNA_gene",
            "def": "A gene that encodes an RNase P RNA. [SO:ke]"
          },
          "SO:0001640": {
            "name": "RNase_MRP_RNA_gene",
            "def": "A gene that encodes a RNase_MRP_RNA. [SO:ke]"
          },
          "SO:0001641": {
            "name": "lincRNA_gene",
            "def": "A gene that encodes large intervening non-coding RNA. [SO:ke]"
          },
          "SO:0001642": {
            "name": "mathematically_defined_repeat",
            "def": "A mathematically defined repeat (MDR) is a experimental feature that is determined by querying overlapping oligomers of length k against a database of shotgun sequence data and identifying regions in the query sequence that exceed a statistically determined threshold of repetitiveness. [SO:jestill]"
          },
          "SO:0001643": {
            "name": "telomerase_RNA_gene",
            "def": "A telomerase RNA gene is a non coding RNA gene the RNA product of which is a component of telomerase. [SO:ke]"
          },
          "SO:0001644": {
            "name": "targeting_vector",
            "def": "An engineered vector that is able to take part in homologous recombination in a host with the intent of introducing site specific genomic modifications. [MGD:tm, PMID:10354467]"
          },
          "SO:0001645": {
            "name": "genetic_marker",
            "def": "A measurable sequence feature that varies within a population. [SO:db]"
          },
          "SO:0001646": {
            "name": "DArT_marker",
            "def": "A genetic marker, discovered using Diversity Arrays Technology (DArT) technology. [SO:ke]"
          },
          "SO:0001647": {
            "name": "kozak_sequence",
            "def": "A kind of ribosome entry site, specific to Eukaryotic organisms that overlaps part of both 5' UTR and CDS sequence. [SO:ke]"
          },
          "SO:0001648": {
            "name": "nested_transposon",
            "def": "A transposon that is disrupted by the insertion of another element. [SO:ke]"
          },
          "SO:0001649": {
            "name": "nested_repeat",
            "def": "A repeat that is disrupted by the insertion of another element. [SO:ke]"
          },
          "SO:0001650": {
            "name": "inframe_variant",
            "def": "A sequence variant which does not cause a disruption of the translational reading frame. [SO:ke]"
          },
          "SO:0001653": {
            "name": "retinoic_acid_responsive_element",
            "def": "A transcription factor binding site of variable direct repeats of the sequence PuGGTCA spaced by five nucleotides (DR5) found in the promoters of retinoic acid-responsive genes, to which retinoic acid receptors bind. [PMID:11327309, PMID:19917671]"
          },
          "SO:0001654": {
            "name": "nucleotide_to_protein_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
          },
          "SO:0001655": {
            "name": "nucleotide_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with nucleotide residues. [SO:cb]"
          },
          "SO:0001656": {
            "name": "metal_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with metal ions. [SO:cb]"
          },
          "SO:0001657": {
            "name": "ligand_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with a small molecule such as a drug, or hormone. [SO:ke]"
          },
          "SO:0001658": {
            "name": "nested_tandem_repeat",
            "def": "An NTR is a nested repeat of two distinct tandem motifs interspersed with each other. [SO:AF]"
          },
          "SO:0001659": {
            "name": "promoter_element"
          },
          "SO:0001660": {
            "name": "core_promoter_element"
          },
          "SO:0001661": {
            "name": "RNA_polymerase_II_TATA_box",
            "def": "A TATA box core promoter of a gene transcribed by RNA polymerase II. [PMID:16858867]"
          },
          "SO:0001662": {
            "name": "RNA_polymerase_III_TATA_box",
            "def": "A TATA box core promoter of a gene transcribed by RNA polymerase III. [SO:ke]"
          },
          "SO:0001663": {
            "name": "BREd_motif",
            "def": "A core TRNA polymerase II promoter element with consensus (G/A)T(T/G/A)(T/A)(G/T)(T/G)(T/G). [PMID:16858867]"
          },
          "SO:0001664": {
            "name": "DCE",
            "def": "A discontinuous core element of RNA polymerase II transcribed genes, situated downstream of the TSS. It is composed of three sub elements: SI, SII and SIII. [PMID:16858867]"
          },
          "SO:0001665": {
            "name": "DCE_SI",
            "def": "A sub element of the DCE core promoter element, with consensus sequence CTTC. [PMID:16858867, SO:ke]"
          },
          "SO:0001666": {
            "name": "DCE_SII",
            "def": "A sub element of the DCE core promoter element with consensus sequence CTGT. [PMID:16858867, SO:ke]"
          },
          "SO:0001667": {
            "name": "DCE_SIII",
            "def": "A sub element of the DCE core promoter element with consensus sequence AGC. [PMID:16858867, SO:ke]"
          },
          "SO:0001668": {
            "name": "proximal_promoter_element",
            "def": "DNA segment that ranges from about -250 to -40 relative to +1 of RNA transcription start site, where sequence specific DNA-binding transcription factors binds, such as Sp1, CTF (CCAAT-binding transcription factor), and CBF (CCAAT-box binding factor). [PMID:12515390, PMID:9679020, SO:ml]"
          },
          "SO:0001669": {
            "name": "RNApol_II_core_promoter",
            "def": "The minimal portion of the promoter required to properly initiate transcription in RNA polymerase II transcribed genes. [PMID:16858867]"
          },
          "SO:0001670": {
            "name": "distal_promoter_element"
          },
          "SO:0001671": {
            "name": "bacterial_RNApol_promoter_sigma_70"
          },
          "SO:0001672": {
            "name": "bacterial_RNApol_promoter_sigma54"
          },
          "SO:0001673": {
            "name": "minus_12_signal",
            "def": "A conserved region about 12-bp upstream of the start point of bacterial transcription units, involved with sigma factor 54. [PMID:18331472]"
          },
          "SO:0001674": {
            "name": "minus_24_signal",
            "def": "A conserved region about 12-bp upstream of the start point of bacterial transcription units, involved with sigma factor 54. [PMID:18331472]"
          },
          "SO:0001675": {
            "name": "A_box_type_1",
            "def": "An A box within an RNA polymerase III type 1 promoter. [SO:ke]"
          },
          "SO:0001676": {
            "name": "A_box_type_2",
            "def": "An A box within an RNA polymerase III type 2 promoter. [SO:ke]"
          },
          "SO:0001677": {
            "name": "intermediate_element",
            "def": "A core promoter region of RNA polymerase III type 1 promoters. [PMID:12381659]"
          },
          "SO:0001678": {
            "name": "regulatory_promoter_element",
            "def": "A promoter element that is not part of the core promoter, but provides the promoter with a specific regulatory region. [PMID:12381659]"
          },
          "SO:0001679": {
            "name": "transcription_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of transcription. [SO:ke]"
          },
          "SO:0001680": {
            "name": "translation_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of translation. [SO:ke]"
          },
          "SO:0001681": {
            "name": "recombination_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of recombination. [SO:ke]"
          },
          "SO:0001682": {
            "name": "replication_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of nucleotide replication. [SO:ke]"
          },
          "SO:0001683": {
            "name": "sequence_motif",
            "def": "A sequence motif is a nucleotide or amino-acid sequence pattern that may have biological significance. [http://en.wikipedia.org/wiki/Sequence_motif]"
          },
          "SO:0001684": {
            "name": "experimental_feature_attribute",
            "def": "An attribute of an experimentally derived feature. [SO:ke]"
          },
          "SO:0001685": {
            "name": "score",
            "def": "The score of an experimentally derived feature such as a p-value. [SO:ke]"
          },
          "SO:0001686": {
            "name": "quality_value",
            "def": "An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score. [SO:ke]"
          },
          "SO:0001687": {
            "name": "restriction_enzyme_recognition_site",
            "def": "The nucleotide region (usually a palindrome) that is recognized by a restriction enzyme. This may or may not be equal to the restriction enzyme binding site. [SO:ke]"
          },
          "SO:0001688": {
            "name": "restriction_enzyme_cleavage_junction",
            "def": "The boundary at which a restriction enzyme breaks the nucleotide sequence. [SO:ke]"
          },
          "SO:0001689": {
            "name": "five_prime_restriction_enzyme_junction",
            "def": "The restriction enzyme cleavage junction on the 5' strand of the nucleotide sequence. [SO:ke]"
          },
          "SO:0001690": {
            "name": "three_prime_restriction_enzyme_junction"
          },
          "SO:0001691": {
            "name": "blunt_end_restriction_enzyme_cleavage_site"
          },
          "SO:0001692": {
            "name": "sticky_end_restriction_enzyme_cleavage_site"
          },
          "SO:0001693": {
            "name": "blunt_end_restriction_enzyme_cleavage_junction",
            "def": "A restriction enzyme cleavage site where both strands are cut at the same position. [SO:ke]"
          },
          "SO:0001694": {
            "name": "single_strand_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme cleavage site whereby only one strand is cut. [SO:ke]"
          },
          "SO:0001695": {
            "name": "restriction_enzyme_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended. [SO:ke]"
          },
          "SO:0001696": {
            "name": "experimentally_defined_binding_region",
            "def": "A region that has been implicated in binding although the exact coordinates of binding may be unknown. [SO:ke]"
          },
          "SO:0001697": {
            "name": "ChIP_seq_region",
            "def": "A region of sequence identified by CHiP seq technology to contain a protein binding site. [SO:ke]"
          },
          "SO:0001698": {
            "name": "ASPE_primer",
            "def": "\\A primer containing an SNV at the 3' end for accurate genotyping. [http://www.ncbi.nlm.nih.gov/pubmed/11252801]"
          },
          "SO:0001699": {
            "name": "dCAPS_primer",
            "def": "A primer with one or more mismatches to the DNA template corresponding to a position within a restriction enzyme recognition site. [http://www.ncbi.nlm.nih.gov/pubmed/9628033]"
          },
          "SO:0001700": {
            "name": "histone_modification",
            "def": "Histone modification is a post translationally modified region whereby residues of the histone protein are modified by methylation, acetylation, phosphorylation, ubiquitination, sumoylation, citrullination, or ADP-ribosylation. [http:en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001701": {
            "name": "histone_methylation_site",
            "def": "A histone modification site where the modification is the methylation of the residue. [SO:ke]"
          },
          "SO:0001702": {
            "name": "histone_acetylation_site",
            "def": "A histone modification where the modification is the acylation of the residue. [SO:ke]"
          },
          "SO:0001703": {
            "name": "H3K9_acetylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is acylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001704": {
            "name": "H3K14_acetylation_site",
            "def": "A kind of histone modification site, whereby the 14th residue (a lysine), from the start of the H3 histone protein is acylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001705": {
            "name": "H3K4_monomethylation_site",
            "def": "A kind of histone modification, whereby the 4th residue (a lysine), from the start of the H3 protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001706": {
            "name": "H3K4_trimethylation",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001707": {
            "name": "H3K9_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001708": {
            "name": "H3K27_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001709": {
            "name": "H3K27_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001710": {
            "name": "H3K79_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is mono- methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001711": {
            "name": "H3K79_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is di-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001712": {
            "name": "H3K79_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001713": {
            "name": "H4K20_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H4histone protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001714": {
            "name": "H2BK5_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H2B protein is methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001715": {
            "name": "ISRE",
            "def": "An ISRE is a transcriptional cis regulatory region, containing the consensus region: YAGTTTC(A/T)YTTTYCC, responsible for increased transcription via interferon binding. [http://genesdev.cshlp.org/content/2/4/383.abstrac]"
          },
          "SO:0001716": {
            "name": "histone_ubiqitination_site",
            "def": "A histone modification site where ubiquitin may be added. [SO:ke]"
          },
          "SO:0001717": {
            "name": "H2B_ubiquitination_site",
            "def": "A histone modification site on H2B where ubiquitin may be added. [SO:ke]"
          },
          "SO:0001718": {
            "name": "H3K18_acetylation_site",
            "def": "A kind of histone modification site, whereby the 14th residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
          },
          "SO:0001719": {
            "name": "H3K23_acylation_site",
            "def": "A kind of histone modification, whereby the 23rd residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
          },
          "SO:0001720": {
            "name": "epigenetically_modified_region",
            "def": "A biological region implicated in inherited changes caused by mechanisms other than changes in the underlying DNA sequence. [http://en.wikipedia.org/wiki/Epigenetics, SO:ke]"
          },
          "SO:0001721": {
            "name": "H3K27_acylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
          },
          "SO:0001722": {
            "name": "H3K36_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [SO:ke]"
          },
          "SO:0001723": {
            "name": "H3K36_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is dimethylated. [SO:ke]"
          },
          "SO:0001724": {
            "name": "H3K36_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [SO:ke]"
          },
          "SO:0001725": {
            "name": "H3K4_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 histone protein is di-methylated. [SO:ke]"
          },
          "SO:0001726": {
            "name": "H3K27_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is di-methylated. [SO:ke]"
          },
          "SO:0001727": {
            "name": "H3K9_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [SO:ke]"
          },
          "SO:0001728": {
            "name": "H3K9_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein may be dimethylated. [SO:ke]"
          },
          "SO:0001729": {
            "name": "H4K16_acylation_site",
            "def": "A kind of histone modification site, whereby the 16th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:ke]"
          },
          "SO:0001730": {
            "name": "H4K5_acylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:ke]"
          },
          "SO:0001731": {
            "name": "H4K8_acylation_site",
            "def": "A kind of histone modification site, whereby the 8th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:KE]"
          },
          "SO:0001732": {
            "name": "H3K27_methylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
          },
          "SO:0001733": {
            "name": "H3K36_methylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
          },
          "SO:0001734": {
            "name": "H3K4_methylation_site",
            "def": "A kind of histone modification, whereby the 4th residue (a lysine), from the start of the H3 protein is methylated. [SO:ke]"
          },
          "SO:0001735": {
            "name": "H3K79_methylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
          },
          "SO:0001736": {
            "name": "H3K9_methylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
          },
          "SO:0001737": {
            "name": "histone_acylation_region",
            "def": "A histone modification, whereby the histone protein is acylated at multiple sites in a region. [SO:ke]"
          },
          "SO:0001738": {
            "name": "H4K_acylation_region",
            "def": "A region of the H4 histone whereby multiple lysines are acylated. [SO:ke]"
          },
          "SO:0001739": {
            "name": "gene_with_non_canonical_start_codon",
            "def": "A gene with a start codon other than AUG. [SO:xp]"
          },
          "SO:0001740": {
            "name": "gene_with_start_codon_CUG",
            "def": "A gene with a translational start codon of CUG. [SO:mc]"
          },
          "SO:0001741": {
            "name": "pseudogenic_gene_segment",
            "def": "A gene segment which when incorporated by somatic recombination in the final gene transcript results in a nonfunctional product. [SO:hd]"
          },
          "SO:0001742": {
            "name": "copy_number_gain",
            "def": "A sequence alteration whereby the copy number of a given regions is greater than the reference sequence. [SO:ke]"
          },
          "SO:0001743": {
            "name": "copy_number_loss",
            "def": "A sequence alteration whereby the copy number of a given region is less than the reference sequence. [SO:ke]"
          },
          "SO:0001744": {
            "name": "UPD",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from one parent and no copies of the same chromosome or region from the other parent. [SO:BM]"
          },
          "SO:0001745": {
            "name": "maternal_uniparental_disomy",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from the mother and no copies of the same chromosome or region from the father. [SO:bm]"
          },
          "SO:0001746": {
            "name": "paternal_uniparental_disomy",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from the father and no copies of the same chromosome or region from the mother. [SO:bm]"
          },
          "SO:0001747": {
            "name": "open_chromatin_region",
            "def": "A DNA sequence that in the normal state of the chromosome corresponds to an unfolded, un-complexed stretch of double-stranded DNA. [SO:cb]"
          },
          "SO:0001748": {
            "name": "SL3_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL3 RNA leader sequence to the 5' end of an mRNA. SL3 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001749": {
            "name": "SL4_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL4 RNA leader sequence to the 5' end of an mRNA. SL4 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001750": {
            "name": "SL5_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL5 RNA leader sequence to the 5' end of an mRNA. SL5 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001751": {
            "name": "SL6_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL6 RNA leader sequence to the 5' end of an mRNA. SL6 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001752": {
            "name": "SL7_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL7 RNA leader sequence to the 5' end of an mRNA. SL7 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001753": {
            "name": "SL8_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL8 RNA leader sequence to the 5' end of an mRNA. SL8 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001754": {
            "name": "SL9_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL9 RNA leader sequence to the 5' end of an mRNA. SL9 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001755": {
            "name": "SL10_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL10 RNA leader sequence to the 5' end of an mRNA. SL10 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001756": {
            "name": "SL11_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL11 RNA leader sequence to the 5' end of an mRNA. SL11 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001757": {
            "name": "SL12_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL12 RNA leader sequence to the 5' end of an mRNA. SL12 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001758": {
            "name": "duplicated_pseudogene",
            "def": "A pseudogene that arose via gene duplication. Generally duplicated pseudogenes have the same structure as the original gene, including intron-exon structure and some regulatory sequence. [http://en.wikipedia.org/wiki/Pseudogene]"
          },
          "SO:0001759": {
            "name": "unitary_pseudogene",
            "def": "A pseudogene, deactivated from original state by mutation, fixed in a population. [http://en.wikipedia.org/wiki/Pseudogene, SO:ke]"
          },
          "SO:0001760": {
            "name": "non_processed_pseudogene",
            "def": "A pseudogene that arose from a means other than retrotransposition. [SO:ke]"
          },
          "SO:0001761": {
            "name": "variant_quality",
            "def": "A dependent entity that inheres in a bearer, a sequence variant. [PMID:17597783, SO:ke]"
          },
          "SO:0001762": {
            "name": "variant_origin",
            "def": "A quality inhering in a variant by virtue of its origin. [PMID:17597783, SO:ke]"
          },
          "SO:0001763": {
            "name": "variant_frequency",
            "def": "A physical quality which inheres to the variant by virtue of the number instances of the variant within a population. [PMID:17597783, SO:ke]"
          },
          "SO:0001764": {
            "name": "unique_variant",
            "def": "A physical quality which inheres to the variant by virtue of the number instances of the variant within a population. [SO:ke]"
          },
          "SO:0001765": {
            "name": "rare_variant"
          },
          "SO:0001766": {
            "name": "polymorphic_variant"
          },
          "SO:0001767": {
            "name": "common_variant"
          },
          "SO:0001768": {
            "name": "fixed_variant"
          },
          "SO:0001769": {
            "name": "variant_phenotype",
            "def": "A quality inhering in a variant by virtue of its phenotype. [PMID:17597783, SO:ke]"
          },
          "SO:0001770": {
            "name": "benign_variant"
          },
          "SO:0001771": {
            "name": "disease_associated_variant"
          },
          "SO:0001772": {
            "name": "disease_causing_variant"
          },
          "SO:0001773": {
            "name": "lethal_variant"
          },
          "SO:0001774": {
            "name": "quantitative_variant"
          },
          "SO:0001775": {
            "name": "maternal_variant"
          },
          "SO:0001776": {
            "name": "paternal_variant"
          },
          "SO:0001777": {
            "name": "somatic_variant"
          },
          "SO:0001778": {
            "name": "germline_variant"
          },
          "SO:0001779": {
            "name": "pedigree_specific_variant"
          },
          "SO:0001780": {
            "name": "population_specific_variant"
          },
          "SO:0001781": {
            "name": "de_novo_variant"
          },
          "SO:0001782": {
            "name": "TF_binding_site_variant",
            "def": "A sequence variant located within a transcription factor binding site. [EBI:fc]"
          },
          "SO:0001784": {
            "name": "complex_structural_alteration",
            "def": "A structural sequence alteration or rearrangement encompassing one or more genome fragments, with 4 or more breakpoints. [FB:reference_manual, NCBI:th, SO:ke]"
          },
          "SO:0001785": {
            "name": "structural_alteration"
          },
          "SO:0001786": {
            "name": "loss_of_heterozygosity",
            "def": "A functional variant whereby the sequence alteration causes a loss of function of one allele of a gene. [SO:ke]"
          },
          "SO:0001787": {
            "name": "splice_donor_5th_base_variant",
            "def": "A sequence variant that causes a change at the 5th base pair after the start of the intron in the orientation of the transcript. [EBI:gr]"
          },
          "SO:0001788": {
            "name": "U_box",
            "def": "An U-box is a conserved T-rich region upstream of a retroviral polypurine tract that is involved in PPT primer creation during reverse transcription. [PMID:10556309, PMID:11577982, PMID:9649446]"
          },
          "SO:0001789": {
            "name": "mating_type_region",
            "def": "A specialized region in the genomes of some yeast and fungi, the genes of which regulate mating type. [SO:ke]"
          },
          "SO:0001790": {
            "name": "paired_end_fragment",
            "def": "An assembly region that has been sequenced from both ends resulting in a read_pair (mate_pair). [SO:ke]"
          },
          "SO:0001791": {
            "name": "exon_variant",
            "def": "A sequence variant that changes exon sequence. [SO:ke]"
          },
          "SO:0001792": {
            "name": "non_coding_transcript_exon_variant",
            "def": "A sequence variant that changes non-coding exon sequence in a non-coding transcript. [EBI:fc, SO:ke]"
          },
          "SO:0001793": {
            "name": "clone_end",
            "def": "A read from an end of the clone sequence. [SO:ke]"
          },
          "SO:0001794": {
            "name": "point_centromere",
            "def": "A point centromere is a relatively small centromere (about 125 bp DNA) in discrete sequence, found in some yeast including S. cerevisiae. [PMID:7502067, SO:vw]"
          },
          "SO:0001795": {
            "name": "regional_centromere",
            "def": "A regional centromere is a large modular centromere found in fission yeast and higher eukaryotes. It consist of a central core region flanked by inverted inner and outer repeat regions. [PMID:7502067, SO:vw]"
          },
          "SO:0001796": {
            "name": "regional_centromere_central_core",
            "def": "A conserved region within the central region of a modular centromere, where the kinetochore is formed. [SO:vw]"
          },
          "SO:0001797": {
            "name": "centromeric_repeat",
            "def": "A repeat region found within the modular centromere. [SO:ke]"
          },
          "SO:0001798": {
            "name": "regional_centromere_inner_repeat_region",
            "def": "The inner inverted repeat region of a modular centromere and part of the central core surrounding a non-conserved central region. This region is adjacent to the central core, on each chromosome arm. [SO:vw]"
          },
          "SO:0001799": {
            "name": "regional_centromere_outer_repeat_region",
            "def": "The heterochromatic outer repeat region of a modular centromere. These repeats exist in tandem arrays on both chromosome arms. [SO:vw]"
          },
          "SO:0001800": {
            "name": "tasiRNA",
            "def": "The sequence of a 21 nucleotide double stranded, polyadenylated non coding RNA, transcribed from the TAS gene. [PMID:16145017]"
          },
          "SO:0001801": {
            "name": "tasiRNA_primary_transcript",
            "def": "A primary transcript encoding a tasiRNA. [PMID:16145017]"
          },
          "SO:0001802": {
            "name": "increased_polyadenylation_variant",
            "def": "A transcript processing variant whereby polyadenylation of the encoded transcript is increased with respect to the reference. [SO:ke]"
          },
          "SO:0001803": {
            "name": "decreased_polyadenylation_variant",
            "def": "A transcript processing variant whereby polyadenylation of the encoded transcript is decreased with respect to the reference. [SO:ke]"
          },
          "SO:0001804": {
            "name": "DDB_box",
            "def": "A conserved polypeptide motif that mediates protein-protein interaction and defines adaptor proteins for DDB1/cullin 4 ubiquitin ligases. [PMID:18794354, PMID:19818632]"
          },
          "SO:0001805": {
            "name": "destruction_box",
            "def": "A conserved polypeptide motif that can be recognized by both Fizzy/Cdc20- and FZR/Cdh1-activated anaphase-promoting complex/cyclosome (APC/C) and targets a protein for ubiquitination and subsequent degradation by the APC/C. The consensus sequence is RXXLXXXXN. [PMID:12208841, PMID:1842691]"
          },
          "SO:0001806": {
            "name": "ER_retention_signal",
            "def": "A C-terminal tetrapeptide motif that mediates retention of a protein in (or retrieval to) the endoplasmic reticulum. In mammals the sequence is KDEL, and in fungi HDEL or DDEL. [doi:10.1093/jxb/50.331.157, PMID:2077689]"
          },
          "SO:0001807": {
            "name": "KEN_box",
            "def": "A conserved polypeptide motif that can be recognized by FZR/Cdh1-activated anaphase-promoting complex/cyclosome (APC/C) and targets a protein for ubiquitination and subsequent degradation by the APC/C. The consensus sequence is KENXXXN. [PMID:10733526, PMID:1220884, PMID:18426916]"
          },
          "SO:0001808": {
            "name": "mitochondrial_targeting_signal",
            "def": "A polypeptide region that targets a polypeptide to the mitochondrion. [PomBase:mah]"
          },
          "SO:0001809": {
            "name": "signal_anchor",
            "def": "A signal sequence that is not cleaved from the polypeptide. Anchors a Type II membrane protein to the membrane. [http://www.cbs.dtu.dk/services/SignalP/background/biobackground.php]"
          },
          "SO:0001810": {
            "name": "PIP_box",
            "def": "A polypeptide region that mediates binding to PCNA. The consensus sequence is QXX(hh)XX(aa), where (h) denotes residues with moderately hydrophobic side chains and (a) denotes residues with highly hydrophobic aromatic side chains. [PMID:9631646]"
          },
          "SO:0001811": {
            "name": "phosphorylation_site",
            "def": "A post-translationally modified region in which residues of the protein are modified by phosphorylation. [PomBase:mah]"
          },
          "SO:0001812": {
            "name": "transmembrane_helix",
            "def": "A region that traverses the lipid bilayer and adopts a helical secondary structure. [PomBase:mah]"
          },
          "SO:0001813": {
            "name": "vacuolar_sorting_signal",
            "def": "A polypeptide region that targets a polypeptide to the vacuole. [PomBase:mah]"
          },
          "SO:0001814": {
            "name": "coding_variant_quality"
          },
          "SO:0001815": {
            "name": "synonymous"
          },
          "SO:0001816": {
            "name": "non_synonymous"
          },
          "SO:0001817": {
            "name": "inframe",
            "def": "An attribute describing a sequence that contains a mutation involving the deletion or insertion of one or more bases, where this number is divisible by 3. [SO:ke]"
          },
          "SO:0001818": {
            "name": "protein_altering_variant",
            "def": "A sequence_variant which is predicted to change the protein encoded in the coding sequence. [EBI:gr]"
          },
          "SO:0001819": {
            "name": "synonymous_variant",
            "def": "A sequence variant where there is no resulting change to the encoded amino acid. [SO:ke]"
          },
          "SO:0001820": {
            "name": "inframe_indel",
            "def": "A coding sequence variant where the change does not alter the frame of the transcript. [SO:ke]"
          },
          "SO:0001821": {
            "name": "inframe_insertion",
            "def": "An inframe non synonymous variant that inserts bases into in the coding sequence. [EBI:gr]"
          },
          "SO:0001822": {
            "name": "inframe_deletion",
            "def": "An inframe non synonymous variant that deletes bases from the coding sequence. [EBI:gr]"
          },
          "SO:0001823": {
            "name": "conservative_inframe_insertion",
            "def": "An inframe increase in cds length that inserts one or more codons into the coding sequence between existing codons. [EBI:gr]"
          },
          "SO:0001824": {
            "name": "disruptive_inframe_insertion",
            "def": "An inframe increase in cds length that inserts one or more codons into the coding sequence within an existing codon. [EBI:gr]"
          },
          "SO:0001825": {
            "name": "conservative_inframe_deletion",
            "def": "An inframe decrease in cds length that deletes one or more entire codons from the coding sequence but does not change any remaining codons. [EBI:gr]"
          },
          "SO:0001826": {
            "name": "disruptive_inframe_deletion",
            "def": "An inframe decrease in cds length that deletes bases from the coding sequence starting within an existing codon. [EBI:gr]"
          },
          "SO:0001827": {
            "name": "mRNA_read",
            "def": "A sequencer read of an mRNA substrate. [SO:ke]"
          },
          "SO:0001828": {
            "name": "genomic_DNA_read",
            "def": "A sequencer read of a genomic DNA substrate. [SO:ke]"
          },
          "SO:0001829": {
            "name": "mRNA_contig",
            "def": "A contig composed of mRNA_reads. [SO:ke]"
          },
          "SO:0001830": {
            "name": "AFLP_fragment",
            "def": "A PCR product obtained by applying the AFLP technique, based on a restriction enzyme digestion of genomic DNA and an amplification of the resulting fragments. [GMOD:ea]"
          },
          "SO:0001831": {
            "name": "protein_hmm_match",
            "def": "A match to a protein HMM such as pfam. [SO:ke]"
          },
          "SO:0001832": {
            "name": "immunoglobulin_region",
            "def": "A region of immunoglobulin sequence, either constant or variable. [SO:ke]"
          },
          "SO:0001833": {
            "name": "V_region",
            "def": "The variable region of an immunoglobulin polypeptide sequence. [SO:ke]"
          },
          "SO:0001834": {
            "name": "C_region",
            "def": "The constant region of an immunoglobulin polypeptide sequence. [SO:ke]"
          },
          "SO:0001835": {
            "name": "N_region",
            "def": "Extra nucleotides inserted between rearranged immunoglobulin segments. [SO:ke]"
          },
          "SO:0001836": {
            "name": "S_region",
            "def": "The switch region of immunoglobulin heavy chains; it is involved in the rearrangement of heavy chain DNA leading to the expression of a different immunoglobulin classes from the same B-cell. [SO:ke]"
          },
          "SO:0001837": {
            "name": "mobile_element_insertion",
            "def": "A kind of insertion where the inserted sequence is a mobile element. [EBI:dvga]"
          },
          "SO:0001838": {
            "name": "novel_sequence_insertion",
            "def": "An insertion the sequence of which cannot be mapped to the reference genome. [NCBI:th]"
          },
          "SO:0001839": {
            "name": "CSL_response_element",
            "def": "A promoter element with consensus sequence GTGRGAA, bound by CSL (CBF1/RBP-JK/Suppressor of Hairless/LAG-1) transcription factors. [PMID:19101542]"
          },
          "SO:0001840": {
            "name": "GATA_box",
            "def": "A GATA transcription factor element containing the consensus sequence WGATAR (in which W indicates A/T and R indicates A/G). [PMID:8321208]"
          },
          "SO:0001841": {
            "name": "polymorphic_pseudogene",
            "def": "Pseudogene owing to a SNP/DIP but in other individuals/haplotypes/strains the gene is translated. [JAX:hd]"
          },
          "SO:0001842": {
            "name": "AP_1_binding_site",
            "def": "A promoter element with consensus sequence TGACTCA, bound by AP-1 and related transcription factors. [PMID:1899230, PMID:3034432, PMID:3125983]"
          },
          "SO:0001843": {
            "name": "CRE",
            "def": "A promoter element with consensus sequence TGACGTCA; bound by the ATF/CREB family of transcription factors. [PMID:11483355, PMID:11483993]"
          },
          "SO:0001844": {
            "name": "CuRE",
            "def": "A promoter element bound by copper ion-sensing transcription factors such as S. cerevisiae Mac1p or S. pombe Cuf1; the consensus sequence is HTHNNGCTGD (more specifically TTTGCKCR in budding yeast). [PMID:10593913, PMID:9188496, PMID:9211922]"
          },
          "SO:0001845": {
            "name": "DRE",
            "def": "A promoter element with consensus sequence CGWGGWNGMM, bound by transcription factors related to RecA and found in promoters of genes expressed following several types of DNA damage or inhibition of DNA synthesis. [PMID:11073995, PMID:8668127]"
          },
          "SO:0001846": {
            "name": "FLEX_element",
            "def": "A promoter element that has consensus sequence GTAAACAAACAAAM and contains a heptameric core GTAAACA, bound by transcription factors with a forkhead DNA-binding domain. [PMID:10747048, PMID:14871934]"
          },
          "SO:0001847": {
            "name": "forkhead_motif",
            "def": "A promoter element with consensus sequence TTTRTTTACA, bound by transcription factors with a forkhead DNA-binding domain. [PMID:15195092]"
          },
          "SO:0001848": {
            "name": "homol_D_box",
            "def": "A core promoter element that has the consensus sequence CAGTCACA (or its inverted form TGTGACTG), and plays the role of a TATA box in promoters that do not contain a canonical TATA sequence. [PMID:7501449, PMID:8458332]"
          },
          "SO:0001849": {
            "name": "homol_E_box",
            "def": "A core promoter element that has the consensus sequence ACCCTACCCT (or its inverted form AGGGTAGGGT), and is found near the homol D box in some promoters that use a homol D box instead of a canonical TATA sequence. [PMID:7501449]"
          },
          "SO:0001850": {
            "name": "HSE",
            "def": "A promoter element that consists of at least three copies of the pentanucleotide NGAAN, bound by the heat shock transcription factor HSF. [PMID:17347150, PMID:8689565]"
          },
          "SO:0001851": {
            "name": "iron_repressed_GATA_element",
            "def": "A GATA promoter element with consensus sequence WGATAA, found in promoters of genes repressed in the presence of iron. [PMID:11956219, PMID:17211681]"
          },
          "SO:0001852": {
            "name": "mating_type_M_box",
            "def": "A promoter element with consensus sequence ACAAT, found in promoters of mating type M-specific genes in fission yeast and bound by the transcription factor Mat1-Mc. [PMID:9233811]"
          },
          "SO:0001853": {
            "name": "androgen_response_element",
            "def": "A non-palindromic sequence found in the promoters of genes whose expression is regulated in response to androgen. [PMID:21796522]"
          },
          "SO:0001854": {
            "name": "smFISH_probe",
            "def": "A smFISH is a probe that binds RNA in a single molecule in situ hybridization experiment. [PMID:18806792]"
          },
          "SO:0001855": {
            "name": "MCB",
            "def": "A promoter element with consensus sequence ACGCGT, bound by the transcription factor complex MBF (MCB-binding factor) and found in promoters of genes expressed during the G1/S transition of the cell cycle. [PMID:16285853]"
          },
          "SO:0001856": {
            "name": "CCAAT_motif",
            "def": "A promoter element with consensus sequence CCAAT, bound by a protein complex that represses transcription in response to low iron levels. [PMID:16963626]"
          },
          "SO:0001857": {
            "name": "Ace2_UAS",
            "def": "A promoter element with consensus sequence CCAGCC, bound by the fungal transcription factor Ace2. [PMID:16678171]"
          },
          "SO:0001858": {
            "name": "TR_box",
            "def": "A promoter element with consensus sequence TTCTTTGTTY, bound an HMG-box transcription factor such as S. pombe Ste11, and found in promoters of genes up-regulated early in meiosis. [PMID:1657709]"
          },
          "SO:0001859": {
            "name": "STREP_motif",
            "def": "A promoter element with consensus sequence CCCCTC, bound by the PKA-responsive zinc finger transcription factor Rst2. [PMID:11739717]"
          },
          "SO:0001860": {
            "name": "rDNA_intergenic_spacer_element",
            "def": "A DNA motif that contains a core consensus sequence AGGTAAGGGTAATGCAC, is found in the intergenic regions of rDNA repeats, and is bound by an RNA polymerase I transcription termination factor (e.g. S. pombe Reb1). [PMID:9016645]"
          },
          "SO:0001861": {
            "name": "sterol_regulatory_element",
            "def": "A 10-bp promoter element bound by sterol regulatory element binding proteins (SREBPs), found in promoters of genes involved in sterol metabolism. Many variants of the sequence ATCACCCCAC function as SREs. [GO:mah, PMID:11111080, PMID:16537923]"
          },
          "SO:0001862": {
            "name": "GT_dinucleotide_repeat",
            "def": "A dinucleotide repeat region composed of GT repeating elements. [SO:ke]"
          },
          "SO:0001863": {
            "name": "GTT_trinucleotide_repeat",
            "def": "A trinucleotide repeat region composed of GTT repeating elements. [SO:ke]"
          },
          "SO:0001864": {
            "name": "Sap1_recognition_motif",
            "def": "A DNA motif to which the S. pombe Sap1 protein binds. The consensus sequence is 5'-TARGCAGNTNYAACGMG-3'; it is found at the mating type locus, where it is important for mating type switching, and at replication fork barriers in rDNA repeats. [PMID:16166653, PMID:7651412]"
          },
          "SO:0001865": {
            "name": "CDRE_motif",
            "def": "An RNA polymerase II promoter element found in the promoters of genes regulated by calcineurin. The consensus sequence is GNGGCKCA. [PMID:16928959]"
          },
          "SO:0001866": {
            "name": "BAC_read_contig",
            "def": "A contig of BAC reads. [GMOD:ea]"
          },
          "SO:0001867": {
            "name": "candidate_gene",
            "def": "A gene suspected of being involved in the expression of a trait. [GMOD:ea]"
          },
          "SO:0001868": {
            "name": "positional_candidate_gene",
            "def": "A candidate gene whose association with a trait is based on the gene's location on a chromosome. [GMOD:ea]"
          },
          "SO:0001869": {
            "name": "functional_candidate_gene",
            "def": "A candidate gene whose function has something in common biologically with the trait under investigation. [GMOD:ea]"
          },
          "SO:0001870": {
            "name": "enhancerRNA",
            "def": "A short ncRNA that is transcribed from an enhancer. May have a regulatory function. [doi:10.1038/465173a, SO:cjm]"
          },
          "SO:0001871": {
            "name": "PCB",
            "def": "A promoter element with consensus sequence GNAACR, bound by the transcription factor complex PBF (PCB-binding factor) and found in promoters of genes expressed during the M/G1 transition of the cell cycle. [GO:mah, PMID:12411492]"
          },
          "SO:0001872": {
            "name": "rearrangement_region",
            "def": "A region of a chromosome, where the chromosome has undergone a large structural rearrangement that altered the genome organization. There is no longer synteny to the reference genome. [NCBI:th, PMID:18564416]"
          },
          "SO:0001873": {
            "name": "interchromosomal_breakpoint",
            "def": "A rearrangement breakpoint between two different chromosomes. [NCBI:th]"
          },
          "SO:0001874": {
            "name": "intrachromosomal_breakpoint",
            "def": "A rearrangement breakpoint within the same chromosome. [NCBI:th]"
          },
          "SO:0001875": {
            "name": "unassigned_supercontig",
            "def": "A supercontig that is not been assigned to any ultracontig during a genome assembly project. [GMOD:ea]"
          },
          "SO:0001876": {
            "name": "partial_genomic_sequence_assembly",
            "def": "A partial DNA sequence assembly of a chromosome or full genome, which contains gaps that are filled with N's. [GMOD:ea]"
          },
          "SO:0001877": {
            "name": "lnc_RNA",
            "def": "A non-coding RNA over 200nucleotides in length. [HGNC:mw]"
          },
          "SO:0001878": {
            "name": "feature_variant",
            "def": "A sequence variant that falls entirely or partially within a genomic feature. [EBI:fc, SO:ke]"
          },
          "SO:0001879": {
            "name": "feature_ablation",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the deletion, is greater than the extent of the underlying genomic features. [SO:ke]"
          },
          "SO:0001880": {
            "name": "feature_amplification",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the structural change, an amplification of sequence, is greater than the extent of the underlying genomic features. [SO:ke]"
          },
          "SO:0001881": {
            "name": "feature_translocation",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the structural change, a translocation, is greater than the extent of the underlying genomic features. [SO:ke]"
          },
          "SO:0001882": {
            "name": "feature_fusion",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where a deletion fuses genomic features. [SO:ke]"
          },
          "SO:0001883": {
            "name": "transcript_translocation",
            "def": "A feature translocation where the region contains a transcript. [SO:ke]"
          },
          "SO:0001884": {
            "name": "regulatory_region_translocation",
            "def": "A feature translocation where the region contains a regulatory region. [SO:ke]"
          },
          "SO:0001885": {
            "name": "TFBS_translocation",
            "def": "A feature translocation where the region contains a transcription factor binding site. [SO:ke]"
          },
          "SO:0001886": {
            "name": "transcript_fusion",
            "def": "A feature fusion where the deletion brings together transcript regions. [SO:ke]"
          },
          "SO:0001887": {
            "name": "regulatory_region_fusion",
            "def": "A feature fusion where the deletion brings together regulatory regions. [SO:ke]"
          },
          "SO:0001888": {
            "name": "TFBS_fusion",
            "def": "A fusion where the deletion brings together transcription factor binding sites. [SO:ke]"
          },
          "SO:0001889": {
            "name": "transcript_amplification",
            "def": "A feature amplification of a region containing a transcript. [SO:ke]"
          },
          "SO:0001890": {
            "name": "transcript_regulatory_region_fusion",
            "def": "A feature fusion where the deletion brings together a regulatory region and a transcript region. [SO:ke]"
          },
          "SO:0001891": {
            "name": "regulatory_region_amplification",
            "def": "A feature amplification of a region containing a regulatory region. [SO:ke]"
          },
          "SO:0001892": {
            "name": "TFBS_amplification",
            "def": "A feature amplification of a region containing a transcription factor binding site. [SO:ke]"
          },
          "SO:0001893": {
            "name": "transcript_ablation",
            "def": "A feature ablation whereby the deleted region includes a transcript feature. [SO:ke]"
          },
          "SO:0001894": {
            "name": "regulatory_region_ablation",
            "def": "A feature ablation whereby the deleted region includes a regulatory region. [SO:ke]"
          },
          "SO:0001895": {
            "name": "TFBS_ablation",
            "def": "A feature ablation whereby the deleted region includes a transcription factor binding site. [SO:ke]"
          },
          "SO:0001896": {
            "name": "transposable_element_CDS",
            "def": "A CDS that is part of a transposable element. [SO:ke]"
          },
          "SO:0001897": {
            "name": "transposable_element_pseudogene",
            "def": "A pseudogene contained within a transposable element. [SO:ke]"
          },
          "SO:0001898": {
            "name": "dg_repeat",
            "def": "A repeat region which is part of the regional centromere outer repeat region. [PMID:16407326, SO:vw]"
          },
          "SO:0001899": {
            "name": "dh_repeat",
            "def": "A repeat region which is part of the regional centromere outer repeat region. [PMID:16407326, SO:vw]"
          },
          "SO:0001900": {
            "name": "M26_binding_site",
            "def": "A promoter element that contains a core sequence TGACGT, bound by a protein complex that regulates transcription of genes encoding PKA pathway components. [PMID:15448137]"
          },
          "SO:0001901": {
            "name": "AACCCT_box",
            "def": "A conserved 17-bp sequence (5'-ATCA(C/A)AACCCTAACCCT-3') commonly present upstream of the start site of histone transcription units functioning as a transcription factor binding site. [PMID:17452352, PMID:4092687]"
          },
          "SO:0001902": {
            "name": "splice_region",
            "def": "A region surrounding a cis_splice site, either within 1-3 bases of the exon or 3-8 bases of the intron. [SO:bm]"
          },
          "SO:0001903": {
            "name": "intronic_lncRNA",
            "def": "A lnc_RNA totally contained within an intron. [PMID:19071207, SO:ke]"
          },
          "SO:0001904": {
            "name": "antisense_lncRNA",
            "def": "Non-coding RNA transcribed from the opposite DNA strand compared with other transcripts and overlap in part with sense RNA. [PMID:19638999]"
          },
          "SO:0001905": {
            "name": "regional_centromere_outer_repeat_transcript",
            "def": "A transcript that is transcribed from the outer repeat region of a regional centromere. [PomBase:mah]"
          },
          "SO:0001906": {
            "name": "feature_truncation",
            "def": "A sequence variant that causes the reduction of a genomic feature, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0001907": {
            "name": "feature_elongation",
            "def": "A sequence variant that causes the extension of a genomic feature, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0001908": {
            "name": "internal_feature_elongation",
            "def": "A sequence variant that causes the extension of a genomic feature from within the feature rather than from the terminus of the feature, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0001909": {
            "name": "frameshift_elongation",
            "def": "A frameshift variant that causes the translational reading frame to be extended relative to the reference feature. [SO:ke]"
          },
          "SO:0001910": {
            "name": "frameshift_truncation",
            "def": "A frameshift variant that causes the translational reading frame to be shortened relative to the reference feature. [SO:ke]"
          },
          "SO:0001911": {
            "name": "copy_number_increase",
            "def": "A sequence variant where copies of a feature are increased relative to the reference. [SO:ke]"
          },
          "SO:0001912": {
            "name": "copy_number_decrease",
            "def": "A sequence variant where copies of a feature are decreased relative to the reference. [SO:ke]"
          },
          "SO:0001913": {
            "name": "bacterial_RNApol_promoter_sigma_ecf",
            "def": "A bacterial promoter with sigma ecf factor binding dependency. This is a type of bacterial promoters that requires a sigma ECF factor to bind to identified -10 and -35 sequence regions in order to mediate binding of the RNA polymerase to the promoter region as part of transcription initiation. [Invitrogen:kc]"
          },
          "SO:0001914": {
            "name": "rDNA_replication_fork_barrier",
            "def": "A DNA motif that is found in eukaryotic rDNA repeats, and is a site of replication fork pausing. [PMID:14645529]"
          },
          "SO:0001915": {
            "name": "transcription_start_cluster",
            "def": "A region defined by a cluster of experimentally determined transcription starting sites. [PMID:19624849, PMID:21372179, SO:andrewgibson]"
          },
          "SO:0001916": {
            "name": "CAGE_tag",
            "def": "A CAGE tag is a sequence tag hat corresponds to 5' ends of mRNA at cap sites, produced by cap analysis gene expression and used to identify transcriptional start sites. [SO:andrewgibson]"
          },
          "SO:0001917": {
            "name": "CAGE_cluster",
            "def": "A kind of transcription_initiation_cluster defined by the clustering of CAGE tags on a sequence region. [PMID:16645617, SO:andrewgibson]"
          },
          "SO:0001918": {
            "name": "5_methylcytosine",
            "def": "A cytosine methylated at the 5 carbon. [SO:rtapella]"
          },
          "SO:0001919": {
            "name": "4_methylcytosine",
            "def": "A cytosine methylated at the 4 nitrogen. [SO:rtapella]"
          },
          "SO:0001920": {
            "name": "N6_methyladenine",
            "def": "An adenine methylated at the 6 nitrogen. [SO:rtapella]"
          },
          "SO:0001921": {
            "name": "mitochondrial_contig",
            "def": "A contig of mitochondria derived sequences. [GMOD:ea]"
          },
          "SO:0001922": {
            "name": "mitochondrial_supercontig",
            "def": "A scaffold composed of mitochondrial contigs. [GMOD:ea]"
          },
          "SO:0001923": {
            "name": "TERRA",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts contain G rich telomeric RNA repeats and RNA tracts corresponding to adjacent subtelomeric sequences. They are 100-9000 bases long. [PMID:22139915]"
          },
          "SO:0001924": {
            "name": "ARRET",
            "def": "A non coding RNA transcript, complementary to subtelomeric tract of TERRA transcript but devoid of the repeats. [PMID:2139915]"
          },
          "SO:0001925": {
            "name": "ARIA",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts consist of C rich repeats. [PMID:22139915]"
          },
          "SO:0001926": {
            "name": "anti_ARRET",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts are antisense of ARRET transcripts. [PMID:22139915]"
          },
          "SO:0001927": {
            "name": "telomeric_transcript",
            "def": "A non-coding transcript derived from the transcript of the telomere. [PMID:22139915]"
          },
          "SO:0001928": {
            "name": "distal_duplication",
            "def": "A duplication of the distal region of a chromosome. [SO:bm]"
          },
          "SO:0001929": {
            "name": "mitochondrial_DNA_read",
            "def": "A sequencer read of a mitochondrial DNA sample. [GMOD:ea]"
          },
          "SO:0001930": {
            "name": "chloroplast_DNA_read",
            "def": "A sequencer read of a chloroplast DNA sample. [GMOD:ea]"
          },
          "SO:0001931": {
            "name": "consensus_gDNA",
            "def": "Genomic DNA sequence produced from some base calling or alignment algorithm which uses aligned or assembled multiple gDNA sequences as input. [GMOD:ea]"
          },
          "SO:0001932": {
            "name": "restriction_enzyme_five_prime_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended and the exposed single strand terminates at the 5' end. [SO:ke]"
          },
          "SO:0001933": {
            "name": "restriction_enzyme_three_prime_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended and the exposed single strand terminates at the 3' end. [SO:ke]"
          },
          "SO:0001934": {
            "name": "monomeric_repeat",
            "def": "A repeat_region containing repeat_units of 1 bp that is repeated multiple times in tandem. [SO:ke]"
          },
          "SO:0001935": {
            "name": "H3K20_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H3 protein is tri-methylated. [EBI:nj]"
          },
          "SO:0001936": {
            "name": "H3K36_acetylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is acylated. [EBI:nj]"
          },
          "SO:0001937": {
            "name": "H2BK12_acetylation_site",
            "def": "A kind of histone modification site, whereby the 12th residue (a lysine), from the start of the H2B protein is methylated. [EBI:nj]"
          },
          "SO:0001938": {
            "name": "H2AK5_acetylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H2A histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001939": {
            "name": "H4K12_acetylation_site",
            "def": "A kind of histone modification site, whereby the 12th residue (a lysine), from the start of the H4 histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001940": {
            "name": "H2BK120_acetylation_site",
            "def": "A kind of histone modification site, whereby the 120th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001941": {
            "name": "H4K91_acetylation_site",
            "def": "A kind of histone modification site, whereby the 91st residue (a lysine), from the start of the H4 histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001942": {
            "name": "H2BK20_acetylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001943": {
            "name": "H3K4ac_acetylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001944": {
            "name": "H2AK9_acetylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H2A histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001945": {
            "name": "H3K56_acetylation_site",
            "def": "A kind of histone modification site, whereby the 56th residue (a lysine), from the start of the H3 histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001946": {
            "name": "H2BK15_acetylation_site",
            "def": "A kind of histone modification site, whereby the 15th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001947": {
            "name": "H3R2_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 2nd residue (an arginine), from the start of the H3 protein is mono-methylated. [EBI:nj]"
          },
          "SO:0001948": {
            "name": "H3R2_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 2nd residue (an arginine), from the start of the H3 protein is di-methylated. [EBI:nj]"
          },
          "SO:0001949": {
            "name": "H4R3_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 3nd residue (an arginine), from the start of the H4 protein is di-methylated. [EBI:nj]"
          },
          "SO:0001950": {
            "name": "H4K4_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H4 protein is tri-methylated. [EBI:nj]"
          },
          "SO:0001951": {
            "name": "H3K23_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 23rd residue (a lysine), from the start of the H3 protein is di-methylated. [EBI:nj]"
          },
          "SO:0001952": {
            "name": "promoter_flanking_region",
            "def": "A region immediately adjacent to a promoter which may or may not contain transcription factor binding sites. [EBI:nj]"
          },
          "SO:0001953": {
            "name": "restriction_enzyme_assembly_scar",
            "def": "A region of DNA sequence formed from the ligation of two sticky ends where the palindrome is broken and no longer comprises the recognition site and thus cannot be re-cut by the restriction enzymes used to create the sticky ends. [SO:ke]"
          },
          "SO:0001954": {
            "name": "restriction_enzyme_region",
            "def": "A region related to restriction enzyme function. [SO:ke]"
          },
          "SO:0001955": {
            "name": "protein_stability_element",
            "def": "A polypeptide region that proves structure in a protein that affects the stability of the protein. [SO:ke]"
          },
          "SO:0001956": {
            "name": "protease_site",
            "def": "A polypeptide_region that  codes for a protease cleavage site. [SO:ke]"
          },
          "SO:0001957": {
            "name": "RNA_stability_element",
            "def": "RNA secondary structure that affects the stability of an RNA molecule. [SO:ke]"
          },
          "SO:0001958": {
            "name": "lariat_intron",
            "def": "A kind of intron whereby the excision is driven by lariat formation. [SO:ke]"
          },
          "SO:0001959": {
            "name": "TCT_motif",
            "def": "A cis-regulatory element, conserved sequence YYC+1TTTYY, and spans -2 to +6 relative to +1 TSS. It is present in most ribosomal protein genes in Drosophila and mammals but not in the yeast Saccharomyces cerevisiae. Resembles the initiator (TCAKTY in Drosophila) but functionally distinct from initiator. [PMID:20801935, SO:myl]"
          },
          "SO:0001960": {
            "name": "5_hydroxymethylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a hydroxymethyl group at the 5 carbon. [SO:ke]"
          },
          "SO:0001961": {
            "name": "5_formylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a formyl group at the 5 carbon. [SO:ke]"
          },
          "SO:0001962": {
            "name": "modified_adenine",
            "def": "A modified adenine DNA base feature. [SO:ke]"
          },
          "SO:0001963": {
            "name": "modified_cytosine",
            "def": "A modified cytosine DNA base feature. [SO:ke]"
          },
          "SO:0001964": {
            "name": "modified_guanine",
            "def": "A modified guanine DNA base feature. [SO:ke]"
          },
          "SO:0001965": {
            "name": "8_oxoguanine",
            "def": "A modified DNA guanine base,at the 8 carbon, often the product of DNA damage. [SO:ke]"
          },
          "SO:0001966": {
            "name": "5_carboxylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a carboxy group at the 5 carbon. [SO:ke]"
          },
          "SO:0001967": {
            "name": "8_oxoadenine",
            "def": "A modified DNA adenine base,at the 8 carbon, often the product of DNA damage. [SO:ke]"
          },
          "SO:0001968": {
            "name": "coding_transcript_variant",
            "def": "A transcript variant of a protein coding gene. [SO:ke]"
          },
          "SO:0001969": {
            "name": "coding_transcript_intron_variant",
            "def": "A transcript variant occurring within an intron of a coding transcript. [SO:ke]"
          },
          "SO:0001970": {
            "name": "non_coding_transcript_intron_variant",
            "def": "A transcript variant occurring within an intron of a non coding transcript. [SO:ke]"
          },
          "SO:0001971": {
            "name": "zinc_finger_binding_site"
          },
          "SO:0001972": {
            "name": "histone_4_acylation_site",
            "def": "A histone 4 modification where the modification is the acylation of the residue. [EBI:nj, SO:ke]"
          },
          "SO:0001973": {
            "name": "histone_3_acetylation_site",
            "def": "A histone 3 modification where the modification is the acylation of the residue. [EBI:nj, SO:ke]"
          },
          "SO:0001974": {
            "name": "CTCF_binding_site",
            "def": "A transcription factor binding site with consensus sequence CCGCGNGGNGGCAG, bound by CCCTF-binding factor. [EBI:nj]"
          },
          "SO:0001975": {
            "name": "five_prime_sticky_end_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme recognition site that, when cleaved, results in 5 prime overhangs. [SO:ke]"
          },
          "SO:0001976": {
            "name": "three_prime_sticky_end_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme recognition site that, when cleaved, results in 3 prime overhangs. [SO:ke]"
          },
          "SO:0001977": {
            "name": "ribonuclease_site",
            "def": "A region of a transcript encoding the cleavage site for a ribonuclease enzyme. [SO:ke]"
          },
          "SO:0001978": {
            "name": "signature",
            "def": "A region of  sequence where developer information is encoded. [SO:ke]"
          },
          "SO:0001979": {
            "name": "RNA_stability_element",
            "def": "A motif that affects the stability of RNA. [PMID:22495308, SO:ke]"
          },
          "SO:0001980": {
            "name": "G_box",
            "def": "A regulatory promoter element identified in mutation experiments, with consensus sequence: CACGTG. Present in promoters, intergenic regions, coding regions, and introns. They are involved in gene expression responses to light and interact with G-box binding factor and I-box binding factor 1a. [PMID:19249238, PMID:8571452, SO:ml]"
          },
          "SO:0001981": {
            "name": "L_box",
            "def": "An orientation dependent  regulatory promoter element, with consensus sequence of TTGCACAN4TTGCACA, found in plants. [PMID:17381552, PMID:2902624, SO:ml]"
          },
          "SO:0001982": {
            "name": "I-box",
            "def": "A plant regulatory promoter motif,  composed of a highly conserved hexamer GATAAG (I-box core). [PMID:2347304, PMID:2902624, SO:ml]"
          },
          "SO:0001983": {
            "name": "5_prime_UTR_premature_start_codon_variant",
            "def": "A 5' UTR variant where a premature start codon is introduced, moved or lost. [SANGER:am]"
          },
          "SO:0001984": {
            "name": "silent_mating_type_cassette_array",
            "def": "A gene cassette array that corresponds to a silenced version of a mating type region. [PomBase:mah]"
          },
          "SO:0001985": {
            "name": "Okazaki_fragment",
            "def": "Any of the DNA segments produced by discontinuous synthesis of the lagging strand during DNA replication. [ISBN:0805350152]"
          },
          "SO:0001986": {
            "name": "upstream_transcript_variant",
            "def": "A feature variant, where the alteration occurs upstream of the transcript TSS. [EBI:gr]"
          },
          "SO:0001987": {
            "name": "downstream_transcript_variant"
          },
          "SO:0001988": {
            "name": "5_prime_UTR_premature_start_codon_gain_variant",
            "def": "A 5' UTR variant where a premature start codon is gained. [Sanger:am]"
          },
          "SO:0001989": {
            "name": "5_prime_UTR_premature_start_codon_loss_variant",
            "def": "A 5' UTR variant where a premature start codon is lost. [SANGER:am]"
          },
          "SO:0001990": {
            "name": "five_prime_UTR_premature_start_codon_location_variant",
            "def": "A 5' UTR variant where a premature start codon is moved. [SANGER:am]"
          },
          "SO:0001991": {
            "name": "consensus_AFLP_fragment",
            "def": "A consensus AFLP fragment is an AFLP sequence produced from any alignment algorithm which uses assembled multiple AFLP sequences as input. [GMOD:ea]"
          },
          "SO:0001992": {
            "name": "nonsynonymous_variant",
            "def": "A non-synonymous variant is an inframe, protein altering variant, resulting in a codon change. [SO:ke]"
          },
          "SO:0001993": {
            "name": "extended_cis_splice_site",
            "def": "Intronic positions associated with cis-splicing. Contains the first and second positions immediately before the exon and the first, second and fifth positions immediately after. [SANGER:am]"
          },
          "SO:0001994": {
            "name": "intron_base_5",
            "def": "Fifth intronic position after the intron exon boundary, close to the 5' edge of the intron. [SANGER:am]"
          },
          "SO:0001995": {
            "name": "extended_intronic_splice_region_variant",
            "def": "A sequence variant occurring in the intron, within 10 bases of exon. [sanger:am]"
          },
          "SO:0001996": {
            "name": "extended_intronic_splice_region",
            "def": "Region of intronic sequence within 10 bases of an exon. [SANGER:am]"
          },
          "SO:0001997": {
            "name": "subtelomere",
            "def": "A heterochromatic region of the chromosome,  adjacent to the telomere (on the centromeric side) that contains repetitive DNA and sometimes genes and it is transcribed. [POMBE:al]"
          },
          "SO:0001998": {
            "name": "sgRNA",
            "def": "A small RNA oligo, typically about 20 bases, that guides the cas nuclease to a target DNA sequence in the CRISPR/cas mutagenesis method. [PMID:23934893]"
          },
          "SO:0001999": {
            "name": "mating_type_region_motif",
            "def": "DNA motif that is a component of a mating type region. [SO:ke]"
          },
          "SO:0002001": {
            "name": "Y_region",
            "def": "A segment of non-homology between a and alpha mating alleles, found at all three mating loci (HML, MAT, and HMR), has two forms (Ya and Yalpha). [SGD:jd]"
          },
          "SO:0002002": {
            "name": "Z1_region",
            "def": "A mating type region motif, one of two segments of homology found at all three mating loci (HML, MAT, and HMR). [SGD:jd]"
          },
          "SO:0002003": {
            "name": "Z2_region",
            "def": "A mating type region motif, the rightmost segment of homology in the HML and MAT mating loci (not present in HMR). [SGD:jd]"
          },
          "SO:0002004": {
            "name": "ARS_consensus_sequence",
            "def": "The ACS is an 11-bp sequence of the form 5'-WTTTAYRTTTW-3' which is at the core of every yeast ARS, and is necessary but not sufficient for recognition and binding by the origin recognition complex (ORC). Functional ARSs require an ACS, as well as other cis elements in the 5' (C domain) and 3' (B domain) flanking sequences of the ACS. [SGD:jd]"
          },
          "SO:0002005": {
            "name": "DSR_motif",
            "def": "The determinant of selective removal (DSR) motif consists of repeats of U(U/C)AAAC. The motif targets meiotic transcripts for removal during mitosis via the exosome. [PMID:22645662]"
          },
          "SO:0002006": {
            "name": "zinc_repressed_element",
            "def": "A promoter element that has the consensus sequence GNMGATC, and is found in promoters of genes repressed in the presence of zinc. [PMID:24003116, POMBE:mh]"
          },
          "SO:0002007": {
            "name": "MNV",
            "def": "An MNV is a multiple nucleotide variant (substitution) in which the inserted sequence is the same length as the replaced sequence. [NCBI:th]"
          },
          "SO:0002008": {
            "name": "rare_amino_acid_variant",
            "def": "A sequence variant whereby at least one base of a codon encoding a rare amino acid is changed, resulting in a different encoded amino acid. [SO:ke]"
          },
          "SO:0002009": {
            "name": "selenocysteine_loss",
            "def": "A sequence variant whereby at least one base of a codon encoding selenocysteine  is changed, resulting in a different encoded amino acid. [SO:ke]"
          },
          "SO:0002010": {
            "name": "pyrrolysine_loss",
            "def": "A sequence variant whereby at least one base of a codon encoding pyrrolysine is changed, resulting in a different encoded amino acid. [SO:ke]"
          },
          "SO:0002011": {
            "name": "intragenic_variant",
            "def": "A variant that occurs within a gene but falls outside of all transcript features. This occurs when alternate transcripts of a gene do not share overlapping  sequence. [SO:ke]"
          },
          "SO:0002012": {
            "name": "start_lost",
            "def": "A codon variant that changes at least one base of the canonical start codon. [SO:ke]"
          },
          "SO:0002013": {
            "name": "5_prime_UTR_truncation",
            "def": "A sequence variant that causes the reduction of a the 5'UTR  with regard to the reference sequence. [SO:ke]"
          },
          "SO:0002014": {
            "name": "5_prime_UTR_elongation",
            "def": "A sequence variant that causes the extension of 5' UTR, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0002015": {
            "name": "3_prime_UTR_truncation",
            "def": "A sequence variant that causes the reduction of a the 3' UTR  with regard to the reference sequence. [SO:ke]"
          },
          "SO:0002016": {
            "name": "3_prime_UTR_elongation",
            "def": "A sequence variant that causes the extension of 3' UTR, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0002017": {
            "name": "conserved_intergenic_variant",
            "def": "A sequence variant located in a conserved intergenic region, between genes. [SO:ke]"
          },
          "SO:0002018": {
            "name": "conserved_intron_variant",
            "def": "A transcript variant occurring within a conserved region of an intron. [SO:ke]"
          },
          "SO:0002019": {
            "name": "start_retained_variant",
            "def": "A sequence variant where at least one base in the start codon is changed, but the start remains. [SO:ke]"
          },
          "SO:0002020": {
            "name": "boundary_element",
            "def": "Boundary elements are DNA motifs that prevent heterochromatin from spreading into neighboring euchromatic regions. [PMID:24013502]"
          },
          "SO:0002021": {
            "name": "mating_type_region_replication_fork_barrier",
            "def": "A DNA motif that is found in eukaryotic rDNA repeats, and is a site of replication fork pausing. [PMID:17614787]"
          },
          "SO:0002022": {
            "name": "priRNA",
            "def": "A small RNA molecule, 22-23 nt in size, that is the product of a longer RNA. The production of priRNAs is independent of dicer and involves binding of RNA by argonaute and trimming by triman. In fission yeast, priRNAs trigger the establishment of heterochromatin. PriRNAs are primarily generated from centromeric transcripts (dg and dh repeats), but may also be produced from degradation products of primary transcripts. [PMID:20178743, PMID:24095277, PomBase:al]"
          },
          "SO:0002023": {
            "name": "multiplexing_sequence_identifier",
            "def": "A nucleic tag which is used in a ligation step of library preparation process to allow pooling of samples while maintaining ability to identify individual source material and creation of a multiplexed library. [OBO:prs, PMID:22574170]"
          },
          "SO:0002024": {
            "name": "W_region",
            "def": "The leftmost segment of homology in the HML and MAT mating loci,  but not present in HMR. [SGD:jd]"
          },
          "SO:0002025": {
            "name": "cis_acting_homologous_chromosome_pairing_region",
            "def": "A genome region where chromosome pairing occurs preferentially during homologous chromosome pairing during early meiotic prophase of Meiosis I. [PMID:22582262, PMID:23117617, PMID:24173580, PomBase:vw]"
          },
          "SO:0002026": {
            "name": "intein_encoding_region",
            "def": "The nucleotide sequence which encodes the intein portion of the precursor gene. [PMID:8165123]"
          },
          "SO:0002027": {
            "name": "uORF",
            "def": "A short open reading frame that is found in the 5' untranslated region of an mRNA and plays a role in translational regulation. [PMID:12890013, PMID:16153175, POMBASE:mah]"
          },
          "SO:0002028": {
            "name": "sORF",
            "def": "An open reading frame that encodes a peptide of less than 100 amino acids. [PMID:23970561, PMID:24705786, POMBASE:mah]"
          },
          "SO:0002029": {
            "name": "tnaORF",
            "def": "A translated ORF encoded entirely within the antisense strand of a known protein coding gene. [POMBASE:vw]"
          },
          "SO:0002030": {
            "name": "X_region",
            "def": "One of two segments of homology found at all three mating loci (HML, MAT and HMR). [SGD:jd]"
          },
          "SO:0002031": {
            "name": "shRNA",
            "def": "A short hairpin RNA (shRNA) is an RNA transcript that makes a tight hairpin turn that can be used to silence target gene expression via RNA interference. [PMID:6699500, SO:ke]"
          },
          "SO:0002032": {
            "name": "moR",
            "def": "A non-coding transcript encoded by sequences adjacent to the ends of the 5' and 3' miR-encoding sequences that abut the loop in precursor miRNA. [SO:ke]"
          },
          "SO:0002033": {
            "name": "loR",
            "def": "A short, non coding transcript of loop-derived sequences encoded in precursor miRNA. [SO:ke]"
          },
          "SO:0002034": {
            "name": "miR_encoding_snoRNA_primary_transcript",
            "def": "A snoRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002035": {
            "name": "lncRNA_primary_transcript",
            "def": "A primary transcript encoding a  lncRNA. [SO:ke]"
          },
          "SO:0002036": {
            "name": "miR_encoding_lncRNA_primary_transcript",
            "def": "A lncRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002037": {
            "name": "miR_encoding_tRNA_primary_transcript",
            "def": "A tRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002038": {
            "name": "shRNA_primary_transcript",
            "def": "A primary transcript encoding an shRNA. [SO:ke]"
          },
          "SO:0002039": {
            "name": "miR_encoding_shRNA_primary_transcript",
            "def": "A shRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002040": {
            "name": "vaultRNA_primary_transcript",
            "def": "A primary transcript encoding a  vaultRNA. [SO:ke]"
          },
          "SO:0002041": {
            "name": "miR_encoding_vaultRNA_primary_transcript",
            "def": "A vaultRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002042": {
            "name": "Y_RNA_primary_transcript",
            "def": "A primary transcript encoding a  Y-RNA. [SO:ke]"
          },
          "SO:0002043": {
            "name": "miR_encoding_Y_RNA_primary_transcript",
            "def": "A Y-RNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002044": {
            "name": "TCS_element",
            "def": "A TCS element is a (yeast) transcription factor binding site, bound by the TEA DNA binding domain (DBD) of transcription factors. The consensus site is CATTCC or CATTCT. [PMID:1489142, PMID:20118212, SO:ke]"
          },
          "SO:0002045": {
            "name": "pheromone_response_element",
            "def": "A PRE is a (yeast) TFBS with consensus site [TGAAAC(A/G)]. [PMID:1489142, SO:ke]"
          },
          "SO:0002046": {
            "name": "FRE",
            "def": "A FRE is an enhancer element necessary and sufficient to confer filamentation associated expression in S. cerevisiae. [PMID:1489142, SO:ke]"
          },
          "SO:0002047": {
            "name": "transcription_pause_site",
            "def": "Transcription pause sites are regions of a gene where RNA polymerase may pause during transcription. The functional role of pausing may be to facilitate factor recruitment, RNA folding, and synchronization with translation. Consensus transcription pause site have been observed in E. coli. [PMID:24789973, SO:ke]"
          },
          "SO:0002048": {
            "name": "disabled_reading_frame",
            "def": "A reading frame that could encode a full-length protein but which contains obvious mid-sequence disablements (frameshifts or premature stop codons). [SGD:se]"
          },
          "SO:0002049": {
            "name": "H3K27_acetylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is acetylated. [SO:rs]"
          },
          "SO:0002050": {
            "name": "constitutive_promoter",
            "def": "A promoter that allows for continual transcription of gene. [SO:ke]"
          },
          "SO:0002051": {
            "name": "inducible_promoter",
            "def": "A promoter whereby activity is induced by the presence or absence of biotic or abiotic factors. [SO:ke]"
          },
          "SO:0002052": {
            "name": "dominant_negative_variant",
            "def": "A variant where the mutated gene product adversely affects the other (wild type) gene product. [SO:ke]"
          },
          "SO:0002053": {
            "name": "gain_of_function_variant",
            "def": "A sequence variant whereby new or enhanced function is conferred on the gene product. [SO:ke]"
          },
          "SO:0002054": {
            "name": "loss_of_function_variant",
            "def": "A sequence variant whereby the gene product has diminished or abolished function. [SO:ke]"
          },
          "SO:0002055": {
            "name": "null_mutation",
            "def": "A variant whereby the gene product is not functional or the gene product is not produced. [SO:ke]"
          },
          "SO:0002056": {
            "name": "intronic_splicing_silencer",
            "def": "An intronic  splicing regulatory element that functions to recruit trans acting splicing factors suppress the transcription of the gene or genes they control. [PMID:23241926, SO:ke]"
          },
          "SO:0002057": {
            "name": "intronic_splicing_enhancer"
          },
          "SO:0002058": {
            "name": "exonic_splicing_silencer",
            "def": "An exonic  splicing regulatory element that functions to recruit trans acting splicing factors suppress the transcription of the gene or genes they control. [PMID:23241926, SO:ke]"
          },
          "SO:0002059": {
            "name": "recombination_enhancer",
            "def": "A regulatory_region that promotes or induces the process of recombination. [PMID:8861911, SGD:se]"
          },
          "SO:0002060": {
            "name": "interchomosomal_translocation",
            "def": "A translocation where the regions involved are from different chromosomes. [NCBI:th]"
          },
          "SO:0002061": {
            "name": "intrachomosomal_translocation",
            "def": "A translocation where the regions involved are from the same chromosome. [NCBI:th]"
          },
          "SO:0002062": {
            "name": "complex_chromosomal_rearrangement",
            "def": "A contiguous cluster of translocations, usually the result of a single catastrophic event such as chromothripsis or chromoanasynthesis. [NCBI:th]"
          },
          "SO:0002063": {
            "name": "alu_insertion",
            "def": "An insertion of sequence from the Alu family of mobile elements. [NCBI:th]"
          },
          "SO:0002064": {
            "name": "LINE1_insertion",
            "def": "An insertion from the Line1 family of mobile elements. [NCBI:th]"
          },
          "SO:0002065": {
            "name": "SVA_insertion",
            "def": "An insertion of sequence from the SVA family of mobile elements. [NCBI:th]"
          },
          "SO:0005836": {
            "name": "regulatory_region",
            "def": "A region of sequence that is involved in the control of a biological process. [SO:ke]"
          },
          "SO:0005837": {
            "name": "U14_snoRNA_primary_transcript",
            "def": "The primary transcript of an evolutionarily conserved eukaryotic low molecular weight RNA capable of intermolecular hybridization with both homologous and heterologous 18S rRNA. [PMID:2251119]"
          },
          "SO:0005841": {
            "name": "methylation_guide_snoRNA",
            "def": "A snoRNA that specifies the site of 2'-O-ribose methylation in an RNA molecule by base pairing with a short sequence around the target residue. [GOC:mah, PMID:12457565]"
          },
          "SO:0005843": {
            "name": "rRNA_cleavage_RNA",
            "def": "An ncRNA that is part of a ribonucleoprotein that cleaves the primary pre-rRNA transcript in the process of producing mature rRNA molecules. [GOC:kgc]"
          },
          "SO:0005845": {
            "name": "exon_of_single_exon_gene",
            "def": "An exon that is the only exon in a gene. [RSC:cb]"
          },
          "SO:0005847": {
            "name": "cassette_array_member"
          },
          "SO:0005848": {
            "name": "gene_cassette_member"
          },
          "SO:0005849": {
            "name": "gene_subarray_member"
          },
          "SO:0005850": {
            "name": "primer_binding_site",
            "def": "Non-covalent primer binding site for initiation of replication, transcription, or reverse transcription. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0005851": {
            "name": "gene_array",
            "def": "An array includes two or more genes, or two or more gene subarrays, contiguously arranged where the individual genes, or subarrays, are either identical in sequence, or essentially so. [SO:ma]"
          },
          "SO:0005852": {
            "name": "gene_subarray",
            "def": "A subarray is, by defintition, a member of a gene array (SO:0005851); the members of a subarray may differ substantially in sequence, but are closely related in function. [SO:ma]"
          },
          "SO:0005853": {
            "name": "gene_cassette",
            "def": "A gene that can be substituted for a related gene at a different site in the genome. [SGD:se]"
          },
          "SO:0005854": {
            "name": "gene_cassette_array",
            "def": "An array of non-functional genes whose members, when captured by recombination form functional genes. [SO:ma]"
          },
          "SO:0005855": {
            "name": "gene_group",
            "def": "A collection of related genes. [SO:ma]"
          },
          "SO:0005856": {
            "name": "selenocysteine_tRNA_primary_transcript",
            "def": "A primary transcript encoding seryl tRNA (SO:000269). [SO:ke]"
          },
          "SO:0005857": {
            "name": "selenocysteinyl_tRNA",
            "def": "A tRNA sequence that has a selenocysteine anticodon, and a 3' selenocysteine binding region. [SO:ke]"
          },
          "SO:0005858": {
            "name": "syntenic_region",
            "def": "A region in which two or more pairs of homologous markers occur on the same chromosome in two or more species. [http://www.informatics.jax.org/silverbook/glossary.shtml]"
          },
          "SO:0100001": {
            "name": "biochemical_region_of_peptide",
            "def": "A region of a peptide that is involved in a biochemical function. [EBIBS:GAR]"
          },
          "SO:0100002": {
            "name": "molecular_contact_region",
            "def": "A region that is involved a contact with another molecule. [EBIBS:GAR]"
          },
          "SO:0100003": {
            "name": "intrinsically_unstructured_polypeptide_region",
            "def": "A region of polypeptide chain with high conformational flexibility. [EBIBS:GAR]"
          },
          "SO:0100004": {
            "name": "catmat_left_handed_three",
            "def": "A motif of 3 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -75 bounds -100 to -50, res i+1: psi 140 bounds 110 to 170. An extra restriction of the length of the O to O distance would be useful, that it be less than 5 Angstrom. More precisely these two oxygens are the main chain carbonyl oxygen atoms of residues i-1 and i+1. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100005": {
            "name": "catmat_left_handed_four",
            "def": "A motif of 4 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i psi -10 bounds -50 to 30, res i+1: phi -90 bounds -120 to -60, res i+1: psi -10 bounds -50 to 30, res i+2: phi -75 bounds -100 to -50, res i+2: psi 140 bounds 110 to 170.  The extra restriction of the length of the O to O distance is similar, that it be less than 5 Angstrom. In this case these two Oxygen atoms are the main chain carbonyl oxygen atoms of residues i-1 and i+2. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100006": {
            "name": "catmat_right_handed_three",
            "def": "A motif of 3 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -75 bounds -100 to -50, res i+1: psi 140 bounds 110 to 170. An extra restriction of the length of the O to O distance would be useful, that it be less than 5 Angstrom. More precisely these two oxygens are the main chain carbonyl oxygen atoms of residues i-1 and i+1. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100007": {
            "name": "catmat_right_handed_four",
            "def": "A motif of 4 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -90 bounds -120 to -60, res i+1: psi -10 bounds -50 to 30, res i+2: phi -75 bounds -100 to -50, res i+2: psi 140 bounds 110 to 170. The extra restriction of the length of the O to O distance is similar, that it be less than 5 Angstrom. In this case these two Oxygen atoms are the main chain carbonyl oxygen atoms of residues i-1 and i+2. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100008": {
            "name": "alpha_beta_motif",
            "def": "A motif of five consecutive residues and two H-bonds in which: H-bond between CO of residue(i) and NH of residue(i+4), H-bond between CO of residue(i) and NH of residue(i+3),Phi angles of residues(i+1), (i+2) and (i+3) are negative. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100009": {
            "name": "lipoprotein_signal_peptide",
            "def": "A peptide that acts as a signal for both membrane translocation and lipid attachment in prokaryotes. [EBIBS:GAR]"
          },
          "SO:0100010": {
            "name": "no_output",
            "def": "An experimental region wherean analysis has been run and not produced any annotation. [EBIBS:GAR]"
          },
          "SO:0100011": {
            "name": "cleaved_peptide_region",
            "def": "The cleaved_peptide_region is the region of a peptide sequence that is cleaved during maturation. [EBIBS:GAR]"
          },
          "SO:0100012": {
            "name": "peptide_coil",
            "def": "Irregular, unstructured regions of a protein's backbone, as distinct from the regular region (namely alpha helix and beta strand - characterised by specific patterns of main-chain hydrogen bonds). [EBIBS:GAR]"
          },
          "SO:0100013": {
            "name": "hydrophobic_region_of_peptide",
            "def": "Hydrophobic regions are regions with a low affinity for water. [EBIBS:GAR]"
          },
          "SO:0100014": {
            "name": "n_terminal_region",
            "def": "The amino-terminal positively-charged region of a signal peptide (approx 1-5 aa). [EBIBS:GAR]"
          },
          "SO:0100015": {
            "name": "c_terminal_region",
            "def": "The more polar, carboxy-terminal region of the signal peptide (approx 3-7 aa). [EBIBS:GAR]"
          },
          "SO:0100016": {
            "name": "central_hydrophobic_region_of_signal_peptide",
            "def": "The central, hydrophobic region of the signal peptide (approx 7-15 aa). [EBIBS:GAR]"
          },
          "SO:0100017": {
            "name": "polypeptide_conserved_motif",
            "def": "A conserved motif is a short (up to 20 amino acids) region of biological interest that is conserved in different proteins. They may or may not have functional or structural significance within the proteins in which they are found. [EBIBS:GAR]"
          },
          "SO:0100018": {
            "name": "polypeptide_binding_motif",
            "def": "A polypeptide binding motif is a short (up to 20 amino acids) polypeptide region of biological interest that contains one or more amino acids experimentally shown to bind to a ligand. [EBIBS:GAR]"
          },
          "SO:0100019": {
            "name": "polypeptide_catalytic_motif",
            "def": "A polypeptide catalytic motif is a short (up to 20 amino acids) polypeptide region that contains one or more active site residues. [EBIBS:GAR]"
          },
          "SO:0100020": {
            "name": "polypeptide_DNA_contact",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with DNA. [EBIBS:GAR, SO:ke]"
          },
          "SO:0100021": {
            "name": "polypeptide_conserved_region",
            "def": "A subsection of sequence with biological interest that is conserved in different proteins. They may or may not have functional or structural significance within the proteins in which they are found. [EBIBS:GAR]"
          },
          "SO:1000002": {
            "name": "substitution",
            "def": "A sequence alteration where the length of the change in the variant is the same as that of the reference. [SO:ke]"
          },
          "SO:1000005": {
            "name": "complex_substitution",
            "def": "When no simple or well defined DNA mutation event describes the observed DNA change, the keyword \\complex\\ should be used. Usually there are multiple equally plausible explanations for the change. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000008": {
            "name": "point_mutation",
            "def": "A single nucleotide change which has occurred at the same position of a corresponding nucleotide in a reference sequence. [SO:immuno_workshop]"
          },
          "SO:1000009": {
            "name": "transition",
            "def": "Change of a pyrimidine nucleotide, C or T, into an other pyrimidine nucleotide, or change of a purine nucleotide, A or G, into an other purine nucleotide. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000010": {
            "name": "pyrimidine_transition",
            "def": "A substitution of a pyrimidine, C or T, for another pyrimidine. [SO:ke]"
          },
          "SO:1000011": {
            "name": "C_to_T_transition",
            "def": "A transition of a cytidine to a thymine. [SO:ke]"
          },
          "SO:1000012": {
            "name": "C_to_T_transition_at_pCpG_site",
            "def": "The transition of cytidine to thymine occurring at a pCpG site as a consequence of the spontaneous deamination of 5'-methylcytidine. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000013": {
            "name": "T_to_C_transition"
          },
          "SO:1000014": {
            "name": "purine_transition",
            "def": "A substitution of a purine, A or G, for another purine. [SO:ke]"
          },
          "SO:1000015": {
            "name": "A_to_G_transition",
            "def": "A transition of an adenine to a guanine. [SO:ke]"
          },
          "SO:1000016": {
            "name": "G_to_A_transition",
            "def": "A transition of a guanine to an adenine. [SO:ke]"
          },
          "SO:1000017": {
            "name": "transversion",
            "def": "Change of a pyrimidine nucleotide, C or T, into a purine nucleotide, A or G, or vice versa. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000018": {
            "name": "pyrimidine_to_purine_transversion",
            "def": "Change of a pyrimidine nucleotide, C or T, into a purine nucleotide, A or G. [SO:ke]"
          },
          "SO:1000019": {
            "name": "C_to_A_transversion",
            "def": "A transversion from cytidine to adenine. [SO:ke]"
          },
          "SO:1000020": {
            "name": "C_to_G_transversion"
          },
          "SO:1000021": {
            "name": "T_to_A_transversion",
            "def": "A transversion from T to A. [SO:ke]"
          },
          "SO:1000022": {
            "name": "T_to_G_transversion",
            "def": "A transversion from T to G. [SO:ke]"
          },
          "SO:1000023": {
            "name": "purine_to_pyrimidine_transversion",
            "def": "Change of a purine nucleotide, A or G , into a pyrimidine nucleotide C or T. [SO:ke]"
          },
          "SO:1000024": {
            "name": "A_to_C_transversion",
            "def": "A transversion from adenine to cytidine. [SO:ke]"
          },
          "SO:1000025": {
            "name": "A_to_T_transversion",
            "def": "A transversion from adenine to thymine. [SO:ke]"
          },
          "SO:1000026": {
            "name": "G_to_C_transversion",
            "def": "A transversion from guanine to cytidine. [SO:ke]"
          },
          "SO:1000027": {
            "name": "G_to_T_transversion",
            "def": "A transversion from guanine to thymine. [SO:ke]"
          },
          "SO:1000028": {
            "name": "intrachromosomal_mutation",
            "def": "A chromosomal structure variation within a single chromosome. [SO:ke]"
          },
          "SO:1000029": {
            "name": "chromosomal_deletion",
            "def": "An incomplete chromosome. [SO:ke]"
          },
          "SO:1000030": {
            "name": "chromosomal_inversion",
            "def": "An interchromosomal mutation where a region of the chromosome is inverted with respect to wild type. [SO:ke]"
          },
          "SO:1000031": {
            "name": "interchromosomal_mutation",
            "def": "A chromosomal structure variation whereby more than one chromosome is involved. [SO:ke]"
          },
          "SO:1000032": {
            "name": "indel",
            "def": "A sequence alteration which included an insertion and a deletion, affecting 2 or more bases. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html, http:http://www.hgvs.org/mutnomen/recs-DNA.html#indel]"
          },
          "SO:1000035": {
            "name": "duplication",
            "def": "An insertion which derives from, or is identical in sequence to, nucleotides present at a known location in the genome. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html, NCBI:th]"
          },
          "SO:1000036": {
            "name": "inversion",
            "def": "A continuous nucleotide sequence is inverted in the same position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000037": {
            "name": "chromosomal_duplication",
            "def": "An extra chromosome. [SO:ke]"
          },
          "SO:1000038": {
            "name": "intrachromosomal_duplication",
            "def": "A duplication that occurred within a chromosome. [SO:ke]"
          },
          "SO:1000039": {
            "name": "direct_tandem_duplication",
            "def": "A tandem duplication where the individual regions are in the same orientation. [SO:ke]"
          },
          "SO:1000040": {
            "name": "inverted_tandem_duplication",
            "def": "A tandem duplication where the individual regions are not in the same orientation. [SO:ke]"
          },
          "SO:1000041": {
            "name": "intrachromosomal_transposition",
            "def": "A chromosome structure variation whereby a transposition occurred within a chromosome. [SO:ke]"
          },
          "SO:1000042": {
            "name": "compound_chromosome",
            "def": "A chromosome structure variant where a monocentric element is caused by the fusion of two chromosome arms. [SO:ke]"
          },
          "SO:1000043": {
            "name": "Robertsonian_fusion",
            "def": "A non reciprocal translocation whereby the participating chromosomes break at their centromeres and the long arms fuse to form a single chromosome with a single centromere. [http://en.wikipedia.org/wiki/Robertsonian_translocation]"
          },
          "SO:1000044": {
            "name": "chromosomal_translocation",
            "def": "An interchromosomal mutation. Rearrangements that alter the pairing of telomeres are classified as translocations. [FB:reference_manual]"
          },
          "SO:1000045": {
            "name": "ring_chromosome",
            "def": "A ring chromosome is a chromosome whose arms have fused together to form a ring, often with the loss of the ends of the chromosome. [http://en.wikipedia.org/wiki/Ring_chromosome]"
          },
          "SO:1000046": {
            "name": "pericentric_inversion",
            "def": "A chromosomal inversion that includes the centromere. [FB:reference_manual]"
          },
          "SO:1000047": {
            "name": "paracentric_inversion",
            "def": "A chromosomal inversion that does not include the centromere. [FB:reference_manual]"
          },
          "SO:1000048": {
            "name": "reciprocal_chromosomal_translocation",
            "def": "A chromosomal translocation with two breaks; two chromosome segments have simply been exchanged. [FB:reference_manual]"
          },
          "SO:1000049": {
            "name": "sequence_variation_affecting_transcript",
            "def": "Any change in mature, spliced and processed, RNA that results from a change in the corresponding DNA sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000050": {
            "name": "sequence_variant_causing_no_change_in_transcript",
            "def": "No effect on the state of the RNA. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000054": {
            "name": "sequence_variation_affecting_coding_sequence",
            "def": "Any of the amino acid coding triplets of a gene are affected by the DNA mutation. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000055": {
            "name": "sequence_variant_causing_initiator_codon_change_in_transcript",
            "def": "The DNA mutation changes, usually destroys, the first coding triplet of a gene. Usually prevents translation although another initiator codon may be used. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000056": {
            "name": "sequence_variant_causing_amino_acid_coding_codon_change_in_transcript",
            "def": "The DNA mutation affects the amino acid coding sequence of a gene; this region includes both the initiator and terminator codons. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000057": {
            "name": "sequence_variant_causing_synonymous_codon_change_in_transcript",
            "def": "The changed codon has the same translation product as the original codon. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000058": {
            "name": "sequence_variant_causing_non_synonymous_codon_change_in_transcript",
            "def": "A DNA point mutation that causes a substitution of an amino acid by an other. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000059": {
            "name": "sequence_variant_causing_missense_codon_change_in_transcript",
            "def": "The nucleotide change in the codon leads to a new codon coding for a new amino acid. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000060": {
            "name": "sequence_variant_causing_conservative_missense_codon_change_in_transcript",
            "def": "The amino acid change following from the codon change does not change the gross properties (size, charge, hydrophobicity) of the amino acid at that position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000061": {
            "name": "sequence_variant_causing_nonconservative_missense_codon_change_in_transcript",
            "def": "The amino acid change following from the codon change changes the gross properties (size, charge, hydrophobicity) of the amino acid in that position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000062": {
            "name": "sequence_variant_causing_nonsense_codon_change_in_transcript",
            "def": "The nucleotide change in the codon triplet creates a terminator codon. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000063": {
            "name": "sequence_variant_causing_terminator_codon_change_in_transcript",
            "def": "The nucleotide change in the codon triplet changes the stop codon, causing an elongated transcript sequence. [SO:ke]"
          },
          "SO:1000064": {
            "name": "sequence_variation_affecting_reading_frame",
            "def": "An umbrella term for terms describing an effect of a sequence variation on the frame of translation. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000065": {
            "name": "frameshift_sequence_variation",
            "def": "A mutation causing a disruption of the translational reading frame, because the number of nucleotides inserted or deleted is not a multiple of three. [SO:ke]"
          },
          "SO:1000066": {
            "name": "sequence_variant_causing_plus_1_frameshift_mutation",
            "def": "A mutation causing a disruption of the translational reading frame, due to the insertion of a nucleotide. [SO:ke]"
          },
          "SO:1000067": {
            "name": "sequence_variant_causing_minus_1_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the deletion of a nucleotide. [SO:ke]"
          },
          "SO:1000068": {
            "name": "sequence_variant_causing_plus_2_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the insertion of two nucleotides. [SO:ke]"
          },
          "SO:1000069": {
            "name": "sequence_variant_causing_minus_2_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the deletion of two nucleotides. [SO:ke]"
          },
          "SO:1000070": {
            "name": "sequence_variant_affecting_transcript_processing",
            "def": "Sequence variant affects the way in which the primary transcriptional product is processed to form the mature transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000071": {
            "name": "sequence_variant_affecting_splicing",
            "def": "A sequence_variant_effect where the way in which the primary transcriptional product is processed to form the mature transcript, specifically by the removal (splicing) of intron sequences is changed. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000072": {
            "name": "sequence_variant_affecting_splice_donor",
            "def": "A sequence_variant_effect that changes the splice donor sequence. [SO:ke]"
          },
          "SO:1000073": {
            "name": "sequence_variant_affecting_splice_acceptor",
            "def": "A sequence_variant_effect that changes the splice acceptor sequence. [SO:ke]"
          },
          "SO:1000074": {
            "name": "sequence_variant_causing_cryptic_splice_activation",
            "def": "A sequence variant causing a new (functional) splice site. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000075": {
            "name": "sequence_variant_affecting_editing",
            "def": "Sequence variant affects the editing of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000076": {
            "name": "sequence_variant_affecting_transcription",
            "def": "Mutation affects the process of transcription, its initiation, progression or termination. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000078": {
            "name": "sequence_variant_decreasing_rate_of_transcription",
            "def": "A sequence variation that decreases the rate a which transcription of the sequence occurs. [SO:ke]"
          },
          "SO:1000079": {
            "name": "sequence_variation_affecting_transcript_sequence"
          },
          "SO:1000080": {
            "name": "sequence_variant_increasing_rate_of_transcription"
          },
          "SO:1000081": {
            "name": "sequence_variant_affecting_rate_of_transcription",
            "def": "A mutation that alters the rate a which transcription of the sequence occurs. [SO:ke]"
          },
          "SO:1000082": {
            "name": "sequence variant_affecting_transcript_stability",
            "def": "Sequence variant affects the stability of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000083": {
            "name": "sequence_variant_increasing_transcript_stability",
            "def": "Sequence variant increases the stability (half-life) of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000084": {
            "name": "sequence_variant_decreasing_transcript_stability",
            "def": "Sequence variant decreases the stability (half-life) of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000085": {
            "name": "sequence_variation_affecting_level_of_transcript",
            "def": "A sequence variation that causes a change in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
          },
          "SO:1000086": {
            "name": "sequence_variation_decreasing_level_of_transcript",
            "def": "A sequence variation that causes a decrease in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
          },
          "SO:1000087": {
            "name": "sequence_variation_increasing_level_of_transcript",
            "def": "A sequence_variation that causes an increase in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
          },
          "SO:1000088": {
            "name": "sequence_variant_affecting_translational_product",
            "def": "A sequence variant causing a change in primary translation product of a transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000089": {
            "name": "sequence_variant_causing_no_change_of_translational_product",
            "def": "The sequence variant at RNA level does not lead to any change in polypeptide. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000092": {
            "name": "sequence_variant_causing_complex_change_of_translational_product",
            "def": "Any sequence variant effect that is known at nucleotide level but cannot be explained by using other key terms. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000093": {
            "name": "sequence_variant_causing_amino_acid_substitution",
            "def": "The replacement of a single amino acid by another. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000094": {
            "name": "sequence_variant_causing_conservative_amino_acid_substitution"
          },
          "SO:1000095": {
            "name": "sequence_variant_causing_nonconservative_amino_acid_substitution"
          },
          "SO:1000096": {
            "name": "sequence_variant_causing_amino_acid_insertion",
            "def": "The insertion of one or more amino acids from the polypeptide, without affecting the surrounding sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000097": {
            "name": "sequence_variant_causing_amino_acid_deletion",
            "def": "The deletion of one or more amino acids from the polypeptide, without affecting the surrounding sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000098": {
            "name": "sequence_variant_causing_polypeptide_truncation",
            "def": "The translational product is truncated at its C-terminus, usually a result of a nonsense codon change in transcript (SO:1000062). [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000099": {
            "name": "sequence_variant_causing_polypeptide_elongation",
            "def": "The extension of the translational product at either (or both) the N-terminus and/or the C-terminus. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000100": {
            "name": "mutation_causing_polypeptide_N_terminal_elongation",
            "def": ". [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000101": {
            "name": "mutation_causing_polypeptide_C_terminal_elongation",
            "def": ". [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000102": {
            "name": "sequence_variant_affecting_level_of_translational_product"
          },
          "SO:1000103": {
            "name": "sequence_variant_decreasing_level_of_translation_product"
          },
          "SO:1000104": {
            "name": "sequence_variant_increasing_level_of_translation_product"
          },
          "SO:1000105": {
            "name": "sequence_variant_affecting_polypeptide_amino_acid_sequence"
          },
          "SO:1000106": {
            "name": "mutation_causing_inframe_polypeptide_N_terminal_elongation"
          },
          "SO:1000107": {
            "name": "mutation_causing_out_of_frame_polypeptide_N_terminal_elongation"
          },
          "SO:1000108": {
            "name": "mutaton_causing_inframe_polypeptide_C_terminal_elongation"
          },
          "SO:1000109": {
            "name": "mutation_causing_out_of_frame_polypeptide_C_terminal_elongation"
          },
          "SO:1000110": {
            "name": "frame_restoring_sequence_variant",
            "def": "A mutation that reverts the sequence of a previous frameshift mutation back to the initial frame. [SO:ke]"
          },
          "SO:1000111": {
            "name": "sequence_variant_affecting_3D_structure_of_polypeptide",
            "def": "A mutation that changes the amino acid sequence of the peptide in such a way that it changes the 3D structure of the molecule. [SO:ke]"
          },
          "SO:1000112": {
            "name": "sequence_variant_causing_no_3D_structural_change"
          },
          "SO:1000115": {
            "name": "sequence_variant_causing_complex_3D_structural_change"
          },
          "SO:1000116": {
            "name": "sequence_variant_causing_conformational_change"
          },
          "SO:1000117": {
            "name": "sequence_variant_affecting_polypeptide_function"
          },
          "SO:1000118": {
            "name": "sequence_variant_causing_loss_of_function_of_polypeptide"
          },
          "SO:1000119": {
            "name": "sequence_variant_causing_inactive_ligand_binding_site"
          },
          "SO:1000120": {
            "name": "sequence_variant_causing_inactive_catalytic_site"
          },
          "SO:1000121": {
            "name": "sequence_variant_causing_polypeptide_localization_change"
          },
          "SO:1000122": {
            "name": "sequence_variant_causing_polypeptide_post_translational_processing_change"
          },
          "SO:1000123": {
            "name": "polypeptide_post_translational_processing_affected"
          },
          "SO:1000124": {
            "name": "sequence_variant_causing_partial_loss_of_function_of_polypeptide"
          },
          "SO:1000125": {
            "name": "sequence_variant_causing_gain_of_function_of_polypeptide"
          },
          "SO:1000126": {
            "name": "sequence_variant_affecting_transcript_secondary_structure",
            "def": "A sequence variant that affects the secondary structure (folding) of the RNA transcript molecule. [SO:ke]"
          },
          "SO:1000127": {
            "name": "sequence_variant_causing_compensatory_transcript_secondary_structure_mutation"
          },
          "SO:1000132": {
            "name": "sequence_variant_effect",
            "def": "The effect of a change in nucleotide sequence. [SO:ke]"
          },
          "SO:1000134": {
            "name": "sequence_variant_causing_polypeptide_fusion"
          },
          "SO:1000136": {
            "name": "autosynaptic_chromosome",
            "def": "An autosynaptic chromosome is the aneuploid product of recombination between a pericentric inversion and a cytologically wild-type chromosome. [PMID:6804304]"
          },
          "SO:1000138": {
            "name": "homo_compound_chromosome",
            "def": "A compound chromosome whereby two copies of the same chromosomal arm attached to a common centromere. The chromosome is diploid for the arm involved. [SO:ke]"
          },
          "SO:1000140": {
            "name": "hetero_compound_chromosome",
            "def": "A compound chromosome whereby two arms from different chromosomes are connected through the centromere of one of them. [FB:reference_manual, SO:ke]"
          },
          "SO:1000141": {
            "name": "chromosome_fission",
            "def": "A chromosome that occurred by the division of a larger chromosome. [SO:ke]"
          },
          "SO:1000142": {
            "name": "dexstrosynaptic_chromosome",
            "def": "An autosynaptic chromosome carrying the two right (D = dextro) telomeres. [FB:manual]"
          },
          "SO:1000143": {
            "name": "laevosynaptic_chromosome",
            "def": "LS is an autosynaptic chromosome carrying the two left (L = levo) telomeres. [FB:manual]"
          },
          "SO:1000144": {
            "name": "free_duplication",
            "def": "A chromosome structure variation whereby the duplicated sequences are carried as a free centric element. [FB:reference_manual]"
          },
          "SO:1000145": {
            "name": "free_ring_duplication",
            "def": "A ring chromosome which is a copy of another chromosome. [SO:ke]"
          },
          "SO:1000147": {
            "name": "deficient_translocation",
            "def": "A chromosomal deletion whereby a translocation occurs in which one of the four broken ends loses a segment before re-joining. [FB:reference_manual]"
          },
          "SO:1000148": {
            "name": "inversion_cum_translocation",
            "def": "A chromosomal translocation whereby the first two breaks are in the same chromosome, and the region between them is rejoined in inverted order to the other side of the first break, such that both sides of break one are present on the same chromosome. The remaining free ends are joined as a translocation with those resulting from the third break. [FB:reference_manual]"
          },
          "SO:1000149": {
            "name": "bipartite_duplication",
            "def": "An interchromosomal mutation whereby the (large) region between the first two breaks listed is lost, and the two flanking segments (one of them centric) are joined as a translocation to the free ends resulting from the third break. [FB:reference_manual]"
          },
          "SO:1000150": {
            "name": "cyclic_translocation",
            "def": "A chromosomal translocation whereby three breaks occurred in three different chromosomes. The centric segment resulting from the first break listed is joined to the acentric segment resulting from the second, rather than the third. [FB:reference_manual]"
          },
          "SO:1000151": {
            "name": "bipartite_inversion",
            "def": "A chromosomal inversion caused by three breaks in the same chromosome; both central segments are inverted in place (i.e., they are not transposed). [FB:reference_manual]"
          },
          "SO:1000152": {
            "name": "uninverted_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
          },
          "SO:1000153": {
            "name": "inverted_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segments. [FB:reference_manual]"
          },
          "SO:1000154": {
            "name": "insertional_duplication",
            "def": "A chromosome duplication involving the insertion of a duplicated region (as opposed to a free duplication). [SO:ke]"
          },
          "SO:1000155": {
            "name": "interchromosomal_transposition",
            "def": "A chromosome structure variation whereby a transposition occurred between chromosomes. [SO:ke]"
          },
          "SO:1000156": {
            "name": "inverted_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segment. [FB:reference_manual]"
          },
          "SO:1000157": {
            "name": "uninverted_interchromosomal_transposition",
            "def": "An interchromosomal transition where the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
          },
          "SO:1000158": {
            "name": "inverted_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segments. [FB:reference_manual]"
          },
          "SO:1000159": {
            "name": "uninverted_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
          },
          "SO:1000160": {
            "name": "unoriented_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
          },
          "SO:1000161": {
            "name": "unoriented_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a copy of the segment between the first two breaks listed is inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
          },
          "SO:1000162": {
            "name": "unoriented_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
          },
          "SO:1000170": {
            "name": "uncharacterized_chromosomal_mutation"
          },
          "SO:1000171": {
            "name": "deficient_inversion",
            "def": "A chromosomal deletion whereby three breaks occur in the same chromosome; one central region is lost, and the other is inverted. [FB:reference_manual, SO:ke]"
          },
          "SO:1000173": {
            "name": "tandem_duplication",
            "def": "A duplication consisting of 2 identical adjacent regions. [SO:ke]"
          },
          "SO:1000175": {
            "name": "partially_characterized_chromosomal_mutation"
          },
          "SO:1000180": {
            "name": "sequence_variant_affecting_gene_structure",
            "def": "A sequence_variant_effect that changes the gene structure. [SO:ke]"
          },
          "SO:1000181": {
            "name": "sequence_variant_causing_gene_fusion",
            "def": "A sequence_variant_effect that changes the gene structure by causing a fusion to another gene. [SO:ke]"
          },
          "SO:1000182": {
            "name": "chromosome_number_variation",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number. [SO:ke]"
          },
          "SO:1000183": {
            "name": "chromosome_structure_variation"
          },
          "SO:1000184": {
            "name": "sequence_variant_causes_exon_loss",
            "def": "A sequence variant affecting splicing and causes an exon loss. [SO:ke]"
          },
          "SO:1000185": {
            "name": "sequence_variant_causes_intron_gain",
            "def": "A sequence variant effect, causing an intron to be gained by the processed transcript; usually a result of a donor acceptor mutation (SO:1000072). [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000186": {
            "name": "sequence_variant_causing_cryptic_splice_donor_activation"
          },
          "SO:1001186": {
            "name": "sequence_variant_causing_cryptic_splice_acceptor_activation"
          },
          "SO:1001187": {
            "name": "alternatively_spliced_transcript",
            "def": "A transcript that is alternatively spliced. [SO:xp]"
          },
          "SO:1001188": {
            "name": "encodes_1_polypeptide",
            "def": "A gene that is alternately spliced, but encodes only one polypeptide. [SO:ke]"
          },
          "SO:1001189": {
            "name": "encodes_greater_than_1_polypeptide",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide. [SO:ke]"
          },
          "SO:1001190": {
            "name": "encodes_different_polypeptides_different_stop",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different stop codons. [SO:ke]"
          },
          "SO:1001191": {
            "name": "encodes_overlapping_peptides_different_start",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different start codons. [SO:ke]"
          },
          "SO:1001192": {
            "name": "encodes_disjoint_polypeptides",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that do not have overlapping peptide sequences. [SO:ke]"
          },
          "SO:1001193": {
            "name": "encodes_overlapping_polypeptides_different_start_and_stop",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different start and stop codons. [SO:ke]"
          },
          "SO:1001194": {
            "name": "alternatively_spliced_gene_encoding_greater_than_1_polypeptide_coding_regions_overlapping"
          },
          "SO:1001195": {
            "name": "encodes_overlapping_peptides",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences. [SO:ke]"
          },
          "SO:1001196": {
            "name": "cryptogene",
            "def": "A maxicircle gene so extensively edited that it cannot be matched to its edited mRNA sequence. [SO:ma]"
          },
          "SO:1001197": {
            "name": "dicistronic_primary_transcript",
            "def": "A primary transcript that has the quality dicistronic. [SO:xp]"
          },
          "SO:1001217": {
            "name": "member_of_regulon"
          },
          "SO:1001244": {
            "name": "alternatively_spliced_transcript_encoding_greater_than_1_polypeptide_different_start_codon_different_stop_codon_coding_regions_non_overlapping"
          },
          "SO:1001246": {
            "name": "CDS_independently_known",
            "def": "A CDS with the evidence status of being independently known. [SO:xp]"
          },
          "SO:1001247": {
            "name": "orphan_CDS",
            "def": "A CDS whose predicted amino acid sequence is unsupported by any experimental evidence or by any match with any other known sequence. [SO:ma]"
          },
          "SO:1001249": {
            "name": "CDS_supported_by_domain_match_data",
            "def": "A CDS that is supported by domain similarity. [SO:xp]"
          },
          "SO:1001251": {
            "name": "CDS_supported_by_sequence_similarity_data",
            "def": "A CDS that is supported by sequence similarity data. [SO:xp]"
          },
          "SO:1001254": {
            "name": "CDS_predicted",
            "def": "A CDS that is predicted. [SO:ke]"
          },
          "SO:1001255": {
            "name": "status_of_coding_sequence"
          },
          "SO:1001259": {
            "name": "CDS_supported_by_EST_or_cDNA_data",
            "def": "A CDS that is supported by similarity to EST or cDNA data. [SO:xp]"
          },
          "SO:1001260": {
            "name": "internal_Shine_Dalgarno_sequence",
            "def": "A Shine-Dalgarno sequence that stimulates recoding through interactions with the anti-Shine-Dalgarno in the RNA of small ribosomal subunits of translating ribosomes. The signal is only operative in Bacteria. [PMID:12519954, SO:ke]"
          },
          "SO:1001261": {
            "name": "recoded_mRNA",
            "def": "The sequence of a mature mRNA transcript, modified before translation or during translation, usually by special cis-acting signals. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8811194&dopt=Abstract]"
          },
          "SO:1001262": {
            "name": "minus_1_translationally_frameshifted",
            "def": "An attribute describing a translational frameshift of -1. [SO:ke]"
          },
          "SO:1001263": {
            "name": "plus_1_translationally_frameshifted",
            "def": "An attribute describing a translational frameshift of +1. [SO:ke]"
          },
          "SO:1001264": {
            "name": "mRNA_recoded_by_translational_bypass",
            "def": "A recoded_mRNA where translation was suspended at a particular codon and resumed at a particular non-overlapping downstream codon. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8811194&dopt=Abstract]"
          },
          "SO:1001265": {
            "name": "mRNA_recoded_by_codon_redefinition",
            "def": "A recoded_mRNA that was modified by an alteration of codon meaning. [SO:ma]"
          },
          "SO:1001266": {
            "name": "stop_codon_redefinition_as_selenocysteine"
          },
          "SO:1001267": {
            "name": "stop_codon_readthrough"
          },
          "SO:1001268": {
            "name": "recoding_stimulatory_region",
            "def": "A site in an mRNA sequence that stimulates the recoding of a region in the same mRNA. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=12519954&dopt=Abstract]"
          },
          "SO:1001269": {
            "name": "four_bp_start_codon",
            "def": "A non-canonical start codon with 4 base pairs. [SO:ke]"
          },
          "SO:1001270": {
            "name": "stop_codon_redefinition_as_pyrrolysine"
          },
          "SO:1001271": {
            "name": "archaeal_intron",
            "def": "An intron characteristic of Archaeal tRNA and rRNA genes, where intron transcript generates a bulge-helix-bulge motif that is recognised by a splicing endoribonuclease. [PMID:9301331, SO:ma]"
          },
          "SO:1001272": {
            "name": "tRNA_intron",
            "def": "An intron found in tRNA that is spliced via endonucleolytic cleavage and ligation rather than transesterification. [SO:ke]"
          },
          "SO:1001273": {
            "name": "CTG_start_codon",
            "def": "A non-canonical start codon of sequence CTG. [SO:ke]"
          },
          "SO:1001274": {
            "name": "SECIS_element",
            "def": "The incorporation of selenocysteine into a protein sequence is directed by an in-frame UGA codon (usually a stop codon) within the coding region of the mRNA. Selenoprotein mRNAs contain a conserved secondary structure in the 3' UTR that is required for the distinction of UGA stop from UGA selenocysteine. The selenocysteine insertion sequence (SECIS) is around 60 nt in length and adopts a hairpin structure which is sufficiently well-defined and conserved to act as a computational screen for selenoprotein genes. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00031]"
          },
          "SO:1001275": {
            "name": "retron",
            "def": "Sequence coding for a short, single-stranded, DNA sequence via a retrotransposed RNA intermediate; characteristic of some microbial genomes. [SO:ma]"
          },
          "SO:1001277": {
            "name": "three_prime_recoding_site",
            "def": "The recoding stimulatory signal located downstream of the recoding site. [SO:ke]"
          },
          "SO:1001279": {
            "name": "three_prime_stem_loop_structure",
            "def": "A recoding stimulatory region, the stem-loop secondary structural element is downstream of the redefined region. [PMID:12519954, SO:ke]"
          },
          "SO:1001280": {
            "name": "five_prime_recoding_site",
            "def": "The recoding stimulatory signal located upstream of the recoding site. [SO:ke]"
          },
          "SO:1001281": {
            "name": "flanking_three_prime_quadruplet_recoding_signal",
            "def": "Four base pair sequence immediately downstream of the redefined region. The redefined region is a frameshift site. The quadruplet is 2 overlapping codons. [PMID:12519954, SO:ke]"
          },
          "SO:1001282": {
            "name": "UAG_stop_codon_signal",
            "def": "A stop codon signal for a UAG stop codon redefinition. [SO:ke]"
          },
          "SO:1001283": {
            "name": "UAA_stop_codon_signal",
            "def": "A stop codon signal for a UAA stop codon redefinition. [SO:ke]"
          },
          "SO:1001284": {
            "name": "regulon",
            "def": "A group of genes, whether linked as a cluster or not, that respond to a common regulatory signal. [ISBN:0198506732]"
          },
          "SO:1001285": {
            "name": "UGA_stop_codon_signal",
            "def": "A stop codon signal for a UGA stop codon redefinition. [SO:ke]"
          },
          "SO:1001286": {
            "name": "three_prime_repeat_recoding_signal",
            "def": "A recoding stimulatory signal, downstream sequence important for recoding that contains repetitive elements. [PMID:12519954, SO:ke]"
          },
          "SO:1001287": {
            "name": "distant_three_prime_recoding_signal",
            "def": "A recoding signal that is found many hundreds of nucleotides 3' of a redefined stop codon. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8709208&dopt=Abstract]"
          },
          "SO:1001288": {
            "name": "stop_codon_signal",
            "def": "A recoding stimulatory signal that is a stop codon and has effect on efficiency of recoding. [PMID:12519954, SO:ke]"
          },
          "SO:2000061": {
            "name": "databank_entry",
            "def": "The sequence referred to by an entry in a databank such as GenBank or SwissProt. [SO:ke]"
          },
          "SO:3000000": {
            "name": "gene_segment",
            "def": "A gene component region which acts as a recombinational unit of a gene whose functional form is generated through somatic recombination. [GOC:add]"
          }
        };
      })(sequenceOntology = exports.sequenceOntology || (exports.sequenceOntology = {}));
    }
  });

  // node_modules/sboljs/node_modules/bioterms/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/sboljs/node_modules/bioterms/dist/index.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.uriToName = exports.sequenceOntology = exports.Specifiers = exports.Predicates = exports.Types = exports.prefixify = exports.Prefixes = void 0;
      var Prefixes_1 = require_Prefixes();
      Object.defineProperty(exports, "Prefixes", { enumerable: true, get: function() {
        return Prefixes_1.Prefixes;
      } });
      Object.defineProperty(exports, "prefixify", { enumerable: true, get: function() {
        return Prefixes_1.prefixify;
      } });
      var Types_1 = require_Types();
      Object.defineProperty(exports, "Types", { enumerable: true, get: function() {
        return Types_1.Types;
      } });
      var Predicates_1 = require_Predicates();
      Object.defineProperty(exports, "Predicates", { enumerable: true, get: function() {
        return Predicates_1.Predicates;
      } });
      var Specifiers_1 = require_Specifiers();
      Object.defineProperty(exports, "Specifiers", { enumerable: true, get: function() {
        return Specifiers_1.Specifiers;
      } });
      var sequenceOntology_1 = require_sequenceOntology();
      Object.defineProperty(exports, "sequenceOntology", { enumerable: true, get: function() {
        return sequenceOntology_1.sequenceOntology;
      } });
      Object.defineProperty(exports, "uriToName", { enumerable: true, get: function() {
        return sequenceOntology_1.uriToName;
      } });
    }
  });

  // node_modules/sboljs/dist/isOwnershipRelation.js
  var require_isOwnershipRelation = __commonJS({
    "node_modules/sboljs/dist/isOwnershipRelation.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var rdfoo_1 = require_dist();
      var ownershipPredicates = [
        bioterms_1.Predicates.SBOL1.annotation,
        bioterms_1.Predicates.SBOL1.dnaSequence,
        bioterms_1.Predicates.SBOL2.sequenceConstraint,
        bioterms_1.Predicates.SBOL2.sequenceAnnotation,
        bioterms_1.Predicates.SBOL2.attachment,
        bioterms_1.Predicates.SBOL2.module,
        bioterms_1.Predicates.SBOL2.functionalComponent,
        bioterms_1.Predicates.SBOL2.participation,
        bioterms_1.Predicates.SBOL2.location,
        bioterms_1.Predicates.SBOL2.sourceLocation,
        bioterms_1.Predicates.SBOL2.interaction,
        bioterms_1.Predicates.Prov.qualifiedAssociation,
        bioterms_1.Predicates.Prov.qualifiedUsage,
        bioterms_1.Predicates.SBOL2.measure,
        bioterms_1.Predicates.SBOL2.variableComponent,
        bioterms_1.Predicates.SBOL2.mapsTo,
        bioterms_1.Predicates.SBOL3.hasConstraint,
        bioterms_1.Predicates.SBOL3.hasFeature,
        bioterms_1.Predicates.SBOL3.hasParticipation,
        bioterms_1.Predicates.SBOL3.hasLocation,
        bioterms_1.Predicates.SBOL3.sourceLocation,
        bioterms_1.Predicates.SBOL3.hasInteraction,
        bioterms_1.Predicates.SBOL3.hasMeasure,
        bioterms_1.Predicates.SBOL3.hasVariableFeature,
        bioterms_1.Predicates.SBOL3.hasInterface
      ];
      function isOwnershipRelation(g, triple6) {
        let p = nodeToURI(triple6.predicate);
        if (ownershipPredicates.indexOf(p) !== -1) {
          return true;
        }
        if (p === bioterms_1.Predicates.SBOL2.component) {
          let s = nodeToURI(triple6.subject);
          if (g.hasMatch(rdfoo_1.node.createUriNode(s), bioterms_1.Predicates.a, rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL2.SequenceAnnotation)))
            return false;
          return true;
        }
        if (p === bioterms_1.Predicates.SBOL1.subComponent) {
          let s = nodeToURI(triple6.subject);
          if (g.hasMatch(rdfoo_1.node.createUriNode(s), bioterms_1.Predicates.a, rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.SequenceAnnotation)))
            return false;
          return true;
        }
        return false;
      }
      exports.default = isOwnershipRelation;
      function nodeToURI(node19) {
        if (node19.termType !== "NamedNode")
          throw new Error("expected NamedNode but found " + JSON.stringify(node19));
        if (typeof node19.value !== "string")
          throw new Error("nominalValue not a string?");
        return node19.value;
      }
    }
  });

  // node_modules/sboljs/dist/SBOLFacade.js
  var require_SBOLFacade = __commonJS({
    "node_modules/sboljs/dist/SBOLFacade.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var rdfoo_1 = require_dist();
      var isOwnershipRelation_1 = require_isOwnershipRelation();
      var SBOLFacade = class extends rdfoo_1.Facade {
        constructor(graph2, view, subject) {
          super(graph2, subject);
          this.view = view;
        }
        hasProperty(predicate) {
          return this.graph.hasMatch(this.subject, predicate, null);
        }
        get owningObject() {
          let ownageTriples = this.graph.match(null, null, this.subject).filter((t) => (0, isOwnershipRelation_1.default)(this.graph, t));
          if (ownageTriples.length === 1) {
            return this.view.subjectToFacade(ownageTriples[0].subject);
          }
        }
        get ownedObjects() {
          let ownageTriples = this.graph.match(this.subject, null, null).filter((t) => (0, isOwnershipRelation_1.default)(this.graph, t));
          return ownageTriples.map((t) => t.object).map((uri) => this.view.subjectToFacade(uri)).filter((o) => o !== void 0);
        }
        isSiblingOf(other) {
          let ourContainer = this.owningObject;
          let theirContainer = other.owningObject;
          if (!ourContainer) {
            if (!theirContainer) {
              return true;
            } else {
              return false;
            }
          } else {
            if (theirContainer && theirContainer.subject.value === ourContainer.subject.value) {
              return true;
            } else {
              return false;
            }
          }
        }
        getSiblings() {
          let ourContainer = this.owningObject;
          if (!ourContainer) {
            return [];
          }
          let containedObjects = ourContainer.ownedObjects;
          for (let i = 0; i < containedObjects.length; ++i) {
            if (containedObjects[i].subject.value === this.subject.value) {
              containedObjects.splice(i, 1);
              break;
            }
          }
          return containedObjects;
        }
        destroy() {
          let toPurge = [];
          add(this);
          for (let obj of toPurge) {
            this.graph.purgeSubject(obj.subject);
          }
          function add(o) {
            toPurge.push(o);
            let owned = o.ownedObjects;
            for (let obj of owned) {
              add(obj);
            }
          }
        }
      };
      exports.default = SBOLFacade;
    }
  });

  // node_modules/sboljs/dist/sbol1/S1Facade.js
  var require_S1Facade = __commonJS({
    "node_modules/sboljs/dist/sbol1/S1Facade.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var SBOLFacade_1 = require_SBOLFacade();
      var S1Facade3 = class extends SBOLFacade_1.default {
        constructor(view, subject) {
          super(view.graph, view, subject);
          this.view = view;
        }
      };
      exports.default = S1Facade3;
    }
  });

  // node_modules/sboljs/dist/sbol1/S1DnaSequence.js
  var require_S1DnaSequence = __commonJS({
    "node_modules/sboljs/dist/sbol1/S1DnaSequence.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var S1Facade_1 = require_S1Facade();
      var S1DnaSequence = class extends S1Facade_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL1.DnaSequence;
        }
        get nucleotides() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL1.nucleotides);
        }
        get name() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL1.name);
        }
      };
      exports.default = S1DnaSequence;
    }
  });

  // node_modules/sboljs/dist/sbol1/S1SequenceAnnotation.js
  var require_S1SequenceAnnotation = __commonJS({
    "node_modules/sboljs/dist/sbol1/S1SequenceAnnotation.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var S1Facade_1 = require_S1Facade();
      var S1DnaComponent_1 = require_S1DnaComponent();
      var S1SequenceAnnotation = class extends S1Facade_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL1.SequenceAnnotation;
        }
        get bioStart() {
          return this.getIntProperty(bioterms_1.Predicates.SBOL1.bioStart);
        }
        get bioEnd() {
          return this.getIntProperty(bioterms_1.Predicates.SBOL1.bioEnd);
        }
        get strand() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL1.strand);
        }
        get subComponent() {
          let subject = this.getProperty(bioterms_1.Predicates.SBOL1.subComponent);
          if (subject === void 0)
            return void 0;
          return new S1DnaComponent_1.default(this.view, subject);
        }
        get precedes() {
          return this.getProperties(bioterms_1.Predicates.SBOL1.precedes).map((subject) => new S1SequenceAnnotation(this.view, subject));
        }
      };
      exports.default = S1SequenceAnnotation;
    }
  });

  // node_modules/sboljs/dist/sbol1/S1DnaComponent.js
  var require_S1DnaComponent = __commonJS({
    "node_modules/sboljs/dist/sbol1/S1DnaComponent.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var S1Facade_1 = require_S1Facade();
      var S1SequenceAnnotation_1 = require_S1SequenceAnnotation();
      var S1DnaSequence_1 = require_S1DnaSequence();
      var S1DnaComponent10 = class extends S1Facade_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL1.DnaComponent;
        }
        get annotations() {
          return this.getProperties(bioterms_1.Predicates.SBOL1.annotation).map((subject) => new S1SequenceAnnotation_1.default(this.view, subject));
        }
        get displayId() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL1.displayId);
        }
        get name() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL1.name);
        }
        get description() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL1.description);
        }
        get dnaSequence() {
          let subject = this.getProperty(bioterms_1.Predicates.SBOL1.dnaSequence);
          if (subject) {
            return new S1DnaSequence_1.default(this.view, subject);
          }
        }
        get subComponents() {
          let visited = /* @__PURE__ */ new Set();
          let scs = [];
          for (let anno of this.annotations) {
            let sc = anno.subComponent;
            if (sc && !visited.has(sc.subject.value)) {
              scs.push(sc.subject);
              visited.add(sc.subject.value);
            }
          }
          return scs.map((subject) => new S1DnaComponent10(this.view, subject));
        }
      };
      exports.default = S1DnaComponent10;
    }
  });

  // node_modules/sboljs/dist/sbol1/S1Collection.js
  var require_S1Collection = __commonJS({
    "node_modules/sboljs/dist/sbol1/S1Collection.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var S1Facade_1 = require_S1Facade();
      var S1DnaComponent_1 = require_S1DnaComponent();
      var S1Collection = class extends S1Facade_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL1.Collection;
        }
        get displayId() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL1.displayId);
        }
        get name() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL1.name);
        }
        get description() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL1.description);
        }
        get components() {
          return this.getProperties(bioterms_1.Predicates.SBOL1.component).map((subject) => new S1DnaComponent_1.default(this.view, subject));
        }
      };
      exports.default = S1Collection;
    }
  });

  // node_modules/sboljs/dist/SBOL1GraphView.js
  var require_SBOL1GraphView = __commonJS({
    "node_modules/sboljs/dist/SBOL1GraphView.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sbol1 = void 0;
      var rdfoo_1 = require_dist();
      var S1DnaSequence_1 = require_S1DnaSequence();
      var S1DnaComponent_1 = require_S1DnaComponent();
      var S1Collection_1 = require_S1Collection();
      var S1SequenceAnnotation_1 = require_S1SequenceAnnotation();
      var bioterms_1 = require_dist2();
      var isOwnershipRelation_1 = require_isOwnershipRelation();
      var SBOL1GraphView17 = class extends rdfoo_1.GraphViewBasic {
        constructor(graph2) {
          super(graph2);
          this.graph = graph2;
        }
        get dnaSequences() {
          return this.instancesOfType(bioterms_1.Types.SBOL1.DnaSequence).map((subject) => new S1DnaSequence_1.default(this, subject));
        }
        get dnaComponents() {
          return this.instancesOfType(bioterms_1.Types.SBOL1.DnaComponent).map((subject) => new S1DnaComponent_1.default(this, subject));
        }
        get collections() {
          return this.instancesOfType(bioterms_1.Types.SBOL1.Collection).map((subject) => new S1Collection_1.default(this, subject));
        }
        subjectToFacade(subject) {
          if (!subject)
            return void 0;
          const types = this.getTypes(subject);
          if (types.indexOf(bioterms_1.Types.SBOL1.DnaSequence) !== -1)
            return new S1DnaSequence_1.default(this, subject);
          if (types.indexOf(bioterms_1.Types.SBOL1.DnaComponent) !== -1)
            return new S1DnaComponent_1.default(this, subject);
          if (types.indexOf(bioterms_1.Types.SBOL1.Collection) !== -1)
            return new S1Collection_1.default(this, subject);
          if (types.indexOf(bioterms_1.Types.SBOL1.SequenceAnnotation) !== -1)
            return new S1SequenceAnnotation_1.default(this, subject);
          return super.subjectToFacade(subject);
        }
        get topLevels() {
          const topLevels = [];
          Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL1.DnaSequence));
          Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL1.DnaComponent));
          Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL1.Collection));
          return topLevels.map((topLevel) => this.subjectToFacade(topLevel));
        }
        serializeXML() {
          let defaultPrefixes = [
            ["rdf", bioterms_1.Prefixes.rdf],
            ["dcterms", bioterms_1.Prefixes.dcterms],
            ["prov", bioterms_1.Prefixes.prov],
            ["sbol", bioterms_1.Prefixes.sbol1],
            ["sbol2", bioterms_1.Prefixes.sbol2],
            ["sbol3", bioterms_1.Prefixes.sbol3],
            ["om", bioterms_1.Prefixes.measure],
            ["synbiohub", "http://wiki.synbiohub.org/wiki/Terms/synbiohub#"],
            ["igem", "http://wiki.synbiohub.org/wiki/Terms/igem#"],
            ["dc", "http://purl.org/dc/elements/1.1/"]
          ];
          return (0, rdfoo_1.serialize)(this.graph, new Map(defaultPrefixes), (t) => (0, isOwnershipRelation_1.default)(this.graph, t), bioterms_1.Prefixes.sbol1);
        }
        get rootDnaComponents() {
          return this.instancesOfType(bioterms_1.Types.SBOL1.DnaComponent).filter((subject) => {
            return !this.graph.hasMatch(null, bioterms_1.Predicates.SBOL1.subComponent, subject);
          }).map((subject) => new S1DnaComponent_1.default(this, subject));
        }
      };
      exports.default = SBOL1GraphView17;
      function sbol12(graph2) {
        return new SBOL1GraphView17(graph2);
      }
      exports.sbol1 = sbol12;
    }
  });

  // node_modules/sboljs/dist/URIUtils.js
  var require_URIUtils = __commonJS({
    "node_modules/sboljs/dist/URIUtils.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var URIUtils = class {
        static addSuffix(uri, suffix) {
          if (uri.match(/\/[0-9]+$/)) {
            let lastSlash = uri.lastIndexOf("/");
            return uri.slice(0, lastSlash) + suffix + uri.slice(lastSlash);
          } else {
            let last = uri.lastIndexOf("#");
            if (last !== -1) {
              return uri.slice(0, last) + suffix + uri.slice(last);
            } else {
              return uri + suffix;
            }
          }
        }
        static getPrefix(uri) {
          if (uri.match(/\/[0-9]+$/)) {
            return popLastToken(popLastToken(uri));
          } else {
            return popLastToken(uri);
          }
        }
        static getSuffix(uri) {
          return uri.slice(0, this.getPrefix(uri).length);
        }
      };
      exports.default = URIUtils;
      function popLastToken(uri) {
        let last = uri.lastIndexOf("#", uri.length - 2);
        if (last === -1)
          last = uri.lastIndexOf("/", uri.length - 2);
        if (last === -1)
          return uri;
        return uri.slice(0, last + 1);
      }
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Facade.js
  var require_S2Facade = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Facade.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var SBOLFacade_1 = require_SBOLFacade();
      var S2Facade = class extends SBOLFacade_1.default {
        constructor(view, subject) {
          super(view.graph, view, subject);
          this.view = view;
        }
      };
      exports.default = S2Facade;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Attachment.js
  var require_S2Attachment = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Attachment.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var S2Attachment = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.Attachment;
        }
        get source() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL2.source);
        }
        set source(source) {
          if (source)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.source, source);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.source);
        }
        get format() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL2.format);
        }
        set format(format) {
          if (format)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.format, format);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.format);
        }
        get size() {
          return this.getIntProperty(bioterms_1.Predicates.SBOL2.size);
        }
        set size(size) {
          if (size)
            this.setIntProperty(bioterms_1.Predicates.SBOL2.size, size);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.size);
        }
        get hash() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL2.hash);
        }
        set hash(hash) {
          if (hash)
            this.setStringProperty(bioterms_1.Predicates.SBOL2.hash, hash);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.hash);
        }
      };
      exports.default = S2Attachment;
      var bioterms_1 = require_dist2();
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Collection.js
  var require_S2Collection = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Collection.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var bioterms_1 = require_dist2();
      var S2Collection = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.Collection;
        }
        get members() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.member).map((subject) => this.view.subjectToFacade(subject)).filter((r) => r !== void 0);
        }
        addMember(member) {
          this.insertProperty(bioterms_1.Predicates.SBOL2.member, member.subject);
        }
        get containingObject() {
          return void 0;
        }
      };
      exports.default = S2Collection;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Measure.js
  var require_S2Measure = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Measure.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var bioterms_1 = require_dist2();
      var S2Measure = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.Measure.Measure;
        }
        get value() {
          return this.getFloatProperty(bioterms_1.Predicates.Measure.hasNumericalValue);
        }
        set value(v) {
          if (v === void 0)
            this.deleteProperty(bioterms_1.Predicates.Measure.hasNumericalValue);
          else
            this.setFloatProperty(bioterms_1.Predicates.Measure.hasNumericalValue, v);
        }
        get unit() {
          return this.getUriProperty(bioterms_1.Predicates.Measure.hasUnit);
        }
        set unit(unit) {
          this.setUriProperty(bioterms_1.Predicates.Measure.hasUnit, unit);
        }
      };
      exports.default = S2Measure;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Identified.js
  var require_S2Identified = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Identified.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var URIUtils_1 = require_URIUtils();
      var S2Facade_1 = require_S2Facade();
      var S2Identified3 = class extends S2Facade_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          throw new Error("base called");
        }
        get name() {
          return this.getStringProperty(bioterms_1.Predicates.Dcterms.title);
        }
        get displayName() {
          return this.name || this.displayId || this.subject.value;
        }
        get displayType() {
          return this.objectType || "unknown";
        }
        set name(name) {
          this.setStringProperty(bioterms_1.Predicates.Dcterms.title, name);
        }
        get description() {
          return this.getStringProperty(bioterms_1.Predicates.Dcterms.description);
        }
        set description(desc) {
          this.setStringProperty(bioterms_1.Predicates.Dcterms.description, desc);
        }
        get displayDescription() {
          return this.description;
        }
        get displayId() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL2.displayId);
        }
        set displayId(displayId) {
          this.setStringProperty(bioterms_1.Predicates.SBOL2.displayId, displayId);
        }
        set displayType(type) {
          this.setUriProperty(bioterms_1.Predicates.a, type);
        }
        get version() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL2.version);
        }
        set version(version) {
          this.setStringProperty(bioterms_1.Predicates.SBOL2.version, version);
        }
        get persistentIdentity() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL2.persistentIdentity);
        }
        set persistentIdentity(subject) {
          this.setUriProperty(bioterms_1.Predicates.SBOL2.persistentIdentity, subject);
        }
        get uriPrefix() {
          return URIUtils_1.default.getPrefix(this.subject.value);
        }
        get attachments() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.attachment).map((attachment) => new S2Attachment_1.default(this.view, attachment));
        }
        get measures() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.measure).map((measure) => new S2Measure_1.default(this.view, measure));
        }
        get containingObject() {
          return void 0;
        }
        get containedObjects() {
          return [];
        }
        get containingCollections() {
          return this.view.graph.match(null, bioterms_1.Predicates.SBOL2.member, this.subject).map((t) => new S2Collection_1.default(this.view, t.subject));
        }
        get uriChain() {
          const containingObject = this.containingObject;
          if (containingObject !== void 0) {
            return containingObject.uriChain + ";" + this.subject.value;
          } else {
            return this.subject.value;
          }
        }
        isSiblingOf(other) {
          let ourContainer = this.containingObject;
          let theirContainer = other.containingObject;
          if (!ourContainer) {
            if (!theirContainer) {
              return true;
            } else {
              return false;
            }
          } else {
            if (theirContainer && theirContainer.subject.value === ourContainer.subject.value) {
              return true;
            } else {
              return false;
            }
          }
        }
        getSiblings() {
          let ourContainer = this.containingObject;
          if (!ourContainer) {
            return [];
          }
          let containedObjects = ourContainer.containedObjects;
          for (let i = 0; i < containedObjects.length; ++i) {
            if (containedObjects[i].subject.value === this.subject.value) {
              containedObjects.splice(i, 1);
              break;
            }
          }
          return containedObjects;
        }
      };
      exports.default = S2Identified3;
      var S2Attachment_1 = require_S2Attachment();
      var S2Collection_1 = require_S2Collection();
      var S2Measure_1 = require_S2Measure();
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Sequence.js
  var require_S2Sequence = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Sequence.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var bioterms_1 = require_dist2();
      var S2ComponentDefinition_1 = require_S2ComponentDefinition();
      var S2Range_1 = require_S2Range();
      var S2Sequence = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.Sequence;
        }
        get displayType() {
          switch (this.encoding) {
            case bioterms_1.Specifiers.SBOL2.SequenceEncoding.AminoAcid:
              return "Amino Acid Sequence";
            case bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid:
            case bioterms_1.Specifiers.SBOL2.SequenceEncoding.RNA:
              return "Nucleic Acid Sequence";
            default:
              return "Sequence";
          }
        }
        get elements() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL2.elements);
        }
        set elements(elements) {
          if (elements === void 0) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.elements);
          } else {
            this.setStringProperty(bioterms_1.Predicates.SBOL2.elements, elements);
          }
        }
        insertFragment(pos, fragment) {
          const elements = this.elements;
          if (elements === void 0)
            throw new Error("???");
          if (pos < 0 || pos >= elements.length)
            return;
          const containingCDs = this.view.graph.match(null, bioterms_1.Predicates.SBOL2.sequence, this.subject).map((t) => t.subject).map((subject) => new S2ComponentDefinition_1.default(this.view, subject));
          containingCDs.forEach((cd) => {
            cd.sequenceAnnotations.forEach((sa) => {
              sa.locations.forEach((location) => {
                if (location instanceof S2Range_1.default) {
                  const range = location;
                  const start = range.start;
                  const end = range.end;
                  if (start === void 0 || end === void 0)
                    throw new Error("???");
                  if (pos >= start && pos <= end) {
                    range.end = end + fragment.length;
                  } else if (pos < start) {
                    range.start = start + fragment.length;
                    range.end = end + fragment.length;
                  }
                }
              });
            });
          });
          const slices = [
            elements.substring(0, pos),
            fragment,
            elements.substring(pos)
          ];
          this.elements = slices.join("");
        }
        deleteFragment(pos, n) {
          const elements = this.elements;
          if (elements === void 0)
            throw new Error("???");
          if (pos < 0 || pos >= elements.length)
            return;
          const containingCDs = this.view.graph.match(null, bioterms_1.Predicates.SBOL2.sequence, this.subject).map((t) => t.subject).map((subject) => new S2ComponentDefinition_1.default(this.view, subject));
          containingCDs.forEach((cd) => {
            cd.sequenceAnnotations.forEach((sa) => {
              sa.locations.forEach((location) => {
                if (location instanceof S2Range_1.default) {
                  const range = location;
                  const start = range.start;
                  const end = range.end;
                  if (start === void 0 || end === void 0)
                    throw new Error("???");
                  if (pos >= start && pos <= end) {
                    range.end = end - n;
                  } else if (pos < start) {
                    range.start = start - n;
                    range.end = end - n;
                  }
                }
              });
            });
          });
          const slices = [
            elements.substring(0, pos),
            elements.substring(pos + n)
          ];
          this.elements = slices.join("");
        }
        get encoding() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL2.encoding);
        }
        set encoding(encoding2) {
          if (encoding2 === void 0) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.encoding);
          } else {
            this.setUriProperty(bioterms_1.Predicates.SBOL2.encoding, encoding2);
          }
        }
        get containingObject() {
          return void 0;
        }
      };
      exports.default = S2Sequence;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Location.js
  var require_S2Location = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Location.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var bioterms_1 = require_dist2();
      var S2SequenceAnnotation_1 = require_S2SequenceAnnotation();
      var S2Sequence_1 = require_S2Sequence();
      var S2Location = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get containingObject() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.location, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("Location has no containing object?");
          }
          return this.view.uriToIdentified(subject);
        }
        get containingSequenceAnnotation() {
          const containingObject = this.containingObject;
          if (!(containingObject instanceof S2SequenceAnnotation_1.default)) {
            throw new Error("???");
          }
          return containingObject;
        }
        get containingComponentInstance() {
          return this.containingSequenceAnnotation.component;
        }
        get containingComponentDefinition() {
          return this.containingSequenceAnnotation.containingComponentDefinition;
        }
        isFixed() {
          return this.facadeType === bioterms_1.Types.SBOL2.Range;
        }
        get sequence() {
          let uri = this.getProperty(bioterms_1.Predicates.SBOL2.sequence);
          if (uri === void 0)
            return void 0;
          let obj = this.view.subjectToFacade(uri);
          if (!(obj instanceof S2Sequence_1.default)) {
            throw new Error("sequence was not a sequence");
          }
          return obj;
        }
        set sequence(sequence) {
          if (sequence !== void 0)
            this.setProperty(bioterms_1.Predicates.SBOL2.sequence, sequence.subject);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.sequence);
        }
      };
      exports.default = S2Location;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2OrientedLocation.js
  var require_S2OrientedLocation = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2OrientedLocation.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var S2Location_1 = require_S2Location();
      var S2OrientedLocation = class extends S2Location_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get orientation() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL2.orientation);
        }
        set orientation(orientation) {
          if (orientation)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.orientation, orientation);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.orientation);
        }
      };
      exports.default = S2OrientedLocation;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Range.js
  var require_S2Range = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Range.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2OrientedLocation_1 = require_S2OrientedLocation();
      var bioterms_1 = require_dist2();
      var S2Range = class extends S2OrientedLocation_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.Range;
        }
        get start() {
          return this.getIntProperty(bioterms_1.Predicates.SBOL2.start);
        }
        set start(n) {
          if (n !== void 0) {
            this.setIntProperty(bioterms_1.Predicates.SBOL2.start, n);
          } else {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.start);
          }
        }
        get end() {
          return this.getIntProperty(bioterms_1.Predicates.SBOL2.end);
        }
        set end(n) {
          if (n !== void 0) {
            this.setIntProperty(bioterms_1.Predicates.SBOL2.end, n);
          } else {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.end);
          }
        }
      };
      exports.default = S2Range;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2GenericLocation.js
  var require_S2GenericLocation = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2GenericLocation.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2OrientedLocation_1 = require_S2OrientedLocation();
      var bioterms_1 = require_dist2();
      var S2GenericLocation = class extends S2OrientedLocation_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.GenericLocation;
        }
      };
      exports.default = S2GenericLocation;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2IdentifiedFactory.js
  var require_S2IdentifiedFactory = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2IdentifiedFactory.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var bioterms_1 = require_dist2();
      var rdfoo_1 = require_dist();
      var S3IdentifiedFactory = class {
        static createTopLevel(view, type, uriPrefix, id, name, version) {
          id = id ? nameToID(id) : "anon";
          let versionSuffix = version !== void 0 ? "/" + version : "";
          const subject = view.graph.generateURI(uriPrefix + id + "$n?$" + versionSuffix);
          view.graph.insertProperties(rdfoo_1.node.createUriNode(subject), {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(type),
            [bioterms_1.Predicates.SBOL2.displayId]: rdfoo_1.node.createStringNode(id),
            [bioterms_1.Predicates.SBOL2.persistentIdentity]: rdfoo_1.node.createUriNode(extractPersistentIdentity(subject, version))
          });
          if (version !== void 0) {
            view.graph.insertProperties(rdfoo_1.node.createUriNode(subject), {
              [bioterms_1.Predicates.SBOL2.version]: rdfoo_1.node.createStringNode(version)
            });
          }
          if (name !== void 0) {
            view.graph.insertProperties(rdfoo_1.node.createUriNode(subject), {
              [bioterms_1.Predicates.Dcterms.title]: rdfoo_1.node.createStringNode(name)
            });
          }
          return new S2Identified_1.default(view, rdfoo_1.node.createUriNode(subject));
        }
        static createChild(view, type, parent, ownershipPredicate, id, name, version) {
          id = id ? nameToID(id) : "anon";
          let versionSuffix = version !== void 0 ? "/" + version : "";
          let parentPersistentIdentity = parent.persistentIdentity;
          const subject = view.graph.generateURI(parentPersistentIdentity + "/" + id + "$n?$" + versionSuffix);
          view.graph.insertProperties(rdfoo_1.node.createUriNode(subject), {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(type),
            [bioterms_1.Predicates.SBOL2.displayId]: rdfoo_1.node.createStringNode(id),
            [bioterms_1.Predicates.SBOL2.persistentIdentity]: rdfoo_1.node.createUriNode(extractPersistentIdentity(subject, version))
          });
          if (version !== void 0) {
            view.graph.insertProperties(rdfoo_1.node.createUriNode(subject), {
              [bioterms_1.Predicates.SBOL2.version]: rdfoo_1.node.createStringNode(version)
            });
          }
          if (name !== void 0) {
            view.graph.insertProperties(rdfoo_1.node.createUriNode(subject), {
              [bioterms_1.Predicates.Dcterms.title]: rdfoo_1.node.createStringNode(name)
            });
          }
          view.graph.insertProperties(parent.subject, {
            [ownershipPredicate]: rdfoo_1.node.createUriNode(subject)
          });
          return new S2Identified_1.default(view, rdfoo_1.node.createUriNode(subject));
        }
      };
      exports.default = S3IdentifiedFactory;
      function nameToID(name) {
        return name.replace(/\s/, "_");
      }
      function extractPersistentIdentity(uri, version) {
        if (version !== void 0) {
          return uri.substr(0, uri.length - version.length - 1);
        } else {
          return uri;
        }
      }
    }
  });

  // node_modules/sboljs/dist/sbol2/S2SequenceAnnotation.js
  var require_S2SequenceAnnotation = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2SequenceAnnotation.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var S2ComponentInstance_1 = require_S2ComponentInstance();
      var S2Range_1 = require_S2Range();
      var S2GenericLocation_1 = require_S2GenericLocation();
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S2IdentifiedFactory_1 = require_S2IdentifiedFactory();
      var S2ComponentDefinition_1 = require_S2ComponentDefinition();
      var S2SequenceAnnotation2 = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.SequenceAnnotation;
        }
        get locations() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.location).map((subject) => this.view.subjectToFacade(subject));
        }
        get rangeLocations() {
          return this.locations.filter((location) => {
            return location.objectType === bioterms_1.Types.SBOL2.Range;
          }).map((identified) => {
            return new S2Range_1.default(this.view, identified.subject);
          });
        }
        get rangeMin() {
          var n = Number.MAX_VALUE;
          this.rangeLocations.forEach((range) => {
            const start = range.start;
            const end = range.end;
            if (start !== void 0 && start < n)
              n = start;
            if (end !== void 0 && end < n)
              n = end;
          });
          return n === Number.MAX_VALUE ? null : n;
        }
        get rangeMax() {
          var n = Number.MIN_VALUE;
          this.rangeLocations.forEach((range) => {
            const start = range.start;
            const end = range.end;
            if (start !== void 0 && start > n)
              n = start;
            if (end !== void 0 && end > n)
              n = end;
          });
          return n === Number.MIN_VALUE ? null : n;
        }
        hasFixedLocation() {
          const locations = this.locations;
          for (var i = 0; i < locations.length; ++i) {
            if (locations[i].isFixed())
              return true;
          }
          return false;
        }
        get containingComponentDefinition() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.sequenceAnnotation, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (subject === void 0) {
            throw new Error("SA not contained by a CD??");
          }
          return new S2ComponentDefinition_1.default(this.view, subject);
        }
        get component() {
          const subject = this.getProperty(bioterms_1.Predicates.SBOL2.component);
          if (subject)
            return new S2ComponentInstance_1.default(this.view, subject);
        }
        set component(component) {
          if (component !== void 0) {
            this.setProperty(bioterms_1.Predicates.SBOL2.component, component.subject);
          } else {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.component);
          }
        }
        get displayName() {
          const component = this.component;
          if (component) {
            const componentDisplayName = component.displayName;
            if (componentDisplayName)
              return componentDisplayName;
          }
          return this.name || this.displayId || "";
        }
        get roles() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL2.role);
        }
        hasRole(role) {
          return this.view.graph.hasMatch(this.subject, bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
        }
        addRole(role) {
          this.insertProperty(bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
        }
        static fromIdentified(identified) {
          const type = identified.objectType;
          if (type === bioterms_1.Types.SBOL2.SequenceAnnotation)
            return new S2SequenceAnnotation2(identified.view, identified.subject);
          if (type === bioterms_1.Types.SBOL2.Component) {
            const sa = new S2ComponentInstance_1.default(identified.view, identified.subject).sequenceAnnotations[0];
            if (sa === void 0) {
              throw new Error("cannot get sequence annotation from " + identified.subject);
            }
            return sa;
          }
          throw new Error("cannot get sequence annotation from " + identified.subject);
        }
        get containingObject() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.sequenceAnnotation, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("SA has no containing object?");
          }
          return this.view.uriToIdentified(subject);
        }
        clearLocations() {
          this.locations.forEach((location) => {
            this.view.graph.purgeSubject(location.subject);
          });
        }
        addLocationGeneric(orientation) {
          let identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.GenericLocation, this, bioterms_1.Predicates.SBOL2.location, "location", this.version);
          let location = new S2GenericLocation_1.default(this.view, identified.subject);
          location.orientation = orientation;
          return location;
        }
        setLocationGeneric(orientation) {
          this.clearLocations();
          this.addLocationGeneric(orientation);
        }
        get allRoles() {
          const rolesHere = this.roles;
          const component = this.component;
          if (component && component.definition) {
            return rolesHere.concat(component.definition.roles);
          } else {
            return rolesHere;
          }
        }
        get displayDescription() {
          var desc = this.description;
          if (desc !== void 0)
            return desc;
          const c = this.component;
          if (c !== void 0)
            return c.displayDescription;
          return void 0;
        }
        get containedObjects() {
          return this.locations;
        }
      };
      exports.default = S2SequenceAnnotation2;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2SequenceConstraint.js
  var require_S2SequenceConstraint = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2SequenceConstraint.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var S2ComponentInstance_1 = require_S2ComponentInstance();
      var bioterms_1 = require_dist2();
      var S2SequenceConstraint = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.SequenceConstraint;
        }
        get containingObject() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.sequenceConstraint, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("SeqCons has no containing object?");
          }
          return this.view.uriToIdentified(subject);
        }
        get constraintRestriction() {
          const restriction = this.getUriProperty(bioterms_1.Predicates.SBOL2.restriction);
          if (restriction === void 0) {
            throw new Error("SeqCons has no restriction?");
          }
          return restriction;
        }
        get constraintSubject() {
          const subject = this.getProperty(bioterms_1.Predicates.SBOL2.subject);
          if (subject === void 0) {
            throw new Error("SeqCons has no subject?");
          }
          return new S2ComponentInstance_1.default(this.view, subject);
        }
        get constraintObject() {
          const object = this.getProperty(bioterms_1.Predicates.SBOL2.object);
          if (object === void 0) {
            throw new Error("SeqCons has no object?");
          }
          return new S2ComponentInstance_1.default(this.view, object);
        }
      };
      exports.default = S2SequenceConstraint;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2ComponentInstance.js
  var require_S2ComponentInstance = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2ComponentInstance.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var S2ComponentDefinition_1 = require_S2ComponentDefinition();
      var S2SequenceAnnotation_1 = require_S2SequenceAnnotation();
      var S2SequenceConstraint_1 = require_S2SequenceConstraint();
      var bioterms_1 = require_dist2();
      var S2Location_1 = require_S2Location();
      var S2ComponentInstance2 = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.Component;
        }
        get displayName() {
          const name = this.name;
          if (name)
            return name;
          const def = this.definition;
          const defName = def.name;
          if (defName)
            return defName;
          return this.displayId || "";
        }
        get definition() {
          const subject = this.getProperty(bioterms_1.Predicates.SBOL2.definition);
          if (!subject) {
            throw new Error("Component " + this.subject.value + " has no definition");
          }
          return new S2ComponentDefinition_1.default(this.view, subject);
        }
        set definition(def) {
          this.setProperty(bioterms_1.Predicates.SBOL2.definition, def.subject);
        }
        get access() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL2.access);
        }
        set access(access) {
          if (access === void 0) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.access);
          } else {
            this.setUriProperty(bioterms_1.Predicates.SBOL2.access, access);
          }
        }
        get sequenceAnnotations() {
          return this.view.graph.match(null, bioterms_1.Predicates.SBOL2.component, this.subject).map((t) => t.subject).filter((subject) => this.view.getType(subject) === bioterms_1.Types.SBOL2.SequenceAnnotation).map((subject) => new S2SequenceAnnotation_1.default(this.view, subject));
        }
        get sequenceConstraints() {
          return this.view.graph.match(null, bioterms_1.Predicates.SBOL2.subject, this.subject).map((t) => t.subject).filter((subject) => this.view.getType(subject) === bioterms_1.Types.SBOL2.SequenceConstraint).map((subject) => new S2SequenceConstraint_1.default(this.view, subject));
        }
        hasRole(role) {
          return this.definition ? this.definition.hasRole(role) : false;
        }
        get containingComponentDefinition() {
          const subject = this.view.graph.match(null, bioterms_1.Predicates.SBOL2.component, this.subject).map((t) => t.subject).filter((s) => {
            return this.view.hasType(s, bioterms_1.Types.SBOL2.ComponentDefinition);
          })[0];
          if (subject === void 0) {
            throw new Error("component not contained by definition?");
          }
          return new S2ComponentDefinition_1.default(this.view, subject);
        }
        get containingObject() {
          return this.containingComponentDefinition;
        }
        isSequenceBound() {
          return this.sequenceAnnotations.length > 0 || this.sequenceConstraints.length > 0;
        }
        get displayDescription() {
          var desc = this.description;
          if (desc !== void 0)
            return desc;
          const def = this.definition;
          if (def !== void 0)
            return def.displayDescription;
          return void 0;
        }
        get sourceLocation() {
          let uri = this.getProperty(bioterms_1.Predicates.SBOL2.sourceLocation);
          if (uri === void 0)
            return void 0;
          let obj = this.view.subjectToFacade(uri);
          if (!(obj instanceof S2Location_1.default)) {
            throw new Error("sourceLocation was not a location");
          }
          return obj;
        }
        set sourceLocation(location) {
          if (location !== void 0)
            this.setProperty(bioterms_1.Predicates.SBOL2.sourceLocation, location.subject);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.sourceLocation);
        }
      };
      exports.default = S2ComponentInstance2;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2ComponentDefinition.js
  var require_S2ComponentDefinition = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2ComponentDefinition.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var S2ComponentInstance_1 = require_S2ComponentInstance();
      var S2Sequence_1 = require_S2Sequence();
      var S2SequenceAnnotation_1 = require_S2SequenceAnnotation();
      var S2SequenceConstraint_1 = require_S2SequenceConstraint();
      var S2Range_1 = require_S2Range();
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S2IdentifiedFactory_1 = require_S2IdentifiedFactory();
      var S2ComponentDefinition3 = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.ComponentDefinition;
        }
        get type() {
          const typeUri = this.getUriProperty(bioterms_1.Predicates.SBOL2.type);
          if (!typeUri)
            throw new Error(this.subject.value + " has no type?");
          return typeUri;
        }
        get types() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL2.type);
        }
        set type(uri) {
          this.setUriProperty(bioterms_1.Predicates.SBOL2.type, uri);
        }
        addType(uri) {
          this.insertProperties({
            [bioterms_1.Predicates.SBOL2.type]: rdfoo_1.node.createUriNode(uri)
          });
        }
        get displayType() {
          for (let role of this.roles) {
            let name = (0, bioterms_1.uriToName)(role);
            if (name) {
              return name;
            }
          }
          return "Design";
        }
        get components() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.component).map((subject) => new S2ComponentInstance_1.default(this.view, subject));
        }
        get roles() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL2.role);
        }
        hasRole(role) {
          return this.graph.hasMatch(this.subject, bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
        }
        addRole(role) {
          this.graph.insertTriple(this.subject, bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
        }
        removeRole(role) {
          this.graph.removeMatches(this.subject, bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
        }
        get sequences() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.sequence).map((subject) => new S2Sequence_1.default(this.view, subject));
        }
        get sequenceAnnotations() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.sequenceAnnotation).map((subject) => new S2SequenceAnnotation_1.default(this.view, subject));
        }
        get sequenceConstraints() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.sequenceConstraint).map((subject) => new S2SequenceConstraint_1.default(this.view, subject));
        }
        isPlasmidBackbone() {
          return this.hasRole(bioterms_1.Specifiers.SO.PlasmidBackbone);
        }
        static fromIdentified(identified) {
          const type = identified.objectType;
          if (type === bioterms_1.Types.SBOL2.ComponentDefinition) {
            return new S2ComponentDefinition3(identified.view, identified.subject);
          }
          if (type === bioterms_1.Types.SBOL2.Component) {
            const def = identified.getProperty(bioterms_1.Predicates.SBOL2.definition);
            if (def === void 0)
              throw new Error("component instance with no def?");
            return new S2ComponentDefinition3(identified.view, def);
          }
          throw new Error("cannot get component definition from " + identified.subject);
        }
        get containingObject() {
          return void 0;
        }
        get containedObjects() {
          return [
            ...this.components,
            ...this.sequenceAnnotations,
            ...this.sequenceConstraints,
            ...this.sequences
          ];
        }
        addComponent(component) {
          this.insertProperty(bioterms_1.Predicates.SBOL2.component, component.subject);
        }
        addComponentByDefinition(componentDefinition, id, name, version) {
          let identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.Component, this, bioterms_1.Predicates.SBOL2.component, id || componentDefinition.displayId || "subcomponent", name, version || this.version);
          let component = new S2ComponentInstance_1.default(this.view, identified.subject);
          component.definition = componentDefinition;
          return component;
        }
        addSequenceAnnotationForComponent(componentInstance) {
          let identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.SequenceAnnotation, this, bioterms_1.Predicates.SBOL2.sequenceAnnotation, componentInstance.displayId + "_sequenceAnnotation", void 0, this.version);
          let sequenceAnnotation = new S2SequenceAnnotation_1.default(this.view, identified.subject);
          sequenceAnnotation.component = componentInstance;
          return sequenceAnnotation;
        }
        createSequence() {
          const seq = this.view.createSequence(this.uriPrefix, this.displayName + "_sequence", this.version);
          this.addSequence(seq);
          return seq;
        }
        addSequence(sequence) {
          this.insertProperty(bioterms_1.Predicates.SBOL2.sequence, sequence.subject);
        }
        annotateRange(start, end, name) {
          this.view.graph.startIgnoringWatchers();
          let identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.SequenceAnnotation, this, bioterms_1.Predicates.SBOL2.sequenceAnnotation, "anno_" + name, this.version);
          let sequenceAnnotation = new S2SequenceAnnotation_1.default(this.view, identified.subject);
          let rangeIdentified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.Range, sequenceAnnotation, bioterms_1.Predicates.SBOL2.location, "range", this.version);
          let range = new S2Range_1.default(this.view, rangeIdentified.subject);
          range.start = start;
          range.end = end;
          this.view.graph.stopIgnoringWatchers();
          return sequenceAnnotation;
        }
        destroy() {
          let instantiations = this.graph.match(null, bioterms_1.Predicates.SBOL2.definition, this.subject).map((t) => new S2ComponentInstance_1.default(this.view, t.subject));
          super.destroy();
          for (let instantiation of instantiations) {
            instantiation.destroy();
          }
        }
      };
      exports.default = S2ComponentDefinition3;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2MapsTo.js
  var require_S2MapsTo = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2MapsTo.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var bioterms_1 = require_dist2();
      var S2MapsTo = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.MapsTo;
        }
        get local() {
          const localsubject = this.getProperty(bioterms_1.Predicates.SBOL2.local);
          if (localsubject === void 0)
            return void 0;
          return this.view.uriToIdentified(localsubject);
        }
        set local(local) {
          if (local)
            this.setProperty(bioterms_1.Predicates.SBOL2.local, local.subject);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.local);
        }
        get remote() {
          const remotesubject = this.getProperty(bioterms_1.Predicates.SBOL2.remote);
          if (remotesubject === void 0)
            return void 0;
          return this.view.uriToIdentified(remotesubject);
        }
        set remote(remote) {
          if (remote)
            this.setProperty(bioterms_1.Predicates.SBOL2.remote, remote.subject);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.remote);
        }
        set refinement(refinement) {
          if (refinement)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.refinement, refinement);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.refinement);
        }
        get refinement() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL2.refinement);
        }
        get containingObject() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.mapsTo, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("MapsTo has no containing object?");
          }
          return this.view.uriToIdentified(subject);
        }
      };
      exports.default = S2MapsTo;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2ModuleInstance.js
  var require_S2ModuleInstance = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2ModuleInstance.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var S2ModuleDefinition_1 = require_S2ModuleDefinition();
      var bioterms_1 = require_dist2();
      var S2MapsTo_1 = require_S2MapsTo();
      var S2IdentifiedFactory_1 = require_S2IdentifiedFactory();
      var S2Measure_1 = require_S2Measure();
      var S2ModuleInstance = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.Module;
        }
        get definition() {
          const subject = this.getProperty(bioterms_1.Predicates.SBOL2.definition);
          if (subject === void 0) {
            throw new Error("module has no definition?");
          }
          return new S2ModuleDefinition_1.default(this.view, subject);
        }
        set definition(def) {
          this.setProperty(bioterms_1.Predicates.SBOL2.definition, def.subject);
        }
        get containingObject() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.module, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("ModuleInstance has no containing object?");
          }
          return this.view.uriToIdentified(subject);
        }
        get mappings() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.mapsTo).map((mapsTo) => new S2MapsTo_1.default(this.view, mapsTo));
        }
        createMapping(local, remote) {
          const identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.MapsTo, this, bioterms_1.Predicates.SBOL2.mapsTo, "mapping_" + local.displayId + "_" + remote.displayId, void 0, this.version);
          const mapping = new S2MapsTo_1.default(this.view, identified.subject);
          mapping.local = local;
          mapping.remote = remote;
          return mapping;
        }
        get measure() {
          let measure = this.getProperty(bioterms_1.Predicates.SBOL2.measure);
          if (measure === void 0)
            return;
          return new S2Measure_1.default(this.view, measure);
        }
        set measure(measure) {
          if (measure === void 0)
            this.deleteProperty(bioterms_1.Predicates.SBOL2.measure);
          else
            this.setProperty(bioterms_1.Predicates.SBOL2.measure, measure.subject);
        }
      };
      exports.default = S2ModuleInstance;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Interaction.js
  var require_S2Interaction = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Interaction.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var S2Participation_1 = require_S2Participation();
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S2IdentifiedFactory_1 = require_S2IdentifiedFactory();
      var S2Measure_1 = require_S2Measure();
      var S2ModuleDefinition_1 = require_S2ModuleDefinition();
      var S2Interaction = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.Interaction;
        }
        get type() {
          const typeUri = this.getProperty(bioterms_1.Predicates.SBOL2.type);
          if (!typeUri)
            throw new Error(this.subject + " has no type?");
          return typeUri.value;
        }
        get types() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL2.type);
        }
        set type(subject) {
          this.setUriProperty(bioterms_1.Predicates.SBOL2.type, subject);
        }
        hasType(type) {
          return this.view.graph.hasMatch(this.subject, bioterms_1.Predicates.SBOL2.type, rdfoo_1.node.createUriNode(type));
        }
        get participations() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.participation).map((subject) => new S2Participation_1.default(this.view, subject));
        }
        get participants() {
          const participants = this.participations.map((participation) => participation.participant);
          return participants.filter((el) => !!el);
        }
        get containingModuleDefinition() {
          var _a;
          const uri = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.interaction, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!uri) {
            throw new Error("Interaction " + this.subject.value + " not contained by a MD?");
          }
          return new S2ModuleDefinition_1.default(this.view, uri);
        }
        get containingObject() {
          return this.containingModuleDefinition;
        }
        addParticipation(participation) {
          this.insertProperties({
            [bioterms_1.Predicates.SBOL2.participation]: participation.subject
          });
        }
        createParticipation(id, version) {
          const identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.Participation, this, bioterms_1.Predicates.SBOL2.participation, id, void 0, version);
          const participation = new S2Participation_1.default(this.view, identified.subject);
          return participation;
        }
        createParticipationWithParticipantAndRole(id, participant, role, version) {
          let participation = this.createParticipation(id, version);
          participation.addRole(role);
          participation.setParticipant(participant);
          return participation;
        }
        get measure() {
          let measure = this.getProperty(bioterms_1.Predicates.SBOL2.measure);
          if (measure === void 0)
            return;
          return new S2Measure_1.default(this.view, measure);
        }
        set measure(measure) {
          if (measure === void 0)
            this.deleteProperty(bioterms_1.Predicates.SBOL2.measure);
          else
            this.setProperty(bioterms_1.Predicates.SBOL2.measure, measure.subject);
        }
      };
      exports.default = S2Interaction;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Participation.js
  var require_S2Participation = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Participation.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var S2FunctionalComponent_1 = require_S2FunctionalComponent();
      var S2Interaction_1 = require_S2Interaction();
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S2Measure_1 = require_S2Measure();
      var S2Participation = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.Participation;
        }
        get participant() {
          const subject = this.getProperty(bioterms_1.Predicates.SBOL2.participant);
          if (subject) {
            return new S2FunctionalComponent_1.default(this.view, subject);
          }
        }
        set participant(participant) {
          if (participant !== void 0) {
            this.setProperty(bioterms_1.Predicates.SBOL2.participant, participant.subject);
          } else {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.participant);
          }
        }
        get interaction() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.participation, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (subject) {
            return new S2Interaction_1.default(this.view, subject);
          }
        }
        get containingObject() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.participation, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("Participation has no containing object?");
          }
          return this.view.uriToIdentified(subject);
        }
        hasRole(subject) {
          return this.view.graph.hasMatch(this.subject, bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(subject));
        }
        addRole(role) {
          this.insertProperty(bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
        }
        get roles() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL2.role);
        }
        setParticipant(participant) {
          this.setProperty(bioterms_1.Predicates.SBOL2.participant, participant.subject);
        }
        get measure() {
          let measure = this.getProperty(bioterms_1.Predicates.SBOL2.measure);
          if (measure === void 0)
            return;
          return new S2Measure_1.default(this.view, measure);
        }
        set measure(measure) {
          if (measure === void 0)
            this.deleteProperty(bioterms_1.Predicates.SBOL2.measure);
          else
            this.setProperty(bioterms_1.Predicates.SBOL2.measure, measure.subject);
        }
      };
      exports.default = S2Participation;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2FunctionalComponent.js
  var require_S2FunctionalComponent = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2FunctionalComponent.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var S2ComponentDefinition_1 = require_S2ComponentDefinition();
      var S2ModuleDefinition_1 = require_S2ModuleDefinition();
      var S2MapsTo_1 = require_S2MapsTo();
      var S2Participation_1 = require_S2Participation();
      var bioterms_1 = require_dist2();
      var S2IdentifiedFactory_1 = require_S2IdentifiedFactory();
      var S2Measure_1 = require_S2Measure();
      var S2FunctionalComponent = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.FunctionalComponent;
        }
        get access() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL2.access);
        }
        set access(access) {
          if (access === void 0) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.access);
          } else {
            this.setUriProperty(bioterms_1.Predicates.SBOL2.access, access);
          }
        }
        get direction() {
          return this.getUriProperty(bioterms_1.Prefixes.sbol2 + "direction");
        }
        set direction(direction) {
          if (direction === void 0) {
            this.deleteProperty(bioterms_1.Prefixes.sbol2 + "direction");
          } else {
            this.setUriProperty(bioterms_1.Prefixes.sbol2 + "direction", direction);
          }
        }
        get displayName() {
          const name = this.name;
          if (name)
            return name;
          const def = this.definition;
          const defName = def.name;
          if (defName)
            return defName;
          return this.displayId || "";
        }
        get definition() {
          const uri = this.getProperty(bioterms_1.Predicates.SBOL2.definition);
          if (!uri) {
            throw new Error("fc " + this.subject.value + " has no def?");
          }
          return new S2ComponentDefinition_1.default(this.view, uri);
        }
        set definition(definition) {
          this.setProperty(bioterms_1.Prefixes.sbol2 + "definition", definition.subject);
        }
        get mappings() {
          return this.view.graph.match(null, bioterms_1.Predicates.SBOL2.local, this.subject).map((t) => t.subject).concat(this.view.graph.match(null, bioterms_1.Predicates.SBOL2.remote, this.subject).map((t) => t.subject)).filter((el) => !!el).map((mapsToUri) => new S2MapsTo_1.default(this.view, mapsToUri));
        }
        createMapping(local, remote, refinement) {
          let id = local.displayId + "_mapsto_" + remote.displayId;
          let identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.MapsTo, this, id, id, this.version);
          let mapsTo = new S2MapsTo_1.default(this.view, identified.subject);
          mapsTo.local = local;
          mapsTo.remote = remote;
          mapsTo.refinement = refinement;
          return mapsTo;
        }
        get containingModuleDefinition() {
          var _a;
          const uri = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.functionalComponent, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!uri) {
            throw new Error("FC " + this.subject.value + " not contained by a MD?");
          }
          return new S2ModuleDefinition_1.default(this.view, uri);
        }
        get participations() {
          return this.view.graph.match(null, bioterms_1.Predicates.SBOL2.participant, this.subject).map((t) => t.subject).map((subject) => subject ? new S2Participation_1.default(this.view, subject) : void 0).filter((el) => !!el);
        }
        get interactions() {
          return this.participations.map((participation) => participation.interaction).filter((el) => !!el);
        }
        get containingObject() {
          return this.containingModuleDefinition;
        }
        get measure() {
          let measure = this.getProperty(bioterms_1.Predicates.SBOL2.measure);
          if (measure === void 0)
            return;
          return new S2Measure_1.default(this.view, measure);
        }
        set measure(measure) {
          if (measure === void 0)
            this.deleteProperty(bioterms_1.Predicates.SBOL2.measure);
          else
            this.setProperty(bioterms_1.Predicates.SBOL2.measure, measure.subject);
        }
      };
      exports.default = S2FunctionalComponent;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Model.js
  var require_S2Model = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Model.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var bioterms_1 = require_dist2();
      var S2Model = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.Model;
        }
        get framework() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL2.framework);
        }
        set framework(framework) {
          this.setUriProperty(bioterms_1.Predicates.SBOL2.framework, framework);
        }
        get language() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL2.language);
        }
        set language(language) {
          this.setUriProperty(bioterms_1.Predicates.SBOL2.language, language);
        }
        get source() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL2.source);
        }
        set source(source) {
          this.setUriProperty(bioterms_1.Predicates.SBOL2.source, source);
        }
      };
      exports.default = S2Model;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2ModuleDefinition.js
  var require_S2ModuleDefinition = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2ModuleDefinition.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var S2ModuleInstance_1 = require_S2ModuleInstance();
      var S2FunctionalComponent_1 = require_S2FunctionalComponent();
      var S2Interaction_1 = require_S2Interaction();
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S2IdentifiedFactory_1 = require_S2IdentifiedFactory();
      var S2Model_1 = require_S2Model();
      var S2ModuleDefinition2 = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.ModuleDefinition;
        }
        get roles() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL2.role);
        }
        hasRole(role) {
          return this.view.graph.hasMatch(this.subject, bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
        }
        addRole(role) {
          this.insertProperty(bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
        }
        removeRole(role) {
          this.view.graph.removeMatches(this.subject, bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
        }
        get containedObjects() {
          return this.modules.concat(this.functionalComponents).concat(this.interactions).concat(this.models);
        }
        get modules() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.module).map((subject) => new S2ModuleInstance_1.default(this.view, subject));
        }
        get functionalComponents() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.functionalComponent).map((subject) => new S2FunctionalComponent_1.default(this.view, subject));
        }
        get interactions() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.interaction).map((subject) => new S2Interaction_1.default(this.view, subject));
        }
        get models() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.model).map((subject) => new S2Model_1.default(this.view, subject));
        }
        get containingObject() {
          return void 0;
        }
        addInteraction(interaction) {
          this.insertProperties({
            [bioterms_1.Predicates.SBOL2.interaction]: interaction.subject
          });
        }
        addFunctionalComponent(fc) {
          this.insertProperties({
            [bioterms_1.Predicates.SBOL2.functionalComponent]: fc.subject
          });
        }
        createInteraction(id, version) {
          const identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.Interaction, this, bioterms_1.Predicates.SBOL2.interaction, id, void 0, version);
          const interaction = new S2Interaction_1.default(this.view, identified.subject);
          return interaction;
        }
        createFunctionalComponent(definition, id, name, version) {
          let actualId = id || definition.displayId || void 0;
          const identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.FunctionalComponent, this, bioterms_1.Predicates.SBOL2.functionalComponent, actualId, name, version || this.version);
          const fc = new S2FunctionalComponent_1.default(this.view, identified.subject);
          fc.definition = definition;
          return fc;
        }
        createSubModule(definition, id, name, version) {
          let actualId = id || definition.displayId || void 0;
          const identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.Module, this, bioterms_1.Predicates.SBOL2.module, actualId, name, version || this.version);
          const m = new S2ModuleInstance_1.default(this.view, identified.subject);
          m.definition = definition;
          return m;
        }
        get displayType() {
          for (let role of this.roles) {
            let name = (0, bioterms_1.uriToName)(role);
            if (name) {
              return name;
            }
          }
          return "Design";
        }
        destroy() {
          let instantiations = this.graph.match(null, bioterms_1.Predicates.SBOL2.definition, this.subject).map((t) => t.subject).map((uri) => new S2ModuleInstance_1.default(this.view, uri));
          super.destroy();
          for (let instantiation of instantiations) {
            instantiation.destroy();
          }
        }
      };
      exports.default = S2ModuleDefinition2;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Cut.js
  var require_S2Cut = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Cut.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2OrientedLocation_1 = require_S2OrientedLocation();
      var bioterms_1 = require_dist2();
      var S2Cut = class extends S2OrientedLocation_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.GenericLocation;
        }
        get at() {
          return this.getIntProperty(bioterms_1.Predicates.SBOL2.at);
        }
        set at(at) {
          if (at) {
            this.setIntProperty(bioterms_1.Predicates.SBOL2.at, at);
          } else {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.at);
          }
        }
      };
      exports.default = S2Cut;
    }
  });

  // node_modules/sboljs/dist/conversion/fastaToSBOL2.js
  var require_fastaToSBOL2 = __commonJS({
    "node_modules/sboljs/dist/conversion/fastaToSBOL2.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var rdfoo_1 = require_dist();
      function fastaToSBOL2(graph2, uriPrefix, fasta) {
        let lines = fasta.split("\n");
        let sequence = null;
        let elements = [];
        for (let line of lines) {
          line = line.trim();
          if (line[0] === ";") {
            continue;
          }
          if (line[0] === ">") {
            if (sequence) {
              setSequenceElementsAndGuessEncoding(sequence, elements.join(""));
              sequence = null;
            }
            let { id, properties } = parseHeader(line);
            sequence = graph2.createSequence(uriPrefix, id, "1");
            sequence.insertProperties(properties);
            continue;
          }
          elements.push(line);
        }
        if (sequence) {
          setSequenceElementsAndGuessEncoding(sequence, elements.join(""));
        }
      }
      exports.default = fastaToSBOL2;
      function parseHeader(header23) {
        if (header23.startsWith(">sp|") || header23.startsWith(">tr|")) {
          let matches = /([^|]*?)\|([^|]*?)([^\s]+=)/g.exec(header23);
          if (matches && matches.length === 4) {
            let accession = matches[1].trim();
            let entryName = matches[2].trim();
            let recommendedName = matches[3].trim();
            return {
              id: entryName,
              properties: {
                [bioterms_1.Predicates.Dcterms.title]: rdfoo_1.node.createStringNode(recommendedName),
                ["http://edamontology.org/data_3021"]: rdfoo_1.node.createStringNode(accession)
              }
            };
          }
        }
        if (header23.startsWith("gb|") || header23.startsWith("emb|") || header23.startsWith("dbj|") || header23.startsWith("sp|") || header23.startsWith("ref|")) {
          let tokens = header23.split("|");
          let accession = tokens[1];
          return {
            id: accession,
            properties: {}
          };
        }
        return {
          id: header23.slice(1).split(" ")[0] || "imported_fasta",
          properties: {
            [bioterms_1.Predicates.Dcterms.title]: rdfoo_1.node.createStringNode(header23.slice(1))
          }
        };
      }
      function setSequenceElementsAndGuessEncoding(sequence, elements) {
        let encoding2 = bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
        let na = /* @__PURE__ */ new Set(["A", "a", "T", "t", "C", "c", "G", "g", "U", "u", "*"]);
        for (let i = 0; i < elements.length; ++i) {
          if (!na.has(elements[i])) {
            encoding2 = bioterms_1.Specifiers.SBOL2.SequenceEncoding.AminoAcid;
            break;
          }
        }
        sequence.encoding = encoding2;
        sequence.elements = elements;
      }
    }
  });

  // node_modules/genbankjs/genbank.js
  var require_genbank = __commonJS({
    "node_modules/genbankjs/genbank.js"(exports) {
      init_shim();
      exports.parseGBF = function parseGBF(gbf) {
        gbf = gbf.split("\n");
        for (var origin = 0; origin < gbf.length; ++origin)
          if (gbf[origin].indexOf("ORIGIN") === 0)
            break;
        var record = {
          sequence: gbf.slice(origin + 1).map(function(line) {
            return line.trim().split(" ").slice(1).join("");
          }).join("")
        };
        parseFlatFile(gbf.slice(0, origin)).forEach(function(field) {
          switch (field.name) {
            case "LOCUS":
              var locus = field.value[0].match(/([^\s]+) +(\d+) bp +([A-Z]+) +([A-Z]+) +(\d\d-[A-Z]{3}-\d{4})/);
              if (locus !== null) {
                record.locusName = locus[1];
                record.sequenceLength = locus[2];
                record.moleculeType = locus[3];
                record.division = locus[4];
                record.modified = locus[5];
              }
              locus = field.value[0].match(/([^\s]+) +(\d+) bp +([A-Z]+) +([a-z]+) +([A-Z]+) +(\d\d-[A-Z]{3}-\d{4})/);
              if (locus !== null) {
                record.locusName = locus[1];
                record.sequenceLength = locus[2];
                record.moleculeType = locus[3];
                record.moleculeTypeDisp = locus[4];
                record.division = locus[5];
                record.modified = locus[6];
              }
              locus = field.value[0].match(/([^\s]+) +(\d+) bp +([A-Z]+) +([a-z]+) +(\d\d-[A-Z]{3}-\d{4})/);
              if (locus !== null) {
                record.locusName = locus[1];
                record.sequenceLength = locus[2];
                record.moleculeType = locus[3];
                record.moleculeTypeDisp = locus[4];
                record.modified = locus[5];
              }
              break;
            case "DEFINITION":
              record.definition = field.value.join(" ");
              break;
            case "ACCESSION":
              record.accession = field.value.join(" ");
              break;
            case "VERSION":
              record.version = field.value.join(" ");
              break;
            case "KEYWORDS":
              if (field.value == ".")
                break;
              break;
            case "SOURCE":
              record.source = {
                name: field.value.join(" ")
              };
              field.children.forEach(function(subfield) {
                if (subfield.name == "ORGANISM") {
                  record.source.organism = {
                    name: subfield.value[0],
                    lineage: subfield.value.slice(1).join(" ").split("; ").map(function(s) {
                      s = s.trim();
                      return s[s.length - 1] == "." ? s.slice(0, s.length - 1) : s;
                    })
                  };
                }
              });
              break;
            case "REFERENCE":
              if (record.references === void 0)
                record.references = [];
              var bases = field.value[0].match(/^([0-9]+) +\(bases ([0-9]+) to ([0-9]+)\)$/);
              var reference = bases !== null ? {
                number: parseInt(bases[1]),
                start: parseInt(bases[2]),
                end: parseInt(bases[3])
              } : {};
              field.children.forEach(function(subfield) {
                switch (subfield.name) {
                  case "AUTHORS":
                    reference.authors = subfield.value.join(" ");
                    break;
                  case "TITLE":
                    reference.title = subfield.value.join(" ");
                    break;
                  case "JOURNAL":
                    reference.journal = subfield.value.join(" ");
                    break;
                  case "PUBMED":
                    reference.pubmed = subfield.value.join(" ");
                    break;
                }
                ;
              });
              record.references.push(reference);
              break;
            case "FEATURES":
              record.features = [];
              field.children.forEach(function(feature) {
                var location = "";
                for (var i = 0; i < feature.value.length; ++i) {
                  if (feature.value[i][0] === "/")
                    break;
                  location += feature.value[i];
                }
                var f = {
                  key: feature.name,
                  location: parseLocation(location)
                };
                var qualifier;
                for (; i < feature.value.length; ++i) {
                  var qualifierLine = feature.value[i];
                  if (qualifierLine[0] === "/") {
                    qualifier = qualifierLine.split("=")[0];
                    var value = qualifierLine.split('"')[1];
                    if (!f[qualifier])
                      f[qualifier] = [value];
                    else
                      f[qualifier].push(value);
                  } else {
                    var value = qualifierLine.split('"')[0];
                    if (qualifier !== "/translation")
                      value = " " + value;
                    f[qualifier][f[qualifier].length - 1] += value;
                  }
                }
                record.features.push(f);
              });
              break;
          }
          ;
        });
        if (record.references) {
          record.references = record.references.sort(function(a, b) {
            return a.number - b.number;
          });
        }
        return record;
      };
      function parseLocation(location) {
        var match = location.match(/([a-z]+)\((.*)\)/);
        if (match !== null) {
          var modifier = match[1];
          if (modifier === "complement") {
            var innerLocation = parseLocation(match[2]);
            innerLocation.strand = "complementary";
            return innerLocation;
          } else if (modifier === "join") {
            return match[2].split(",").map(parseLocation);
          } else {
            throw new Error("unknown modifier: " + modifier);
          }
        } else {
          var partial3Prime = location.indexOf("<") !== -1;
          var partial5Prime = location.indexOf(">") !== -1;
          var startEndMatch = location.replace(/[<>]/g, "").match(/^([0-9]+)\.\.([0-9]+)$/);
          if (startEndMatch == null && location.match(/^([0-9]+)$/)) {
            return {
              start: parseInt(location),
              end: parseInt(location),
              partial3Prime,
              partial5Prime
            };
          } else {
            return {
              start: parseInt(startEndMatch[1]),
              end: parseInt(startEndMatch[2]),
              partial3Prime,
              partial5Prime
            };
          }
        }
      }
      function parseFlatFile(lines) {
        function getIndent(line) {
          for (var indent22 = 0; line[indent22] == " "; )
            ++indent22;
          return indent22;
        }
        function readFields(indent22) {
          var fields = [], field, valueColumn;
          while (lines.length > 0) {
            var line = lines[0];
            var lineIndent = getIndent(line);
            if (lineIndent < indent22)
              break;
            if (lineIndent > indent22) {
              if (lineIndent != valueColumn) {
                field.children = readFields(lineIndent);
                continue;
              }
              field.value.push(line.slice(lineIndent));
            }
            if (lineIndent == indent22) {
              var delim = line.indexOf(" ", lineIndent);
              valueColumn = delim + getIndent(line.slice(delim));
              field = {
                name: line.slice(lineIndent, delim),
                value: [line.slice(valueColumn)]
              };
              fields.push(field);
            }
            lines = lines.slice(1);
          }
          return fields;
        }
        return readFields(0);
      }
    }
  });

  // node_modules/sboljs/dist/conversion/genbankToSBOL2.js
  var require_genbankToSBOL2 = __commonJS({
    "node_modules/sboljs/dist/conversion/genbankToSBOL2.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var genbank = require_genbank();
      var bioterms_1 = require_dist2();
      function genbankToSBOL2(graph2, uriPrefix, gb) {
        let gbf = genbank.parseGBF(gb);
        let sequence = graph2.createSequence(uriPrefix, gbf.locusName + "_sequence", "1");
        if (gbf.moleculeType === "DNA") {
          sequence.encoding = bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
        } else {
          sequence.encoding = bioterms_1.Specifiers.SBOL2.SequenceEncoding.AminoAcid;
        }
        if (gbf.definition)
          sequence.description = gbf.definition;
        if (gbf.sequence)
          sequence.elements = gbf.sequence;
        if (!gbf.locusName) {
          console.dir(gbf);
          throw new Error("missing locusName?");
        }
        let componentDefinition = graph2.createComponentDefinition(uriPrefix, gbf.locusName, "1");
        if (gbf.moleculeType === "DNA") {
          componentDefinition.type = bioterms_1.Specifiers.SBOL2.Type.DNA;
        } else {
          componentDefinition.type = bioterms_1.Specifiers.SBOL2.Type.Protein;
        }
        componentDefinition.description = gbf.definition;
        for (let feature of gbf.features) {
          let name = feature.key;
          if (feature["/gene"] && feature["/gene"][0]) {
            name = feature["/gene"][0];
          } else if (feature["/product"] && feature["/product"][0]) {
            name = feature["/product"][0];
          }
          let sequenceAnnotation = componentDefinition.annotateRange(feature.location.start, feature.location.end, name);
          if (feature.location.strand === "complementary") {
            sequenceAnnotation.locations[0].orientation = bioterms_1.Specifiers.SBOL2.Orientation.ReverseComplement;
          }
          let soTerm = genbankToSO[feature.key];
          if (soTerm) {
            sequenceAnnotation.addRole(soTerm);
          }
        }
      }
      exports.default = genbankToSBOL2;
      var soToGenbank = {
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000001"]: "misc_feature",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000002"]: "misc_structure",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000005"]: "satellite",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000013"]: "scRNA",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000019"]: "stem_loop",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000112"]: "primer",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000139"]: "RBS",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000552"]: "RBS",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000140"]: "attenuator",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000141"]: "terminator",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000147"]: "exon",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000149"]: "source",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000165"]: "enhancer",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000167"]: "promoter",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000172"]: "CAAT_signal",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000173"]: "GC_signal",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000174"]: "TATA_signal",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000175"]: "-10_signal",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000176"]: "-35_signal",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000185"]: "precursor_RNA",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000185"]: "prim_transcript",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000188"]: "intron",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000204"]: "5'UTR",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000205"]: "3'UTR",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000233"]: "misc_RNA",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000234"]: "mRNA",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000252"]: "rRNA",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000253"]: "tRNA",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000274"]: "snRNA",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000286"]: "LTR",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000296"]: "rep_origin",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000297"]: "D-loop",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000298"]: "misc_recomb",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000305"]: "modified_base",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000313"]: "stem_loop",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000316"]: "CDS",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000331"]: "STS",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000409"]: "misc_binding",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000410"]: "protein_bind",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000413"]: "misc_difference",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000418"]: "sig_peptide",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000419"]: "mat_peptide",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000458"]: "D_segment",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000470"]: "J_region",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000551"]: "polyA_signal",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000553"]: "polyA_site",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000555"]: "5'clip",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000557"]: "3'clip",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000657"]: "repeat_region",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000704"]: "gene",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000723"]: "iDNA",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000725"]: "transit_peptide",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000726"]: "repeat_unit",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001023"]: "allele",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001054"]: "transposon",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001060"]: "variation",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001411"]: "misc_signal",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001645"]: "misc_marker",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001833"]: "V_region",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001834"]: "C_region",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001835"]: "N_region",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001836"]: "S_region",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0005836"]: "regulatory",
        [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0005850"]: "primer_bind"
      };
      var genbankToSO = /* @__PURE__ */ Object.create(null);
      Object.keys(soToGenbank).forEach((uri) => {
        let gb = soToGenbank[uri];
        if (genbankToSO[gb] === void 0) {
          genbankToSO[gb] = uri;
        }
      });
    }
  });

  // node_modules/rdfoo-prov/node_modules/bioterms/dist/Prefixes.js
  var require_Prefixes2 = __commonJS({
    "node_modules/rdfoo-prov/node_modules/bioterms/dist/Prefixes.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.prefixify = exports.Prefixes = void 0;
      var Prefixes5;
      (function(Prefixes6) {
        Prefixes6.sbol1 = "http://sbols.org/v1#";
        Prefixes6.sbol2 = "http://sbols.org/v2#";
        Prefixes6.sbolx = "http://sboldata.org/sbolx#";
        Prefixes6.sbol3 = "http://sbols.org/v3#";
        Prefixes6.rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
        Prefixes6.visual = "http://wiki.synbiohub.org/wiki/Terms/visual#";
        Prefixes6.sequenceOntologyPurl = "http://purl.org/obo/owl/SO#";
        Prefixes6.sequenceOntologyIdentifiersOrg = "http://identifiers.org/so/";
        Prefixes6.go = "http://identifiers.org/go/";
        Prefixes6.dcterms = "http://purl.org/dc/terms/";
        Prefixes6.rdfs = "http://www.w3.org/2000/01/rdf-schema#";
        Prefixes6.svg = "http://www.w3.org/2000/svg#";
        Prefixes6.sbo = "http://identifiers.org/biomodels.sbo/";
        Prefixes6.sboNs = "https://identifiers.org/SBO:";
        Prefixes6.sybio = "http://www.sybio.ncl.ac.uk#";
        Prefixes6.prov = "http://www.w3.org/ns/prov#";
        Prefixes6.enrichment = "http://wiki.synbiohub.org/wiki/Terms/enrichment#";
        Prefixes6.measure = "http://www.ontology-of-units-of-measure.org/resource/om-2/";
      })(Prefixes5 = exports.Prefixes || (exports.Prefixes = {}));
      function prefixify(uri) {
        uri = "" + uri;
        for (var i = 0; i < keys.length; ++i) {
          const prefix = keys[i];
          const uriPrefix = Prefixes5[prefix];
          if (uri.indexOf(uriPrefix) === 0) {
            return prefix + ":" + uri.slice(uriPrefix.length);
          }
        }
        return uri;
      }
      exports.prefixify = prefixify;
      var keys = Object.keys(Prefixes5);
    }
  });

  // node_modules/rdfoo-prov/node_modules/bioterms/dist/Types.js
  var require_Types2 = __commonJS({
    "node_modules/rdfoo-prov/node_modules/bioterms/dist/Types.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Types = void 0;
      var Prefixes_1 = require_Prefixes2();
      var Types9;
      (function(Types10) {
        let SBOL1;
        (function(SBOL12) {
          SBOL12.DnaComponent = Prefixes_1.Prefixes.sbol1 + "DnaComponent";
          SBOL12.DnaSequence = Prefixes_1.Prefixes.sbol1 + "DnaSequence";
          SBOL12.Collection = Prefixes_1.Prefixes.sbol1 + "Collection";
          SBOL12.SequenceAnnotation = Prefixes_1.Prefixes.sbol1 + "SequenceAnnotation";
        })(SBOL1 = Types10.SBOL1 || (Types10.SBOL1 = {}));
        let SBOL2;
        (function(SBOL22) {
          SBOL22.ModuleDefinition = Prefixes_1.Prefixes.sbol2 + "ModuleDefinition";
          SBOL22.ComponentDefinition = Prefixes_1.Prefixes.sbol2 + "ComponentDefinition";
          SBOL22.Module = Prefixes_1.Prefixes.sbol2 + "Module";
          SBOL22.Component = Prefixes_1.Prefixes.sbol2 + "Component";
          SBOL22.Range = Prefixes_1.Prefixes.sbol2 + "Range";
          SBOL22.Cut = Prefixes_1.Prefixes.sbol2 + "Cut";
          SBOL22.GenericLocation = Prefixes_1.Prefixes.sbol2 + "GenericLocation";
          SBOL22.SequenceAnnotation = Prefixes_1.Prefixes.sbol2 + "SequenceAnnotation";
          SBOL22.SequenceConstraint = Prefixes_1.Prefixes.sbol2 + "SequenceConstraint";
          SBOL22.Interaction = Prefixes_1.Prefixes.sbol2 + "Interaction";
          SBOL22.Participation = Prefixes_1.Prefixes.sbol2 + "Participation";
          SBOL22.Collection = Prefixes_1.Prefixes.sbol2 + "Collection";
          SBOL22.FunctionalComponent = Prefixes_1.Prefixes.sbol2 + "FunctionalComponent";
          SBOL22.Sequence = Prefixes_1.Prefixes.sbol2 + "Sequence";
          SBOL22.MapsTo = Prefixes_1.Prefixes.sbol2 + "MapsTo";
          SBOL22.Attachment = Prefixes_1.Prefixes.sbol2 + "Attachment";
          SBOL22.Model = Prefixes_1.Prefixes.sbol2 + "Model";
          SBOL22.Implementation = Prefixes_1.Prefixes.sbol2 + "Implementation";
          SBOL22.Experiment = Prefixes_1.Prefixes.sbol2 + "Experiment";
          SBOL22.ExperimentalData = Prefixes_1.Prefixes.sbol2 + "ExperimentalData";
          SBOL22.CombinatorialDerivation = Prefixes_1.Prefixes.sbol2 + "CombinatorialDerivation";
          SBOL22.VariableComponent = Prefixes_1.Prefixes.sbol2 + "VariableComponent";
        })(SBOL2 = Types10.SBOL2 || (Types10.SBOL2 = {}));
        let SBOLX;
        (function(SBOLX2) {
          SBOLX2.Component = Prefixes_1.Prefixes.sbolx + "Component";
          SBOLX2.SubComponent = Prefixes_1.Prefixes.sbolx + "SubComponent";
          SBOLX2.Range = Prefixes_1.Prefixes.sbolx + "Range";
          SBOLX2.Cut = Prefixes_1.Prefixes.sbolx + "Cut";
          SBOLX2.SequenceConstraint = Prefixes_1.Prefixes.sbolx + "SequenceConstraint";
          SBOLX2.Interaction = Prefixes_1.Prefixes.sbolx + "Interaction";
          SBOLX2.Participation = Prefixes_1.Prefixes.sbolx + "Participation";
          SBOLX2.Collection = Prefixes_1.Prefixes.sbolx + "Collection";
          SBOLX2.Sequence = Prefixes_1.Prefixes.sbolx + "Sequence";
          SBOLX2.OrientedLocation = Prefixes_1.Prefixes.sbolx + "OrientedLocation";
          SBOLX2.SequenceAnnotation = Prefixes_1.Prefixes.sbolx + "SequenceAnnotation";
          SBOLX2.Attachment = Prefixes_1.Prefixes.sbolx + "Attachment";
          SBOLX2.Model = Prefixes_1.Prefixes.sbolx + "Model";
          SBOLX2.Implementation = Prefixes_1.Prefixes.sbolx + "Implementation";
          SBOLX2.MapsTo = Prefixes_1.Prefixes.sbolx + "MapsTo";
          SBOLX2.Experiment = Prefixes_1.Prefixes.sbolx + "Experiment";
          SBOLX2.ExperimentalData = Prefixes_1.Prefixes.sbolx + "ExperimentalData";
        })(SBOLX = Types10.SBOLX || (Types10.SBOLX = {}));
        let SBOL3;
        (function(SBOL32) {
          SBOL32.Component = Prefixes_1.Prefixes.sbol3 + "Component";
          SBOL32.SubComponent = Prefixes_1.Prefixes.sbol3 + "SubComponent";
          SBOL32.Range = Prefixes_1.Prefixes.sbol3 + "Range";
          SBOL32.Cut = Prefixes_1.Prefixes.sbol3 + "Cut";
          SBOL32.EntireSequence = Prefixes_1.Prefixes.sbol3 + "EntireSequence";
          SBOL32.Constraint = Prefixes_1.Prefixes.sbol3 + "Constraint";
          SBOL32.Interaction = Prefixes_1.Prefixes.sbol3 + "Interaction";
          SBOL32.Participation = Prefixes_1.Prefixes.sbol3 + "Participation";
          SBOL32.Collection = Prefixes_1.Prefixes.sbol3 + "Collection";
          SBOL32.Sequence = Prefixes_1.Prefixes.sbol3 + "Sequence";
          SBOL32.OrientedLocation = Prefixes_1.Prefixes.sbol3 + "OrientedLocation";
          SBOL32.SequenceFeature = Prefixes_1.Prefixes.sbol3 + "SequenceFeature";
          SBOL32.Attachment = Prefixes_1.Prefixes.sbol3 + "Attachment";
          SBOL32.Model = Prefixes_1.Prefixes.sbol3 + "Model";
          SBOL32.Implementation = Prefixes_1.Prefixes.sbol3 + "Implementation";
          SBOL32.MapsTo = Prefixes_1.Prefixes.sbol3 + "MapsTo";
          SBOL32.Experiment = Prefixes_1.Prefixes.sbol3 + "Experiment";
          SBOL32.ExperimentalData = Prefixes_1.Prefixes.sbol3 + "ExperimentalData";
          SBOL32.Namespace = Prefixes_1.Prefixes.sbol3 + "Namespace";
          SBOL32.CombinatorialDerivation = Prefixes_1.Prefixes.sbol3 + "CombinatorialDerivation";
          SBOL32.VariableFeature = Prefixes_1.Prefixes.sbol3 + "VariableFeature";
          SBOL32.Interface = Prefixes_1.Prefixes.sbol3 + "Interface";
          SBOL32.LocalSubComponent = Prefixes_1.Prefixes.sbol3 + "LocalSubComponent";
          SBOL32.ExternallyDefined = Prefixes_1.Prefixes.sbol3 + "ExternallyDefined";
        })(SBOL3 = Types10.SBOL3 || (Types10.SBOL3 = {}));
        let Visual;
        (function(Visual2) {
          Visual2.ModuleDepiction = Prefixes_1.Prefixes.visual + "ModuleDepiction";
          Visual2.ComponentDepiction = Prefixes_1.Prefixes.visual + "ComponentDepiction";
          Visual2.Glyph = Prefixes_1.Prefixes.visual + "Glyph";
          Visual2.Label = Prefixes_1.Prefixes.visual + "Label";
        })(Visual = Types10.Visual || (Types10.Visual = {}));
        let SyBiOnt;
        (function(SyBiOnt2) {
          SyBiOnt2.Protein = Prefixes_1.Prefixes.sybio + "Protein";
          SyBiOnt2.InduciblePromoter = Prefixes_1.Prefixes.sybio + "InduciblePromoter";
          SyBiOnt2.Reaction = Prefixes_1.Prefixes.sybio + "Reaction";
          SyBiOnt2.ReactionParticipant = Prefixes_1.Prefixes.sybio + "ReactionParticipant";
          SyBiOnt2.Compound = Prefixes_1.Prefixes.sybio + "Compound";
        })(SyBiOnt = Types10.SyBiOnt || (Types10.SyBiOnt = {}));
        let Prov;
        (function(Prov2) {
          Prov2.Agent = Prefixes_1.Prefixes.prov + "Agent";
          Prov2.Association = Prefixes_1.Prefixes.prov + "Association";
          Prov2.Activity = Prefixes_1.Prefixes.prov + "Activity";
          Prov2.Usage = Prefixes_1.Prefixes.prov + "Usage";
          Prov2.Plan = Prefixes_1.Prefixes.prov + "Plan";
        })(Prov = Types10.Prov || (Types10.Prov = {}));
        let Enrichment;
        (function(Enrichment2) {
          Enrichment2.GeneProduct = Prefixes_1.Prefixes.enrichment + "GeneProduct";
        })(Enrichment = Types10.Enrichment || (Types10.Enrichment = {}));
        let Measure;
        (function(Measure_1) {
          Measure_1.Measure = Prefixes_1.Prefixes.measure + "Measure";
        })(Measure = Types10.Measure || (Types10.Measure = {}));
      })(Types9 = exports.Types || (exports.Types = {}));
    }
  });

  // node_modules/rdfoo-prov/node_modules/bioterms/dist/Predicates.js
  var require_Predicates2 = __commonJS({
    "node_modules/rdfoo-prov/node_modules/bioterms/dist/Predicates.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Predicates = void 0;
      var Prefixes_1 = require_Prefixes2();
      var Predicates14;
      (function(Predicates15) {
        Predicates15.a = Prefixes_1.Prefixes.rdf + "type";
        let SBOL1;
        (function(SBOL12) {
          SBOL12.nucleotides = Prefixes_1.Prefixes.sbol1 + "nucleotides";
          SBOL12.subComponent = Prefixes_1.Prefixes.sbol1 + "subComponent";
          SBOL12.dnaSequence = Prefixes_1.Prefixes.sbol1 + "dnaSequence";
          SBOL12.bioStart = Prefixes_1.Prefixes.sbol1 + "bioStart";
          SBOL12.bioEnd = Prefixes_1.Prefixes.sbol1 + "bioEnd";
          SBOL12.displayId = Prefixes_1.Prefixes.sbol1 + "displayId";
          SBOL12.name = Prefixes_1.Prefixes.sbol1 + "name";
          SBOL12.description = Prefixes_1.Prefixes.sbol1 + "description";
          SBOL12.annotation = Prefixes_1.Prefixes.sbol1 + "annotation";
          SBOL12.strand = Prefixes_1.Prefixes.sbol1 + "strand";
          SBOL12.component = Prefixes_1.Prefixes.sbol1 + "component";
          SBOL12.precedes = Prefixes_1.Prefixes.sbol1 + "precedes";
        })(SBOL1 = Predicates15.SBOL1 || (Predicates15.SBOL1 = {}));
        let SBOL2;
        (function(SBOL22) {
          SBOL22.component = Prefixes_1.Prefixes.sbol2 + "component";
          SBOL22.module = Prefixes_1.Prefixes.sbol2 + "module";
          SBOL22.definition = Prefixes_1.Prefixes.sbol2 + "definition";
          SBOL22.functionalComponent = Prefixes_1.Prefixes.sbol2 + "functionalComponent";
          SBOL22.role = Prefixes_1.Prefixes.sbol2 + "role";
          SBOL22.location = Prefixes_1.Prefixes.sbol2 + "location";
          SBOL22.start = Prefixes_1.Prefixes.sbol2 + "start";
          SBOL22.end = Prefixes_1.Prefixes.sbol2 + "end";
          SBOL22.at = Prefixes_1.Prefixes.sbol2 + "at";
          SBOL22.sequenceAnnotation = Prefixes_1.Prefixes.sbol2 + "sequenceAnnotation";
          SBOL22.sequenceConstraint = Prefixes_1.Prefixes.sbol2 + "sequenceConstraint";
          SBOL22.orientation = Prefixes_1.Prefixes.sbol2 + "orientation";
          SBOL22.displayId = Prefixes_1.Prefixes.sbol2 + "displayId";
          SBOL22.version = Prefixes_1.Prefixes.sbol2 + "version";
          SBOL22.access = Prefixes_1.Prefixes.sbol2 + "access";
          SBOL22.mapsTo = Prefixes_1.Prefixes.sbol2 + "mapsTo";
          SBOL22.local = Prefixes_1.Prefixes.sbol2 + "local";
          SBOL22.remote = Prefixes_1.Prefixes.sbol2 + "remote";
          SBOL22.refinement = Prefixes_1.Prefixes.sbol2 + "refinement";
          SBOL22.interaction = Prefixes_1.Prefixes.sbol2 + "interaction";
          SBOL22.participation = Prefixes_1.Prefixes.sbol2 + "participation";
          SBOL22.participant = Prefixes_1.Prefixes.sbol2 + "participant";
          SBOL22.type = Prefixes_1.Prefixes.sbol2 + "type";
          SBOL22.sequence = Prefixes_1.Prefixes.sbol2 + "sequence";
          SBOL22.encoding = Prefixes_1.Prefixes.sbol2 + "encoding";
          SBOL22.elements = Prefixes_1.Prefixes.sbol2 + "elements";
          SBOL22.persistentIdentity = Prefixes_1.Prefixes.sbol2 + "persistentIdentity";
          SBOL22.restriction = Prefixes_1.Prefixes.sbol2 + "restriction";
          SBOL22.subject = Prefixes_1.Prefixes.sbol2 + "subject";
          SBOL22.object = Prefixes_1.Prefixes.sbol2 + "object";
          SBOL22.member = Prefixes_1.Prefixes.sbol2 + "member";
          SBOL22.model = Prefixes_1.Prefixes.sbol2 + "model";
          SBOL22.framework = Prefixes_1.Prefixes.sbol2 + "framework";
          SBOL22.language = Prefixes_1.Prefixes.sbol2 + "language";
          SBOL22.source = Prefixes_1.Prefixes.sbol2 + "source";
          SBOL22.attachment = Prefixes_1.Prefixes.sbol2 + "attachment";
          SBOL22.format = Prefixes_1.Prefixes.sbol2 + "format";
          SBOL22.size = Prefixes_1.Prefixes.sbol2 + "size";
          SBOL22.hash = Prefixes_1.Prefixes.sbol2 + "hash";
          SBOL22.built = Prefixes_1.Prefixes.sbol2 + "built";
          SBOL22.experimentalData = Prefixes_1.Prefixes.sbol2 + "experimentalData";
          SBOL22.sourceLocation = Prefixes_1.Prefixes.sbol2 + "sourceLocation";
          SBOL22.measure = Prefixes_1.Prefixes.sbol2 + "measure";
          SBOL22.template = Prefixes_1.Prefixes.sbol2 + "template";
          SBOL22.variableComponent = Prefixes_1.Prefixes.sbol2 + "variableComponent";
          SBOL22.strategy = Prefixes_1.Prefixes.sbol2 + "strategy";
          SBOL22.variable = Prefixes_1.Prefixes.sbol2 + "variable";
          SBOL22.variant = Prefixes_1.Prefixes.sbol2 + "variant";
          SBOL22.variantCollection = Prefixes_1.Prefixes.sbol2 + "variantCollection";
          SBOL22.variantDerivation = Prefixes_1.Prefixes.sbol2 + "variantDerivation";
        })(SBOL2 = Predicates15.SBOL2 || (Predicates15.SBOL2 = {}));
        let SBOLX;
        (function(SBOLX2) {
          SBOLX2.subComponent = Prefixes_1.Prefixes.sbolx + "subComponent";
          SBOLX2.instanceOf = Prefixes_1.Prefixes.sbolx + "instanceOf";
          SBOLX2.role = Prefixes_1.Prefixes.sbolx + "role";
          SBOLX2.location = Prefixes_1.Prefixes.sbolx + "location";
          SBOLX2.start = Prefixes_1.Prefixes.sbolx + "start";
          SBOLX2.end = Prefixes_1.Prefixes.sbolx + "end";
          SBOLX2.at = Prefixes_1.Prefixes.sbolx + "at";
          SBOLX2.sequenceAnnotation = Prefixes_1.Prefixes.sbolx + "sequenceAnnotation";
          SBOLX2.sequenceConstraint = Prefixes_1.Prefixes.sbolx + "sequenceConstraint";
          SBOLX2.orientation = Prefixes_1.Prefixes.sbolx + "orientation";
          SBOLX2.id = Prefixes_1.Prefixes.sbolx + "id";
          SBOLX2.version = Prefixes_1.Prefixes.sbolx + "version";
          SBOLX2.access = Prefixes_1.Prefixes.sbolx + "access";
          SBOLX2.mapsTo = Prefixes_1.Prefixes.sbolx + "mapsTo";
          SBOLX2.local = Prefixes_1.Prefixes.sbolx + "local";
          SBOLX2.remote = Prefixes_1.Prefixes.sbolx + "remote";
          SBOLX2.refinement = Prefixes_1.Prefixes.sbolx + "refinement";
          SBOLX2.interaction = Prefixes_1.Prefixes.sbolx + "interaction";
          SBOLX2.participation = Prefixes_1.Prefixes.sbolx + "participation";
          SBOLX2.participant = Prefixes_1.Prefixes.sbolx + "participant";
          SBOLX2.type = Prefixes_1.Prefixes.sbolx + "type";
          SBOLX2.sequence = Prefixes_1.Prefixes.sbolx + "sequence";
          SBOLX2.encoding = Prefixes_1.Prefixes.sbolx + "encoding";
          SBOLX2.elements = Prefixes_1.Prefixes.sbolx + "elements";
          SBOLX2.persistentIdentity = Prefixes_1.Prefixes.sbolx + "persistentIdentity";
          SBOLX2.restriction = Prefixes_1.Prefixes.sbolx + "restriction";
          SBOLX2.subject = Prefixes_1.Prefixes.sbolx + "subject";
          SBOLX2.object = Prefixes_1.Prefixes.sbolx + "object";
          SBOLX2.member = Prefixes_1.Prefixes.sbolx + "member";
          SBOLX2.model = Prefixes_1.Prefixes.sbolx + "model";
          SBOLX2.framework = Prefixes_1.Prefixes.sbolx + "framework";
          SBOLX2.language = Prefixes_1.Prefixes.sbolx + "language";
          SBOLX2.source = Prefixes_1.Prefixes.sbolx + "source";
          SBOLX2.attachment = Prefixes_1.Prefixes.sbolx + "attachment";
          SBOLX2.format = Prefixes_1.Prefixes.sbolx + "format";
          SBOLX2.size = Prefixes_1.Prefixes.sbolx + "size";
          SBOLX2.hash = Prefixes_1.Prefixes.sbolx + "hash";
          SBOLX2.built = Prefixes_1.Prefixes.sbolx + "built";
          SBOLX2.experimentalData = Prefixes_1.Prefixes.sbolx + "experimentalData";
          SBOLX2.sourceLocation = Prefixes_1.Prefixes.sbolx + "sourceLocation";
          SBOLX2.measure = Prefixes_1.Prefixes.sbolx + "measure";
        })(SBOLX = Predicates15.SBOLX || (Predicates15.SBOLX = {}));
        let SBOL3;
        (function(SBOL32) {
          SBOL32.instanceOf = Prefixes_1.Prefixes.sbol3 + "instanceOf";
          SBOL32.role = Prefixes_1.Prefixes.sbol3 + "role";
          SBOL32.hasLocation = Prefixes_1.Prefixes.sbol3 + "hasLocation";
          SBOL32.start = Prefixes_1.Prefixes.sbol3 + "start";
          SBOL32.end = Prefixes_1.Prefixes.sbol3 + "end";
          SBOL32.at = Prefixes_1.Prefixes.sbol3 + "at";
          SBOL32.hasFeature = Prefixes_1.Prefixes.sbol3 + "hasFeature";
          SBOL32.hasConstraint = Prefixes_1.Prefixes.sbol3 + "hasConstraint";
          SBOL32.orientation = Prefixes_1.Prefixes.sbol3 + "orientation";
          SBOL32.displayId = Prefixes_1.Prefixes.sbol3 + "displayId";
          SBOL32.name = Prefixes_1.Prefixes.sbol3 + "name";
          SBOL32.description = Prefixes_1.Prefixes.sbol3 + "description";
          SBOL32.access = Prefixes_1.Prefixes.sbol3 + "access";
          SBOL32.mapsTo = Prefixes_1.Prefixes.sbol3 + "mapsTo";
          SBOL32.local = Prefixes_1.Prefixes.sbol3 + "local";
          SBOL32.remote = Prefixes_1.Prefixes.sbol3 + "remote";
          SBOL32.refinement = Prefixes_1.Prefixes.sbol3 + "refinement";
          SBOL32.hasInteraction = Prefixes_1.Prefixes.sbol3 + "hasInteraction";
          SBOL32.hasInterface = Prefixes_1.Prefixes.sbol3 + "hasInterface";
          SBOL32.hasParticipation = Prefixes_1.Prefixes.sbol3 + "hasParticipation";
          SBOL32.participant = Prefixes_1.Prefixes.sbol3 + "participant";
          SBOL32.type = Prefixes_1.Prefixes.sbol3 + "type";
          SBOL32.hasSequence = Prefixes_1.Prefixes.sbol3 + "hasSequence";
          SBOL32.encoding = Prefixes_1.Prefixes.sbol3 + "encoding";
          SBOL32.elements = Prefixes_1.Prefixes.sbol3 + "elements";
          SBOL32.persistentIdentity = Prefixes_1.Prefixes.sbol3 + "persistentIdentity";
          SBOL32.restriction = Prefixes_1.Prefixes.sbol3 + "restriction";
          SBOL32.subject = Prefixes_1.Prefixes.sbol3 + "subject";
          SBOL32.object = Prefixes_1.Prefixes.sbol3 + "object";
          SBOL32.member = Prefixes_1.Prefixes.sbol3 + "member";
          SBOL32.hasModel = Prefixes_1.Prefixes.sbol3 + "hasModel";
          SBOL32.framework = Prefixes_1.Prefixes.sbol3 + "framework";
          SBOL32.language = Prefixes_1.Prefixes.sbol3 + "language";
          SBOL32.source = Prefixes_1.Prefixes.sbol3 + "source";
          SBOL32.hasAttachment = Prefixes_1.Prefixes.sbol3 + "hasAttachment";
          SBOL32.format = Prefixes_1.Prefixes.sbol3 + "format";
          SBOL32.size = Prefixes_1.Prefixes.sbol3 + "size";
          SBOL32.hash = Prefixes_1.Prefixes.sbol3 + "hash";
          SBOL32.built = Prefixes_1.Prefixes.sbol3 + "built";
          SBOL32.experimentalData = Prefixes_1.Prefixes.sbol3 + "experimentalData";
          SBOL32.sourceLocation = Prefixes_1.Prefixes.sbol3 + "sourceLocation";
          SBOL32.hasMeasure = Prefixes_1.Prefixes.sbol3 + "hasMeasure";
          SBOL32.hasNamespace = Prefixes_1.Prefixes.sbol3 + "hasNamespace";
          SBOL32.template = Prefixes_1.Prefixes.sbol3 + "template";
          SBOL32.hasVariableFeature = Prefixes_1.Prefixes.sbol3 + "hasVariableFeature";
          SBOL32.strategy = Prefixes_1.Prefixes.sbol3 + "strategy";
          SBOL32.variable = Prefixes_1.Prefixes.sbol3 + "variable";
          SBOL32.variant = Prefixes_1.Prefixes.sbol3 + "variant";
          SBOL32.variantCollection = Prefixes_1.Prefixes.sbol3 + "variantCollection";
          SBOL32.variantDerivation = Prefixes_1.Prefixes.sbol3 + "variantDerivation";
          SBOL32.variantMeasure = Prefixes_1.Prefixes.sbol3 + "variantMeasure";
          SBOL32.input = Prefixes_1.Prefixes.sbol3 + "input";
          SBOL32.output = Prefixes_1.Prefixes.sbol3 + "output";
          SBOL32.nondirectional = Prefixes_1.Prefixes.sbol3 + "nondirectional";
          SBOL32.definition = Prefixes_1.Prefixes.sbol3 + "definition";
        })(SBOL3 = Predicates15.SBOL3 || (Predicates15.SBOL3 = {}));
        let Dcterms;
        (function(Dcterms2) {
          Dcterms2.title = Prefixes_1.Prefixes.dcterms + "title";
          Dcterms2.description = Prefixes_1.Prefixes.dcterms + "description";
        })(Dcterms = Predicates15.Dcterms || (Predicates15.Dcterms = {}));
        let SVG;
        (function(SVG2) {
          SVG2.fontFamily = Prefixes_1.Prefixes.svg + "font-family";
          SVG2.fontSize = Prefixes_1.Prefixes.svg + "font-size";
          SVG2.fontStyle = Prefixes_1.Prefixes.svg + "font-style";
        })(SVG = Predicates15.SVG || (Predicates15.SVG = {}));
        let SyBiOnt;
        (function(SyBiOnt2) {
          SyBiOnt2.encodedBy = Prefixes_1.Prefixes.sybio + "encodedBy";
          SyBiOnt2.EC = Prefixes_1.Prefixes.sybio + "EC";
          SyBiOnt2.isBalanced = Prefixes_1.Prefixes.sybio + "isBalanced";
          SyBiOnt2.isReactionClass = Prefixes_1.Prefixes.sybio + "isReactionClass";
          SyBiOnt2.inPolymerization = Prefixes_1.Prefixes.sybio + "inPolymerization";
          SyBiOnt2.inTransport = Prefixes_1.Prefixes.sybio + "inTransport";
          SyBiOnt2.reactionDirection = Prefixes_1.Prefixes.sybio + "reactionDirection";
          SyBiOnt2.hasReactionParticipant = Prefixes_1.Prefixes.sybio + "hasReactionParticipant";
          SyBiOnt2.referencesCompound = Prefixes_1.Prefixes.sybio + "referencesCompound";
          SyBiOnt2.reactionSide = Prefixes_1.Prefixes.sybio + "reactionSide";
          SyBiOnt2.reactionSummary = Prefixes_1.Prefixes.sybio + "reactionSummary";
          SyBiOnt2.stoicRatio = Prefixes_1.Prefixes.sybio + "stoichiometricRatio";
          SyBiOnt2.compoundCharge = Prefixes_1.Prefixes.sybio + "compoundCharge";
          SyBiOnt2.compoundFormula = Prefixes_1.Prefixes.sybio + "compoundFormula";
          SyBiOnt2.compoundMass = Prefixes_1.Prefixes.sybio + "compoundMass";
          SyBiOnt2.compoundSmilesFormula = Prefixes_1.Prefixes.sybio + "compoundSmilesFormula";
          SyBiOnt2.interactsWith = Prefixes_1.Prefixes.sybio + "interactsWith";
          SyBiOnt2.taxId = Prefixes_1.Prefixes.sybio + "taxId";
        })(SyBiOnt = Predicates15.SyBiOnt || (Predicates15.SyBiOnt = {}));
        let Prov;
        (function(Prov2) {
          Prov2.wasDerivedFrom = Prefixes_1.Prefixes.prov + "wasDerivedFrom";
          Prov2.wasGeneratedBy = Prefixes_1.Prefixes.prov + "wasGeneratedBy";
          Prov2.qualifiedAssociation = Prefixes_1.Prefixes.prov + "qualifiedAssociation";
          Prov2.qualifiedUsage = Prefixes_1.Prefixes.prov + "qualifiedUsage";
          Prov2.startedAtTime = Prefixes_1.Prefixes.prov + "startedAtTime";
          Prov2.endedAtTime = Prefixes_1.Prefixes.prov + "endedAtTime";
          Prov2.wasInformedBy = Prefixes_1.Prefixes.prov + "wasInformedBy";
          Prov2.agent = Prefixes_1.Prefixes.prov + "agent";
          Prov2.entity = Prefixes_1.Prefixes.prov + "entity";
          Prov2.hadRole = Prefixes_1.Prefixes.prov + "hadRole";
          Prov2.hadPlan = Prefixes_1.Prefixes.prov + "hadPlan";
        })(Prov = Predicates15.Prov || (Predicates15.Prov = {}));
        let Enrichment;
        (function(Enrichment2) {
          Enrichment2.hint = Prefixes_1.Prefixes.enrichment + "hint";
          Enrichment2.orfStart = Prefixes_1.Prefixes.enrichment + "orfStart";
          Enrichment2.orfEnd = Prefixes_1.Prefixes.enrichment + "orfEnd";
        })(Enrichment = Predicates15.Enrichment || (Predicates15.Enrichment = {}));
        let Measure;
        (function(Measure2) {
          Measure2.hasNumericalValue = Prefixes_1.Prefixes.measure + "hasNumericalValue";
          Measure2.hasUnit = Prefixes_1.Prefixes.measure + "hasUnit";
        })(Measure = Predicates15.Measure || (Predicates15.Measure = {}));
      })(Predicates14 = exports.Predicates || (exports.Predicates = {}));
    }
  });

  // node_modules/rdfoo-prov/node_modules/bioterms/dist/Specifiers.js
  var require_Specifiers2 = __commonJS({
    "node_modules/rdfoo-prov/node_modules/bioterms/dist/Specifiers.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Specifiers = void 0;
      var Prefixes_1 = require_Prefixes2();
      var Specifiers2;
      (function(Specifiers3) {
        let SBOL2;
        (function(SBOL22) {
          let Orientation;
          (function(Orientation2) {
            Orientation2.Inline = Prefixes_1.Prefixes.sbol2 + "inline";
            Orientation2.ReverseComplement = Prefixes_1.Prefixes.sbol2 + "reverseComplement";
          })(Orientation = SBOL22.Orientation || (SBOL22.Orientation = {}));
          let Direction;
          (function(Direction2) {
            Direction2.Input = Prefixes_1.Prefixes.sbol2 + "in";
            Direction2.Output = Prefixes_1.Prefixes.sbol2 + "out";
            Direction2.InputAndOutput = Prefixes_1.Prefixes.sbol2 + "inout";
            Direction2.None = Prefixes_1.Prefixes.sbol2 + "none";
          })(Direction = SBOL22.Direction || (SBOL22.Direction = {}));
          let Access;
          (function(Access2) {
            Access2.PublicAccess = Prefixes_1.Prefixes.sbol2 + "public";
            Access2.PrivateAccess = Prefixes_1.Prefixes.sbol2 + "private";
          })(Access = SBOL22.Access || (SBOL22.Access = {}));
          let Type;
          (function(Type2) {
            Type2.DNA = Prefixes_1.Prefixes.sboNs + "0000251";
            Type2.RNA = Prefixes_1.Prefixes.sboNs + "0000250";
            Type2.Protein = Prefixes_1.Prefixes.sboNs + "0000252";
            Type2.SmallMolecule = Prefixes_1.Prefixes.sboNs + "0000247";
            Type2.Complex = Prefixes_1.Prefixes.sboNs + "0000253";
            Type2.Effector = "http://identifiers.org/chebi/CHEBI:35224";
            Type2.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000988";
          })(Type = SBOL22.Type || (SBOL22.Type = {}));
          let SequenceEncoding;
          (function(SequenceEncoding2) {
            SequenceEncoding2.NucleicAcid = "https://identifiers.org/edam:format_1207";
            SequenceEncoding2.RNA = "https://identifiers.org/edam:format_1207";
            SequenceEncoding2.AminoAcid = "https://identifiers.org/edam:format_1208";
          })(SequenceEncoding = SBOL22.SequenceEncoding || (SBOL22.SequenceEncoding = {}));
          let SequenceConstraint;
          (function(SequenceConstraint2) {
            SequenceConstraint2.Precedes = Prefixes_1.Prefixes.sbol2 + "precedes";
            SequenceConstraint2.OppositeOrientationAs = Prefixes_1.Prefixes.sbol2 + "oppositeOrientationAs";
          })(SequenceConstraint = SBOL22.SequenceConstraint || (SBOL22.SequenceConstraint = {}));
          let ProvRole;
          (function(ProvRole2) {
            ProvRole2.Design = Prefixes_1.Prefixes.sbol2 + "design";
            ProvRole2.Build = Prefixes_1.Prefixes.sbol2 + "build";
            ProvRole2.Test = Prefixes_1.Prefixes.sbol2 + "test";
            ProvRole2.Learn = Prefixes_1.Prefixes.sbol2 + "learn";
          })(ProvRole = SBOL22.ProvRole || (SBOL22.ProvRole = {}));
          let MapsToRefinement;
          (function(MapsToRefinement2) {
            MapsToRefinement2.UseLocal = Prefixes_1.Prefixes.sbol2 + "useLocal";
            MapsToRefinement2.UseRemote = Prefixes_1.Prefixes.sbol2 + "useRemote";
          })(MapsToRefinement = SBOL22.MapsToRefinement || (SBOL22.MapsToRefinement = {}));
        })(SBOL2 = Specifiers3.SBOL2 || (Specifiers3.SBOL2 = {}));
        let SBOLX;
        (function(SBOLX2) {
          let Orientation;
          (function(Orientation2) {
            Orientation2.Inline = Prefixes_1.Prefixes.sbolx + "inline";
            Orientation2.ReverseComplement = Prefixes_1.Prefixes.sbolx + "reverseComplement";
          })(Orientation = SBOLX2.Orientation || (SBOLX2.Orientation = {}));
          let Direction;
          (function(Direction2) {
            Direction2.Input = Prefixes_1.Prefixes.sbolx + "in";
            Direction2.Output = Prefixes_1.Prefixes.sbolx + "out";
            Direction2.InputAndOutput = Prefixes_1.Prefixes.sbolx + "inout";
            Direction2.None = Prefixes_1.Prefixes.sbolx + "none";
          })(Direction = SBOLX2.Direction || (SBOLX2.Direction = {}));
          let Access;
          (function(Access2) {
            Access2.PublicAccess = Prefixes_1.Prefixes.sbolx + "public";
            Access2.PrivateAccess = Prefixes_1.Prefixes.sbolx + "private";
          })(Access = SBOLX2.Access || (SBOLX2.Access = {}));
          let Type;
          (function(Type2) {
            Type2.DNA = "http://www.biopax.org/release/biopax-level3.owl#DnaRegion";
            Type2.RNA = "http://www.biopax.org/release/biopax-level3.owl#RnaRegion";
            Type2.Protein = "http://www.biopax.org/release/biopax-level3.owl#Protein";
            Type2.SmallMolecule = "http://www.biopax.org/release/biopax-level3.owl#SmallMolecule";
            Type2.Complex = "http://www.biopax.org/release/biopax-level3.owl#Complex";
            Type2.Effector = "http://identifiers.org/chebi/CHEBI:35224";
            Type2.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000988";
          })(Type = SBOLX2.Type || (SBOLX2.Type = {}));
          let SequenceEncoding;
          (function(SequenceEncoding2) {
            SequenceEncoding2.NucleicAcid = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.RNA = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.AminoAcid = "http://www.chem.qmul.ac.uk/iupac/AminoAcid/";
          })(SequenceEncoding = SBOLX2.SequenceEncoding || (SBOLX2.SequenceEncoding = {}));
          let SequenceConstraint;
          (function(SequenceConstraint2) {
            SequenceConstraint2.Precedes = Prefixes_1.Prefixes.sbolx + "precedes";
            SequenceConstraint2.OppositeOrientationAs = Prefixes_1.Prefixes.sbolx + "oppositeOrientationAs";
          })(SequenceConstraint = SBOLX2.SequenceConstraint || (SBOLX2.SequenceConstraint = {}));
          let ProvRole;
          (function(ProvRole2) {
            ProvRole2.Design = Prefixes_1.Prefixes.sbolx + "design";
            ProvRole2.Build = Prefixes_1.Prefixes.sbolx + "build";
            ProvRole2.Test = Prefixes_1.Prefixes.sbolx + "test";
            ProvRole2.Learn = Prefixes_1.Prefixes.sbolx + "learn";
          })(ProvRole = SBOLX2.ProvRole || (SBOLX2.ProvRole = {}));
          let MapsToRefinement;
          (function(MapsToRefinement2) {
            MapsToRefinement2.UseLocal = Prefixes_1.Prefixes.sbolx + "useLocal";
            MapsToRefinement2.UseRemote = Prefixes_1.Prefixes.sbolx + "useRemote";
          })(MapsToRefinement = SBOLX2.MapsToRefinement || (SBOLX2.MapsToRefinement = {}));
        })(SBOLX = Specifiers3.SBOLX || (Specifiers3.SBOLX = {}));
        let SBOL3;
        (function(SBOL32) {
          let Orientation;
          (function(Orientation2) {
            Orientation2.Inline = Prefixes_1.Prefixes.sbol3 + "inline";
            Orientation2.ReverseComplement = Prefixes_1.Prefixes.sbol3 + "reverseComplement";
          })(Orientation = SBOL32.Orientation || (SBOL32.Orientation = {}));
          let Direction;
          (function(Direction2) {
            Direction2.Input = Prefixes_1.Prefixes.sbol3 + "in";
            Direction2.Output = Prefixes_1.Prefixes.sbol3 + "out";
            Direction2.InputAndOutput = Prefixes_1.Prefixes.sbol3 + "inout";
            Direction2.None = Prefixes_1.Prefixes.sbol3 + "none";
          })(Direction = SBOL32.Direction || (SBOL32.Direction = {}));
          let Access;
          (function(Access2) {
            Access2.PublicAccess = Prefixes_1.Prefixes.sbol3 + "public";
            Access2.PrivateAccess = Prefixes_1.Prefixes.sbol3 + "private";
          })(Access = SBOL32.Access || (SBOL32.Access = {}));
          let Type;
          (function(Type2) {
            Type2.DNA = "http://www.biopax.org/release/biopax-level3.owl#DnaRegion";
            Type2.RNA = "http://www.biopax.org/release/biopax-level3.owl#RnaRegion";
            Type2.Protein = "http://www.biopax.org/release/biopax-level3.owl#Protein";
            Type2.SmallMolecule = "http://www.biopax.org/release/biopax-level3.owl#SmallMolecule";
            Type2.Complex = "http://www.biopax.org/release/biopax-level3.owl#Complex";
            Type2.Effector = "http://identifiers.org/chebi/CHEBI:35224";
            Type2.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000988";
          })(Type = SBOL32.Type || (SBOL32.Type = {}));
          let SequenceEncoding;
          (function(SequenceEncoding2) {
            SequenceEncoding2.NucleicAcid = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.RNA = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.AminoAcid = "http://www.chem.qmul.ac.uk/iupac/AminoAcid/";
          })(SequenceEncoding = SBOL32.SequenceEncoding || (SBOL32.SequenceEncoding = {}));
          let Constraint;
          (function(Constraint2) {
            Constraint2.Precedes = Prefixes_1.Prefixes.sbol3 + "precedes";
            Constraint2.OppositeOrientationAs = Prefixes_1.Prefixes.sbol3 + "oppositeOrientationAs";
          })(Constraint = SBOL32.Constraint || (SBOL32.Constraint = {}));
          let ProvRole;
          (function(ProvRole2) {
            ProvRole2.Design = Prefixes_1.Prefixes.sbol3 + "design";
            ProvRole2.Build = Prefixes_1.Prefixes.sbol3 + "build";
            ProvRole2.Test = Prefixes_1.Prefixes.sbol3 + "test";
            ProvRole2.Learn = Prefixes_1.Prefixes.sbol3 + "learn";
          })(ProvRole = SBOL32.ProvRole || (SBOL32.ProvRole = {}));
          let MapsToRefinement;
          (function(MapsToRefinement2) {
            MapsToRefinement2.UseLocal = Prefixes_1.Prefixes.sbol3 + "useLocal";
            MapsToRefinement2.UseRemote = Prefixes_1.Prefixes.sbol3 + "useRemote";
          })(MapsToRefinement = SBOL32.MapsToRefinement || (SBOL32.MapsToRefinement = {}));
        })(SBOL3 = Specifiers3.SBOL3 || (Specifiers3.SBOL3 = {}));
        let Visual;
        (function(Visual2) {
          Visual2.Blackbox = Prefixes_1.Prefixes.visual + "blackbox";
          Visual2.Whitebox = Prefixes_1.Prefixes.visual + "whitebox";
          Visual2.Float = Prefixes_1.Prefixes.visual + "float";
          Visual2.Backbone = Prefixes_1.Prefixes.visual + "backbone";
          Visual2.Forward = Prefixes_1.Prefixes.visual + "forward";
          Visual2.Reverse = Prefixes_1.Prefixes.visual + "reverse";
          Visual2.Expandable = Prefixes_1.Prefixes.visual + "expandable";
          Visual2.NotExpandable = Prefixes_1.Prefixes.visual + "notExpandable";
          Visual2.AnchorTop = Prefixes_1.Prefixes.visual + "anchorTop";
          Visual2.AnchorMid = Prefixes_1.Prefixes.visual + "anchorMid";
          Visual2.AnchorBottom = Prefixes_1.Prefixes.visual + "anchorBottom";
        })(Visual = Specifiers3.Visual || (Specifiers3.Visual = {}));
        let SO;
        (function(SO2) {
          SO2.CDS = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000316";
          SO2.Promoter = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000167";
          SO2.RBS = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000139";
          SO2.RestrictionSite = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001687";
          SO2.Terminator = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000141";
          SO2.OriginOfReplication = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000296";
          SO2.OriginOfTransfer = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000724";
          SO2.PlasmidBackbone = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000755";
          SO2.EngineeredRegion = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000804";
        })(SO = Specifiers3.SO || (Specifiers3.SO = {}));
        let SBO;
        (function(SBO2) {
          SBO2.Inhibition = Prefixes_1.Prefixes.sbo + "SBO:0000169";
          SBO2.Inhibitor = Prefixes_1.Prefixes.sbo + "SBO:0000020";
          SBO2.Inhibited = Prefixes_1.Prefixes.sbo + "SBO:0000642";
          SBO2.Stimulation = Prefixes_1.Prefixes.sbo + "SBO:0000170";
          SBO2.Stimulator = Prefixes_1.Prefixes.sbo + "SBO:0000459";
          SBO2.Stimulated = Prefixes_1.Prefixes.sbo + "SBO:0000643";
          SBO2.GeneticProduction = Prefixes_1.Prefixes.sbo + "SBO:0000589";
          SBO2.Product = Prefixes_1.Prefixes.sbo + "SBO:0000011";
          SBO2.Modifier = Prefixes_1.Prefixes.sbo + "SBO:0000019";
          SBO2.Promoter = Prefixes_1.Prefixes.sbo + "SBO:0000598";
          SBO2.Control = Prefixes_1.Prefixes.sbo + "SBO:0000168";
        })(SBO = Specifiers3.SBO || (Specifiers3.SBO = {}));
        let GO;
        (function(GO2) {
          GO2.ProteinDepolymerization = Prefixes_1.Prefixes.go + "GO:0051261";
          GO2.CovalentChromatinModification = Prefixes_1.Prefixes.go + "GO:0016569";
          GO2.ProteinProcessing = Prefixes_1.Prefixes.go + "GO:0016485";
          GO2.ProteinBinding = Prefixes_1.Prefixes.go + "GO:0005515";
          GO2.CatalyticActivity = Prefixes_1.Prefixes.go + "GO:0003824";
        })(GO = Specifiers3.GO || (Specifiers3.GO = {}));
        let SyBiOnt;
        (function(SyBiOnt2) {
          SyBiOnt2.Bidirectional = Prefixes_1.Prefixes.sybio + "Bidirectional";
          SyBiOnt2.LeftToRight = Prefixes_1.Prefixes.sybio + "LeftToRight";
          SyBiOnt2.RightToLeft = Prefixes_1.Prefixes.sybio + "RightToLeft";
          SyBiOnt2.UndefinedDirection = Prefixes_1.Prefixes.sybio + "UndefinedDirection";
          SyBiOnt2.LeftSide = Prefixes_1.Prefixes.sybio + "LeftSide";
          SyBiOnt2.RightSide = Prefixes_1.Prefixes.sybio + "RightSide";
        })(SyBiOnt = Specifiers3.SyBiOnt || (Specifiers3.SyBiOnt = {}));
      })(Specifiers2 = exports.Specifiers || (exports.Specifiers = {}));
    }
  });

  // node_modules/rdfoo-prov/node_modules/bioterms/dist/sequenceOntology.js
  var require_sequenceOntology2 = __commonJS({
    "node_modules/rdfoo-prov/node_modules/bioterms/dist/sequenceOntology.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sequenceOntology = exports.uriToName = void 0;
      function uriToName(uri) {
        let temp = uri.split("/");
        let id = temp.pop();
        let entry = sequenceOntology.so[id];
        if (!entry)
          return void 0;
        let name = entry["name"];
        return name;
      }
      exports.uriToName = uriToName;
      var sequenceOntology;
      (function(sequenceOntology2) {
        sequenceOntology2.so = {
          "SO:0000000": {
            "name": "Sequence_Ontology"
          },
          "SO:0000001": {
            "name": "region",
            "def": "A sequence_feature with an extent greater than zero. A nucleotide region is composed of bases and a polypeptide region is composed of amino acids. [SO:ke]"
          },
          "SO:0000002": {
            "name": "sequence_secondary_structure",
            "def": "A folded sequence. [SO:ke]"
          },
          "SO:0000003": {
            "name": "G_quartet",
            "def": "G-quartets are unusual nucleic acid structures consisting of a planar arrangement where each guanine is hydrogen bonded by hoogsteen pairing to another guanine in the quartet. [http://www.ncbi.nlm.nih.gov/pubmed/7919797?dopt=Abstract]"
          },
          "SO:0000004": {
            "name": "interior_coding_exon"
          },
          "SO:0000005": {
            "name": "satellite_DNA",
            "def": "The many tandem repeats (identical or related) of a short basic repeating unit; many have a base composition or other property different from the genome average that allows them to be separated from the bulk (main band) genomic DNA. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000006": {
            "name": "PCR_product",
            "def": "A region amplified by a PCR reaction. [SO:ke]"
          },
          "SO:0000007": {
            "name": "read_pair",
            "def": "One of a pair of sequencing reads in which the two members of the pair are related by originating at either end of a clone insert. [SO:ls]"
          },
          "SO:0000008": {
            "name": "gene_sensu_your_favorite_organism"
          },
          "SO:0000009": {
            "name": "gene_class"
          },
          "SO:0000010": {
            "name": "protein_coding"
          },
          "SO:0000011": {
            "name": "non_protein_coding"
          },
          "SO:0000012": {
            "name": "scRNA_primary_transcript",
            "def": "The primary transcript of any one of several small cytoplasmic RNA molecules present in the cytoplasm and sometimes nucleus of a Eukaryote. [http://www.ebi.ac.uk/embl/WebFeat/align/scRNA_s.html]"
          },
          "SO:0000013": {
            "name": "scRNA",
            "def": "A small non coding RNA sequence, present in the cytoplasm. [SO:ke]"
          },
          "SO:0000014": {
            "name": "INR_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters required for the correct positioning of the polymerase for the start of transcription. Overlaps the TSS. The mammalian consensus sequence is YYAN(T|A)YY; the Drosophila consensus sequence is TCA(G|T)t(T|C). In each the A is at position +1 with respect to the TSS. Functionally similar to the TATA box element. [PMID:12651739, PMID:16858867]"
          },
          "SO:0000015": {
            "name": "DPE_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters; Positioned from +28 to +32 with respect to the TSS (+1). Experimental results suggest that the DPE acts in conjunction with the INR_motif to provide a binding site for TFIID in the absence of a TATA box to mediate transcription of TATA-less promoters. Consensus sequence (A|G)G(A|T)(C|T)(G|A|C). [PMID:12651739:12537576, PMID:16858867]"
          },
          "SO:0000016": {
            "name": "BREu_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, located immediately upstream of some TATA box elements at -37 to -32 with respect to the TSS (+1). Consensus sequence is (G|C)(G|C)(G|A)CGCC. Binds TFIIB. [PMID:12651739, PMID:16858867]"
          },
          "SO:0000017": {
            "name": "PSE_motif",
            "def": "A sequence element characteristic of the promoters of snRNA genes transcribed by RNA polymerase II or by RNA polymerase III. Located between -45 and -60 relative to the TSS. The human PSE_motif consensus sequence is TCACCNTNA(C|G)TNAAAAG(T|G). [PMID:12651739]"
          },
          "SO:0000018": {
            "name": "linkage_group",
            "def": "A group of loci that can be grouped in a linear order representing the different degrees of linkage among the genes concerned. [ISBN:038752046]"
          },
          "SO:0000020": {
            "name": "RNA_internal_loop",
            "def": "A region of double stranded RNA where the bases do not conform to WC base pairing. The loop is closed on both sides by canonical base pairing. If the interruption to base pairing occurs on one strand only, it is known as a bulge. [SO:ke]"
          },
          "SO:0000021": {
            "name": "asymmetric_RNA_internal_loop",
            "def": "An internal RNA loop where one of the strands includes more bases than the corresponding region on the other strand. [SO:ke]"
          },
          "SO:0000022": {
            "name": "A_minor_RNA_motif",
            "def": "A region forming a motif, composed of adenines, where the minor groove edges are inserted into the minor groove of another helix. [SO:ke]"
          },
          "SO:0000023": {
            "name": "K_turn_RNA_motif",
            "def": "The kink turn (K-turn) is an RNA structural motif that creates a sharp (~120 degree) bend between two continuous helices. [SO:ke]"
          },
          "SO:0000024": {
            "name": "sarcin_like_RNA_motif",
            "def": "A loop in ribosomal RNA containing the sites of attack for ricin and sarcin. [http://www.ncbi.nlm.nih.gov/pubmed/7897662]"
          },
          "SO:0000025": {
            "name": "symmetric_RNA_internal_loop",
            "def": "An internal RNA loop where the extent of the loop on both stands is the same size. [SO:ke]"
          },
          "SO:0000026": {
            "name": "RNA_junction_loop"
          },
          "SO:0000027": {
            "name": "RNA_hook_turn"
          },
          "SO:0000028": {
            "name": "base_pair"
          },
          "SO:0000029": {
            "name": "WC_base_pair",
            "def": "The canonical base pair, where two bases interact via WC edges, with glycosidic bonds oriented cis relative to the axis of orientation. [PMID:12177293]"
          },
          "SO:0000030": {
            "name": "sugar_edge_base_pair",
            "def": "A type of non-canonical base-pairing. [PMID:12177293]"
          },
          "SO:0000031": {
            "name": "aptamer",
            "def": "DNA or RNA molecules that have been selected from random pools based on their ability to bind other molecules. [http://aptamer.icmb.utexas.edu]"
          },
          "SO:0000032": {
            "name": "DNA_aptamer",
            "def": "DNA molecules that have been selected from random pools based on their ability to bind other molecules. [http:aptamer.icmb.utexas.edu]"
          },
          "SO:0000033": {
            "name": "RNA_aptamer",
            "def": "RNA molecules that have been selected from random pools based on their ability to bind other molecules. [http://aptamer.icmb.utexas.edu]"
          },
          "SO:0000034": {
            "name": "morpholino_oligo",
            "def": "Morpholino oligos are synthesized from four different Morpholino subunits, each of which contains one of the four genetic bases (A, C, G, T) linked to a 6-membered morpholine ring. Eighteen to 25 subunits of these four subunit types are joined in a specific order by non-ionic phosphorodiamidate intersubunit linkages to give a Morpholino. [http://www.gene-tools.com/]"
          },
          "SO:0000035": {
            "name": "riboswitch",
            "def": "A riboswitch is a part of an mRNA that can act as a direct sensor of small molecules to control their own expression. A riboswitch is a cis element in the 5' end of an mRNA, that acts as a direct sensor of metabolites. [PMID:2820954]"
          },
          "SO:0000036": {
            "name": "matrix_attachment_site",
            "def": "A DNA region that is required for the binding of chromatin to the nuclear matrix. [SO:ma]"
          },
          "SO:0000037": {
            "name": "locus_control_region",
            "def": "A DNA region that includes DNAse hypersensitive sites located 5' to a gene that confers the high-level, position-independent, and copy number-dependent expression to that gene. [SO:ma]"
          },
          "SO:0000038": {
            "name": "match_set",
            "def": "A collection of match parts. [SO:ke]"
          },
          "SO:0000039": {
            "name": "match_part",
            "def": "A part of a match, for example an hsp from blast is a match_part. [SO:ke]"
          },
          "SO:0000040": {
            "name": "genomic_clone",
            "def": "A clone of a DNA region of a genome. [SO:ma]"
          },
          "SO:0000041": {
            "name": "sequence_operation",
            "def": "An operation that can be applied to a sequence, that results in a change. [SO:ke]"
          },
          "SO:0000042": {
            "name": "pseudogene_attribute",
            "def": "An attribute of a pseudogene (SO:0000336). [SO:ma]"
          },
          "SO:0000043": {
            "name": "processed_pseudogene",
            "def": "A pseudogene where by an mRNA was retrotransposed. The mRNA sequence is transcribed back into the genome, lacking introns and promoters, but often including a polyA tail. [SO:xp]"
          },
          "SO:0000044": {
            "name": "pseudogene_by_unequal_crossing_over",
            "def": "A pseudogene caused by unequal crossing over at recombination. [SO:ke]"
          },
          "SO:0000045": {
            "name": "delete",
            "def": "To remove a subsection of sequence. [SO:ke]"
          },
          "SO:0000046": {
            "name": "insert",
            "def": "To insert a subsection of sequence. [SO:ke]"
          },
          "SO:0000047": {
            "name": "invert",
            "def": "To invert a subsection of sequence. [SO:ke]"
          },
          "SO:0000048": {
            "name": "substitute",
            "def": "To substitute a subsection of sequence for another. [SO:ke]"
          },
          "SO:0000049": {
            "name": "translocate",
            "def": "To translocate a subsection of sequence. [SO:ke]"
          },
          "SO:0000050": {
            "name": "gene_part",
            "def": "A part of a gene, that has no other route in the ontology back to region. This concept is necessary for logical inference as these parts must have the properties of region. It also allows us to associate all the parts of genes with a gene. [SO:ke]"
          },
          "SO:0000051": {
            "name": "probe",
            "def": "A DNA sequence used experimentally to detect the presence or absence of a complementary nucleic acid. [SO:ma]"
          },
          "SO:0000052": {
            "name": "assortment_derived_deficiency"
          },
          "SO:0000053": {
            "name": "sequence_variant_affecting_regulatory_region",
            "def": "A sequence_variant_effect which changes the regulatory region of a gene. [SO:ke]"
          },
          "SO:0000054": {
            "name": "aneuploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number. [SO:ke]"
          },
          "SO:0000055": {
            "name": "hyperploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number as extra chromosomes are present. [SO:ke]"
          },
          "SO:0000056": {
            "name": "hypoploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number as some chromosomes are missing. [SO:ke]"
          },
          "SO:0000057": {
            "name": "operator",
            "def": "A regulatory element of an operon to which activators or repressors bind thereby effecting translation of genes in that operon. [SO:ma]"
          },
          "SO:0000058": {
            "name": "assortment_derived_aneuploid"
          },
          "SO:0000059": {
            "name": "nuclease_binding_site",
            "def": "A binding site that, of a nucleotide molecule, that interacts selectively and non-covalently with polypeptide residues of a nuclease. [SO:cb]"
          },
          "SO:0000060": {
            "name": "compound_chromosome_arm"
          },
          "SO:0000061": {
            "name": "restriction_enzyme_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues of a restriction enzyme. [SO:cb]"
          },
          "SO:0000062": {
            "name": "deficient_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby a translocation in which one of the four broken ends loses a segment before re-joining. [FB:reference_manual]"
          },
          "SO:0000063": {
            "name": "deficient_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a translocation in which one of the four broken ends loses a segment before re-joining. [SO:ke]"
          },
          "SO:0000064": {
            "name": "gene_by_transcript_attribute"
          },
          "SO:0000065": {
            "name": "free_chromosome_arm",
            "def": "A chromosome structure variation whereby an arm exists as an individual chromosome element. [SO:ke]"
          },
          "SO:0000066": {
            "name": "gene_by_polyadenylation_attribute"
          },
          "SO:0000067": {
            "name": "gene_to_gene_feature"
          },
          "SO:0000068": {
            "name": "overlapping",
            "def": "An attribute describing a gene that has a sequence that overlaps the sequence of another gene. [SO:ke]"
          },
          "SO:0000069": {
            "name": "inside_intron",
            "def": "An attribute to describe a gene when it is located within the intron of another gene. [SO:ke]"
          },
          "SO:0000070": {
            "name": "inside_intron_antiparallel",
            "def": "An attribute to describe a gene when it is located within the intron of another gene and on the opposite strand. [SO:ke]"
          },
          "SO:0000071": {
            "name": "inside_intron_parallel",
            "def": "An attribute to describe a gene when it is located within the intron of another gene and on the same strand. [SO:ke]"
          },
          "SO:0000072": {
            "name": "end_overlapping_gene"
          },
          "SO:0000073": {
            "name": "five_prime_three_prime_overlap",
            "def": "An attribute to describe a gene when the five prime region overlaps with another gene's 3' region. [SO:ke]"
          },
          "SO:0000074": {
            "name": "five_prime_five_prime_overlap",
            "def": "An attribute to describe a gene when the five prime region overlaps with another gene's five prime region. [SO:ke]"
          },
          "SO:0000075": {
            "name": "three_prime_three_prime_overlap",
            "def": "An attribute to describe a gene when the 3' region overlaps with another gene's 3' region. [SO:ke]"
          },
          "SO:0000076": {
            "name": "three_prime_five_prime_overlap",
            "def": "An attribute to describe a gene when the 3' region overlaps with another gene's 5' region. [SO:ke]"
          },
          "SO:0000077": {
            "name": "antisense",
            "def": "A region sequence that is complementary to a sequence of messenger RNA. [SO:ke]"
          },
          "SO:0000078": {
            "name": "polycistronic_transcript",
            "def": "A transcript that is polycistronic. [SO:xp]"
          },
          "SO:0000079": {
            "name": "dicistronic_transcript",
            "def": "A transcript that is dicistronic. [SO:ke]"
          },
          "SO:0000080": {
            "name": "operon_member"
          },
          "SO:0000081": {
            "name": "gene_array_member"
          },
          "SO:0000082": {
            "name": "processed_transcript_attribute"
          },
          "SO:0000083": {
            "name": "macronuclear_sequence"
          },
          "SO:0000084": {
            "name": "micronuclear_sequence"
          },
          "SO:0000085": {
            "name": "gene_by_genome_location"
          },
          "SO:0000086": {
            "name": "gene_by_organelle_of_genome"
          },
          "SO:0000087": {
            "name": "nuclear_gene",
            "def": "A gene from nuclear sequence. [SO:xp]"
          },
          "SO:0000088": {
            "name": "mt_gene",
            "def": "A gene located in mitochondrial sequence. [SO:xp]"
          },
          "SO:0000089": {
            "name": "kinetoplast_gene",
            "def": "A gene located in kinetoplast sequence. [SO:xp]"
          },
          "SO:0000090": {
            "name": "plastid_gene",
            "def": "A gene from plastid sequence. [SO:xp]"
          },
          "SO:0000091": {
            "name": "apicoplast_gene",
            "def": "A gene from apicoplast sequence. [SO:xp]"
          },
          "SO:0000092": {
            "name": "ct_gene",
            "def": "A gene from chloroplast sequence. [SO:xp]"
          },
          "SO:0000093": {
            "name": "chromoplast_gene",
            "def": "A gene from chromoplast_sequence. [SO:xp]"
          },
          "SO:0000094": {
            "name": "cyanelle_gene",
            "def": "A gene from cyanelle sequence. [SO:xp]"
          },
          "SO:0000095": {
            "name": "leucoplast_gene",
            "def": "A plastid gene from leucoplast sequence. [SO:xp]"
          },
          "SO:0000096": {
            "name": "proplastid_gene",
            "def": "A gene from proplastid sequence. [SO:ke]"
          },
          "SO:0000097": {
            "name": "nucleomorph_gene",
            "def": "A gene from nucleomorph sequence. [SO:xp]"
          },
          "SO:0000098": {
            "name": "plasmid_gene",
            "def": "A gene from plasmid sequence. [SO:xp]"
          },
          "SO:0000099": {
            "name": "proviral_gene",
            "def": "A gene from proviral sequence. [SO:xp]"
          },
          "SO:0000100": {
            "name": "endogenous_retroviral_gene",
            "def": "A proviral gene with origin endogenous retrovirus. [SO:xp]"
          },
          "SO:0000101": {
            "name": "transposable_element",
            "def": "A transposon or insertion sequence. An element that can insert in a variety of DNA sequences. [http://www.sci.sdsu.edu/~smaloy/Glossary/T.html]"
          },
          "SO:0000102": {
            "name": "expressed_sequence_match",
            "def": "A match to an EST or cDNA sequence. [SO:ke]"
          },
          "SO:0000103": {
            "name": "clone_insert_end",
            "def": "The end of the clone insert. [SO:ke]"
          },
          "SO:0000104": {
            "name": "polypeptide",
            "def": "A sequence of amino acids linked by peptide bonds which may lack appreciable tertiary structure and may not be liable to irreversible denaturation. [SO:ma]"
          },
          "SO:0000105": {
            "name": "chromosome_arm",
            "def": "A region of the chromosome between the centromere and the telomere. Human chromosomes have two arms, the p arm (short) and the q arm (long) which are separated from each other by the centromere. [http://www.medterms.com/script/main/art.asp?articlekey=5152]"
          },
          "SO:0000106": {
            "name": "non_capped_primary_transcript"
          },
          "SO:0000107": {
            "name": "sequencing_primer"
          },
          "SO:0000108": {
            "name": "mRNA_with_frameshift",
            "def": "An mRNA with a frameshift. [SO:xp]"
          },
          "SO:0000109": {
            "name": "sequence_variant_obs",
            "def": "A sequence_variant is a non exact copy of a sequence_feature or genome exhibiting one or more sequence_alteration. [SO:ke]"
          },
          "SO:0000110": {
            "name": "sequence_feature",
            "def": "Any extent of continuous biological sequence. [LAMHDI:mb, SO:ke]"
          },
          "SO:0000111": {
            "name": "transposable_element_gene",
            "def": "A gene encoded within a transposable element. For example gag, int, env and pol are the transposable element genes of the TY element in yeast. [SO:ke]"
          },
          "SO:0000112": {
            "name": "primer",
            "def": "An oligo to which new deoxyribonucleotides can be added by DNA polymerase. [SO:ke]"
          },
          "SO:0000113": {
            "name": "proviral_region",
            "def": "A viral sequence which has integrated into a host genome. [SO:ke]"
          },
          "SO:0000114": {
            "name": "methylated_cytosine",
            "def": "A methylated deoxy-cytosine. [SO:ke]"
          },
          "SO:0000115": {
            "name": "transcript_feature"
          },
          "SO:0000116": {
            "name": "edited",
            "def": "An attribute describing a sequence that is modified by editing. [SO:ke]"
          },
          "SO:0000117": {
            "name": "transcript_with_readthrough_stop_codon"
          },
          "SO:0000118": {
            "name": "transcript_with_translational_frameshift",
            "def": "A transcript with a translational frameshift. [SO:xp]"
          },
          "SO:0000119": {
            "name": "regulated",
            "def": "An attribute to describe a sequence that is regulated. [SO:ke]"
          },
          "SO:0000120": {
            "name": "protein_coding_primary_transcript",
            "def": "A primary transcript that, at least in part, encodes one or more proteins. [SO:ke]"
          },
          "SO:0000121": {
            "name": "forward_primer",
            "def": "A single stranded oligo used for polymerase chain reaction. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
          },
          "SO:0000122": {
            "name": "RNA_sequence_secondary_structure",
            "def": "A folded RNA sequence. [SO:ke]"
          },
          "SO:0000123": {
            "name": "transcriptionally_regulated",
            "def": "An attribute describing a gene that is regulated at transcription. [SO:ma]"
          },
          "SO:0000124": {
            "name": "transcriptionally_constitutive",
            "def": "Expressed in relatively constant amounts without regard to cellular environmental conditions such as the concentration of a particular substrate. [SO:ke]"
          },
          "SO:0000125": {
            "name": "transcriptionally_induced",
            "def": "An inducer molecule is required for transcription to occur. [SO:ke]"
          },
          "SO:0000126": {
            "name": "transcriptionally_repressed",
            "def": "A repressor molecule is required for transcription to stop. [SO:ke]"
          },
          "SO:0000127": {
            "name": "silenced_gene",
            "def": "A gene that is silenced. [SO:xp]"
          },
          "SO:0000128": {
            "name": "gene_silenced_by_DNA_modification",
            "def": "A gene that is silenced by DNA modification. [SO:xp]"
          },
          "SO:0000129": {
            "name": "gene_silenced_by_DNA_methylation",
            "def": "A gene that is silenced by DNA methylation. [SO:xp]"
          },
          "SO:0000130": {
            "name": "post_translationally_regulated",
            "def": "An attribute describing a gene that is regulated after it has been translated. [SO:ke]"
          },
          "SO:0000131": {
            "name": "translationally_regulated",
            "def": "An attribute describing a gene that is regulated as it is translated. [SO:ke]"
          },
          "SO:0000132": {
            "name": "reverse_primer",
            "def": "A single stranded oligo used for polymerase chain reaction. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
          },
          "SO:0000133": {
            "name": "epigenetically_modified",
            "def": "This attribute describes a gene where heritable changes other than those in the DNA sequence occur. These changes include: modification to the DNA (such as DNA methylation, the covalent modification of cytosine), and post-translational modification of histones. [SO:ke]"
          },
          "SO:0000134": {
            "name": "genomically_imprinted",
            "def": "Imprinted genes are epigenetically modified genes that are expressed monoallelically according to their parent of origin. [SO:ke]"
          },
          "SO:0000135": {
            "name": "maternally_imprinted",
            "def": "The maternal copy of the gene is modified, rendering it transcriptionally silent. [SO:ke]"
          },
          "SO:0000136": {
            "name": "paternally_imprinted",
            "def": "The paternal copy of the gene is modified, rendering it transcriptionally silent. [SO:ke]"
          },
          "SO:0000137": {
            "name": "allelically_excluded",
            "def": "Allelic exclusion is a process occurring in diploid organisms, where a gene is inactivated and not expressed in that cell. [SO:ke]"
          },
          "SO:0000138": {
            "name": "gene_rearranged_at_DNA_level",
            "def": "An epigenetically modified gene, rearranged at the DNA level. [SO:xp]"
          },
          "SO:0000139": {
            "name": "ribosome_entry_site",
            "def": "Region in mRNA where ribosome assembles. [SO:ke]"
          },
          "SO:0000140": {
            "name": "attenuator",
            "def": "A sequence segment located within the five prime end of an mRNA that causes premature termination of translation. [SO:as]"
          },
          "SO:0000141": {
            "name": "terminator",
            "def": "The sequence of DNA located either at the end of the transcript that causes RNA polymerase to terminate transcription. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000142": {
            "name": "DNA_sequence_secondary_structure",
            "def": "A folded DNA sequence. [SO:ke]"
          },
          "SO:0000143": {
            "name": "assembly_component",
            "def": "A region of known length which may be used to manufacture a longer region. [SO:ke]"
          },
          "SO:0000144": {
            "name": "primary_transcript_attribute"
          },
          "SO:0000145": {
            "name": "recoded_codon",
            "def": "A codon that has been redefined at translation. The redefinition may be as a result of translational bypass, translational frameshifting or stop codon readthrough. [SO:xp]"
          },
          "SO:0000146": {
            "name": "capped",
            "def": "An attribute describing when a sequence, usually an mRNA is capped by the addition of a modified guanine nucleotide at the 5' end. [SO:ke]"
          },
          "SO:0000147": {
            "name": "exon",
            "def": "A region of the transcript sequence within a gene which is not removed from the primary RNA transcript by RNA splicing. [SO:ke]"
          },
          "SO:0000148": {
            "name": "supercontig",
            "def": "One or more contigs that have been ordered and oriented using end-read information. Contains gaps that are filled with N's. [SO:ls]"
          },
          "SO:0000149": {
            "name": "contig",
            "def": "A contiguous sequence derived from sequence assembly. Has no gaps, but may contain N's from unavailable bases. [SO:ls]"
          },
          "SO:0000150": {
            "name": "read",
            "def": "A sequence obtained from a single sequencing experiment. Typically a read is produced when a base calling program interprets information from a chromatogram trace file produced from a sequencing machine. [SO:rd]"
          },
          "SO:0000151": {
            "name": "clone",
            "def": "A piece of DNA that has been inserted in a vector so that it can be propagated in a host bacterium or some other organism. [SO:ke]"
          },
          "SO:0000152": {
            "name": "YAC",
            "def": "Yeast Artificial Chromosome, a vector constructed from the telomeric, centromeric, and replication origin sequences needed for replication in yeast cells. [SO:ma]"
          },
          "SO:0000153": {
            "name": "BAC",
            "def": "Bacterial Artificial Chromosome, a cloning vector that can be propagated as mini-chromosomes in a bacterial host. [SO:ma]"
          },
          "SO:0000154": {
            "name": "PAC",
            "def": "The P1-derived artificial chromosome are DNA constructs that are derived from the DNA of P1 bacteriophage. They can carry large amounts (about 100-300 kilobases) of other sequences for a variety of bioengineering purposes. It is one type of vector used to clone DNA fragments (100- to 300-kb insert size; average, 150 kb) in Escherichia coli cells. [http://en.wikipedia.org/wiki/P1-derived_artificial_chromosome]"
          },
          "SO:0000155": {
            "name": "plasmid",
            "def": "A self replicating, using the hosts cellular machinery, often circular nucleic acid molecule that is distinct from a chromosome in the organism. [SO:ma]"
          },
          "SO:0000156": {
            "name": "cosmid",
            "def": "A cloning vector that is a hybrid of lambda phages and a plasmid that can be propagated as a plasmid or packaged as a phage,since they retain the lambda cos sites. [SO:ma]"
          },
          "SO:0000157": {
            "name": "phagemid",
            "def": "A plasmid which carries within its sequence a bacteriophage replication origin. When the host bacterium is infected with \\helper\\ phage, a phagemid is replicated along with the phage DNA and packaged into phage capsids. [SO:ma]"
          },
          "SO:0000158": {
            "name": "fosmid",
            "def": "A cloning vector that utilizes the E. coli F factor. [SO:ma]"
          },
          "SO:0000159": {
            "name": "deletion",
            "def": "The point at which one or more contiguous nucleotides were excised. [SO:ke]"
          },
          "SO:0000160": {
            "name": "lambda_clone",
            "def": "A linear clone derived from lambda bacteriophage. The genes involved in the lysogenic pathway are removed from the from the viral DNA. Up to 25 kb of foreign DNA can then be inserted into the lambda genome. [ISBN:0-1767-2380-8]"
          },
          "SO:0000161": {
            "name": "methylated_adenine",
            "def": "A modified  base in which adenine has been methylated. [SO:ke]"
          },
          "SO:0000162": {
            "name": "splice_site",
            "def": "Consensus region of primary transcript bordering junction of splicing. A region that overlaps exactly 2 base and adjacent_to splice_junction. [SO:cjm, SO:ke]"
          },
          "SO:0000163": {
            "name": "five_prime_cis_splice_site",
            "def": "Intronic 2 bp region bordering the exon, at the 5' edge of the intron. A splice_site that is downstream_adjacent_to exon and starts intron. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html, SO:cjm, SO:ke]"
          },
          "SO:0000164": {
            "name": "three_prime_cis_splice_site",
            "def": "Intronic 2 bp region bordering the exon, at the 3' edge of the intron. A splice_site that is upstream_adjacent_to exon and finishes intron. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html, SO:cjm, SO:ke]"
          },
          "SO:0000165": {
            "name": "enhancer",
            "def": "A cis-acting sequence that increases the utilization of (some) eukaryotic promoters, and can function in either orientation and in any location (upstream or downstream) relative to the promoter. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000166": {
            "name": "enhancer_bound_by_factor",
            "def": "An enhancer bound by a factor. [SO:xp]"
          },
          "SO:0000167": {
            "name": "promoter",
            "def": "A regulatory_region composed of the TSS(s) and binding sites for TF_complexes of the basal transcription machinery. [SO:regcreative]"
          },
          "SO:0000168": {
            "name": "restriction_enzyme_cut_site",
            "def": "A specific nucleotide sequence of DNA at or near which a particular restriction enzyme cuts the DNA. [SO:ma]"
          },
          "SO:0000169": {
            "name": "RNApol_I_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase I binds, to begin transcription. [SO:ke]"
          },
          "SO:0000170": {
            "name": "RNApol_II_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase II binds, to begin transcription. [SO:ke]"
          },
          "SO:0000171": {
            "name": "RNApol_III_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase III binds, to begin transcription. [SO:ke]"
          },
          "SO:0000172": {
            "name": "CAAT_signal",
            "def": "Part of a conserved sequence located about 75-bp upstream of the start point of eukaryotic transcription units which may be involved in RNA polymerase binding; consensus=GG(C|T)CAATCT. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000173": {
            "name": "GC_rich_promoter_region",
            "def": "A conserved GC-rich region located upstream of the start point of eukaryotic transcription units which may occur in multiple copies or in either orientation; consensus=GGGCGG. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000174": {
            "name": "TATA_box",
            "def": "A conserved AT-rich septamer found about 25-bp before the start point of many eukaryotic RNA polymerase II transcript units; may be involved in positioning the enzyme for correct initiation; consensus=TATA(A|T)A(A|T). [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, PMID:16858867]"
          },
          "SO:0000175": {
            "name": "minus_10_signal",
            "def": "A conserved region about 10-bp upstream of the start point of bacterial transcription units which may be involved in binding RNA polymerase; consensus=TAtAaT. This region is associated with sigma factor 70. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000176": {
            "name": "minus_35_signal",
            "def": "A conserved hexamer about 35-bp upstream of the start point of bacterial transcription units; consensus=TTGACa or TGTTGACA. This region is associated with sigma factor 70. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000177": {
            "name": "cross_genome_match",
            "def": "A nucleotide match against a sequence from another organism. [SO:ma]"
          },
          "SO:0000178": {
            "name": "operon",
            "def": "A group of contiguous genes transcribed as a single (polycistronic) mRNA from a single regulatory region. [SO:ma]"
          },
          "SO:0000179": {
            "name": "clone_insert_start",
            "def": "The start of the clone insert. [SO:ke]"
          },
          "SO:0000180": {
            "name": "retrotransposon",
            "def": "A transposable element that is incorporated into a chromosome by a mechanism that requires reverse transcriptase. [http://www.dddmag.com/Glossary.aspx#r]"
          },
          "SO:0000181": {
            "name": "translated_nucleotide_match",
            "def": "A match against a translated sequence. [SO:ke]"
          },
          "SO:0000182": {
            "name": "DNA_transposon",
            "def": "A transposon where the mechanism of transposition is via a DNA intermediate. [SO:ke]"
          },
          "SO:0000183": {
            "name": "non_transcribed_region",
            "def": "A region of the gene which is not transcribed. [SO:ke]"
          },
          "SO:0000184": {
            "name": "U2_intron",
            "def": "A major type of spliceosomal intron spliced by the U2 spliceosome, that includes U1, U2, U4/U6 and U5 snRNAs. [PMID:9428511]"
          },
          "SO:0000185": {
            "name": "primary_transcript",
            "def": "A transcript that in its initial state requires modification to be functional. [SO:ma]"
          },
          "SO:0000186": {
            "name": "LTR_retrotransposon",
            "def": "A retrotransposon flanked by long terminal repeat sequences. [SO:ke]"
          },
          "SO:0000187": {
            "name": "repeat_family",
            "def": "A group of characterized repeat sequences. [SO:ke]"
          },
          "SO:0000188": {
            "name": "intron",
            "def": "A region of a primary transcript that is transcribed, but removed from within the transcript by splicing together the sequences (exons) on either side of it. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000189": {
            "name": "non_LTR_retrotransposon",
            "def": "A retrotransposon without long terminal repeat sequences. [SO:ke]"
          },
          "SO:0000190": {
            "name": "five_prime_intron"
          },
          "SO:0000191": {
            "name": "interior_intron"
          },
          "SO:0000192": {
            "name": "three_prime_intron"
          },
          "SO:0000193": {
            "name": "RFLP_fragment",
            "def": "A DNA fragment used as a reagent to detect the polymorphic genomic loci by hybridizing against the genomic DNA digested with a given restriction enzyme. [GOC:pj]"
          },
          "SO:0000194": {
            "name": "LINE_element",
            "def": "A dispersed repeat family with many copies, each from 1 to 6 kb long. New elements are generated by retroposition of a transcribed copy. Typically the LINE contains 2 ORF's one of which is reverse transcriptase, and 3'and 5' direct repeats. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html]"
          },
          "SO:0000195": {
            "name": "coding_exon",
            "def": "An exon whereby at least one base is part of a codon (here, 'codon' is inclusive of the stop_codon). [SO:ke]"
          },
          "SO:0000196": {
            "name": "five_prime_coding_exon_coding_region",
            "def": "The sequence of the five_prime_coding_exon that codes for protein. [SO:cjm]"
          },
          "SO:0000197": {
            "name": "three_prime_coding_exon_coding_region",
            "def": "The sequence of the three_prime_coding_exon that codes for protein. [SO:cjm]"
          },
          "SO:0000198": {
            "name": "noncoding_exon",
            "def": "An exon that does not contain any codons. [SO:ke]"
          },
          "SO:0000199": {
            "name": "translocation",
            "def": "A region of nucleotide sequence that has translocated to a new position. The observed adjacency of two previously separated regions. [NCBI:th, SO:ke]"
          },
          "SO:0000200": {
            "name": "five_prime_coding_exon",
            "def": "The 5' most coding exon. [SO:ke]"
          },
          "SO:0000201": {
            "name": "interior_exon",
            "def": "An exon that is bounded by 5' and 3' splice sites. [PMID:10373547]"
          },
          "SO:0000202": {
            "name": "three_prime_coding_exon",
            "def": "The coding exon that is most 3-prime on a given transcript. [SO:ma]"
          },
          "SO:0000203": {
            "name": "UTR",
            "def": "Messenger RNA sequences that are untranslated and lie five prime or three prime to sequences which are translated. [SO:ke]"
          },
          "SO:0000204": {
            "name": "five_prime_UTR",
            "def": "A region at the 5' end of a mature transcript (preceding the initiation codon) that is not translated into a protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000205": {
            "name": "three_prime_UTR",
            "def": "A region at the 3' end of a mature transcript (following the stop codon) that is not translated into a protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000206": {
            "name": "SINE_element",
            "def": "A repetitive element, a few hundred base pairs long, that is dispersed throughout the genome. A common human SINE is the Alu element. [SO:ke]"
          },
          "SO:0000207": {
            "name": "simple_sequence_length_variation"
          },
          "SO:0000208": {
            "name": "terminal_inverted_repeat_element",
            "def": "A DNA transposable element defined as having termini with perfect, or nearly perfect short inverted repeats, generally 10 - 40 nucleotides long. [http://www.genetics.org/cgi/reprint/156/4/1983.pdf]"
          },
          "SO:0000209": {
            "name": "rRNA_primary_transcript",
            "def": "A primary transcript encoding a ribosomal RNA. [SO:ke]"
          },
          "SO:0000210": {
            "name": "tRNA_primary_transcript",
            "def": "A primary transcript encoding a transfer RNA (SO:0000253). [SO:ke]"
          },
          "SO:0000211": {
            "name": "alanine_tRNA_primary_transcript",
            "def": "A primary transcript encoding alanyl tRNA. [SO:ke]"
          },
          "SO:0000212": {
            "name": "arginine_tRNA_primary_transcript",
            "def": "A primary transcript encoding arginyl tRNA (SO:0000255). [SO:ke]"
          },
          "SO:0000213": {
            "name": "asparagine_tRNA_primary_transcript",
            "def": "A primary transcript encoding asparaginyl tRNA (SO:0000256). [SO:ke]"
          },
          "SO:0000214": {
            "name": "aspartic_acid_tRNA_primary_transcript",
            "def": "A primary transcript encoding aspartyl tRNA (SO:0000257). [SO:ke]"
          },
          "SO:0000215": {
            "name": "cysteine_tRNA_primary_transcript",
            "def": "A primary transcript encoding cysteinyl tRNA (SO:0000258). [SO:ke]"
          },
          "SO:0000216": {
            "name": "glutamic_acid_tRNA_primary_transcript",
            "def": "A primary transcript encoding glutaminyl tRNA (SO:0000260). [SO:ke]"
          },
          "SO:0000217": {
            "name": "glutamine_tRNA_primary_transcript",
            "def": "A primary transcript encoding glutamyl tRNA (SO:0000260). [SO:ke]"
          },
          "SO:0000218": {
            "name": "glycine_tRNA_primary_transcript",
            "def": "A primary transcript encoding glycyl tRNA (SO:0000263). [SO:ke]"
          },
          "SO:0000219": {
            "name": "histidine_tRNA_primary_transcript",
            "def": "A primary transcript encoding histidyl tRNA (SO:0000262). [SO:ke]"
          },
          "SO:0000220": {
            "name": "isoleucine_tRNA_primary_transcript",
            "def": "A primary transcript encoding isoleucyl tRNA (SO:0000263). [SO:ke]"
          },
          "SO:0000221": {
            "name": "leucine_tRNA_primary_transcript",
            "def": "A primary transcript encoding leucyl tRNA (SO:0000264). [SO:ke]"
          },
          "SO:0000222": {
            "name": "lysine_tRNA_primary_transcript",
            "def": "A primary transcript encoding lysyl tRNA (SO:0000265). [SO:ke]"
          },
          "SO:0000223": {
            "name": "methionine_tRNA_primary_transcript",
            "def": "A primary transcript encoding methionyl tRNA (SO:0000266). [SO:ke]"
          },
          "SO:0000224": {
            "name": "phenylalanine_tRNA_primary_transcript",
            "def": "A primary transcript encoding phenylalanyl tRNA (SO:0000267). [SO:ke]"
          },
          "SO:0000225": {
            "name": "proline_tRNA_primary_transcript",
            "def": "A primary transcript encoding prolyl tRNA (SO:0000268). [SO:ke]"
          },
          "SO:0000226": {
            "name": "serine_tRNA_primary_transcript",
            "def": "A primary transcript encoding seryl tRNA (SO:000269). [SO:ke]"
          },
          "SO:0000227": {
            "name": "threonine_tRNA_primary_transcript",
            "def": "A primary transcript encoding threonyl tRNA (SO:000270). [SO:ke]"
          },
          "SO:0000228": {
            "name": "tryptophan_tRNA_primary_transcript",
            "def": "A primary transcript encoding tryptophanyl tRNA (SO:000271). [SO:ke]"
          },
          "SO:0000229": {
            "name": "tyrosine_tRNA_primary_transcript",
            "def": "A primary transcript encoding tyrosyl tRNA (SO:000272). [SO:ke]"
          },
          "SO:0000230": {
            "name": "valine_tRNA_primary_transcript",
            "def": "A primary transcript encoding valyl tRNA (SO:000273). [SO:ke]"
          },
          "SO:0000231": {
            "name": "snRNA_primary_transcript",
            "def": "A primary transcript encoding a small nuclear RNA (SO:0000274). [SO:ke]"
          },
          "SO:0000232": {
            "name": "snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar mRNA (SO:0000275). [SO:ke]"
          },
          "SO:0000233": {
            "name": "mature_transcript",
            "def": "A transcript which has undergone the necessary modifications, if any, for its function. In eukaryotes this includes, for example, processing of introns, cleavage, base modification, and modifications to the 5' and/or the 3' ends, other than addition of bases. In bacteria functional mRNAs are usually not modified. [SO:ke]"
          },
          "SO:0000234": {
            "name": "mRNA",
            "def": "Messenger RNA is the intermediate molecule between DNA and protein. It includes UTR and coding sequences. It does not contain introns. [SO:ma]"
          },
          "SO:0000235": {
            "name": "TF_binding_site",
            "def": "A region of a nucleotide molecule that binds a Transcription Factor or Transcription Factor complex [GO:0005667]. [SO:ke]"
          },
          "SO:0000236": {
            "name": "ORF",
            "def": "The in-frame interval between the stop codons of a reading frame which when read as sequential triplets, has the potential of encoding a sequential string of amino acids. TER(NNN)nTER. [SGD:rb, SO:ma]"
          },
          "SO:0000237": {
            "name": "transcript_attribute"
          },
          "SO:0000238": {
            "name": "foldback_element",
            "def": "A transposable element with extensive secondary structure, characterized by large modular imperfect long inverted repeats. [http://www.genetics.org/cgi/reprint/156/4/1983.pdf]"
          },
          "SO:0000239": {
            "name": "flanking_region",
            "def": "The sequences extending on either side of a specific region. [SO:ke]"
          },
          "SO:0000240": {
            "name": "chromosome_variation"
          },
          "SO:0000241": {
            "name": "internal_UTR",
            "def": "A UTR bordered by the terminal and initial codons of two CDSs in a polycistronic transcript. Every UTR is either 5', 3' or internal. [SO:cjm]"
          },
          "SO:0000242": {
            "name": "untranslated_region_polycistronic_mRNA",
            "def": "The untranslated sequence separating the 'cistrons' of multicistronic mRNA. [SO:ke]"
          },
          "SO:0000243": {
            "name": "internal_ribosome_entry_site",
            "def": "Sequence element that recruits a ribosomal subunit to internal mRNA for translation initiation. [SO:ke]"
          },
          "SO:0000244": {
            "name": "four_cutter_restriction_site"
          },
          "SO:0000245": {
            "name": "mRNA_by_polyadenylation_status"
          },
          "SO:0000246": {
            "name": "polyadenylated",
            "def": "A attribute describing the addition of a poly A tail to the 3' end of a mRNA molecule. [SO:ke]"
          },
          "SO:0000247": {
            "name": "mRNA_not_polyadenylated"
          },
          "SO:0000248": {
            "name": "sequence_length_variation"
          },
          "SO:0000249": {
            "name": "six_cutter_restriction_site"
          },
          "SO:0000250": {
            "name": "modified_RNA_base_feature",
            "def": "A post_transcriptionally modified base. [SO:ke]"
          },
          "SO:0000251": {
            "name": "eight_cutter_restriction_site"
          },
          "SO:0000252": {
            "name": "rRNA",
            "def": "RNA that comprises part of a ribosome, and that can provide both structural scaffolding and catalytic activity. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, ISBN:0198506732]"
          },
          "SO:0000253": {
            "name": "tRNA",
            "def": "Transfer RNA (tRNA) molecules are approximately 80 nucleotides in length. Their secondary structure includes four short double-helical elements and three loops (D, anti-codon, and T loops). Further hydrogen bonds mediate the characteristic L-shaped molecular structure. Transfer RNAs have two regions of fundamental functional importance: the anti-codon, which is responsible for specific mRNA codon recognition, and the 3' end, to which the tRNA's corresponding amino acid is attached (by aminoacyl-tRNA synthetases). Transfer RNAs cope with the degeneracy of the genetic code in two manners: having more than one tRNA (with a specific anti-codon) for a particular amino acid; and 'wobble' base-pairing, i.e. permitting non-standard base-pairing at the 3rd anti-codon position. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00005, ISBN:0198506732]"
          },
          "SO:0000254": {
            "name": "alanyl_tRNA",
            "def": "A tRNA sequence that has an alanine anticodon, and a 3' alanine binding region. [SO:ke]"
          },
          "SO:0000255": {
            "name": "rRNA_small_subunit_primary_transcript",
            "def": "A primary transcript encoding a small ribosomal subunit RNA. [SO:ke]"
          },
          "SO:0000256": {
            "name": "asparaginyl_tRNA",
            "def": "A tRNA sequence that has an asparagine anticodon, and a 3' asparagine binding region. [SO:ke]"
          },
          "SO:0000257": {
            "name": "aspartyl_tRNA",
            "def": "A tRNA sequence that has an aspartic acid anticodon, and a 3' aspartic acid binding region. [SO:ke]"
          },
          "SO:0000258": {
            "name": "cysteinyl_tRNA",
            "def": "A tRNA sequence that has a cysteine anticodon, and a 3' cysteine binding region. [SO:ke]"
          },
          "SO:0000259": {
            "name": "glutaminyl_tRNA",
            "def": "A tRNA sequence that has a glutamine anticodon, and a 3' glutamine binding region. [SO:ke]"
          },
          "SO:0000260": {
            "name": "glutamyl_tRNA",
            "def": "A tRNA sequence that has a glutamic acid anticodon, and a 3' glutamic acid binding region. [SO:ke]"
          },
          "SO:0000261": {
            "name": "glycyl_tRNA",
            "def": "A tRNA sequence that has a glycine anticodon, and a 3' glycine binding region. [SO:ke]"
          },
          "SO:0000262": {
            "name": "histidyl_tRNA",
            "def": "A tRNA sequence that has a histidine anticodon, and a 3' histidine binding region. [SO:ke]"
          },
          "SO:0000263": {
            "name": "isoleucyl_tRNA",
            "def": "A tRNA sequence that has an isoleucine anticodon, and a 3' isoleucine binding region. [SO:ke]"
          },
          "SO:0000264": {
            "name": "leucyl_tRNA",
            "def": "A tRNA sequence that has a leucine anticodon, and a 3' leucine binding region. [SO:ke]"
          },
          "SO:0000265": {
            "name": "lysyl_tRNA",
            "def": "A tRNA sequence that has a lysine anticodon, and a 3' lysine binding region. [SO:ke]"
          },
          "SO:0000266": {
            "name": "methionyl_tRNA",
            "def": "A tRNA sequence that has a methionine anticodon, and a 3' methionine binding region. [SO:ke]"
          },
          "SO:0000267": {
            "name": "phenylalanyl_tRNA",
            "def": "A tRNA sequence that has a phenylalanine anticodon, and a 3' phenylalanine binding region. [SO:ke]"
          },
          "SO:0000268": {
            "name": "prolyl_tRNA",
            "def": "A tRNA sequence that has a proline anticodon, and a 3' proline binding region. [SO:ke]"
          },
          "SO:0000269": {
            "name": "seryl_tRNA",
            "def": "A tRNA sequence that has a serine anticodon, and a 3' serine binding region. [SO:ke]"
          },
          "SO:0000270": {
            "name": "threonyl_tRNA",
            "def": "A tRNA sequence that has a threonine anticodon, and a 3' threonine binding region. [SO:ke]"
          },
          "SO:0000271": {
            "name": "tryptophanyl_tRNA",
            "def": "A tRNA sequence that has a tryptophan anticodon, and a 3' tryptophan binding region. [SO:ke]"
          },
          "SO:0000272": {
            "name": "tyrosyl_tRNA",
            "def": "A tRNA sequence that has a tyrosine anticodon, and a 3' tyrosine binding region. [SO:ke]"
          },
          "SO:0000273": {
            "name": "valyl_tRNA",
            "def": "A tRNA sequence that has a valine anticodon, and a 3' valine binding region. [SO:ke]"
          },
          "SO:0000274": {
            "name": "snRNA",
            "def": "A small nuclear RNA molecule involved in pre-mRNA splicing and processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, PMID:11733745, WB:ems]"
          },
          "SO:0000275": {
            "name": "snoRNA",
            "def": "A snoRNA (small nucleolar RNA) is any one of a class of small RNAs that are associated with the eukaryotic nucleus as components of small nucleolar ribonucleoproteins. They participate in the processing or modifications of many RNAs, mostly ribosomal RNAs (rRNAs) though snoRNAs are also known to target other classes of RNA, including spliceosomal RNAs, tRNAs, and mRNAs via a stretch of sequence that is complementary to a sequence in the targeted RNA. [GOC:kgc]"
          },
          "SO:0000276": {
            "name": "miRNA",
            "def": "Small, ~22-nt, RNA molecule that is the endogenous transcript of a miRNA gene (or the product of other non coding RNA genes. Micro RNAs are produced from precursor molecules (SO:0000647) that can form local hairpin structures, which ordinarily are processed (usually via the Dicer pathway) such that a single miRNA molecule accumulates from one arm of a hairpin precursor molecule. Micro RNAs may trigger the cleavage of their target molecules or act as translational repressors. [PMID:11081512, PMID:12592000]"
          },
          "SO:0000277": {
            "name": "bound_by_factor",
            "def": "An attribute describing a sequence that is bound by another molecule. [SO:ke]"
          },
          "SO:0000278": {
            "name": "transcript_bound_by_nucleic_acid",
            "def": "A transcript that is bound by a nucleic acid. [SO:xp]"
          },
          "SO:0000279": {
            "name": "transcript_bound_by_protein",
            "def": "A transcript that is bound by a protein. [SO:xp]"
          },
          "SO:0000280": {
            "name": "engineered_gene",
            "def": "A gene that is engineered. [SO:xp]"
          },
          "SO:0000281": {
            "name": "engineered_foreign_gene",
            "def": "A gene that is engineered and foreign. [SO:xp]"
          },
          "SO:0000282": {
            "name": "mRNA_with_minus_1_frameshift",
            "def": "An mRNA with a minus 1 frameshift. [SO:xp]"
          },
          "SO:0000283": {
            "name": "engineered_foreign_transposable_element_gene",
            "def": "A transposable_element that is engineered and foreign. [SO:xp]"
          },
          "SO:0000284": {
            "name": "type_I_enzyme_restriction_site",
            "def": "The recognition site is bipartite and interrupted. [http://www.promega.com]"
          },
          "SO:0000285": {
            "name": "foreign_gene",
            "def": "A gene that is foreign. [SO:xp]"
          },
          "SO:0000286": {
            "name": "long_terminal_repeat",
            "def": "A sequence directly repeated at both ends of a defined sequence, of the sort typically found in retroviruses. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000287": {
            "name": "fusion_gene",
            "def": "A gene that is a fusion. [SO:xp]"
          },
          "SO:0000288": {
            "name": "engineered_fusion_gene",
            "def": "A fusion gene that is engineered. [SO:xp]"
          },
          "SO:0000289": {
            "name": "microsatellite",
            "def": "A repeat_region containing repeat_units of 2 to 10 bp repeated in tandem. [http://www.informatics.jax.org/silver/glossary.shtml, NCBI:th]"
          },
          "SO:0000290": {
            "name": "dinucleotide_repeat_microsatellite_feature"
          },
          "SO:0000291": {
            "name": "trinucleotide_repeat_microsatellite_feature"
          },
          "SO:0000292": {
            "name": "repetitive_element"
          },
          "SO:0000293": {
            "name": "engineered_foreign_repetitive_element",
            "def": "A repetitive element that is engineered and foreign. [SO:xp]"
          },
          "SO:0000294": {
            "name": "inverted_repeat",
            "def": "The sequence is complementarily repeated on the opposite strand. It is a palindrome, and it may, or may not be hyphenated. Examples: GCTGATCAGC, or GCTGA-----TCAGC. [SO:ke]"
          },
          "SO:0000295": {
            "name": "U12_intron",
            "def": "A type of spliceosomal intron spliced by the U12 spliceosome, that includes U11, U12, U4atac/U6atac and U5 snRNAs. [PMID:9428511]"
          },
          "SO:0000296": {
            "name": "origin_of_replication",
            "def": "The origin of replication; starting site for duplication of a nucleic acid molecule to give two identical copies. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000297": {
            "name": "D_loop",
            "def": "Displacement loop; a region within mitochondrial DNA in which a short stretch of RNA is paired with one strand of DNA, displacing the original partner DNA strand in this region; also used to describe the displacement of a region of one strand of duplex DNA by a single stranded invader in the reaction catalyzed by RecA protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000298": {
            "name": "recombination_feature"
          },
          "SO:0000299": {
            "name": "specific_recombination_site"
          },
          "SO:0000300": {
            "name": "recombination_feature_of_rearranged_gene"
          },
          "SO:0000301": {
            "name": "vertebrate_immune_system_gene_recombination_feature"
          },
          "SO:0000302": {
            "name": "J_gene_recombination_feature",
            "def": "Recombination signal including J-heptamer, J-spacer and J-nonamer in 5' of J-region of a J-gene or J-sequence. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000303": {
            "name": "clip",
            "def": "Part of the primary transcript that is clipped off during processing. [SO:ke]"
          },
          "SO:0000304": {
            "name": "type_II_enzyme_restriction_site",
            "def": "The recognition site is either palindromic, partially palindromic or an interrupted palindrome. Cleavage occurs within the recognition site. [http://www.promega.com]"
          },
          "SO:0000305": {
            "name": "modified_DNA_base",
            "def": "A modified nucleotide, i.e. a nucleotide other than A, T, C. G. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000306": {
            "name": "methylated_DNA_base_feature",
            "def": "A nucleotide modified by methylation. [SO:ke]"
          },
          "SO:0000307": {
            "name": "CpG_island",
            "def": "Regions of a few hundred to a few thousand bases in vertebrate genomes that are relatively GC and CpG rich; they are typically unmethylated and often found near the 5' ends of genes. [SO:rd]"
          },
          "SO:0000308": {
            "name": "sequence_feature_locating_method"
          },
          "SO:0000309": {
            "name": "computed_feature"
          },
          "SO:0000310": {
            "name": "predicted_ab_initio_computation"
          },
          "SO:0000311": {
            "name": "computed_feature_by_similarity",
            "def": ". [SO:ma]"
          },
          "SO:0000312": {
            "name": "experimentally_determined",
            "def": "Attribute to describe a feature that has been experimentally verified. [SO:ke]"
          },
          "SO:0000313": {
            "name": "stem_loop",
            "def": "A double-helical region of nucleic acid formed by base-pairing between adjacent (inverted) complementary sequences. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000314": {
            "name": "direct_repeat",
            "def": "A repeat where the same sequence is repeated in the same direction. Example: GCTGA-followed by-GCTGA. [SO:ke]"
          },
          "SO:0000315": {
            "name": "TSS",
            "def": "The first base where RNA polymerase begins to synthesize the RNA transcript. [SO:ke]"
          },
          "SO:0000316": {
            "name": "CDS",
            "def": "A contiguous sequence which begins with, and includes, a start codon and ends with, and includes, a stop codon. [SO:ma]"
          },
          "SO:0000317": {
            "name": "cDNA_clone",
            "def": "Complementary DNA; A piece of DNA copied from an mRNA and spliced into a vector for propagation in a suitable host. [http://seqcore.brcf.med.umich.edu/doc/educ/dnapr/mbglossary/mbgloss.html]"
          },
          "SO:0000318": {
            "name": "start_codon",
            "def": "First codon to be translated by a ribosome. [SO:ke]"
          },
          "SO:0000319": {
            "name": "stop_codon",
            "def": "In mRNA, a set of three nucleotides that indicates the end of information for protein synthesis. [SO:ke]"
          },
          "SO:0000320": {
            "name": "intronic_splice_enhancer",
            "def": "Sequences within the intron that modulate splice site selection for some introns. [SO:ke]"
          },
          "SO:0000321": {
            "name": "mRNA_with_plus_1_frameshift",
            "def": "An mRNA with a plus 1 frameshift. [SO:ke]"
          },
          "SO:0000322": {
            "name": "nuclease_hypersensitive_site"
          },
          "SO:0000323": {
            "name": "coding_start",
            "def": "The first base to be translated into protein. [SO:ke]"
          },
          "SO:0000324": {
            "name": "tag",
            "def": "A nucleotide sequence that may be used to identify a larger sequence. [SO:ke]"
          },
          "SO:0000325": {
            "name": "rRNA_large_subunit_primary_transcript",
            "def": "A primary transcript encoding a large ribosomal subunit RNA. [SO:ke]"
          },
          "SO:0000326": {
            "name": "SAGE_tag",
            "def": "A short diagnostic sequence tag, serial analysis of gene expression (SAGE), that allows the quantitative and simultaneous analysis of a large number of transcripts. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=7570003&dopt=Abstract]"
          },
          "SO:0000327": {
            "name": "coding_end",
            "def": "The last base to be translated into protein. It does not include the stop codon. [SO:ke]"
          },
          "SO:0000328": {
            "name": "microarray_oligo"
          },
          "SO:0000329": {
            "name": "mRNA_with_plus_2_frameshift",
            "def": "An mRNA with a plus 2 frameshift. [SO:xp]"
          },
          "SO:0000330": {
            "name": "conserved_region",
            "def": "Region of sequence similarity by descent from a common ancestor. [SO:ke]"
          },
          "SO:0000331": {
            "name": "STS",
            "def": "Short (typically a few hundred base pairs) DNA sequence that has a single occurrence in a genome and whose location and base sequence are known. [http://www.biospace.com]"
          },
          "SO:0000332": {
            "name": "coding_conserved_region",
            "def": "Coding region of sequence similarity by descent from a common ancestor. [SO:ke]"
          },
          "SO:0000333": {
            "name": "exon_junction",
            "def": "The boundary between two exons in a processed transcript. [SO:ke]"
          },
          "SO:0000334": {
            "name": "nc_conserved_region",
            "def": "Non-coding region of sequence similarity by descent from a common ancestor. [SO:ke]"
          },
          "SO:0000335": {
            "name": "mRNA_with_minus_2_frameshift",
            "def": "A mRNA with a minus 2 frameshift. [SO:ke]"
          },
          "SO:0000336": {
            "name": "pseudogene",
            "def": "A sequence that closely resembles a known functional gene, at another locus within a genome, that is non-functional as a consequence of (usually several) mutations that prevent either its transcription or translation (or both). In general, pseudogenes result from either reverse transcription of a transcript of their \\normal\\ paralog (SO:0000043) (in which case the pseudogene typically lacks introns and includes a poly(A) tail) or from recombination (SO:0000044) (in which case the pseudogene is typically a tandem duplication of its \\normal\\ paralog). [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html]"
          },
          "SO:0000337": {
            "name": "RNAi_reagent",
            "def": "A double stranded RNA duplex, at least 20bp long, used experimentally to inhibit gene function by RNA interference. [SO:rd]"
          },
          "SO:0000338": {
            "name": "MITE",
            "def": "A highly repetitive and short (100-500 base pair) transposable element with terminal inverted repeats (TIR) and target site duplication (TSD). MITEs do not encode proteins. [http://www.pnas.org/cgi/content/full/97/18/10083]"
          },
          "SO:0000339": {
            "name": "recombination_hotspot",
            "def": "A region in a genome which promotes recombination. [SO:rd]"
          },
          "SO:0000340": {
            "name": "chromosome",
            "def": "Structural unit composed of a nucleic acid molecule which controls its own replication through the interaction of specific proteins at one or more origins of replication. [SO:ma]"
          },
          "SO:0000341": {
            "name": "chromosome_band",
            "def": "A cytologically distinguishable feature of a chromosome, often made visible by staining, and usually alternating light and dark. [SO:ma]"
          },
          "SO:0000342": {
            "name": "site_specific_recombination_target_region"
          },
          "SO:0000343": {
            "name": "match",
            "def": "A region of sequence, aligned to another sequence with some statistical significance, using an algorithm such as BLAST or SIM4. [SO:ke]"
          },
          "SO:0000344": {
            "name": "splice_enhancer",
            "def": "Region of a transcript that regulates splicing. [SO:ke]"
          },
          "SO:0000345": {
            "name": "EST",
            "def": "A tag produced from a single sequencing read from a cDNA clone or PCR product; typically a few hundred base pairs long. [SO:ke]"
          },
          "SO:0000346": {
            "name": "loxP_site"
          },
          "SO:0000347": {
            "name": "nucleotide_match",
            "def": "A match against a nucleotide sequence. [SO:ke]"
          },
          "SO:0000348": {
            "name": "nucleic_acid",
            "def": "An attribute describing a sequence consisting of nucleobases bound to repeating units. The forms found in nature are deoxyribonucleic acid (DNA), where the repeating units are 2-deoxy-D-ribose rings connected to a phosphate backbone, and ribonucleic acid (RNA), where the repeating units are D-ribose rings connected to a phosphate backbone. [CHEBI:33696, RSC:cb]"
          },
          "SO:0000349": {
            "name": "protein_match",
            "def": "A match against a protein sequence. [SO:ke]"
          },
          "SO:0000350": {
            "name": "FRT_site",
            "def": "An inversion site found on the Saccharomyces cerevisiae 2 micron plasmid. [SO:ma]"
          },
          "SO:0000351": {
            "name": "synthetic_sequence",
            "def": "An attribute to decide a sequence of nucleotides, nucleotide analogs, or amino acids that has been designed by an experimenter and which may, or may not, correspond with any natural sequence. [SO:ma]"
          },
          "SO:0000352": {
            "name": "DNA",
            "def": "An attribute describing a sequence consisting of nucleobases bound to a repeating unit made of a 2-deoxy-D-ribose ring connected to a phosphate backbone. [RSC:cb]"
          },
          "SO:0000353": {
            "name": "sequence_assembly",
            "def": "A sequence of nucleotides that has been algorithmically derived from an alignment of two or more different sequences. [SO:ma]"
          },
          "SO:0000354": {
            "name": "group_1_intron_homing_endonuclease_target_region",
            "def": "A region of intronic nucleotide sequence targeted by a nuclease enzyme. [SO:ke]"
          },
          "SO:0000355": {
            "name": "haplotype_block",
            "def": "A region of the genome which is co-inherited as the result of the lack of historic recombination within it. [SO:ma]"
          },
          "SO:0000356": {
            "name": "RNA",
            "def": "An attribute describing a sequence consisting of nucleobases bound to a repeating unit made of a D-ribose ring connected to a phosphate backbone. [RSC:cb]"
          },
          "SO:0000357": {
            "name": "flanked",
            "def": "An attribute describing a region that is bounded either side by a particular kind of region. [SO:ke]"
          },
          "SO:0000359": {
            "name": "floxed",
            "def": "An attribute describing sequence that is flanked by Lox-P sites. [SO:ke]"
          },
          "SO:0000360": {
            "name": "codon",
            "def": "A set of (usually) three nucleotide bases in a DNA or RNA sequence, which together code for a unique amino acid or the termination of translation and are contained within the CDS. [http://www.everythingbio.com/glos/definition.php?word=codon, SO:ke]"
          },
          "SO:0000361": {
            "name": "FRT_flanked",
            "def": "An attribute to describe sequence that is flanked by the FLP recombinase recognition site, FRT. [SO:ke]"
          },
          "SO:0000362": {
            "name": "invalidated_by_chimeric_cDNA",
            "def": "A cDNA clone constructed from more than one mRNA. Usually an experimental artifact. [SO:ma]"
          },
          "SO:0000363": {
            "name": "floxed_gene",
            "def": "A transgene that is floxed. [SO:xp]"
          },
          "SO:0000364": {
            "name": "transposable_element_flanking_region",
            "def": "The region of sequence surrounding a transposable element. [SO:ke]"
          },
          "SO:0000365": {
            "name": "integron",
            "def": "A region encoding an integrase which acts at a site adjacent to it (attI_site) to insert DNA which must include but is not limited to an attC_site. [SO:as]"
          },
          "SO:0000366": {
            "name": "insertion_site",
            "def": "The junction where an insertion occurred. [SO:ke]"
          },
          "SO:0000367": {
            "name": "attI_site",
            "def": "A region within an integron, adjacent to an integrase, at which site specific recombination involving an attC_site takes place. [SO:as]"
          },
          "SO:0000368": {
            "name": "transposable_element_insertion_site",
            "def": "The junction in a genome where a transposable_element has inserted. [SO:ke]"
          },
          "SO:0000369": {
            "name": "integrase_coding_region"
          },
          "SO:0000370": {
            "name": "small_regulatory_ncRNA",
            "def": "A non-coding RNA, usually with a specific secondary structure, that acts to regulate gene expression. [SO:ma]"
          },
          "SO:0000371": {
            "name": "conjugative_transposon",
            "def": "A transposon that encodes function required for conjugation. [http://www.sci.sdsu.edu/~smaloy/Glossary/C.html]"
          },
          "SO:0000372": {
            "name": "enzymatic_RNA",
            "def": "An RNA sequence that has catalytic activity with or without an associated ribonucleoprotein. [RSC:cb]"
          },
          "SO:0000373": {
            "name": "recombinationally_inverted_gene",
            "def": "A recombinationally rearranged gene by inversion. [SO:xp]"
          },
          "SO:0000374": {
            "name": "ribozyme",
            "def": "An RNA with catalytic activity. [SO:ma]"
          },
          "SO:0000375": {
            "name": "rRNA_5_8S",
            "def": "5_8S ribosomal RNA (5. 8S rRNA) is a component of the large subunit of the eukaryotic ribosome. It is transcribed by RNA polymerase I as part of the 45S precursor that also contains 18S and 28S rRNA. Functionally, it is thought that 5.8S rRNA may be involved in ribosome translocation. It is also known to form covalent linkage to the p53 tumour suppressor protein. 5_8S rRNA is also found in archaea. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00002]"
          },
          "SO:0000376": {
            "name": "RNA_6S",
            "def": "A small (184-nt in E. coli) RNA that forms a hairpin type structure. 6S RNA associates with RNA polymerase in a highly specific manner. 6S RNA represses expression from a sigma70-dependent promoter during stationary phase. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00013]"
          },
          "SO:0000377": {
            "name": "CsrB_RsmB_RNA",
            "def": "An enterobacterial RNA that binds the CsrA protein. The CsrB RNAs contain a conserved motif CAGGXXG that is found in up to 18 copies and has been suggested to bind CsrA. The Csr regulatory system has a strong negative regulatory effect on glycogen biosynthesis, glyconeogenesis and glycogen catabolism and a positive regulatory effect on glycolysis. In other bacteria such as Erwinia caratovara the RsmA protein has been shown to regulate the production of virulence determinants, such extracellular enzymes. RsmA binds to RsmB regulatory RNA which is also a member of this family. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00018]"
          },
          "SO:0000378": {
            "name": "DsrA_RNA",
            "def": "DsrA RNA regulates both transcription, by overcoming transcriptional silencing by the nucleoid-associated H-NS protein, and translation, by promoting efficient translation of the stress sigma factor, RpoS. These two activities of DsrA can be separated by mutation: the first of three stem-loops of the 85 nucleotide RNA is necessary for RpoS translation but not for anti-H-NS action, while the second stem-loop is essential for antisilencing and less critical for RpoS translation. The third stem-loop, which behaves as a transcription terminator, can be substituted by the trp transcription terminator without loss of either DsrA function. The sequence of the first stem-loop of DsrA is complementary with the upstream leader portion of RpoS messenger RNA, suggesting that pairing of DsrA with the RpoS message might be important for translational regulation. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00014]"
          },
          "SO:0000379": {
            "name": "GcvB_RNA",
            "def": "A small untranslated RNA involved in expression of the dipeptide and oligopeptide transport systems in Escherichia coli. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00022]"
          },
          "SO:0000380": {
            "name": "hammerhead_ribozyme",
            "def": "A small catalytic RNA motif that catalyzes self-cleavage reaction. Its name comes from its secondary structure which resembles a carpenter's hammer. The hammerhead ribozyme is involved in the replication of some viroid and some satellite RNAs. [PMID:2436805]"
          },
          "SO:0000381": {
            "name": "group_IIA_intron"
          },
          "SO:0000382": {
            "name": "group_IIB_intron"
          },
          "SO:0000383": {
            "name": "MicF_RNA",
            "def": "A non-translated 93 nt antisense RNA that binds its target ompF mRNA and regulates ompF expression by inhibiting translation and inducing degradation of the message. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00033]"
          },
          "SO:0000384": {
            "name": "OxyS_RNA",
            "def": "A small untranslated RNA which is induced in response to oxidative stress in Escherichia coli. Acts as a global regulator to activate or repress the expression of as many as 40 genes, including the fhlA-encoded transcriptional activator and the rpoS-encoded sigma(s) subunit of RNA polymerase. OxyS is bound by the Hfq protein, that increases the OxyS RNA interaction with its target messages. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00035]"
          },
          "SO:0000385": {
            "name": "RNase_MRP_RNA",
            "def": "The RNA molecule essential for the catalytic activity of RNase MRP, an enzymatically active ribonucleoprotein with two distinct roles in eukaryotes. In mitochondria it plays a direct role in the initiation of mitochondrial DNA replication. In the nucleus it is involved in precursor rRNA processing, where it cleaves the internal transcribed spacer 1 between 18S and 5.8S rRNAs. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00030]"
          },
          "SO:0000386": {
            "name": "RNase_P_RNA",
            "def": "The RNA component of Ribonuclease P (RNase P), a ubiquitous endoribonuclease, found in archaea, bacteria and eukarya as well as chloroplasts and mitochondria. Its best characterized activity is the generation of mature 5 prime ends of tRNAs by cleaving the 5 prime leader elements of precursor-tRNAs. Cellular RNase Ps are ribonucleoproteins. RNA from bacterial RNase Ps retains its catalytic activity in the absence of the protein subunit, i.e. it is a ribozyme. Isolated eukaryotic and archaeal RNase P RNA has not been shown to retain its catalytic function, but is still essential for the catalytic activity of the holoenzyme. Although the archaeal and eukaryotic holoenzymes have a much greater protein content than the bacterial ones, the RNA cores from all the three lineages are homologous. Helices corresponding to P1, P2, P3, P4, and P10/11 are common to all cellular RNase P RNAs. Yet, there is considerable sequence variation, particularly among the eukaryotic RNAs. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00010]"
          },
          "SO:0000387": {
            "name": "RprA_RNA",
            "def": "Translational regulation of the stationary phase sigma factor RpoS is mediated by the formation of a double-stranded RNA stem-loop structure in the upstream region of the rpoS messenger RNA, occluding the translation initiation site. Clones carrying rprA (RpoS regulator RNA) increased the translation of RpoS. The rprA gene encodes a 106 nucleotide regulatory RNA. As with DsrA Rfam:RF00014, RprA is predicted to form three stem-loops. Thus, at least two small RNAs, DsrA and RprA, participate in the positive regulation of RpoS translation. Unlike DsrA, RprA does not have an extensive region of complementarity to the RpoS leader, leaving its mechanism of action unclear. RprA is non-essential. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00034]"
          },
          "SO:0000388": {
            "name": "RRE_RNA",
            "def": "The Rev response element (RRE) is encoded within the HIV-env gene. Rev is an essential regulatory protein of HIV that binds an internal loop of the RRE leading, encouraging further Rev-RRE binding. This RNP complex is critical for mRNA export and hence for expression of the HIV structural proteins. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00036]"
          },
          "SO:0000389": {
            "name": "spot_42_RNA",
            "def": "A 109-nucleotide RNA of E. coli that seems to have a regulatory role on the galactose operon. Changes in Spot 42 levels are implicated in affecting DNA polymerase I levels. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00021]"
          },
          "SO:0000390": {
            "name": "telomerase_RNA",
            "def": "The RNA component of telomerase, a reverse transcriptase that synthesizes telomeric DNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00025]"
          },
          "SO:0000391": {
            "name": "U1_snRNA",
            "def": "U1 is a small nuclear RNA (snRNA) component of the spliceosome (involved in pre-mRNA splicing). Its 5' end forms complementary base pairs with the 5' splice junction, thus defining the 5' donor site of an intron. There are significant differences in sequence and secondary structure between metazoan and yeast U1 snRNAs, the latter being much longer (568 nucleotides as compared to 164 nucleotides in human). Nevertheless, secondary structure predictions suggest that all U1 snRNAs share a 'common core' consisting of helices I, II, the proximal region of III, and IV. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00003]"
          },
          "SO:0000392": {
            "name": "U2_snRNA",
            "def": "U2 is a small nuclear RNA (snRNA) component of the spliceosome (involved in pre-mRNA splicing). Complementary binding between U2 snRNA (in an area lying towards the 5' end but 3' to hairpin I) and the branchpoint sequence (BPS) of the intron results in the bulging out of an unpaired adenine, on the BPS, which initiates a nucleophilic attack at the intronic 5' splice site, thus starting the first of two transesterification reactions that mediate splicing. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00004]"
          },
          "SO:0000393": {
            "name": "U4_snRNA",
            "def": "U4 small nuclear RNA (U4 snRNA) is a component of the major U2-dependent spliceosome. It forms a duplex with U6, and with each splicing round, it is displaced from U6 (and the spliceosome) in an ATP-dependent manner, allowing U6 to refold and create the active site for splicing catalysis. A recycling process involving protein Prp24 re-anneals U4 and U6. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00015]"
          },
          "SO:0000394": {
            "name": "U4atac_snRNA",
            "def": "An snRNA required for the splicing of the minor U12-dependent class of eukaryotic nuclear introns. It forms a base paired complex with U6atac_snRNA (SO:0000397). [PMID:=12409455]"
          },
          "SO:0000395": {
            "name": "U5_snRNA",
            "def": "U5 RNA is a component of both types of known spliceosome. The precise function of this molecule is unknown, though it is known that the 5' loop is required for splice site selection and p220 binding, and that both the 3' stem-loop and the Sm site are important for Sm protein binding and cap methylation. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00020]"
          },
          "SO:0000396": {
            "name": "U6_snRNA",
            "def": "U6 snRNA is a component of the spliceosome which is involved in splicing pre-mRNA. The putative secondary structure consensus base pairing is confined to a short 5' stem loop, but U6 snRNA is thought to form extensive base-pair interactions with U4 snRNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00015]"
          },
          "SO:0000397": {
            "name": "U6atac_snRNA",
            "def": "U6atac_snRNA is an snRNA required for the splicing of the minor U12-dependent class of eukaryotic nuclear introns. It forms a base paired complex with U4atac_snRNA (SO:0000394). [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=retrieve&db=pubmed&list_uids=12409455&dopt=Abstract]"
          },
          "SO:0000398": {
            "name": "U11_snRNA",
            "def": "U11 snRNA plays a role in splicing of the minor U12-dependent class of eukaryotic nuclear introns, similar to U1 snRNA in the major class spliceosome it base pairs to the conserved 5' splice site sequence. [PMID:9622129]"
          },
          "SO:0000399": {
            "name": "U12_snRNA",
            "def": "The U12 small nuclear (snRNA), together with U4atac/U6atac, U5, and U11 snRNAs and associated proteins, forms a spliceosome that cleaves a divergent class of low-abundance pre-mRNA introns. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00007]"
          },
          "SO:0000400": {
            "name": "sequence_attribute",
            "def": "An attribute describes a quality of sequence. [SO:ke]"
          },
          "SO:0000401": {
            "name": "gene_attribute"
          },
          "SO:0000402": {
            "name": "enhancer_attribute"
          },
          "SO:0000403": {
            "name": "U14_snoRNA",
            "def": "U14 small nucleolar RNA (U14 snoRNA) is required for early cleavages of eukaryotic precursor rRNAs. In yeasts, this molecule possess a stem-loop region (known as the Y-domain) which is essential for function. A similar structure, but with a different consensus sequence, is found in plants, but is absent in vertebrates. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00016, PMID:2551119]"
          },
          "SO:0000404": {
            "name": "vault_RNA",
            "def": "A family of RNAs are found as part of the enigmatic vault ribonucleoprotein complex. The complex consists of a major vault protein (MVP), two minor vault proteins (VPARP and TEP1), and several small untranslated RNA molecules. It has been suggested that the vault complex is involved in drug resistance. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00006]"
          },
          "SO:0000405": {
            "name": "Y_RNA",
            "def": "Y RNAs are components of the Ro ribonucleoprotein particle (Ro RNP), in association with Ro60 and La proteins. The Y RNAs and Ro60 and La proteins are well conserved, but the function of the Ro RNP is not known. In humans the RNA component can be one of four small RNAs: hY1, hY3, hY4 and hY5. These small RNAs are predicted to fold into a conserved secondary structure containing three stem structures. The largest of the four, hY1, contains an additional hairpin. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00019]"
          },
          "SO:0000406": {
            "name": "twintron",
            "def": "An intron within an intron. Twintrons are group II or III introns, into which another group II or III intron has been transposed. [PMID:1899376, PMID:7823908]"
          },
          "SO:0000407": {
            "name": "rRNA_18S",
            "def": "A large polynucleotide in eukaryotes, which functions as the small subunit of the ribosome. [SO:ke]"
          },
          "SO:0000408": {
            "name": "site",
            "def": "The interbase position where something (eg an aberration) occurred. [SO:ke]"
          },
          "SO:0000409": {
            "name": "binding_site",
            "def": "A biological_region of sequence that, in the molecule, interacts selectively and non-covalently with other molecules. A region on the surface of a molecule that may interact with another molecule. When applied to polypeptides: Amino acids involved in binding or interactions. It can also apply to an amino acid bond which is represented by the positions of the two flanking amino acids. [EBIBS:GAR, SO:ke]"
          },
          "SO:0000410": {
            "name": "protein_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with polypeptide molecules. [SO:ke]"
          },
          "SO:0000411": {
            "name": "rescue_region",
            "def": "A region that rescues. [SO:xp]"
          },
          "SO:0000412": {
            "name": "restriction_fragment",
            "def": "A region of polynucleotide sequence produced by digestion with a restriction endonuclease. [SO:ke]"
          },
          "SO:0000413": {
            "name": "sequence_difference",
            "def": "A region where the sequence differs from that of a specified sequence. [SO:ke]"
          },
          "SO:0000414": {
            "name": "invalidated_by_genomic_contamination",
            "def": "An attribute to describe a feature that is invalidated due to genomic contamination. [SO:ke]"
          },
          "SO:0000415": {
            "name": "invalidated_by_genomic_polyA_primed_cDNA",
            "def": "An attribute to describe a feature that is invalidated due to polyA priming. [SO:ke]"
          },
          "SO:0000416": {
            "name": "invalidated_by_partial_processing",
            "def": "An attribute to describe a feature that is invalidated due to partial processing. [SO:ke]"
          },
          "SO:0000417": {
            "name": "polypeptide_domain",
            "def": "A structurally or functionally defined protein region. In proteins with multiple domains, the combination of the domains determines the function of the protein. A region which has been shown to recur throughout evolution. [EBIBS:GAR]"
          },
          "SO:0000418": {
            "name": "signal_peptide",
            "def": "The signal_peptide is a short region of the peptide located at the N-terminus that directs the protein to be secreted or part of membrane components. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000419": {
            "name": "mature_protein_region",
            "def": "The polypeptide sequence that remains when the cleaved peptide regions have been cleaved from the immature peptide. [EBIBS:GAR, http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, SO:cb]"
          },
          "SO:0000420": {
            "name": "five_prime_terminal_inverted_repeat"
          },
          "SO:0000421": {
            "name": "three_prime_terminal_inverted_repeat"
          },
          "SO:0000422": {
            "name": "U5_LTR_region"
          },
          "SO:0000423": {
            "name": "R_LTR_region"
          },
          "SO:0000424": {
            "name": "U3_LTR_region"
          },
          "SO:0000425": {
            "name": "five_prime_LTR"
          },
          "SO:0000426": {
            "name": "three_prime_LTR"
          },
          "SO:0000427": {
            "name": "R_five_prime_LTR_region"
          },
          "SO:0000428": {
            "name": "U5_five_prime_LTR_region"
          },
          "SO:0000429": {
            "name": "U3_five_prime_LTR_region"
          },
          "SO:0000430": {
            "name": "R_three_prime_LTR_region"
          },
          "SO:0000431": {
            "name": "U3_three_prime_LTR_region"
          },
          "SO:0000432": {
            "name": "U5_three_prime_LTR_region"
          },
          "SO:0000433": {
            "name": "non_LTR_retrotransposon_polymeric_tract",
            "def": "A polymeric tract, such as poly(dA), within a non_LTR_retrotransposon. [SO:ke]"
          },
          "SO:0000434": {
            "name": "target_site_duplication",
            "def": "A sequence of the target DNA that is duplicated when a transposable element or phage inserts; usually found at each end the insertion. [http://www.koko.gov.my/CocoaBioTech/Glossaryt.html]"
          },
          "SO:0000435": {
            "name": "RR_tract",
            "def": "A polypurine tract within an LTR_retrotransposon. [SO:ke]"
          },
          "SO:0000436": {
            "name": "ARS",
            "def": "A sequence that can autonomously replicate, as a plasmid, when transformed into a bacterial host. [SO:ma]"
          },
          "SO:0000437": {
            "name": "assortment_derived_duplication"
          },
          "SO:0000438": {
            "name": "gene_not_polyadenylated"
          },
          "SO:0000439": {
            "name": "inverted_ring_chromosome"
          },
          "SO:0000440": {
            "name": "vector_replicon",
            "def": "A replicon that has been modified to act as a vector for foreign sequence. [SO:ma]"
          },
          "SO:0000441": {
            "name": "ss_oligo",
            "def": "A single stranded oligonucleotide. [SO:ke]"
          },
          "SO:0000442": {
            "name": "ds_oligo",
            "def": "A double stranded oligonucleotide. [SO:ke]"
          },
          "SO:0000443": {
            "name": "polymer_attribute",
            "def": "An attribute to describe the kind of biological sequence. [SO:ke]"
          },
          "SO:0000444": {
            "name": "three_prime_noncoding_exon",
            "def": "Non-coding exon in the 3' UTR. [SO:ke]"
          },
          "SO:0000445": {
            "name": "five_prime_noncoding_exon",
            "def": "Non-coding exon in the 5' UTR. [SO:ke]"
          },
          "SO:0000446": {
            "name": "UTR_intron",
            "def": "Intron located in the untranslated region. [SO:ke]"
          },
          "SO:0000447": {
            "name": "five_prime_UTR_intron",
            "def": "An intron located in the 5' UTR. [SO:ke]"
          },
          "SO:0000448": {
            "name": "three_prime_UTR_intron",
            "def": "An intron located in the 3' UTR. [SO:ke]"
          },
          "SO:0000449": {
            "name": "random_sequence",
            "def": "A sequence of nucleotides or amino acids which, by design, has a \\random\\ order of components, given a predetermined input frequency of these components. [SO:ma]"
          },
          "SO:0000450": {
            "name": "interband",
            "def": "A light region between two darkly staining bands in a polytene chromosome. [SO:ma]"
          },
          "SO:0000451": {
            "name": "gene_with_polyadenylated_mRNA",
            "def": "A gene that encodes a polyadenylated mRNA. [SO:xp]"
          },
          "SO:0000452": {
            "name": "transgene_attribute"
          },
          "SO:0000453": {
            "name": "chromosomal_transposition",
            "def": "A chromosome structure variant whereby a region of a chromosome has been transferred to another position. Among interchromosomal rearrangements, the term transposition is reserved for that class in which the telomeres of the chromosomes involved are coupled (that is to say, form the two ends of a single DNA molecule) as in wild-type. [FB:reference_manual, SO:ke]"
          },
          "SO:0000454": {
            "name": "rasiRNA",
            "def": "A 17-28-nt, small interfering RNA derived from transcripts of repetitive elements. [http://www.developmentalcell.com/content/article/abstract?uid=PIIS1534580703002284]"
          },
          "SO:0000455": {
            "name": "gene_with_mRNA_with_frameshift",
            "def": "A gene that encodes an mRNA with a frameshift. [SO:xp]"
          },
          "SO:0000456": {
            "name": "recombinationally_rearranged_gene",
            "def": "A gene that is recombinationally rearranged. [SO:ke]"
          },
          "SO:0000457": {
            "name": "interchromosomal_duplication",
            "def": "A chromosome duplication involving an insertion from another chromosome. [SO:ke]"
          },
          "SO:0000458": {
            "name": "D_gene_segment",
            "def": "Germline genomic DNA including D-region with 5' UTR and 3' UTR, also designated as D-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000459": {
            "name": "gene_with_trans_spliced_transcript",
            "def": "A gene with a transcript that is trans-spliced. [SO:xp]"
          },
          "SO:0000460": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_segment"
          },
          "SO:0000461": {
            "name": "inversion_derived_bipartite_deficiency",
            "def": "A chromosomal deletion whereby a chromosome generated by recombination between two inversions; has a deficiency at each end of the inversion. [FB:km]"
          },
          "SO:0000462": {
            "name": "pseudogenic_region",
            "def": "A non-functional descendant of a functional entity. [SO:cjm]"
          },
          "SO:0000463": {
            "name": "encodes_alternately_spliced_transcripts",
            "def": "A gene that encodes more than one transcript. [SO:ke]"
          },
          "SO:0000464": {
            "name": "decayed_exon",
            "def": "A non-functional descendant of an exon. [SO:ke]"
          },
          "SO:0000465": {
            "name": "inversion_derived_deficiency_plus_duplication",
            "def": "A chromosome deletion whereby a chromosome is generated by recombination between two inversions; there is a deficiency at one end of the inversion and a duplication at the other end of the inversion. [FB:km]"
          },
          "SO:0000466": {
            "name": "V_gene_segment",
            "def": "Germline genomic DNA including L-part1, V-intron and V-exon, with the 5' UTR and 3' UTR. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000467": {
            "name": "post_translationally_regulated_by_protein_stability",
            "def": "An attribute describing a gene sequence where the resulting protein is regulated by the stability of the resulting protein. [SO:ke]"
          },
          "SO:0000468": {
            "name": "golden_path_fragment",
            "def": "One of the pieces of sequence that make up a golden path. [SO:rd]"
          },
          "SO:0000469": {
            "name": "post_translationally_regulated_by_protein_modification",
            "def": "An attribute describing a gene sequence where the resulting protein is modified to regulate it. [SO:ke]"
          },
          "SO:0000470": {
            "name": "J_gene_segment",
            "def": "Germline genomic DNA of an immunoglobulin/T-cell receptor gene including J-region with 5' UTR (SO:0000204) and 3' UTR (SO:0000205), also designated as J-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000471": {
            "name": "autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation. [SO:ke]"
          },
          "SO:0000472": {
            "name": "tiling_path",
            "def": "A set of regions which overlap with minimal polymorphism to form a linear sequence. [SO:cjm]"
          },
          "SO:0000473": {
            "name": "negatively_autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation where it decreases transcription. [SO:ke]"
          },
          "SO:0000474": {
            "name": "tiling_path_fragment",
            "def": "A piece of sequence that makes up a tiling_path (SO:0000472). [SO:ke]"
          },
          "SO:0000475": {
            "name": "positively_autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation, where it increases transcription. [SO:ke]"
          },
          "SO:0000476": {
            "name": "contig_read",
            "def": "A DNA sequencer read which is part of a contig. [SO:ke]"
          },
          "SO:0000477": {
            "name": "polycistronic_gene",
            "def": "A gene that is polycistronic. [SO:ke]"
          },
          "SO:0000478": {
            "name": "C_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene including C-region (and introns if present) with 5' UTR (SO:0000204) and 3' UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000479": {
            "name": "trans_spliced_transcript",
            "def": "A transcript that is trans-spliced. [SO:xp]"
          },
          "SO:0000480": {
            "name": "tiling_path_clone",
            "def": "A clone which is part of a tiling path. A tiling path is a set of sequencing substrates, typically clones, which have been selected in order to efficiently cover a region of the genome in preparation for sequencing and assembly. [SO:ke]"
          },
          "SO:0000481": {
            "name": "terminal_inverted_repeat",
            "def": "An inverted repeat (SO:0000294) occurring at the termini of a DNA transposon. [SO:ke]"
          },
          "SO:0000482": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_gene_cluster"
          },
          "SO:0000483": {
            "name": "nc_primary_transcript",
            "def": "A primary transcript that is never translated into a protein. [SO:ke]"
          },
          "SO:0000484": {
            "name": "three_prime_coding_exon_noncoding_region",
            "def": "The sequence of the 3' exon that is not coding. [SO:ke]"
          },
          "SO:0000485": {
            "name": "DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one DJ-gene, and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000486": {
            "name": "five_prime_coding_exon_noncoding_region",
            "def": "The sequence of the 5' exon preceding the start codon. [SO:ke]"
          },
          "SO:0000487": {
            "name": "VDJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000488": {
            "name": "VDJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000489": {
            "name": "VJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000490": {
            "name": "VJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000491": {
            "name": "VJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000492": {
            "name": "D_gene_recombination_feature"
          },
          "SO:0000493": {
            "name": "three_prime_D_heptamer",
            "def": "7 nucleotide recombination site like CACAGTG, part of a 3' D-recombination signal sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000494": {
            "name": "three_prime_D_nonamer",
            "def": "A 9 nucleotide recombination site (e.g. ACAAAAACC), part of a 3' D-recombination signal sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000495": {
            "name": "three_prime_D_spacer",
            "def": "A 12 or 23 nucleotide spacer between the 3'D-HEPTAMER and 3'D-NONAMER of a 3'D-RS. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000496": {
            "name": "five_prime_D_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACTGTG), part of a 5' D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000497": {
            "name": "five_prime_D_nonamer",
            "def": "9 nucleotide recombination site (e.g. GGTTTTTGT), part of a five_prime_D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000498": {
            "name": "five_prime_D_spacer",
            "def": "12 or 23 nucleotide spacer between the 5' D-heptamer (SO:0000496) and 5' D-nonamer (SO:0000497) of a 5' D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000499": {
            "name": "virtual_sequence",
            "def": "A continuous piece of sequence similar to the 'virtual contig' concept of the Ensembl database. [SO:ke]"
          },
          "SO:0000500": {
            "name": "Hoogsteen_base_pair",
            "def": "A type of non-canonical base-pairing. This is less energetically favourable than watson crick base pairing. Hoogsteen GC base pairs only have two hydrogen bonds. [PMID:12177293]"
          },
          "SO:0000501": {
            "name": "reverse_Hoogsteen_base_pair",
            "def": "A type of non-canonical base-pairing. [SO:ke]"
          },
          "SO:0000502": {
            "name": "transcribed_region",
            "def": "A region of sequence that is transcribed. This region may cover the transcript of a gene, it may emcompas the sequence covered by all of the transcripts of a alternately spliced gene, or it may cover the region transcribed by a polycistronic transcript. A gene may have 1 or more transcribed regions and a transcribed_region may belong to one or more genes. [SO:ke]"
          },
          "SO:0000503": {
            "name": "alternately_spliced_gene_encodeing_one_transcript"
          },
          "SO:0000504": {
            "name": "D_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000505": {
            "name": "D_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene and one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000506": {
            "name": "D_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000507": {
            "name": "pseudogenic_exon",
            "def": "A non functional descendant of an exon, part of a pseudogene. [SO:ke]"
          },
          "SO:0000508": {
            "name": "D_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene, and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000509": {
            "name": "D_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one D-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000510": {
            "name": "VD_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in partially rearranged genomic DNA including L-part1, V-intron and V-D-exon, with the 5' UTR (SO:0000204) and 3' UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000511": {
            "name": "J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000512": {
            "name": "inversion_derived_deficiency_plus_aneuploid",
            "def": "A chromosomal deletion whereby a chromosome generated by recombination between two inversions; has a deficiency at one end and presumed to have a deficiency or duplication at the other end of the inversion. [FB:km]"
          },
          "SO:0000513": {
            "name": "J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000514": {
            "name": "J_nonamer",
            "def": "9 nucleotide recombination site (e.g. GGTTTTTGT), part of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000515": {
            "name": "J_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACAGTG), part of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000516": {
            "name": "pseudogenic_transcript",
            "def": "A non functional descendant of a transcript, part of a pseudogene. [SO:ke]"
          },
          "SO:0000517": {
            "name": "J_spacer",
            "def": "12 or 23 nucleotide spacer between the J-nonamer and the J-heptamer of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000518": {
            "name": "V_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000519": {
            "name": "V_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000520": {
            "name": "V_VDJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000521": {
            "name": "V_VDJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one VDJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000522": {
            "name": "V_VDJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000523": {
            "name": "V_VJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000524": {
            "name": "V_VJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one VJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000525": {
            "name": "V_VJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000526": {
            "name": "V_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one V-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000527": {
            "name": "V_D_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000528": {
            "name": "V_D_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000529": {
            "name": "V_D_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000530": {
            "name": "V_D_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000531": {
            "name": "V_D_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one D-gene and one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000532": {
            "name": "V_D_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one D-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000533": {
            "name": "V_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACAGTG), part of V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000534": {
            "name": "V_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000535": {
            "name": "V_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000536": {
            "name": "V_nonamer",
            "def": "9 nucleotide recombination site (e.g. ACAAAAACC), part of V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000537": {
            "name": "V_spacer",
            "def": "12 or 23 nucleotide spacer between the V-heptamer and the V-nonamer of a V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000538": {
            "name": "V_gene_recombination_feature",
            "def": "Recombination signal including V-heptamer, V-spacer and V-nonamer in 3' of V-region of a V-gene or V-sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000539": {
            "name": "DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000540": {
            "name": "DJ_J_C_cluster",
            "def": "Genomic DNA in rearranged configuration including at least one D-J-GENE, one J-GENE and one C-GENE. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000541": {
            "name": "VDJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000542": {
            "name": "V_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000543": {
            "name": "alternately_spliced_gene_encoding_greater_than_one_transcript"
          },
          "SO:0000544": {
            "name": "helitron",
            "def": "A rolling circle transposon. Autonomous helitrons encode a 5'-to-3' DNA helicase and nuclease/ligase similar to those encoded by known rolling-circle replicons. [http://www.pnas.org/cgi/content/full/100/11/6569]"
          },
          "SO:0000545": {
            "name": "recoding_pseudoknot",
            "def": "The pseudoknots involved in recoding are unique in that, as they play their role as a structure, they are immediately unfolded and their now linear sequence serves as a template for decoding. [http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=33937]"
          },
          "SO:0000546": {
            "name": "designed_sequence"
          },
          "SO:0000547": {
            "name": "inversion_derived_bipartite_duplication",
            "def": "A chromosome generated by recombination between two inversions; there is a duplication at each end of the inversion. [FB:km]"
          },
          "SO:0000548": {
            "name": "gene_with_edited_transcript",
            "def": "A gene that encodes a transcript that is edited. [SO:xp]"
          },
          "SO:0000549": {
            "name": "inversion_derived_duplication_plus_aneuploid",
            "def": "A chromosome generated by recombination between two inversions; has a duplication at one end and presumed to have a deficiency or duplication at the other end of the inversion. [FB:km]"
          },
          "SO:0000550": {
            "name": "aneuploid_chromosome",
            "def": "A chromosome structural variation whereby either a chromosome exists in addition to the normal chromosome complement or is lacking. [SO:ke]"
          },
          "SO:0000551": {
            "name": "polyA_signal_sequence",
            "def": "The recognition sequence necessary for endonuclease cleavage of an RNA transcript that is followed by polyadenylation; consensus=AATAAA. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000552": {
            "name": "Shine_Dalgarno_sequence",
            "def": "A region in the 5' UTR that pairs with the 16S rRNA during formation of the preinitiation complex. [SO:jh]"
          },
          "SO:0000553": {
            "name": "polyA_site",
            "def": "The site on an RNA transcript to which will be added adenine residues by post-transcriptional polyadenylation. The boundary between the UTR and the polyA sequence. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000554": {
            "name": "assortment_derived_deficiency_plus_duplication"
          },
          "SO:0000555": {
            "name": "five_prime_clip",
            "def": "5' most region of a precursor transcript that is clipped off during processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000556": {
            "name": "five_prime_D_recombination_signal_sequence",
            "def": "Recombination signal of an immunoglobulin/T-cell receptor gene, including the 5' D-nonamer (SO:0000497), 5' D-spacer (SO:0000498), and 5' D-heptamer (SO:0000396) in 5' of the D-region of a D-gene, or in 5' of the D-region of DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000557": {
            "name": "three_prime_clip",
            "def": "3'-most region of a precursor transcript that is clipped off during processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000558": {
            "name": "C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene including more than one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000559": {
            "name": "D_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one D-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000560": {
            "name": "D_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one D-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000561": {
            "name": "heptamer_of_recombination_feature_of_vertebrate_immune_system_gene",
            "def": "Seven nucleotide recombination site (e.g. CACAGTG), part of V-gene, D-gene or J-gene recombination feature of an immunoglobulin or T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000562": {
            "name": "nonamer_of_recombination_feature_of_vertebrate_immune_system_gene"
          },
          "SO:0000563": {
            "name": "vertebrate_immune_system_gene_recombination_spacer"
          },
          "SO:0000564": {
            "name": "V_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000565": {
            "name": "V_VDJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000566": {
            "name": "V_VJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000567": {
            "name": "inversion_derived_aneuploid_chromosome",
            "def": "A chromosome may be generated by recombination between two inversions; presumed to have a deficiency or duplication at each end of the inversion. [FB:km]"
          },
          "SO:0000568": {
            "name": "bidirectional_promoter",
            "def": "An unregulated promoter that allows continuous expression. [SO:ke]"
          },
          "SO:0000569": {
            "name": "retrotransposed",
            "def": "An attribute of a feature that occurred as the product of a reverse transcriptase mediated event. [SO:ke]"
          },
          "SO:0000570": {
            "name": "three_prime_D_recombination_signal_sequence",
            "def": "Recombination signal of an immunoglobulin/T-cell receptor gene, including the 3' D-heptamer (SO:0000493), 3' D-spacer, and 3' D-nonamer (SO:0000494) in 3' of the D-region of a D-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000571": {
            "name": "miRNA_encoding"
          },
          "SO:0000572": {
            "name": "DJ_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in partially rearranged genomic DNA including D-J-region with 5' UTR and 3' UTR, also designated as D-J-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000573": {
            "name": "rRNA_encoding"
          },
          "SO:0000574": {
            "name": "VDJ_gene_segment",
            "def": "Rearranged genomic DNA of immunoglobulin/T-cell receptor gene including L-part1, V-intron and V-D-J-exon, with the 5'UTR (SO:0000204) and 3'UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000575": {
            "name": "scRNA_encoding"
          },
          "SO:0000576": {
            "name": "VJ_gene_segment",
            "def": "Rearranged genomic DNA of immunoglobulin/T-cell receptor gene including L-part1, V-intron and V-J-exon, with the 5'UTR (SO:0000204) and 3'UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000577": {
            "name": "centromere",
            "def": "A region of chromosome where the spindle fibers attach during mitosis and meiosis. [SO:ke]"
          },
          "SO:0000578": {
            "name": "snoRNA_encoding"
          },
          "SO:0000579": {
            "name": "edited_transcript_feature",
            "def": "A locatable feature on a transcript that is edited. [SO:ma]"
          },
          "SO:0000580": {
            "name": "methylation_guide_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a methylation guide small nucleolar RNA. [SO:ke]"
          },
          "SO:0000581": {
            "name": "cap",
            "def": "A structure consisting of a 7-methylguanosine in 5'-5' triphosphate linkage with the first nucleotide of an mRNA. It is added post-transcriptionally, and is not encoded in the DNA. [http://seqcore.brcf.med.umich.edu/doc/educ/dnapr/mbglossary/mbgloss.html]"
          },
          "SO:0000582": {
            "name": "rRNA_cleavage_snoRNA_primary_transcript",
            "def": "A primary transcript encoding an rRNA cleavage snoRNA. [SO:ke]"
          },
          "SO:0000583": {
            "name": "pre_edited_region",
            "def": "The region of a transcript that will be edited. [http://dna.kdna.ucla.edu/rna/index.aspx]"
          },
          "SO:0000584": {
            "name": "tmRNA",
            "def": "A tmRNA liberates a mRNA from a stalled ribosome. To accomplish this part of the tmRNA is used as a reading frame that ends in a translation stop signal. The broken mRNA is replaced in the ribosome by the tmRNA and translation of the tmRNA leads to addition of a proteolysis tag to the incomplete protein enabling recognition by a protease. Recently a number of permuted tmRNAs genes have been found encoded in two parts. TmRNAs have been identified in eubacteria and some chloroplasts but are absent from archeal and Eukaryote nuclear genomes. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00023]"
          },
          "SO:0000585": {
            "name": "C_D_box_snoRNA_encoding"
          },
          "SO:0000586": {
            "name": "tmRNA_primary_transcript",
            "def": "A primary transcript encoding a tmRNA (SO:0000584). [SO:ke]"
          },
          "SO:0000587": {
            "name": "group_I_intron",
            "def": "Group I catalytic introns are large self-splicing ribozymes. They catalyze their own excision from mRNA, tRNA and rRNA precursors in a wide range of organisms. The core secondary structure consists of 9 paired regions (P1-P9). These fold to essentially two domains, the P4-P6 domain (formed from the stacking of P5, P4, P6 and P6a helices) and the P3-P9 domain (formed from the P8, P3, P7 and P9 helices). Group I catalytic introns often have long ORFs inserted in loop regions. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00028]"
          },
          "SO:0000588": {
            "name": "autocatalytically_spliced_intron",
            "def": "A self spliced intron. [SO:ke]"
          },
          "SO:0000589": {
            "name": "SRP_RNA_primary_transcript",
            "def": "A primary transcript encoding a signal recognition particle RNA. [SO:ke]"
          },
          "SO:0000590": {
            "name": "SRP_RNA",
            "def": "The signal recognition particle (SRP) is a universally conserved ribonucleoprotein. It is involved in the co-translational targeting of proteins to membranes. The eukaryotic SRP consists of a 300-nucleotide 7S RNA and six proteins: SRPs 72, 68, 54, 19, 14, and 9. Archaeal SRP consists of a 7S RNA and homologues of the eukaryotic SRP19 and SRP54 proteins. In most eubacteria, the SRP consists of a 4.5S RNA and the Ffh protein (a homologue of the eukaryotic SRP54 protein). Eukaryotic and archaeal 7S RNAs have very similar secondary structures, with eight helical elements. These fold into the Alu and S domains, separated by a long linker region. Eubacterial SRP is generally a simpler structure, with the M domain of Ffh bound to a region of the 4.5S RNA that corresponds to helix 8 of the eukaryotic and archaeal SRP S domain. Some Gram-positive bacteria (e.g. Bacillus subtilis), however, have a larger SRP RNA that also has an Alu domain. The Alu domain is thought to mediate the peptide chain elongation retardation function of the SRP. The universally conserved helix which interacts with the SRP54/Ffh M domain mediates signal sequence recognition. In eukaryotes and archaea, the SRP19-helix 6 complex is thought to be involved in SRP assembly and stabilizes helix 8 for SRP54 binding. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00017]"
          },
          "SO:0000591": {
            "name": "pseudoknot",
            "def": "A tertiary structure in RNA where nucleotides in a loop form base pairs with a region of RNA downstream of the loop. [RSC:cb]"
          },
          "SO:0000592": {
            "name": "H_pseudoknot",
            "def": "A pseudoknot which contains two stems and at least two loops. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=10334330&dopt=Abstract]"
          },
          "SO:0000593": {
            "name": "C_D_box_snoRNA",
            "def": "Most box C/D snoRNAs also contain long (>10 nt) sequences complementary to rRNA. Boxes C and D, as well as boxes C' and D', are usually located in close proximity, and form a structure known as the box C/D motif. This motif is important for snoRNA stability, processing, nucleolar targeting and function. A small number of box C/D snoRNAs are involved in rRNA processing; most, however, are known or predicted to serve as guide RNAs in ribose methylation of rRNA. Targeting involves direct base pairing of the snoRNA at the rRNA site to be modified and selection of a rRNA nucleotide a fixed distance from box D or D'. [http://www.bio.umass.edu/biochem/rna-sequence/Yeast_snoRNA_Database/snoRNA_DataBase.html]"
          },
          "SO:0000594": {
            "name": "H_ACA_box_snoRNA",
            "def": "Members of the box H/ACA family contain an ACA triplet, exactly 3 nt upstream from the 3' end and an H-box in a hinge region that links two structurally similar functional domains of the molecule. Both boxes are important for snoRNA biosynthesis and function. A few box H/ACA snoRNAs are involved in rRNA processing; most others are known or predicted to participate in selection of uridine nucleosides in rRNA to be converted to pseudouridines. Site selection is mediated by direct base pairing of the snoRNA with rRNA through one or both targeting domains. [http://www.bio.umass.edu/biochem/rna-sequence/Yeast_snoRNA_Database/snoRNA_DataBase.html]"
          },
          "SO:0000595": {
            "name": "C_D_box_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar RNA of the box C/D family. [SO:ke]"
          },
          "SO:0000596": {
            "name": "H_ACA_box_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar RNA of the box H/ACA family. [SO:ke]"
          },
          "SO:0000597": {
            "name": "transcript_edited_by_U_insertion/deletion",
            "def": "The insertion and deletion of uridine (U) residues, usually within coding regions of mRNA transcripts of cryptogenes in the mitochondrial genome of kinetoplastid protozoa. [http://www.rna.ucla.edu/index.html]"
          },
          "SO:0000598": {
            "name": "edited_by_C_insertion_and_dinucleotide_insertion"
          },
          "SO:0000599": {
            "name": "edited_by_C_to_U_substitution"
          },
          "SO:0000600": {
            "name": "edited_by_A_to_I_substitution"
          },
          "SO:0000601": {
            "name": "edited_by_G_addition"
          },
          "SO:0000602": {
            "name": "guide_RNA",
            "def": "A short 3'-uridylated RNA that can form a duplex (except for its post-transcriptionally added oligo_U tail (SO:0000609)) with a stretch of mature edited mRNA. [http://www.rna.ucla.edu/index.html]"
          },
          "SO:0000603": {
            "name": "group_II_intron",
            "def": "Group II introns are found in rRNA, tRNA and mRNA of organelles in fungi, plants and protists, and also in mRNA in bacteria. They are large self-splicing ribozymes and have 6 structural domains (usually designated dI to dVI). A subset of group II introns also encode essential splicing proteins in intronic ORFs. The length of these introns can therefore be up to 3kb. Splicing occurs in almost identical fashion to nuclear pre-mRNA splicing with two transesterification steps. The 2' hydroxyl of a bulged adenosine in domain VI attacks the 5' splice site, followed by nucleophilic attack on the 3' splice site by the 3' OH of the upstream exon. Protein machinery is required for splicing in vivo, and long range intron to intron and intron-exon interactions are important for splice site positioning. Group II introns are further sub-classified into groups IIA and IIB which differ in splice site consensus, distance of bulged A from 3' splice site, some tertiary interactions, and intronic ORF phylogeny. [http://www.sanger.ac.uk/Software/Rfam/browse/index.shtml]"
          },
          "SO:0000604": {
            "name": "editing_block",
            "def": "Edited mRNA sequence mediated by a single guide RNA (SO:0000602). [http://dna.kdna.ucla.edu/rna/index.aspx]"
          },
          "SO:0000605": {
            "name": "intergenic_region",
            "def": "A region containing or overlapping no genes that is bounded on either side by a gene, or bounded by a gene and the end of the chromosome. [SO:cjm]"
          },
          "SO:0000606": {
            "name": "editing_domain",
            "def": "Edited mRNA sequence mediated by two or more overlapping guide RNAs (SO:0000602). [http://dna.kdna.ucla.edu/rna/index.aspx]"
          },
          "SO:0000607": {
            "name": "unedited_region",
            "def": "The region of an edited transcript that will not be edited. [http://dna.kdna.ucla.edu/rna/index.aspx]"
          },
          "SO:0000608": {
            "name": "H_ACA_box_snoRNA_encoding"
          },
          "SO:0000609": {
            "name": "oligo_U_tail",
            "def": "The string of non-encoded U's at the 3' end of a guide RNA (SO:0000602). [http://www.rna.ucla.edu/]"
          },
          "SO:0000610": {
            "name": "polyA_sequence",
            "def": "Sequence of about 100 nucleotides of A added to the 3' end of most eukaryotic mRNAs. [SO:ke]"
          },
          "SO:0000611": {
            "name": "branch_site",
            "def": "A pyrimidine rich sequence near the 3' end of an intron to which the 5'end becomes covalently bound during nuclear splicing. The resulting structure resembles a lariat. [SO:ke]"
          },
          "SO:0000612": {
            "name": "polypyrimidine_tract",
            "def": "The polypyrimidine tract is one of the cis-acting sequence elements directing intron removal in pre-mRNA splicing. [http://nar.oupjournals.org/cgi/content/full/25/4/888]"
          },
          "SO:0000613": {
            "name": "bacterial_RNApol_promoter",
            "def": "A DNA sequence to which bacterial RNA polymerase binds, to begin transcription. [SO:ke]"
          },
          "SO:0000614": {
            "name": "bacterial_terminator",
            "def": "A terminator signal for bacterial transcription. [SO:ke]"
          },
          "SO:0000615": {
            "name": "terminator_of_type_2_RNApol_III_promoter",
            "def": "A terminator signal for RNA polymerase III transcription. [SO:ke]"
          },
          "SO:0000616": {
            "name": "transcription_end_site",
            "def": "The base where transcription ends. [SO:ke]"
          },
          "SO:0000617": {
            "name": "RNApol_III_promoter_type_1"
          },
          "SO:0000618": {
            "name": "RNApol_III_promoter_type_2"
          },
          "SO:0000619": {
            "name": "A_box",
            "def": "A variably distant linear promoter region recognized by TFIIIC, with consensus sequence TGGCnnAGTGG. [SO:ke]"
          },
          "SO:0000620": {
            "name": "B_box",
            "def": "A variably distant linear promoter region recognized by TFIIIC, with consensus sequence AGGTTCCAnnCC. [SO:ke]"
          },
          "SO:0000621": {
            "name": "RNApol_III_promoter_type_3"
          },
          "SO:0000622": {
            "name": "C_box",
            "def": "An RNA polymerase III type 1 promoter with consensus sequence CAnnCCn. [SO:ke]"
          },
          "SO:0000623": {
            "name": "snRNA_encoding"
          },
          "SO:0000624": {
            "name": "telomere",
            "def": "A specific structure at the end of a linear chromosome, required for the integrity and maintenance of the end. [SO:ma]"
          },
          "SO:0000625": {
            "name": "silencer",
            "def": "A regulatory region which upon binding of transcription factors, suppress the transcription of the gene or genes they control. [SO:ke]"
          },
          "SO:0000626": {
            "name": "chromosomal_regulatory_element"
          },
          "SO:0000627": {
            "name": "insulator",
            "def": "A transcriptional cis regulatory region that when located between a CM and a gene's promoter prevents the CRM from modulating that genes expression. [SO:regcreative]"
          },
          "SO:0000628": {
            "name": "chromosomal_structural_element"
          },
          "SO:0000629": {
            "name": "five_prime_open_reading_frame"
          },
          "SO:0000630": {
            "name": "upstream_AUG_codon",
            "def": "A start codon upstream of the ORF. [SO:ke]"
          },
          "SO:0000631": {
            "name": "polycistronic_primary_transcript",
            "def": "A primary transcript encoding for more than one gene product. [SO:ke]"
          },
          "SO:0000632": {
            "name": "monocistronic_primary_transcript",
            "def": "A primary transcript encoding for one gene product. [SO:ke]"
          },
          "SO:0000633": {
            "name": "monocistronic_mRNA",
            "def": "An mRNA with either a single protein product, or for which the regions encoding all its protein products overlap. [SO:rd]"
          },
          "SO:0000634": {
            "name": "polycistronic_mRNA",
            "def": "An mRNA that encodes multiple proteins from at least two non-overlapping regions. [SO:rd]"
          },
          "SO:0000635": {
            "name": "mini_exon_donor_RNA",
            "def": "A primary transcript that donates the spliced leader to other mRNA. [SO:ke]"
          },
          "SO:0000636": {
            "name": "spliced_leader_RNA"
          },
          "SO:0000637": {
            "name": "engineered_plasmid",
            "def": "A plasmid that is engineered. [SO:xp]"
          },
          "SO:0000638": {
            "name": "transcribed_spacer_region",
            "def": "Part of an rRNA transcription unit that is transcribed but discarded during maturation, not giving rise to any part of rRNA. [http://oregonstate.edu/instruction/bb492/general/glossary.html]"
          },
          "SO:0000639": {
            "name": "internal_transcribed_spacer_region",
            "def": "Non-coding regions of DNA sequence that separate genes coding for the 28S, 5.8S, and 18S ribosomal RNAs. [SO:ke]"
          },
          "SO:0000640": {
            "name": "external_transcribed_spacer_region",
            "def": "Non-coding regions of DNA that precede the sequence that codes for the ribosomal RNA. [SO:ke]"
          },
          "SO:0000641": {
            "name": "tetranucleotide_repeat_microsatellite_feature"
          },
          "SO:0000642": {
            "name": "SRP_RNA_encoding"
          },
          "SO:0000643": {
            "name": "minisatellite",
            "def": "A repeat region containing tandemly repeated sequences having a unit length of 10 to 40 bp. [http://www.informatics.jax.org/silver/glossary.shtml]"
          },
          "SO:0000644": {
            "name": "antisense_RNA",
            "def": "Antisense RNA is RNA that is transcribed from the coding, rather than the template, strand of DNA. It is therefore complementary to mRNA. [SO:ke]"
          },
          "SO:0000645": {
            "name": "antisense_primary_transcript",
            "def": "The reverse complement of the primary transcript. [SO:ke]"
          },
          "SO:0000646": {
            "name": "siRNA",
            "def": "A small RNA molecule that is the product of a longer exogenous or endogenous dsRNA, which is either a bimolecular duplex or very long hairpin, processed (via the Dicer pathway) such that numerous siRNAs accumulate from both strands of the dsRNA. SRNAs trigger the cleavage of their target molecules. [PMID:12592000]"
          },
          "SO:0000647": {
            "name": "miRNA_primary_transcript",
            "def": "A primary transcript encoding a micro RNA. [SO:ke]"
          },
          "SO:0000650": {
            "name": "small_subunit_rRNA",
            "def": "Ribosomal RNA transcript that structures the small subunit of the ribosome. [SO:ke]"
          },
          "SO:0000651": {
            "name": "large_subunit_rRNA",
            "def": "Ribosomal RNA transcript that structures the large subunit of the ribosome. [SO:ke]"
          },
          "SO:0000652": {
            "name": "rRNA_5S",
            "def": "5S ribosomal RNA (5S rRNA) is a component of the large ribosomal subunit in both prokaryotes and eukaryotes. In eukaryotes, it is synthesised by RNA polymerase III (the other eukaryotic rRNAs are cleaved from a 45S precursor synthesised by RNA polymerase I). In Xenopus oocytes, it has been shown that fingers 4-7 of the nine-zinc finger transcription factor TFIIIA can bind to the central region of 5S RNA. Thus, in addition to positively regulating 5S rRNA transcription, TFIIIA also stabilizes 5S rRNA until it is required for transcription. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00001]"
          },
          "SO:0000653": {
            "name": "rRNA_28S",
            "def": "A component of the large ribosomal subunit. [SO:ke]"
          },
          "SO:0000654": {
            "name": "maxicircle_gene",
            "def": "A mitochondrial gene located in a maxicircle. [SO:xp]"
          },
          "SO:0000655": {
            "name": "ncRNA",
            "def": "An RNA transcript that does not encode for a protein rather the RNA molecule is the gene product. [SO:ke]"
          },
          "SO:0000656": {
            "name": "stRNA_encoding"
          },
          "SO:0000657": {
            "name": "repeat_region",
            "def": "A region of sequence containing one or more repeat units. [SO:ke]"
          },
          "SO:0000658": {
            "name": "dispersed_repeat",
            "def": "A repeat that is located at dispersed sites in the genome. [SO:ke]"
          },
          "SO:0000659": {
            "name": "tmRNA_encoding"
          },
          "SO:0000660": {
            "name": "DNA_invertase_target_sequence"
          },
          "SO:0000661": {
            "name": "intron_attribute"
          },
          "SO:0000662": {
            "name": "spliceosomal_intron",
            "def": "An intron which is spliced by the spliceosome. [SO:ke]"
          },
          "SO:0000663": {
            "name": "tRNA_encoding"
          },
          "SO:0000664": {
            "name": "introgressed_chromosome_region"
          },
          "SO:0000665": {
            "name": "monocistronic_transcript",
            "def": "A transcript that is monocistronic. [SO:xp]"
          },
          "SO:0000666": {
            "name": "mobile_intron",
            "def": "An intron (mitochondrial, chloroplast, nuclear or prokaryotic) that encodes a double strand sequence specific endonuclease allowing for mobility. [SO:ke]"
          },
          "SO:0000667": {
            "name": "insertion",
            "def": "The sequence of one or more nucleotides added between two adjacent nucleotides in the sequence. [SO:ke]"
          },
          "SO:0000668": {
            "name": "EST_match",
            "def": "A match against an EST sequence. [SO:ke]"
          },
          "SO:0000669": {
            "name": "sequence_rearrangement_feature"
          },
          "SO:0000670": {
            "name": "chromosome_breakage_sequence",
            "def": "A sequence within the micronuclear DNA of ciliates at which chromosome breakage and telomere addition occurs during nuclear differentiation. [SO:ma]"
          },
          "SO:0000671": {
            "name": "internal_eliminated_sequence",
            "def": "A sequence eliminated from the genome of ciliates during nuclear differentiation. [SO:ma]"
          },
          "SO:0000672": {
            "name": "macronucleus_destined_segment",
            "def": "A sequence that is conserved, although rearranged relative to the micronucleus, in the macronucleus of a ciliate genome. [SO:ma]"
          },
          "SO:0000673": {
            "name": "transcript",
            "def": "An RNA synthesized on a DNA or RNA template by an RNA polymerase. [SO:ma]"
          },
          "SO:0000674": {
            "name": "non_canonical_splice_site",
            "def": "A splice site where the donor and acceptor sites differ from the canonical form. [SO:ke]"
          },
          "SO:0000675": {
            "name": "canonical_splice_site",
            "def": "The major class of splice site with dinucleotides GT and AG for donor and acceptor sites, respectively. [SO:ke]"
          },
          "SO:0000676": {
            "name": "canonical_three_prime_splice_site",
            "def": "The canonical 3' splice site has the sequence \\AG\\. [SO:ke]"
          },
          "SO:0000677": {
            "name": "canonical_five_prime_splice_site",
            "def": "The canonical 5' splice site has the sequence \\GT\\. [SO:ke]"
          },
          "SO:0000678": {
            "name": "non_canonical_three_prime_splice_site",
            "def": "A 3' splice site that does not have the sequence \\AG\\. [SO:ke]"
          },
          "SO:0000679": {
            "name": "non_canonical_five_prime_splice_site",
            "def": "A 5' splice site which does not have the sequence \\GT\\. [SO:ke]"
          },
          "SO:0000680": {
            "name": "non_canonical_start_codon",
            "def": "A start codon that is not the usual AUG sequence. [SO:ke]"
          },
          "SO:0000681": {
            "name": "aberrant_processed_transcript",
            "def": "A transcript that has been processed \\incorrectly\\, for example by the failure of splicing of one or more exons. [SO:ke]"
          },
          "SO:0000682": {
            "name": "splicing_feature"
          },
          "SO:0000683": {
            "name": "exonic_splice_enhancer",
            "def": "Exonic splicing enhancers (ESEs) facilitate exon definition by assisting in the recruitment of splicing factors to the adjacent intron. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=12403462&dopt=Abstract]"
          },
          "SO:0000684": {
            "name": "nuclease_sensitive_site",
            "def": "A region of nucleotide sequence targeted by a nuclease enzyme. [SO:ma]"
          },
          "SO:0000685": {
            "name": "DNAseI_hypersensitive_site"
          },
          "SO:0000686": {
            "name": "translocation_element",
            "def": "A chromosomal translocation whereby the chromosomes carrying non-homologous centromeres may be recovered independently. These chromosomes are described as translocation elements. This occurs for some translocations, particularly but not exclusively, reciprocal translocations. [SO:ma]"
          },
          "SO:0000687": {
            "name": "deletion_junction",
            "def": "The space between two bases in a sequence which marks the position where a deletion has occurred. [SO:ke]"
          },
          "SO:0000688": {
            "name": "golden_path",
            "def": "A set of subregions selected from sequence contigs which when concatenated form a nonredundant linear sequence. [SO:ls]"
          },
          "SO:0000689": {
            "name": "cDNA_match",
            "def": "A match against cDNA sequence. [SO:ke]"
          },
          "SO:0000690": {
            "name": "gene_with_polycistronic_transcript",
            "def": "A gene that encodes a polycistronic transcript. [SO:xp]"
          },
          "SO:0000691": {
            "name": "cleaved_initiator_methionine",
            "def": "The initiator methionine that has been cleaved from a mature polypeptide sequence. [EBIBS:GAR]"
          },
          "SO:0000692": {
            "name": "gene_with_dicistronic_transcript",
            "def": "A gene that encodes a dicistronic transcript. [SO:xp]"
          },
          "SO:0000693": {
            "name": "gene_with_recoded_mRNA",
            "def": "A gene that encodes an mRNA that is recoded. [SO:xp]"
          },
          "SO:0000694": {
            "name": "SNP",
            "def": "SNPs are single base pair positions in genomic DNA at which different sequence alternatives exist in normal individuals in some population(s), wherein the least frequent variant has an abundance of 1% or greater. [SO:cb]"
          },
          "SO:0000695": {
            "name": "reagent",
            "def": "A sequence used in experiment. [SO:ke]"
          },
          "SO:0000696": {
            "name": "oligo",
            "def": "A short oligonucleotide sequence, of length on the order of 10's of bases; either single or double stranded. [SO:ma]"
          },
          "SO:0000697": {
            "name": "gene_with_stop_codon_read_through",
            "def": "A gene that encodes a transcript with stop codon readthrough. [SO:xp]"
          },
          "SO:0000698": {
            "name": "gene_with_stop_codon_redefined_as_pyrrolysine",
            "def": "A gene encoding an mRNA that has the stop codon redefined as pyrrolysine. [SO:xp]"
          },
          "SO:0000699": {
            "name": "junction",
            "def": "A sequence_feature with an extent of zero. [SO:ke]"
          },
          "SO:0000700": {
            "name": "remark",
            "def": "A comment about the sequence. [SO:ke]"
          },
          "SO:0000701": {
            "name": "possible_base_call_error",
            "def": "A region of sequence where the validity of the base calling is questionable. [SO:ke]"
          },
          "SO:0000702": {
            "name": "possible_assembly_error",
            "def": "A region of sequence where there may have been an error in the assembly. [SO:ke]"
          },
          "SO:0000703": {
            "name": "experimental_result_region",
            "def": "A region of sequence implicated in an experimental result. [SO:ke]"
          },
          "SO:0000704": {
            "name": "gene",
            "def": "A region (or regions) that includes all of the sequence elements necessary to encode a functional transcript. A gene may include regulatory regions, transcribed regions and/or other functional sequence regions. [SO:immuno_workshop]"
          },
          "SO:0000705": {
            "name": "tandem_repeat",
            "def": "Two or more adjacent copies of a region (of length greater than 1). [SO:ke]"
          },
          "SO:0000706": {
            "name": "trans_splice_acceptor_site",
            "def": "The 3' splice site of the acceptor primary transcript. [SO:ke]"
          },
          "SO:0000707": {
            "name": "trans_splice_donor_site",
            "def": "The 5' five prime splice site region of the donor RNA. [SO:ke]"
          },
          "SO:0000708": {
            "name": "SL1_acceptor_site",
            "def": "A trans_splicing_acceptor_site which appends the 22nt SL1 RNA leader sequence to the 5' end of most mRNAs. [SO:nlw]"
          },
          "SO:0000709": {
            "name": "SL2_acceptor_site",
            "def": "A trans_splicing_acceptor_site which appends the 22nt SL2 RNA leader sequence to the 5' end of mRNAs. SL2 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0000710": {
            "name": "gene_with_stop_codon_redefined_as_selenocysteine",
            "def": "A gene encoding an mRNA that has the stop codon redefined as selenocysteine. [SO:xp]"
          },
          "SO:0000711": {
            "name": "gene_with_mRNA_recoded_by_translational_bypass",
            "def": "A gene with mRNA recoded by translational bypass. [SO:xp]"
          },
          "SO:0000712": {
            "name": "gene_with_transcript_with_translational_frameshift",
            "def": "A gene encoding a transcript that has a translational frameshift. [SO:xp]"
          },
          "SO:0000713": {
            "name": "DNA_motif",
            "def": "A motif that is active in the DNA form of the sequence. [SO:ke]"
          },
          "SO:0000714": {
            "name": "nucleotide_motif",
            "def": "A region of nucleotide sequence corresponding to a known motif. [SO:ke]"
          },
          "SO:0000715": {
            "name": "RNA_motif",
            "def": "A motif that is active in RNA sequence. [SO:ke]"
          },
          "SO:0000716": {
            "name": "dicistronic_mRNA",
            "def": "An mRNA that has the quality dicistronic. [SO:ke]"
          },
          "SO:0000717": {
            "name": "reading_frame",
            "def": "A nucleic acid sequence that when read as sequential triplets, has the potential of encoding a sequential string of amino acids. It need not contain the start or stop codon. [SGD:rb]"
          },
          "SO:0000718": {
            "name": "blocked_reading_frame",
            "def": "A reading_frame that is interrupted by one or more stop codons; usually identified through inter-genomic sequence comparisons. [SGD:rb]"
          },
          "SO:0000719": {
            "name": "ultracontig",
            "def": "An ordered and oriented set of scaffolds based on somewhat weaker sets of inferential evidence such as one set of mate pair reads together with supporting evidence from ESTs or location of markers from SNP or microsatellite maps, or cytogenetic localization of contained markers. [FB:WG]"
          },
          "SO:0000720": {
            "name": "foreign_transposable_element",
            "def": "A transposable element that is foreign. [SO:ke]"
          },
          "SO:0000721": {
            "name": "gene_with_dicistronic_primary_transcript",
            "def": "A gene that encodes a dicistronic primary transcript. [SO:xp]"
          },
          "SO:0000722": {
            "name": "gene_with_dicistronic_mRNA",
            "def": "A gene that encodes a polycistronic mRNA. [SO:xp]"
          },
          "SO:0000723": {
            "name": "iDNA",
            "def": "Genomic sequence removed from the genome, as a normal event, by a process of recombination. [SO:ma]"
          },
          "SO:0000724": {
            "name": "oriT",
            "def": "A region of a DNA molecule where transfer is initiated during the process of conjugation or mobilization. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000725": {
            "name": "transit_peptide",
            "def": "The transit_peptide is a short region at the N-terminus of the peptide that directs the protein to an organelle (chloroplast, mitochondrion, microbody or cyanelle). [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000726": {
            "name": "repeat_unit",
            "def": "The simplest repeated component of a repeat region. A single repeat. [SO:ke]"
          },
          "SO:0000727": {
            "name": "CRM",
            "def": "A regulatory region where transcription factor binding sites clustered to regulate various aspects of transcription activities. (CRMs can be located a few kb to hundred kb upstream of the basal promoter, in the coding sequence, within introns, or in the downstream 3'UTR sequences, as well as on different chromosome). A single gene can be regulated by multiple CRMs to give precise control of its spatial and temporal expression. CRMs function as nodes in large, intertwined regulatory network. [PMID:19660565, SO:SG]"
          },
          "SO:0000728": {
            "name": "intein",
            "def": "A region of a peptide that is able to excise itself and rejoin the remaining portions with a peptide bond. [SO:ke]"
          },
          "SO:0000729": {
            "name": "intein_containing",
            "def": "An attribute of protein-coding genes where the initial protein product contains an intein. [SO:ke]"
          },
          "SO:0000730": {
            "name": "gap",
            "def": "A gap in the sequence of known length. The unknown bases are filled in with N's. [SO:ke]"
          },
          "SO:0000731": {
            "name": "fragmentary",
            "def": "An attribute to describe a feature that is incomplete. [SO:ke]"
          },
          "SO:0000732": {
            "name": "predicted",
            "def": "An attribute describing an unverified region. [SO:ke]"
          },
          "SO:0000733": {
            "name": "feature_attribute",
            "def": "An attribute describing a located_sequence_feature. [SO:ke]"
          },
          "SO:0000734": {
            "name": "exemplar_mRNA",
            "def": "An exemplar is a representative cDNA sequence for each gene. The exemplar approach is a method that usually involves some initial clustering into gene groups and the subsequent selection of a representative from each gene group. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
          },
          "SO:0000735": {
            "name": "sequence_location"
          },
          "SO:0000736": {
            "name": "organelle_sequence"
          },
          "SO:0000737": {
            "name": "mitochondrial_sequence"
          },
          "SO:0000738": {
            "name": "nuclear_sequence"
          },
          "SO:0000739": {
            "name": "nucleomorphic_sequence"
          },
          "SO:0000740": {
            "name": "plastid_sequence"
          },
          "SO:0000741": {
            "name": "kinetoplast",
            "def": "A kinetoplast is an interlocked network of thousands of minicircles and tens of maxicircles, located near the base of the flagellum of some protozoan species. [PMID:8395055]"
          },
          "SO:0000742": {
            "name": "maxicircle",
            "def": "A maxicircle is a replicon, part of a kinetoplast, that contains open reading frames and replicates via a rolling circle method. [PMID:8395055]"
          },
          "SO:0000743": {
            "name": "apicoplast_sequence"
          },
          "SO:0000744": {
            "name": "chromoplast_sequence"
          },
          "SO:0000745": {
            "name": "chloroplast_sequence"
          },
          "SO:0000746": {
            "name": "cyanelle_sequence"
          },
          "SO:0000747": {
            "name": "leucoplast_sequence"
          },
          "SO:0000748": {
            "name": "proplastid_sequence"
          },
          "SO:0000749": {
            "name": "plasmid_location"
          },
          "SO:0000750": {
            "name": "amplification_origin",
            "def": "An origin_of_replication that is used for the amplification of a chromosomal nucleic acid sequence. [SO:ma]"
          },
          "SO:0000751": {
            "name": "proviral_location"
          },
          "SO:0000752": {
            "name": "gene_group_regulatory_region"
          },
          "SO:0000753": {
            "name": "clone_insert",
            "def": "The region of sequence that has been inserted and is being propagated by the clone. [SO:ke]"
          },
          "SO:0000754": {
            "name": "lambda_vector",
            "def": "The lambda bacteriophage is the vector for the linear lambda clone. The genes involved in the lysogenic pathway are removed from the from the viral DNA. Up to 25 kb of foreign DNA can then be inserted into the lambda genome. [ISBN:0-1767-2380-8]"
          },
          "SO:0000755": {
            "name": "plasmid_vector"
          },
          "SO:0000756": {
            "name": "cDNA",
            "def": "DNA synthesized by reverse transcriptase using RNA as a template. [SO:ma]"
          },
          "SO:0000757": {
            "name": "single_stranded_cDNA"
          },
          "SO:0000758": {
            "name": "double_stranded_cDNA"
          },
          "SO:0000759": {
            "name": "plasmid_clone"
          },
          "SO:0000760": {
            "name": "YAC_clone"
          },
          "SO:0000761": {
            "name": "phagemid_clone"
          },
          "SO:0000762": {
            "name": "PAC_clone"
          },
          "SO:0000763": {
            "name": "fosmid_clone"
          },
          "SO:0000764": {
            "name": "BAC_clone"
          },
          "SO:0000765": {
            "name": "cosmid_clone"
          },
          "SO:0000766": {
            "name": "pyrrolysyl_tRNA",
            "def": "A tRNA sequence that has a pyrrolysine anticodon, and a 3' pyrrolysine binding region. [SO:ke]"
          },
          "SO:0000767": {
            "name": "clone_insert_start"
          },
          "SO:0000768": {
            "name": "episome",
            "def": "A plasmid that may integrate with a chromosome. [SO:ma]"
          },
          "SO:0000769": {
            "name": "tmRNA_coding_piece",
            "def": "The region of a two-piece tmRNA that bears the reading frame encoding the proteolysis tag. The tmRNA gene undergoes circular permutation in some groups of bacteria. Processing of the transcripts from such a gene leaves the mature tmRNA in two pieces, base-paired together. [doi:10.1093/nar/gkh795, Indiana:kw, issn:1362-4962]"
          },
          "SO:0000770": {
            "name": "tmRNA_acceptor_piece",
            "def": "The acceptor region of a two-piece tmRNA that when mature is charged at its 3' end with alanine. The tmRNA gene undergoes circular permutation in some groups of bacteria; processing of the transcripts from such a gene leaves the mature tmRNA in two pieces, base-paired together. [doi:10.1093/nar/gkh795, Indiana:kw]"
          },
          "SO:0000771": {
            "name": "QTL",
            "def": "A quantitative trait locus (QTL) is a polymorphic locus which contains alleles that differentially affect the expression of a continuously distributed phenotypic trait. Usually it is a marker described by statistical association to quantitative variation in the particular phenotypic trait that is thought to be controlled by the cumulative action of alleles at multiple loci. [http://rgd.mcw.edu/tu/qtls/]"
          },
          "SO:0000772": {
            "name": "genomic_island",
            "def": "A genomic island is an integrated mobile genetic element, characterized by size (over 10 Kb). It that has features that suggest a foreign origin. These can include nucleotide distribution (oligonucleotides signature, CG content etc.) that differs from the bulk of the chromosome and/or genes suggesting DNA mobility. [Phigo:at, SO:ke]"
          },
          "SO:0000773": {
            "name": "pathogenic_island",
            "def": "Mobile genetic elements that contribute to rapid changes in virulence potential. They are present on the genomes of pathogenic strains but absent from the genomes of non pathogenic members of the same or related species. [SO:ke]"
          },
          "SO:0000774": {
            "name": "metabolic_island",
            "def": "A transmissible element containing genes involved in metabolism, analogous to the pathogenicity islands of gram negative bacteria. [SO:ke]"
          },
          "SO:0000775": {
            "name": "adaptive_island",
            "def": "An adaptive island is a genomic island that provides an adaptive advantage to the host. [SO:ke]"
          },
          "SO:0000776": {
            "name": "symbiosis_island",
            "def": "A transmissible element containing genes involved in symbiosis, analogous to the pathogenicity islands of gram negative bacteria. [SO:ke]"
          },
          "SO:0000777": {
            "name": "pseudogenic_rRNA",
            "def": "A non functional descendant of an rRNA. [SO:ke]"
          },
          "SO:0000778": {
            "name": "pseudogenic_tRNA",
            "def": "A non functional descendent of a tRNA. [SO:ke]"
          },
          "SO:0000779": {
            "name": "engineered_episome",
            "def": "An episome that is engineered. [SO:xp]"
          },
          "SO:0000780": {
            "name": "transposable_element_attribute"
          },
          "SO:0000781": {
            "name": "transgenic",
            "def": "Attribute describing sequence that has been integrated with foreign sequence. [SO:ke]"
          },
          "SO:0000782": {
            "name": "natural",
            "def": "An attribute describing a feature that occurs in nature. [SO:ke]"
          },
          "SO:0000783": {
            "name": "engineered",
            "def": "An attribute to describe a region that was modified in vitro. [SO:ke]"
          },
          "SO:0000784": {
            "name": "foreign",
            "def": "An attribute to describe a region from another species. [SO:ke]"
          },
          "SO:0000785": {
            "name": "cloned_region"
          },
          "SO:0000786": {
            "name": "reagent_attribute"
          },
          "SO:0000787": {
            "name": "clone_attribute"
          },
          "SO:0000788": {
            "name": "cloned"
          },
          "SO:0000789": {
            "name": "validated",
            "def": "An attribute to describe a feature that has been proven. [SO:ke]"
          },
          "SO:0000790": {
            "name": "invalidated",
            "def": "An attribute describing a feature that is invalidated. [SO:ke]"
          },
          "SO:0000791": {
            "name": "cloned_genomic"
          },
          "SO:0000792": {
            "name": "cloned_cDNA"
          },
          "SO:0000793": {
            "name": "engineered_DNA"
          },
          "SO:0000794": {
            "name": "engineered_rescue_region",
            "def": "A rescue region that is engineered. [SO:xp]"
          },
          "SO:0000795": {
            "name": "rescue_mini_gene",
            "def": "A mini_gene that rescues. [SO:xp]"
          },
          "SO:0000796": {
            "name": "transgenic_transposable_element",
            "def": "TE that has been modified in vitro, including insertion of DNA derived from a source other than the originating TE. [FB:mc]"
          },
          "SO:0000797": {
            "name": "natural_transposable_element",
            "def": "TE that exists (or existed) in nature. [FB:mc]"
          },
          "SO:0000798": {
            "name": "engineered_transposable_element",
            "def": "TE that has been modified by manipulations in vitro. [FB:mc]"
          },
          "SO:0000799": {
            "name": "engineered_foreign_transposable_element",
            "def": "A transposable_element that is engineered and foreign. [FB:mc]"
          },
          "SO:0000800": {
            "name": "assortment_derived_duplication",
            "def": "A multi-chromosome duplication aberration generated by reassortment of other aberration components. [FB:gm]"
          },
          "SO:0000801": {
            "name": "assortment_derived_deficiency_plus_duplication",
            "def": "A multi-chromosome aberration generated by reassortment of other aberration components; presumed to have a deficiency and a duplication. [FB:gm]"
          },
          "SO:0000802": {
            "name": "assortment_derived_deficiency",
            "def": "A multi-chromosome deficiency aberration generated by reassortment of other aberration components. [FB:gm]"
          },
          "SO:0000803": {
            "name": "assortment_derived_aneuploid",
            "def": "A multi-chromosome aberration generated by reassortment of other aberration components; presumed to have a deficiency or a duplication. [FB:gm]"
          },
          "SO:0000804": {
            "name": "engineered_region",
            "def": "A region that is engineered. [SO:xp]"
          },
          "SO:0000805": {
            "name": "engineered_foreign_region",
            "def": "A region that is engineered and foreign. [SO:xp]"
          },
          "SO:0000806": {
            "name": "fusion"
          },
          "SO:0000807": {
            "name": "engineered_tag",
            "def": "A tag that is engineered. [SO:xp]"
          },
          "SO:0000808": {
            "name": "validated_cDNA_clone",
            "def": "A cDNA clone that has been validated. [SO:xp]"
          },
          "SO:0000809": {
            "name": "invalidated_cDNA_clone",
            "def": "A cDNA clone that is invalid. [SO:xp]"
          },
          "SO:0000810": {
            "name": "chimeric_cDNA_clone",
            "def": "A cDNA clone invalidated because it is chimeric. [SO:xp]"
          },
          "SO:0000811": {
            "name": "genomically_contaminated_cDNA_clone",
            "def": "A cDNA clone invalidated by genomic contamination. [SO:xp]"
          },
          "SO:0000812": {
            "name": "polyA_primed_cDNA_clone",
            "def": "A cDNA clone invalidated by polyA priming. [SO:xp]"
          },
          "SO:0000813": {
            "name": "partially_processed_cDNA_clone",
            "def": "A cDNA invalidated clone by partial processing. [SO:xp]"
          },
          "SO:0000814": {
            "name": "rescue",
            "def": "An attribute describing a region's ability, when introduced to a mutant organism, to re-establish (rescue) a phenotype. [SO:ke]"
          },
          "SO:0000815": {
            "name": "mini_gene",
            "def": "By definition, minigenes are short open-reading frames (ORF), usually encoding approximately 9 to 20 amino acids, which are expressed in vivo (as distinct from being synthesized as peptide or protein ex vivo and subsequently injected). The in vivo synthesis confers a distinct advantage: the expressed sequences can enter both antigen presentation pathways, MHC I (inducing CD8+ T- cells, which are usually cytotoxic T-lymphocytes (CTL)) and MHC II (inducing CD4+ T-cells, usually 'T-helpers' (Th)); and can encounter B-cells, inducing antibody responses. Three main vector approaches have been used to deliver minigenes: viral vectors, bacterial vectors and plasmid DNA. [PMID:15992143]"
          },
          "SO:0000816": {
            "name": "rescue_gene",
            "def": "A gene that rescues. [SO:xp]"
          },
          "SO:0000817": {
            "name": "wild_type",
            "def": "An attribute describing sequence with the genotype found in nature and/or standard laboratory stock. [SO:ke]"
          },
          "SO:0000818": {
            "name": "wild_type_rescue_gene",
            "def": "A gene that rescues. [SO:xp]"
          },
          "SO:0000819": {
            "name": "mitochondrial_chromosome",
            "def": "A chromosome originating in a mitochondria. [SO:xp]"
          },
          "SO:0000820": {
            "name": "chloroplast_chromosome",
            "def": "A chromosome originating in a chloroplast. [SO:xp]"
          },
          "SO:0000821": {
            "name": "chromoplast_chromosome",
            "def": "A chromosome originating in a chromoplast. [SO:xp]"
          },
          "SO:0000822": {
            "name": "cyanelle_chromosome",
            "def": "A chromosome originating in a cyanelle. [SO:xp]"
          },
          "SO:0000823": {
            "name": "leucoplast_chromosome",
            "def": "A chromosome with origin in a leucoplast. [SO:xp]"
          },
          "SO:0000824": {
            "name": "macronuclear_chromosome",
            "def": "A chromosome originating in a macronucleus. [SO:xp]"
          },
          "SO:0000825": {
            "name": "micronuclear_chromosome",
            "def": "A chromosome originating in a micronucleus. [SO:xp]"
          },
          "SO:0000828": {
            "name": "nuclear_chromosome",
            "def": "A chromosome originating in a nucleus. [SO:xp]"
          },
          "SO:0000829": {
            "name": "nucleomorphic_chromosome",
            "def": "A chromosome originating in a nucleomorph. [SO:xp]"
          },
          "SO:0000830": {
            "name": "chromosome_part",
            "def": "A region of a chromosome. [SO:ke]"
          },
          "SO:0000831": {
            "name": "gene_member_region",
            "def": "A region of a gene. [SO:ke]"
          },
          "SO:0000832": {
            "name": "promoter_region",
            "def": "A region of sequence which is part of a promoter. [SO:ke]"
          },
          "SO:0000833": {
            "name": "transcript_region",
            "def": "A region of a transcript. [SO:ke]"
          },
          "SO:0000834": {
            "name": "mature_transcript_region",
            "def": "A region of a mature transcript. [SO:ke]"
          },
          "SO:0000835": {
            "name": "primary_transcript_region",
            "def": "A part of a primary transcript. [SO:ke]"
          },
          "SO:0000836": {
            "name": "mRNA_region",
            "def": "A region of an mRNA. [SO:cb]"
          },
          "SO:0000837": {
            "name": "UTR_region",
            "def": "A region of UTR. [SO:ke]"
          },
          "SO:0000838": {
            "name": "rRNA_primary_transcript_region",
            "def": "A region of an rRNA primary transcript. [SO:ke]"
          },
          "SO:0000839": {
            "name": "polypeptide_region",
            "def": "Biological sequence region that can be assigned to a specific subsequence of a polypeptide. [SO:GAR, SO:ke]"
          },
          "SO:0000840": {
            "name": "repeat_component",
            "def": "A region of a repeated sequence. [SO:ke]"
          },
          "SO:0000841": {
            "name": "spliceosomal_intron_region",
            "def": "A region within an intron. [SO:ke]"
          },
          "SO:0000842": {
            "name": "gene_component_region"
          },
          "SO:0000843": {
            "name": "bacterial_RNApol_promoter_region",
            "def": "A region which is part of a bacterial RNA polymerase promoter. [SO:ke]"
          },
          "SO:0000844": {
            "name": "RNApol_II_promoter_region",
            "def": "A region of sequence which is a promoter for RNA polymerase II. [SO:ke]"
          },
          "SO:0000845": {
            "name": "RNApol_III_promoter_type_1_region",
            "def": "A region of sequence which is a promoter for RNA polymerase III type 1. [SO:ke]"
          },
          "SO:0000846": {
            "name": "RNApol_III_promoter_type_2_region",
            "def": "A region of sequence which is a promoter for RNA polymerase III type 2. [SO:ke]"
          },
          "SO:0000847": {
            "name": "tmRNA_region",
            "def": "A region of a tmRNA. [SO:cb]"
          },
          "SO:0000848": {
            "name": "LTR_component"
          },
          "SO:0000849": {
            "name": "three_prime_LTR_component"
          },
          "SO:0000850": {
            "name": "five_prime_LTR_component"
          },
          "SO:0000851": {
            "name": "CDS_region",
            "def": "A region of a CDS. [SO:cb]"
          },
          "SO:0000852": {
            "name": "exon_region",
            "def": "A region of an exon. [RSC:cb]"
          },
          "SO:0000853": {
            "name": "homologous_region",
            "def": "A region that is homologous to another region. [SO:ke]"
          },
          "SO:0000854": {
            "name": "paralogous_region",
            "def": "A homologous_region that is paralogous to another region. [SO:ke]"
          },
          "SO:0000855": {
            "name": "orthologous_region",
            "def": "A homologous_region that is orthologous to another region. [SO:ke]"
          },
          "SO:0000856": {
            "name": "conserved"
          },
          "SO:0000857": {
            "name": "homologous",
            "def": "Similarity due to common ancestry. [SO:ke]"
          },
          "SO:0000858": {
            "name": "orthologous",
            "def": "An attribute describing a kind of homology where divergence occurred after a speciation event. [SO:ke]"
          },
          "SO:0000859": {
            "name": "paralogous",
            "def": "An attribute describing a kind of homology where divergence occurred after a duplication event. [SO:ke]"
          },
          "SO:0000860": {
            "name": "syntenic",
            "def": "Attribute describing sequence regions occurring in same order on chromosome of different species. [SO:ke]"
          },
          "SO:0000861": {
            "name": "capped_primary_transcript",
            "def": "A primary transcript that is capped. [SO:xp]"
          },
          "SO:0000862": {
            "name": "capped_mRNA",
            "def": "An mRNA that is capped. [SO:xp]"
          },
          "SO:0000863": {
            "name": "mRNA_attribute",
            "def": "An attribute describing an mRNA feature. [SO:ke]"
          },
          "SO:0000864": {
            "name": "exemplar",
            "def": "An attribute describing a sequence is representative of a class of similar sequences. [SO:ke]"
          },
          "SO:0000865": {
            "name": "frameshift",
            "def": "An attribute describing a sequence that contains a mutation involving the deletion or insertion of one or more bases, where this number is not divisible by 3. [SO:ke]"
          },
          "SO:0000866": {
            "name": "minus_1_frameshift",
            "def": "A frameshift caused by deleting one base. [SO:ke]"
          },
          "SO:0000867": {
            "name": "minus_2_frameshift",
            "def": "A frameshift caused by deleting two bases. [SO:ke]"
          },
          "SO:0000868": {
            "name": "plus_1_frameshift",
            "def": "A frameshift caused by inserting one base. [SO:ke]"
          },
          "SO:0000869": {
            "name": "plus_2_framshift",
            "def": "A frameshift caused by inserting two bases. [SO:ke]"
          },
          "SO:0000870": {
            "name": "trans_spliced",
            "def": "An attribute describing transcript sequence that is created by splicing exons from diferent genes. [SO:ke]"
          },
          "SO:0000871": {
            "name": "polyadenylated_mRNA",
            "def": "An mRNA that is polyadenylated. [SO:xp]"
          },
          "SO:0000872": {
            "name": "trans_spliced_mRNA",
            "def": "An mRNA that is trans-spliced. [SO:xp]"
          },
          "SO:0000873": {
            "name": "edited_transcript",
            "def": "A transcript that is edited. [SO:ke]"
          },
          "SO:0000874": {
            "name": "edited_transcript_by_A_to_I_substitution",
            "def": "A transcript that has been edited by A to I substitution. [SO:ke]"
          },
          "SO:0000875": {
            "name": "bound_by_protein",
            "def": "An attribute describing a sequence that is bound by a protein. [SO:ke]"
          },
          "SO:0000876": {
            "name": "bound_by_nucleic_acid",
            "def": "An attribute describing a sequence that is bound by a nucleic acid. [SO:ke]"
          },
          "SO:0000877": {
            "name": "alternatively_spliced",
            "def": "An attribute describing a situation where a gene may encode for more than 1 transcript. [SO:ke]"
          },
          "SO:0000878": {
            "name": "monocistronic",
            "def": "An attribute describing a sequence that contains the code for one gene product. [SO:ke]"
          },
          "SO:0000879": {
            "name": "dicistronic",
            "def": "An attribute describing a sequence that contains the code for two gene products. [SO:ke]"
          },
          "SO:0000880": {
            "name": "polycistronic",
            "def": "An attribute describing a sequence that contains the code for more than one gene product. [SO:ke]"
          },
          "SO:0000881": {
            "name": "recoded",
            "def": "An attribute describing an mRNA sequence that has been reprogrammed at translation, causing localized alterations. [SO:ke]"
          },
          "SO:0000882": {
            "name": "codon_redefined",
            "def": "An attribute describing the alteration of codon meaning. [SO:ke]"
          },
          "SO:0000883": {
            "name": "stop_codon_read_through",
            "def": "A stop codon redefined to be a new amino acid. [SO:ke]"
          },
          "SO:0000884": {
            "name": "stop_codon_redefined_as_pyrrolysine",
            "def": "A stop codon redefined to be the new amino acid, pyrrolysine. [SO:ke]"
          },
          "SO:0000885": {
            "name": "stop_codon_redefined_as_selenocysteine",
            "def": "A stop codon redefined to be the new amino acid, selenocysteine. [SO:ke]"
          },
          "SO:0000886": {
            "name": "recoded_by_translational_bypass",
            "def": "Recoded mRNA where a block of nucleotides is not translated. [SO:ke]"
          },
          "SO:0000887": {
            "name": "translationally_frameshifted",
            "def": "Recoding by frameshifting a particular site. [SO:ke]"
          },
          "SO:0000888": {
            "name": "maternally_imprinted_gene",
            "def": "A gene that is maternally_imprinted. [SO:xp]"
          },
          "SO:0000889": {
            "name": "paternally_imprinted_gene",
            "def": "A gene that is paternally imprinted. [SO:xp]"
          },
          "SO:0000890": {
            "name": "post_translationally_regulated_gene",
            "def": "A gene that is post translationally regulated. [SO:xp]"
          },
          "SO:0000891": {
            "name": "negatively_autoregulated_gene",
            "def": "A gene that is negatively autoreguated. [SO:xp]"
          },
          "SO:0000892": {
            "name": "positively_autoregulated_gene",
            "def": "A gene that is positively autoregulated. [SO:xp]"
          },
          "SO:0000893": {
            "name": "silenced",
            "def": "An attribute describing an epigenetic process where a gene is inactivated at transcriptional or translational level. [SO:ke]"
          },
          "SO:0000894": {
            "name": "silenced_by_DNA_modification",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by DNA modifications, resulting in repression of transcription. [SO:ke]"
          },
          "SO:0000895": {
            "name": "silenced_by_DNA_methylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by DNA methylation, resulting in repression of transcription. [SO:ke]"
          },
          "SO:0000896": {
            "name": "translationally_regulated_gene",
            "def": "A gene that is translationally regulated. [SO:xp]"
          },
          "SO:0000897": {
            "name": "allelically_excluded_gene",
            "def": "A gene that is allelically_excluded. [SO:xp]"
          },
          "SO:0000898": {
            "name": "epigenetically_modified_gene",
            "def": "A gene that is epigenetically modified. [SO:ke]"
          },
          "SO:0000899": {
            "name": "nuclear_mitochondrial",
            "def": "An attribute describing a nuclear pseudogene of a mitochndrial gene. [SO:ke]"
          },
          "SO:0000900": {
            "name": "processed",
            "def": "An attribute describing a pseudogene where by an mRNA was retrotransposed. The mRNA sequence is transcribed back into the genome, lacking introns and promotors, but often including a polyA tail. [SO:ke]"
          },
          "SO:0000901": {
            "name": "unequally_crossed_over",
            "def": "An attribute describing a pseudogene that was created by tandem duplication and unequal crossing over during recombination. [SO:ke]"
          },
          "SO:0000902": {
            "name": "transgene",
            "def": "A transgene is a gene that has been transferred naturally or by any of a number of genetic engineering techniques from one organism to another. [SO:xp]"
          },
          "SO:0000903": {
            "name": "endogenous_retroviral_sequence"
          },
          "SO:0000904": {
            "name": "rearranged_at_DNA_level",
            "def": "An attribute to describe the sequence of a feature, where the DNA is rearranged. [SO:ke]"
          },
          "SO:0000905": {
            "name": "status",
            "def": "An attribute describing the status of a feature, based on the available evidence. [SO:ke]"
          },
          "SO:0000906": {
            "name": "independently_known",
            "def": "Attribute to describe a feature that is independently known - not predicted. [SO:ke]"
          },
          "SO:0000907": {
            "name": "supported_by_sequence_similarity",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity techniques. [SO:ke]"
          },
          "SO:0000908": {
            "name": "supported_by_domain_match",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity of a known domain. [SO:ke]"
          },
          "SO:0000909": {
            "name": "supported_by_EST_or_cDNA",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity to EST or cDNA data. [SO:ke]"
          },
          "SO:0000910": {
            "name": "orphan"
          },
          "SO:0000911": {
            "name": "predicted_by_ab_initio_computation",
            "def": "An attribute describing a feature that is predicted by a computer program that did not rely on sequence similarity. [SO:ke]"
          },
          "SO:0000912": {
            "name": "asx_turn",
            "def": "A motif of three consecutive residues and one H-bond in which: residue(i) is Aspartate or Asparagine (Asx), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2). [http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0000913": {
            "name": "cloned_cDNA_insert",
            "def": "A clone insert made from cDNA. [SO:xp]"
          },
          "SO:0000914": {
            "name": "cloned_genomic_insert",
            "def": "A clone insert made from genomic DNA. [SO:xp]"
          },
          "SO:0000915": {
            "name": "engineered_insert",
            "def": "A clone insert that is engineered. [SO:xp]"
          },
          "SO:0000916": {
            "name": "edit_operation"
          },
          "SO:0000917": {
            "name": "insert_U",
            "def": "An edit to insert a U. [SO:ke]"
          },
          "SO:0000918": {
            "name": "delete_U",
            "def": "An edit to delete a uridine. [SO:ke]"
          },
          "SO:0000919": {
            "name": "substitute_A_to_I",
            "def": "An edit to substitute an I for an A. [SO:ke]"
          },
          "SO:0000920": {
            "name": "insert_C",
            "def": "An edit to insert a cytidine. [SO:ke]"
          },
          "SO:0000921": {
            "name": "insert_dinucleotide",
            "def": "An edit to insert a dinucleotide. [SO:ke]"
          },
          "SO:0000922": {
            "name": "substitute_C_to_U",
            "def": "An edit to substitute an U for a C. [SO:ke]"
          },
          "SO:0000923": {
            "name": "insert_G",
            "def": "An edit to insert a G. [SO:ke]"
          },
          "SO:0000924": {
            "name": "insert_GC",
            "def": "An edit to insert a GC dinucleotide. [SO:ke]"
          },
          "SO:0000925": {
            "name": "insert_GU",
            "def": "An edit to insert a GU dinucleotide. [SO:ke]"
          },
          "SO:0000926": {
            "name": "insert_CU",
            "def": "An edit to insert a CU dinucleotide. [SO:ke]"
          },
          "SO:0000927": {
            "name": "insert_AU",
            "def": "An edit to insert a AU dinucleotide. [SO:ke]"
          },
          "SO:0000928": {
            "name": "insert_AA",
            "def": "An edit to insert a AA dinucleotide. [SO:ke]"
          },
          "SO:0000929": {
            "name": "edited_mRNA",
            "def": "An mRNA that is edited. [SO:xp]"
          },
          "SO:0000930": {
            "name": "guide_RNA_region",
            "def": "A region of guide RNA. [SO:ma]"
          },
          "SO:0000931": {
            "name": "anchor_region",
            "def": "A region of a guide_RNA that base-pairs to a target mRNA. [SO:jk]"
          },
          "SO:0000932": {
            "name": "pre_edited_mRNA"
          },
          "SO:0000933": {
            "name": "intermediate",
            "def": "An attribute to describe a feature between stages of processing. [SO:ke]"
          },
          "SO:0000934": {
            "name": "miRNA_target_site",
            "def": "A miRNA target site is a binding site where the molecule is a micro RNA. [FB:cds]"
          },
          "SO:0000935": {
            "name": "edited_CDS",
            "def": "A CDS that is edited. [SO:xp]"
          },
          "SO:0000936": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_rearranged_segment"
          },
          "SO:0000937": {
            "name": "vertebrate_immune_system_feature"
          },
          "SO:0000938": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_rearranged_gene_cluster"
          },
          "SO:0000939": {
            "name": "vertebrate_immune_system_gene_recombination_signal_feature"
          },
          "SO:0000940": {
            "name": "recombinationally_rearranged"
          },
          "SO:0000941": {
            "name": "recombinationally_rearranged_vertebrate_immune_system_gene",
            "def": "A recombinationally rearranged gene of the vertebrate immune system. [SO:xp]"
          },
          "SO:0000942": {
            "name": "attP_site",
            "def": "An integration/excision site of a phage chromosome at which a recombinase acts to insert the phage DNA at a cognate integration/excision site on a bacterial chromosome. [SO:as]"
          },
          "SO:0000943": {
            "name": "attB_site",
            "def": "An integration/excision site of a bacterial chromosome at which a recombinase acts to insert foreign DNA containing a cognate integration/excision site. [SO:as]"
          },
          "SO:0000944": {
            "name": "attL_site",
            "def": "A region that results from recombination between attP_site and attB_site, composed of the 5' portion of attB_site and the 3' portion of attP_site. [SO:as]"
          },
          "SO:0000945": {
            "name": "attR_site",
            "def": "A region that results from recombination between attP_site and attB_site, composed of the 5' portion of attP_site and the 3' portion of attB_site. [SO:as]"
          },
          "SO:0000946": {
            "name": "integration_excision_site",
            "def": "A region specifically recognised by a recombinase, which inserts or removes another region marked by a distinct cognate integration/excision site. [SO:as]"
          },
          "SO:0000947": {
            "name": "resolution_site",
            "def": "A region specifically recognized by a recombinase, which separates a physically contiguous circle of DNA into two physically separate circles. [SO:as]"
          },
          "SO:0000948": {
            "name": "inversion_site",
            "def": "A region specifically recognised by a recombinase, which inverts the region flanked by a pair of sites. [SO:ma]"
          },
          "SO:0000949": {
            "name": "dif_site",
            "def": "A site at which replicated bacterial circular chromosomes are decatenated by site specific resolvase. [SO:as]"
          },
          "SO:0000950": {
            "name": "attC_site",
            "def": "An attC site is a sequence required for the integration of a DNA of an integron. [SO:as]"
          },
          "SO:0000951": {
            "name": "eukaryotic_terminator"
          },
          "SO:0000952": {
            "name": "oriV",
            "def": "An origin of vegetative replication in plasmids and phages. [SO:as]"
          },
          "SO:0000953": {
            "name": "oriC",
            "def": "An origin of bacterial chromosome replication. [SO:as]"
          },
          "SO:0000954": {
            "name": "DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, DNA molecule. [SO:ma]"
          },
          "SO:0000955": {
            "name": "double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded DNA molecule. [SO:ma]"
          },
          "SO:0000956": {
            "name": "single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded DNA molecule. [SO:ma]"
          },
          "SO:0000957": {
            "name": "linear_double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, linear DNA molecule. [SO:ma]"
          },
          "SO:0000958": {
            "name": "circular_double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, circular DNA molecule. [SO:ma]"
          },
          "SO:0000959": {
            "name": "linear_single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, linear DNA molecule. [SO:ma]"
          },
          "SO:0000960": {
            "name": "circular_single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, circular DNA molecule. [SO:ma]"
          },
          "SO:0000961": {
            "name": "RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, RNA molecule. [SO:ma]"
          },
          "SO:0000962": {
            "name": "single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded RNA molecule. [SO:ma]"
          },
          "SO:0000963": {
            "name": "linear_single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, linear RNA molecule. [SO:ma]"
          },
          "SO:0000964": {
            "name": "linear_double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, linear RNA molecule. [SO:ma]"
          },
          "SO:0000965": {
            "name": "double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded RNA molecule. [SO:ma]"
          },
          "SO:0000966": {
            "name": "circular_single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, circular DNA molecule. [SO:ma]"
          },
          "SO:0000967": {
            "name": "circular_double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, circular RNA molecule. [SO:ma]"
          },
          "SO:0000968": {
            "name": "sequence_replication_mode"
          },
          "SO:0000969": {
            "name": "rolling_circle"
          },
          "SO:0000970": {
            "name": "theta_replication"
          },
          "SO:0000971": {
            "name": "DNA_replication_mode"
          },
          "SO:0000972": {
            "name": "RNA_replication_mode"
          },
          "SO:0000973": {
            "name": "insertion_sequence",
            "def": "A terminal_inverted_repeat_element that is bacterial and only encodes the functions required for its transposition between these inverted repeats. [SO:as]"
          },
          "SO:0000975": {
            "name": "minicircle_gene"
          },
          "SO:0000976": {
            "name": "cryptic",
            "def": "A feature_attribute describing a feature that is not manifest under normal conditions. [SO:ke]"
          },
          "SO:0000977": {
            "name": "anchor_binding_site"
          },
          "SO:0000978": {
            "name": "template_region",
            "def": "A region of a guide_RNA that specifies the insertions and deletions of bases in the editing of a target mRNA. [SO:jk]"
          },
          "SO:0000979": {
            "name": "gRNA_encoding",
            "def": "A non-protein_coding gene that encodes a guide_RNA. [SO:ma]"
          },
          "SO:0000980": {
            "name": "minicircle",
            "def": "A minicircle is a replicon, part of a kinetoplast, that encodes for guide RNAs. [PMID:8395055]"
          },
          "SO:0000981": {
            "name": "rho_dependent_bacterial_terminator"
          },
          "SO:0000982": {
            "name": "rho_independent_bacterial_terminator"
          },
          "SO:0000983": {
            "name": "strand_attribute"
          },
          "SO:0000984": {
            "name": "single"
          },
          "SO:0000985": {
            "name": "double"
          },
          "SO:0000986": {
            "name": "topology_attribute"
          },
          "SO:0000987": {
            "name": "linear",
            "def": "A quality of a nucleotide polymer that has a 3'-terminal residue and a 5'-terminal residue. [SO:cb]"
          },
          "SO:0000988": {
            "name": "circular",
            "def": "A quality of a nucleotide polymer that has no terminal nucleotide residues. [SO:cb]"
          },
          "SO:0000989": {
            "name": "class_II_RNA",
            "def": "Small non-coding RNA (59-60 nt long) containing 5' and 3' ends that are predicted to come together to form a stem structure. Identified in the social amoeba Dictyostelium discoideum and localized in the cytoplasm. [PMID:15333696]"
          },
          "SO:0000990": {
            "name": "class_I_RNA",
            "def": "Small non-coding RNA (55-65 nt long) containing highly conserved 5' and 3' ends (16 and 8 nt, respectively) that are predicted to come together to form a stem structure. Identified in the social amoeba Dictyostelium discoideum and localized in the cytoplasm. [PMID:15333696]"
          },
          "SO:0000991": {
            "name": "genomic_DNA"
          },
          "SO:0000992": {
            "name": "BAC_cloned_genomic_insert"
          },
          "SO:0000993": {
            "name": "consensus"
          },
          "SO:0000994": {
            "name": "consensus_region"
          },
          "SO:0000995": {
            "name": "consensus_mRNA"
          },
          "SO:0000996": {
            "name": "predicted_gene"
          },
          "SO:0000997": {
            "name": "gene_fragment"
          },
          "SO:0000998": {
            "name": "recursive_splice_site",
            "def": "A recursive splice site is a splice site which subdivides a large intron. Recursive splicing is a mechanism that splices large introns by sub dividing the intron at non exonic elements and alternate exons. [http://www.genetics.org/cgi/content/full/170/2/661]"
          },
          "SO:0000999": {
            "name": "BAC_end",
            "def": "A region of sequence from the end of a BAC clone that may provide a highly specific marker. [SO:ke]"
          },
          "SO:0001000": {
            "name": "rRNA_16S",
            "def": "A large polynucleotide in Bacteria and Archaea, which functions as the small subunit of the ribosome. [SO:ke]"
          },
          "SO:0001001": {
            "name": "rRNA_23S",
            "def": "A large polynucleotide in Bacteria and Archaea, which functions as the large subunit of the ribosome. [SO:ke]"
          },
          "SO:0001002": {
            "name": "rRNA_25S",
            "def": "A large polynucleotide which functions as part of the large subunit of the ribosome in some eukaryotes. [RSC:cb]"
          },
          "SO:0001003": {
            "name": "solo_LTR",
            "def": "A recombination product between the 2 LTR of the same element. [SO:ke]"
          },
          "SO:0001004": {
            "name": "low_complexity"
          },
          "SO:0001005": {
            "name": "low_complexity_region"
          },
          "SO:0001006": {
            "name": "prophage",
            "def": "A phage genome after it has established in the host genome in a latent/immune state either as a plasmid or as an integrated \\island\\. [GOC:jl]"
          },
          "SO:0001007": {
            "name": "cryptic_prophage",
            "def": "A remnant of an integrated prophage in the host genome or an \\island\\ in the host genome that includes phage like-genes. [GOC:jl]"
          },
          "SO:0001008": {
            "name": "tetraloop",
            "def": "A base-paired stem with loop of 4 non-hydrogen bonded nucleotides. [SO:ke]"
          },
          "SO:0001009": {
            "name": "DNA_constraint_sequence",
            "def": "A double-stranded DNA used to control macromolecular structure and function. [http:/www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=search&db=pubmed&term=SILVERMAN+SK[au\\]&dispmax=50]"
          },
          "SO:0001010": {
            "name": "i_motif",
            "def": "A cytosine rich domain whereby strands associate both inter- and intramolecularly at moderately acidic pH. [PMID:9753739]"
          },
          "SO:0001011": {
            "name": "PNA_oligo",
            "def": "Peptide nucleic acid, is a chemical not known to occur naturally but is artificially synthesized and used in some biological research and medical treatments. The PNA backbone is composed of repeating N-(2-aminoethyl)-glycine units linked by peptide bonds. The purine and pyrimidine bases are linked to the backbone by methylene carbonyl bonds. [SO:ke]"
          },
          "SO:0001012": {
            "name": "DNAzyme",
            "def": "A DNA sequence with catalytic activity. [SO:cb]"
          },
          "SO:0001013": {
            "name": "MNP",
            "def": "A multiple nucleotide polymorphism with alleles of common length > 1, for example AAA/TTT. [http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs=rs2067431]"
          },
          "SO:0001014": {
            "name": "intron_domain"
          },
          "SO:0001015": {
            "name": "wobble_base_pair",
            "def": "A type of non-canonical base pairing, most commonly between G and U, which is important for the secondary structure of RNAs. It has similar thermodynamic stability to the Watson-Crick pairing. Wobble base pairs only have two hydrogen bonds. Other wobble base pair possibilities are I-A, I-U and I-C. [PMID:11256617]"
          },
          "SO:0001016": {
            "name": "internal_guide_sequence",
            "def": "A purine-rich sequence in the group I introns which determines the locations of the splice sites in group I intron splicing and has catalytic activity. [SO:cb]"
          },
          "SO:0001017": {
            "name": "silent_mutation",
            "def": "A sequence variant that does not affect protein function. Silent mutations may occur in genic ( CDS, UTR, intron etc) and intergenic regions. Silent mutations may have affects on processes such as splicing and regulation. [SO:ke]"
          },
          "SO:0001018": {
            "name": "epitope",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with antibodies, B cells or T cells. [http://en.wikipedia.org/wiki/Epitope, SO:cb]"
          },
          "SO:0001019": {
            "name": "copy_number_variation",
            "def": "A variation that increases or decreases the copy number of a given region. [SO:ke]"
          },
          "SO:0001020": {
            "name": "sequence_variant_affecting_copy_number"
          },
          "SO:0001021": {
            "name": "chromosome_breakpoint"
          },
          "SO:0001022": {
            "name": "inversion_breakpoint",
            "def": "The point within a chromosome where an inversion begins or ends. [SO:cb]"
          },
          "SO:0001023": {
            "name": "allele",
            "def": "An allele is one of a set of coexisting sequence variants of a gene. [SO:immuno_workshop]"
          },
          "SO:0001024": {
            "name": "haplotype",
            "def": "A haplotype is one of a set of coexisting sequence variants of a haplotype block. [SO:immuno_workshop]"
          },
          "SO:0001025": {
            "name": "polymorphic_sequence_variant",
            "def": "A sequence variant that is segregating in one or more natural populations of a species. [SO:immuno_workshop]"
          },
          "SO:0001026": {
            "name": "genome",
            "def": "A genome is the sum of genetic material within a cell or virion. [SO:immuno_workshop]"
          },
          "SO:0001027": {
            "name": "genotype",
            "def": "A genotype is a variant genome, complete or incomplete. [SO:immuno_workshop]"
          },
          "SO:0001028": {
            "name": "diplotype",
            "def": "A diplotype is a pair of haplotypes from a given individual. It is a genotype where the phase is known. [SO:immuno_workshop]"
          },
          "SO:0001029": {
            "name": "direction_attribute"
          },
          "SO:0001030": {
            "name": "forward",
            "def": "Forward is an attribute of the feature, where the feature is in the 5' to 3' direction. [SO:ke]"
          },
          "SO:0001031": {
            "name": "reverse",
            "def": "Reverse is an attribute of the feature, where the feature is in the 3' to 5' direction. Again could be applied to primer. [SO:ke]"
          },
          "SO:0001032": {
            "name": "mitochondrial_DNA"
          },
          "SO:0001033": {
            "name": "chloroplast_DNA"
          },
          "SO:0001034": {
            "name": "miRtron",
            "def": "A de-branched intron which mimics the structure of pre-miRNA and enters the miRNA processing pathway without Drosha mediated cleavage. [PMID:17589500, SO:ma]"
          },
          "SO:0001035": {
            "name": "piRNA",
            "def": "A small non coding RNA, part of a silencing system that prevents the spreading of selfish genetic elements. [SO:ke]"
          },
          "SO:0001036": {
            "name": "arginyl_tRNA",
            "def": "A tRNA sequence that has an arginine anticodon, and a 3' arginine binding region. [SO:ke]"
          },
          "SO:0001037": {
            "name": "mobile_genetic_element",
            "def": "A nucleotide region with either intra-genome or intracellular mobility, of varying length, which often carry the information necessary for transfer and recombination with the host genome. [PMID:14681355]"
          },
          "SO:0001038": {
            "name": "extrachromosomal_mobile_genetic_element",
            "def": "An MGE that is not integrated into the host chromosome. [SO:ke]"
          },
          "SO:0001039": {
            "name": "integrated_mobile_genetic_element",
            "def": "An MGE that is integrated into the host chromosome. [SO:ke]"
          },
          "SO:0001040": {
            "name": "integrated_plasmid",
            "def": "A plasmid sequence that is integrated within the host chromosome. [SO:ke]"
          },
          "SO:0001041": {
            "name": "viral_sequence",
            "def": "The region of nucleotide sequence of a virus, a submicroscopic particle that replicates by infecting a host cell. [SO:ke]"
          },
          "SO:0001042": {
            "name": "phage_sequence",
            "def": "The nucleotide sequence of a virus that infects bacteria. [SO:ke]"
          },
          "SO:0001043": {
            "name": "attCtn_site",
            "def": "An attachment site located on a conjugative transposon and used for site-specific integration of a conjugative transposon. [Phigo:at]"
          },
          "SO:0001044": {
            "name": "nuclear_mt_pseudogene",
            "def": "A nuclear pseudogene of either coding or non-coding mitochondria derived sequence. [SO:xp]"
          },
          "SO:0001045": {
            "name": "cointegrated_plasmid",
            "def": "A MGE region consisting of two fused plasmids resulting from a replicative transposition event. [phigo:at]"
          },
          "SO:0001046": {
            "name": "IRLinv_site",
            "def": "Component of the inversion site located at the left of a region susceptible to site-specific inversion. [Phigo:at]"
          },
          "SO:0001047": {
            "name": "IRRinv_site",
            "def": "Component of the inversion site located at the right of a region susceptible to site-specific inversion. [Phigo:at]"
          },
          "SO:0001048": {
            "name": "inversion_site_part",
            "def": "A region located within an inversion site. [SO:ke]"
          },
          "SO:0001049": {
            "name": "defective_conjugative_transposon",
            "def": "An island that contains genes for integration/excision and the gene and site for the initiation of intercellular transfer by conjugation. It can be complemented for transfer by a conjugative transposon. [Phigo:ariane]"
          },
          "SO:0001050": {
            "name": "repeat_fragment",
            "def": "A portion of a repeat, interrupted by the insertion of another element. [SO:ke]"
          },
          "SO:0001051": {
            "name": "nested_region"
          },
          "SO:0001052": {
            "name": "nested_repeat"
          },
          "SO:0001053": {
            "name": "nested_transposon"
          },
          "SO:0001054": {
            "name": "transposon_fragment",
            "def": "A portion of a transposon, interrupted by the insertion of another element. [SO:ke]"
          },
          "SO:0001055": {
            "name": "transcriptional_cis_regulatory_region",
            "def": "A regulatory_region that modulates the transcription of a gene or genes. [PMID:9679020, SO:regcreative]"
          },
          "SO:0001056": {
            "name": "splicing_regulatory_region",
            "def": "A regulatory_region that modulates splicing. [SO:ke]"
          },
          "SO:0001057": {
            "name": "enhanceosome"
          },
          "SO:0001058": {
            "name": "promoter_targeting_sequence",
            "def": "A transcriptional_cis_regulatory_region that restricts the activity of a CRM to a single promoter and which functions only when both itself and an insulator are located between the CRM and the promoter. [SO:regcreative]"
          },
          "SO:0001059": {
            "name": "sequence_alteration",
            "def": "A sequence_alteration is a sequence_feature whose extent is the deviation from another sequence. [SO:ke]"
          },
          "SO:0001060": {
            "name": "sequence_variant",
            "def": "A sequence_variant is a non exact copy of a sequence_feature or genome exhibiting one or more sequence_alteration. [SO:ke]"
          },
          "SO:0001061": {
            "name": "propeptide_cleavage_site",
            "def": "The propeptide_cleavage_site is the arginine/lysine boundary on a propeptide where cleavage occurs. [EBIBS:GAR]"
          },
          "SO:0001062": {
            "name": "propeptide",
            "def": "Part of a peptide chain which is cleaved off during the formation of the mature protein. [EBIBS:GAR]"
          },
          "SO:0001063": {
            "name": "immature_peptide_region",
            "def": "An immature_peptide_region is the extent of the peptide after it has been translated and before any processing occurs. [EBIBS:GAR]"
          },
          "SO:0001064": {
            "name": "active_peptide",
            "def": "Active peptides are proteins which are biologically active, released from a precursor molecule. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001066": {
            "name": "compositionally_biased_region_of_peptide",
            "def": "Polypeptide region that is rich in a particular amino acid or homopolymeric and greater than three residues in length. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001067": {
            "name": "polypeptide_motif",
            "def": "A sequence motif is a short (up to 20 amino acids) region of biological interest. Such motifs, although they are too short to constitute functional domains, share sequence similarities and are conserved in different proteins. They display a common function (protein-binding, subcellular location etc.). [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001068": {
            "name": "polypeptide_repeat",
            "def": "A polypeptide_repeat is a single copy of an internal sequence repetition. [EBIBS:GAR]"
          },
          "SO:0001070": {
            "name": "polypeptide_structural_region",
            "def": "Region of polypeptide with a given structural property. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001071": {
            "name": "membrane_structure",
            "def": "Arrangement of the polypeptide with respect to the lipid bilayer. [EBIBS:GAR]"
          },
          "SO:0001072": {
            "name": "extramembrane_polypeptide_region",
            "def": "Polypeptide region that is localized outside of a lipid bilayer. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001073": {
            "name": "cytoplasmic_polypeptide_region",
            "def": "Polypeptide region that is localized inside the cytoplasm. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001074": {
            "name": "non_cytoplasmic_polypeptide_region",
            "def": "Polypeptide region that is localized outside of a lipid bilayer and outside of the cytoplasm. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001075": {
            "name": "intramembrane_polypeptide_region",
            "def": "Polypeptide region present in the lipid bilayer. [EBIBS:GAR]"
          },
          "SO:0001076": {
            "name": "membrane_peptide_loop",
            "def": "Polypeptide region localized within the lipid bilayer where both ends traverse the same membrane. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001077": {
            "name": "transmembrane_polypeptide_region",
            "def": "Polypeptide region traversing the lipid bilayer. [EBIBS:GAR, UniProt:curator_manual]"
          },
          "SO:0001078": {
            "name": "polypeptide_secondary_structure",
            "def": "A region of peptide with secondary structure has hydrogen bonding along the peptide chain that causes a defined conformation of the chain. [EBIBS:GAR]"
          },
          "SO:0001079": {
            "name": "polypeptide_structural_motif",
            "def": "Motif is a three-dimensional structural element within the chain, which appears also in a variety of other molecules. Unlike a domain, a motif does not need to form a stable globular unit. [EBIBS:GAR]"
          },
          "SO:0001080": {
            "name": "coiled_coil",
            "def": "A coiled coil is a structural motif in proteins, in which alpha-helices are coiled together like the strands of a rope. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001081": {
            "name": "helix_turn_helix",
            "def": "A motif comprising two helices separated by a turn. [EBIBS:GAR]"
          },
          "SO:0001082": {
            "name": "polypeptide_sequencing_information",
            "def": "Incompatibility in the sequence due to some experimental problem. [EBIBS:GAR]"
          },
          "SO:0001083": {
            "name": "non_adjacent_residues",
            "def": "Indicates that two consecutive residues in a fragment sequence are not consecutive in the full-length protein and that there are a number of unsequenced residues between them. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001084": {
            "name": "non_terminal_residue",
            "def": "The residue at an extremity of the sequence is not the terminal residue. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001085": {
            "name": "sequence_conflict",
            "def": "Different sources report differing sequences. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001086": {
            "name": "sequence_uncertainty",
            "def": "Describes the positions in a sequence where the authors are unsure about the sequence assignment. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001087": {
            "name": "cross_link",
            "def": "Posttranslationally formed amino acid bonds. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001088": {
            "name": "disulfide_bond",
            "def": "The covalent bond between sulfur atoms that binds two peptide chains or different parts of one peptide chain and is a structural determinant in many protein molecules. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001089": {
            "name": "post_translationally_modified_region",
            "def": "A region where a transformation occurs in a protein after it has been synthesized. This which may regulate, stabilize, crosslink or introduce new chemical functionalities in the protein. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001090": {
            "name": "covalent_binding_site",
            "def": "Binding involving a covalent bond. [EBIBS:GAR]"
          },
          "SO:0001091": {
            "name": "non_covalent_binding_site",
            "def": "Binding site for any chemical group (co-enzyme, prosthetic group, etc.). [EBIBS:GAR]"
          },
          "SO:0001092": {
            "name": "polypeptide_metal_contact",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with metal ions. [EBIBS:GAR, SO:cb, UniProt:curation_manual]"
          },
          "SO:0001093": {
            "name": "protein_protein_contact",
            "def": "A binding site that, in the protein molecule, interacts selectively and non-covalently with polypeptide residues. [EBIBS:GAR, UniProt:Curation_manual]"
          },
          "SO:0001094": {
            "name": "polypeptide_calcium_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with calcium ions. [EBIBS:GAR]"
          },
          "SO:0001095": {
            "name": "polypeptide_cobalt_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with cobalt ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001096": {
            "name": "polypeptide_copper_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with copper ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001097": {
            "name": "polypeptide_iron_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with iron ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001098": {
            "name": "polypeptide_magnesium_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with magnesium ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001099": {
            "name": "polypeptide_manganese_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with manganese ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001100": {
            "name": "polypeptide_molybdenum_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with molybdenum ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001101": {
            "name": "polypeptide_nickel_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with nickel ions. [EBIBS:GAR]"
          },
          "SO:0001102": {
            "name": "polypeptide_tungsten_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with tungsten ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001103": {
            "name": "polypeptide_zinc_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with zinc ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001104": {
            "name": "catalytic_residue",
            "def": "Amino acid involved in the activity of an enzyme. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001105": {
            "name": "polypeptide_ligand_contact",
            "def": "Residues which interact with a ligand. [EBIBS:GAR]"
          },
          "SO:0001106": {
            "name": "asx_motif",
            "def": "A motif of five consecutive residues and two H-bonds in which: Residue(i) is Aspartate or Asparagine (Asx), side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2) or (i+3), main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+3) or (i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001107": {
            "name": "beta_bulge",
            "def": "A motif of three residues within a beta-sheet in which the main chains of two consecutive residues are H-bonded to that of the third, and in which the dihedral angles are as follows: Residue(i): -140 degrees < phi(l) -20 degrees , -90 degrees < psi(l) < 40 degrees. Residue (i+1): -180 degrees < phi < -25 degrees or +120 degrees < phi < +180 degrees, +40 degrees < psi < +180 degrees or -180 degrees < psi < -120 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001108": {
            "name": "beta_bulge_loop",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds. Beta bulge loops often occur at the loop ends of beta-hairpins. [EBIBS:GAR, Http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001109": {
            "name": "beta_bulge_loop_five",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds in which: the main-chain NH of residue(i) is H-bonded to the main-chain CO of residue(i+4), the main-chain CO of residue i is H-bonded to the main-chain NH of residue(i+3), these loops have an RL nest at residues i+2 and i+3. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001110": {
            "name": "beta_bulge_loop_six",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds in which: the main-chain NH of residue(i) is H-bonded to the main-chain CO of residue(i+5), the main-chain CO of residue i is H-bonded to the main-chain NH of residue(i+4), these loops have an RL nest at residues i+3 and i+4. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001111": {
            "name": "beta_strand",
            "def": "A beta strand describes a single length of polypeptide chain that forms part of a beta sheet. A single continuous stretch of amino acids adopting an extended conformation of hydrogen bonds between the N-O and the C=O of another part of the peptide. This forms a secondary protein structure in which two or more extended polypeptide regions are hydrogen-bonded to one another in a planar array. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001112": {
            "name": "antiparallel_beta_strand",
            "def": "A peptide region which hydrogen bonded to another region of peptide running in the oposite direction (one running N-terminal to C-terminal and one running C-terminal to N-terminal). Hydrogen bonding occurs between every other C=O from one strand to every other N-H on the adjacent strand. In this case, if two atoms C-alpha (i) and C-alpha (j) are adjacent in two hydrogen-bonded beta strands, then they form two mutual backbone hydrogen bonds to each other's flanking peptide groups; this is known as a close pair of hydrogen bonds. The peptide backbone dihedral angles (phi, psi) are about (-140 degrees, 135 degrees) in antiparallel sheets. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001113": {
            "name": "parallel_beta_strand",
            "def": "A peptide region which hydrogen bonded to another region of peptide running in the oposite direction (both running N-terminal to C-terminal). This orientation is slightly less stable because it introduces nonplanarity in the inter-strand hydrogen bonding pattern. Hydrogen bonding occurs between every other C=O from one strand to every other N-H on the adjacent strand. In this case, if two atoms C-alpha (i)and C-alpha (j) are adjacent in two hydrogen-bonded beta strands, then they do not hydrogen bond to each other; rather, one residue forms hydrogen bonds to the residues that flank the other (but not vice versa). For example, residue i may form hydrogen bonds to residues j - 1 and j + 1; this is known as a wide pair of hydrogen bonds. By contrast, residue j may hydrogen-bond to different residues altogether, or to none at all. The dihedral angles (phi, psi) are about (-120 degrees, 115 degrees) in parallel sheets. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001114": {
            "name": "peptide_helix",
            "def": "A helix is a secondary_structure conformation where the peptide backbone forms a coil. [EBIBS:GAR]"
          },
          "SO:0001115": {
            "name": "left_handed_peptide_helix",
            "def": "A left handed helix is a region of peptide where the coiled conformation turns in an anticlockwise, left handed screw. [EBIBS:GAR]"
          },
          "SO:0001116": {
            "name": "right_handed_peptide_helix",
            "def": "A right handed helix is a region of peptide where the coiled conformation turns in a clockwise, right handed screw. [EBIBS:GAR]"
          },
          "SO:0001117": {
            "name": "alpha_helix",
            "def": "The helix has 3.6 residues per turn which corresponds to a translation of 1.5 angstroms (= 0.15 nm) along the helical axis. Every backbone N-H group donates a hydrogen bond to the backbone C=O group of the amino acid four residues earlier. [EBIBS:GAR]"
          },
          "SO:0001118": {
            "name": "pi_helix",
            "def": "The pi helix has 4.1 residues per turn and a translation of 1.15  (=0.115 nm) along the helical axis. The N-H group of an amino acid forms a hydrogen bond with the C=O group of the amino acid five residues earlier. [EBIBS:GAR]"
          },
          "SO:0001119": {
            "name": "three_ten_helix",
            "def": "The 3-10 helix has 3 residues per turn with a translation of 2.0 angstroms (=0.2 nm) along the helical axis. The N-H group of an amino acid forms a hydrogen bond with the C=O group of the amino acid three residues earlier. [EBIBS:GAR]"
          },
          "SO:0001120": {
            "name": "polypeptide_nest_motif",
            "def": "A motif of two consecutive residues with dihedral angles. Nest should not have Proline as any residue. Nests frequently occur as parts of other motifs such as Schellman loops. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001121": {
            "name": "polypeptide_nest_left_right_motif",
            "def": "A motif of two consecutive residues with dihedral angles: Residue(i): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001122": {
            "name": "polypeptide_nest_right_left_motif",
            "def": "A motif of two consecutive residues with dihedral angles: Residue(i): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001123": {
            "name": "schellmann_loop",
            "def": "A motif of six or seven consecutive residues that contains two H-bonds. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001124": {
            "name": "schellmann_loop_seven",
            "def": "Wild type: A motif of seven consecutive residues that contains two H-bonds in which: the main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+6), the main-chain CO of residue(i+1) is H-bonded to the main-chain NH of residue(i+5). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001125": {
            "name": "schellmann_loop_six",
            "def": "Common Type: A motif of six consecutive residues that contains two H-bonds in which: the main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+5) the main-chain CO of residue(i+1) is H-bonded to the main-chain NH of residue(i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001126": {
            "name": "serine_threonine_motif",
            "def": "A motif of five consecutive residues and two hydrogen bonds in which: residue(i) is Serine (S) or Threonine (T), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2) or (i+3) , the main-chain CO group of residue(i) is H-bonded to the main-chain NH of residue(i+3) or (i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001127": {
            "name": "serine_threonine_staple_motif",
            "def": "A motif of four or five consecutive residues and one H-bond in which: residue(i) is Serine (S) or Threonine (T), the side-chain OH of residue(i) is H-bonded to the main-chain CO of residue(i3) or (i4), Phi angles of residues(i1), (i2) and (i3) are negative. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001128": {
            "name": "polypeptide_turn_motif",
            "def": "A reversal in the direction of the backbone of a protein that is stabilized by hydrogen bond between backbone NH and CO groups, involving no more than 4 amino acid residues. [EBIBS:GAR, uniprot:feature_type]"
          },
          "SO:0001129": {
            "name": "asx_turn_left_handed_type_one",
            "def": "Left handed type I (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, -90 degrees < psi +120 degrees < +40 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001130": {
            "name": "asx_turn_left_handed_type_two",
            "def": "Left handed type II (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, +80 degrees < psi +120 degrees < +180 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001131": {
            "name": "asx_turn_right_handed_type_two",
            "def": "Right handed type II (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, +80 degrees < psi +120 degrees < +180 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001132": {
            "name": "asx_turn_right_handed_type_one",
            "def": "Right handed type I (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, -90 degrees < psi +120 degrees < +40 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001133": {
            "name": "beta_turn",
            "def": "A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles of the second and third residues, which are the basis for sub-categorization. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001134": {
            "name": "beta_turn_left_handed_type_one",
            "def": "Left handed type I:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles:- Residue(i+1): -140 degrees > phi > -20 degrees, -90 degrees > psi > +40 degrees. Residue(i+2): -140 degrees > phi > -20 degrees, -90 degrees > psi > +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001135": {
            "name": "beta_turn_left_handed_type_two",
            "def": "Left handed type II: A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees > phi > -20 degrees, +80 degrees > psi > +180 degrees. Residue(i+2): +20 degrees > phi > +140 degrees, -40 degrees > psi > +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001136": {
            "name": "beta_turn_right_handed_type_one",
            "def": "Right handed type I:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. Residue(i+2): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001137": {
            "name": "beta_turn_right_handed_type_two",
            "def": "Right handed type II:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees < phi < -20 degrees, +80 degrees < psi < +180 degrees. Residue(i+2): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001138": {
            "name": "gamma_turn",
            "def": "Gamma turns, defined for 3 residues i,( i+1),( i+2) if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001139": {
            "name": "gamma_turn_classic",
            "def": "Gamma turns, defined for 3 residues i, i+1, i+2 if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees: phi(i+1)=75.0 - psi(i+1)=-64.0. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001140": {
            "name": "gamma_turn_inverse",
            "def": "Gamma turns, defined for 3 residues i, i+1, i+2 if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees: phi(i+1)=-79.0 - psi(i+1)=69.0. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001141": {
            "name": "serine_threonine_turn",
            "def": "A motif of three consecutive residues and one H-bond in which: residue(i) is Serine (S) or Threonine (T), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001142": {
            "name": "st_turn_left_handed_type_one",
            "def": "The peptide twists in an anticlockwise, left handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, -90 degrees psi +120 degrees < +40 degrees, residue(i+1): -140 degrees < phi < -20 degrees, -90 < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001143": {
            "name": "st_turn_left_handed_type_two",
            "def": "The peptide twists in an anticlockwise, left handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, +80 degrees psi +120 degrees < +180 degrees, residue(i+1): +20 degrees < phi < +140 degrees, -40 < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001144": {
            "name": "st_turn_right_handed_type_one",
            "def": "The peptide twists in an clockwise, right handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, -90 degrees psi +120 degrees < +40 degrees, residue(i+1): -140 degrees < phi < -20 degrees, -90 < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001145": {
            "name": "st_turn_right_handed_type_two",
            "def": "The peptide twists in an clockwise, right handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, +80 degrees psi +120 degrees < +180 degrees, residue(i+1): +20 degrees < phi < +140 degrees, -40 < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001146": {
            "name": "polypeptide_variation_site",
            "def": "A site of sequence variation (alteration). Alternative sequence due to naturally occurring events such as polymorphisms and alternative splicing or experimental methods such as site directed mutagenesis. [EBIBS:GAR, SO:ke]"
          },
          "SO:0001147": {
            "name": "natural_variant_site",
            "def": "Describes the natural sequence variants due to polymorphisms, disease-associated mutations, RNA editing and variations between strains, isolates or cultivars. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001148": {
            "name": "mutated_variant_site",
            "def": "Site which has been experimentally altered. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001149": {
            "name": "alternate_sequence_site",
            "def": "Description of sequence variants produced by alternative splicing, alternative promoter usage, alternative initiation and ribosomal frameshifting. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001150": {
            "name": "beta_turn_type_six",
            "def": "A motif of four consecutive peptide resides of type VIa or type VIb and where the i+2 residue is cis-proline. [SO:cb]"
          },
          "SO:0001151": {
            "name": "beta_turn_type_six_a",
            "def": "A motif of four consecutive peptide residues, of which the i+2 residue is proline, and that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -60 degrees, psi ~ 120 degrees. Residue(i+2): phi ~ -90 degrees, psi ~ 0 degrees. [PMID:2371257, SO:cb]"
          },
          "SO:0001152": {
            "name": "beta_turn_type_six_a_one"
          },
          "SO:0001153": {
            "name": "beta_turn_type_six_a_two"
          },
          "SO:0001154": {
            "name": "beta_turn_type_six_b",
            "def": "A motif of four consecutive peptide residues, of which the i+2 residue is proline, and that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -120 degrees, psi ~ 120 degrees. Residue(i+2): phi ~ -60 degrees, psi ~ 0 degrees. [PMID:2371257, SO:cb]"
          },
          "SO:0001155": {
            "name": "beta_turn_type_eight",
            "def": "A motif of four consecutive peptide residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -60 degrees, psi ~ -30 degrees. Residue(i+2): phi ~ -120 degrees, psi ~ 120 degrees. [PMID:2371257, SO:cb]"
          },
          "SO:0001156": {
            "name": "DRE_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -10 and -60 relative to the TSS. Consensus sequence is WATCGATW. [PMID:12537576]"
          },
          "SO:0001157": {
            "name": "DMv4_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, located immediately upstream of some TATA box elements with respect to the TSS (+1). Consensus sequence is YGGTCACACTR. Marked spatial preference within core promoter; tend to occur near the TSS, although not as tightly as INR (SO:0000014). [PMID:16827941:12537576]"
          },
          "SO:0001158": {
            "name": "E_box_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -60 and +1 relative to the TSS. Consensus sequence is AWCAGCTGWT. Tends to co-occur with DMv2 (SO:0001161). Tends to not occur with DPE motif (SO:0000015). [PMID:12537576:16827941]"
          },
          "SO:0001159": {
            "name": "DMv5_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -50 and -10 relative to the TSS. Consensus sequence is KTYRGTATWTTT. Tends to co-occur with DMv4 (SO:0001157) . Tends to not occur with DPE motif (SO:0000015) or MTE (SO:0001162). [PMID:12537576:16827941]"
          },
          "SO:0001160": {
            "name": "DMv3_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -30 and +15 relative to the TSS. Consensus sequence is KNNCAKCNCTRNY. Tends to co-occur with DMv2 (SO:0001161). Tends to not occur with DPE motif (SO:0000015) or MTE (0001162). [PMID:12537576:16827941]"
          },
          "SO:0001161": {
            "name": "DMv2_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -60 and -45 relative to the TSS. Consensus sequence is MKSYGGCARCGSYSS. Tends to co-occur with DMv3 (SO:0001160). Tends to not occur with DPE motif (SO:0000015) or MTE (SO:0001162). [PMID:12537576:16827941]"
          },
          "SO:0001162": {
            "name": "MTE",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between +20 and +30 relative to the TSS. Consensus sequence is CSARCSSAACGS. Tends to co-occur with INR motif (SO:0000014). Tends to not occur with DPE motif (SO:0000015) or DMv5 (SO:0001159). [PMID:12537576:15231738, PMID:16858867]"
          },
          "SO:0001163": {
            "name": "INR1_motif",
            "def": "A promoter motif with consensus sequence TCATTCG. [PMID:16827941]"
          },
          "SO:0001164": {
            "name": "DPE1_motif",
            "def": "A promoter motif with consensus sequence CGGACGT. [PMID:16827941]"
          },
          "SO:0001165": {
            "name": "DMv1_motif",
            "def": "A promoter motif with consensus sequence CARCCCT. [PMID:16827941]"
          },
          "SO:0001166": {
            "name": "GAGA_motif",
            "def": "A non directional promoter motif with consensus sequence GAGAGCG. [PMID:16827941]"
          },
          "SO:0001167": {
            "name": "NDM2_motif",
            "def": "A non directional promoter motif with consensus CGMYGYCR. [PMID:16827941]"
          },
          "SO:0001168": {
            "name": "NDM3_motif",
            "def": "A non directional promoter motif with consensus sequence GAAAGCT. [PMID:16827941]"
          },
          "SO:0001169": {
            "name": "ds_RNA_viral_sequence",
            "def": "A ds_RNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as double stranded RNA. [SO:ke]"
          },
          "SO:0001170": {
            "name": "polinton",
            "def": "A kind of DNA transposon that populates the genomes of protists, fungi, and animals, characterized by a unique set of proteins necessary for their transposition, including a protein-primed DNA polymerase B, retroviral integrase, cysteine protease, and ATPase. Polintons are characterized by 6-bp target site duplications, terminal-inverted repeats that are several hundred nucleotides long, and 5'-AG and TC-3' termini. Polintons exist as autonomous and nonautonomous elements. [PMID:16537396]"
          },
          "SO:0001171": {
            "name": "rRNA_21S",
            "def": "A component of the large ribosomal subunit in mitochondrial rRNA. [RSC:cb]"
          },
          "SO:0001172": {
            "name": "tRNA_region",
            "def": "A region of a tRNA. [RSC:cb]"
          },
          "SO:0001173": {
            "name": "anticodon_loop",
            "def": "A sequence of seven nucleotide bases in tRNA which contains the anticodon. It has the sequence 5'-pyrimidine-purine-anticodon-modified purine-any base-3. [ISBN:0716719207]"
          },
          "SO:0001174": {
            "name": "anticodon",
            "def": "A sequence of three nucleotide bases in tRNA which recognizes a codon in mRNA. [RSC:cb]"
          },
          "SO:0001175": {
            "name": "CCA_tail",
            "def": "Base sequence at the 3' end of a tRNA. The 3'-hydroxyl group on the terminal adenosine is the attachment point for the amino acid. [ISBN:0716719207]"
          },
          "SO:0001176": {
            "name": "DHU_loop",
            "def": "Non-base-paired sequence of nucleotide bases in tRNA. It contains several dihydrouracil residues. [ISBN:071671920]"
          },
          "SO:0001177": {
            "name": "T_loop",
            "def": "Non-base-paired sequence of three nucleotide bases in tRNA. It has sequence T-Psi-C. [ISBN:0716719207]"
          },
          "SO:0001178": {
            "name": "pyrrolysine_tRNA_primary_transcript",
            "def": "A primary transcript encoding pyrrolysyl tRNA (SO:0000766). [RSC:cb]"
          },
          "SO:0001179": {
            "name": "U3_snoRNA",
            "def": "U3 snoRNA is a member of the box C/D class of small nucleolar RNAs. The U3 snoRNA secondary structure is characterised by a small 5' domain (with boxes A and A'), and a larger 3' domain (with boxes B, C, C', and D), the two domains being linked by a single-stranded hinge. Boxes B and C form the B/C motif, which appears to be exclusive to U3 snoRNAs, and boxes C' and D form the C'/D motif. The latter is functionally similar to the C/D motifs found in other snoRNAs. The 5' domain and the hinge region act as a pre-rRNA-binding domain. The 3' domain has conserved protein-binding sites. Both the box B/C and box C'/D motifs are sufficient for nuclear retention of U3 snoRNA. The box C'/D motif is also necessary for nucleolar localization, stability and hypermethylation of U3 snoRNA. Both box B/C and C'/D motifs are involved in specific protein interactions and are necessary for the rRNA processing functions of U3 snoRNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00012]"
          },
          "SO:0001180": {
            "name": "AU_rich_element",
            "def": "A cis-acting element found in the 3' UTR of some mRNA which is rich in AUUUA pentamers. Messenger RNAs bearing multiple AU-rich elements are often unstable. [PMID:7892223]"
          },
          "SO:0001181": {
            "name": "Bruno_response_element",
            "def": "A cis-acting element found in the 3' UTR of some mRNA which is bound by the Drosophila Bruno protein and its homologs. [PMID:10893231]"
          },
          "SO:0001182": {
            "name": "iron_responsive_element",
            "def": "A regulatory sequence found in the 5' and 3' UTRs of many mRNAs which encode iron-binding proteins. It has a hairpin structure and is recognized by trans-acting proteins known as iron-regulatory proteins. [PMID:3198610, PMID:8710843]"
          },
          "SO:0001183": {
            "name": "morpholino_backbone",
            "def": "An attribute describing a sequence composed of nucleobases bound to a morpholino backbone. A morpholino backbone consists of morpholine (CHEBI:34856) rings connected by phosphorodiamidate linkages. [RSC:cb]"
          },
          "SO:0001184": {
            "name": "PNA",
            "def": "An attribute describing a sequence composed of peptide nucleic acid (CHEBI:48021), a chemical consisting of nucleobases bound to a backbone composed of repeating N-(2-aminoethyl)-glycine units linked by peptide bonds. The purine and pyrimidine bases are linked to the backbone by methylene carbonyl bonds. [RSC:cb]"
          },
          "SO:0001185": {
            "name": "enzymatic",
            "def": "An attribute describing the sequence of a transcript that has catalytic activity with or without an associated ribonucleoprotein. [RSC:cb]"
          },
          "SO:0001186": {
            "name": "ribozymic",
            "def": "An attribute describing the sequence of a transcript that has catalytic activity even without an associated ribonucleoprotein. [RSC:cb]"
          },
          "SO:0001187": {
            "name": "pseudouridylation_guide_snoRNA",
            "def": "A snoRNA that specifies the site of pseudouridylation in an RNA molecule by base pairing with a short sequence around the target residue. [GOC:mah, PMID:12457565]"
          },
          "SO:0001188": {
            "name": "LNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of 'locked' deoxyribose rings connected to a phosphate backbone. The deoxyribose unit's conformation is 'locked' by a 2'-C,4'-C-oxymethylene link. [CHEBI:48010]"
          },
          "SO:0001189": {
            "name": "LNA_oligo",
            "def": "An oligo composed of LNA residues. [RSC:cb]"
          },
          "SO:0001190": {
            "name": "TNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of threose rings connected to a phosphate backbone. [CHEBI:48019]"
          },
          "SO:0001191": {
            "name": "TNA_oligo",
            "def": "An oligo composed of TNA residues. [RSC:cb]"
          },
          "SO:0001192": {
            "name": "GNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of an acyclic three-carbon propylene glycol connected to a phosphate backbone. It has two enantiomeric forms, (R)-GNA and (S)-GNA. [CHEBI:48015]"
          },
          "SO:0001193": {
            "name": "GNA_oligo",
            "def": "An oligo composed of GNA residues. [RSC:cb]"
          },
          "SO:0001194": {
            "name": "R_GNA",
            "def": "An attribute describing a GNA sequence in the (R)-GNA enantiomer. [CHEBI:48016]"
          },
          "SO:0001195": {
            "name": "R_GNA_oligo",
            "def": "An oligo composed of (R)-GNA residues. [RSC:cb]"
          },
          "SO:0001196": {
            "name": "S_GNA",
            "def": "An attribute describing a GNA sequence in the (S)-GNA enantiomer. [CHEBI:48017]"
          },
          "SO:0001197": {
            "name": "S_GNA_oligo",
            "def": "An oligo composed of (S)-GNA residues. [RSC:cb]"
          },
          "SO:0001198": {
            "name": "ds_DNA_viral_sequence",
            "def": "A ds_DNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as double stranded DNA. [SO:ke]"
          },
          "SO:0001199": {
            "name": "ss_RNA_viral_sequence",
            "def": "A ss_RNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as single stranded RNA. [SO:ke]"
          },
          "SO:0001200": {
            "name": "negative_sense_ssRNA_viral_sequence",
            "def": "A negative_sense_RNA_viral_sequence is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus that is complementary to mRNA and must be converted to positive sense RNA by RNA polymerase before translation. [SO:ke]"
          },
          "SO:0001201": {
            "name": "positive_sense_ssRNA_viral_sequence",
            "def": "A positive_sense_RNA_viral_sequence is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus that can be immediately translated by the host. [SO:ke]"
          },
          "SO:0001202": {
            "name": "ambisense_ssRNA_viral_sequence",
            "def": "A ambisense_RNA_virus is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus with both messenger and anti messenger polarity. [SO:ke]"
          },
          "SO:0001203": {
            "name": "RNA_polymerase_promoter",
            "def": "A region (DNA) to which RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001204": {
            "name": "Phage_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which Bacteriophage RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001205": {
            "name": "SP6_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which the SP6 RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001206": {
            "name": "T3_RNA_Polymerase_Promoter",
            "def": "A DNA sequence to which the T3 RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001207": {
            "name": "T7_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which the T7 RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001208": {
            "name": "five_prime_EST",
            "def": "An EST read from the 5' end of a transcript that usually codes for a protein. These regions tend to be conserved across species and do not change much within a gene family. [http://www.ncbi.nlm.nih.gov/About/primer/est.html]"
          },
          "SO:0001209": {
            "name": "three_prime_EST",
            "def": "An EST read from the 3' end of a transcript. They are more likely to fall within non-coding, or untranslated regions(UTRs). [http://www.ncbi.nlm.nih.gov/About/primer/est.html]"
          },
          "SO:0001210": {
            "name": "translational_frameshift",
            "def": "The region of mRNA (not divisible by 3 bases) that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
          },
          "SO:0001211": {
            "name": "plus_1_translational_frameshift",
            "def": "The region of mRNA 1 base long that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
          },
          "SO:0001212": {
            "name": "plus_2_translational_frameshift",
            "def": "The region of mRNA 2 bases long that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
          },
          "SO:0001213": {
            "name": "group_III_intron",
            "def": "Group III introns are introns found in the mRNA of the plastids of euglenoid protists. They are spliced by a two step transesterification with bulged adenosine as initiating nucleophile. [PMID:11377794]"
          },
          "SO:0001214": {
            "name": "noncoding_region_of_exon",
            "def": "The maximal intersection of exon and UTR. [SO:ke]"
          },
          "SO:0001215": {
            "name": "coding_region_of_exon",
            "def": "The region of an exon that encodes for protein sequence. [SO:ke]"
          },
          "SO:0001216": {
            "name": "endonuclease_spliced_intron",
            "def": "An intron that spliced via endonucleolytic cleavage and ligation rather than transesterification. [SO:ke]"
          },
          "SO:0001217": {
            "name": "protein_coding_gene"
          },
          "SO:0001218": {
            "name": "transgenic_insertion",
            "def": "An insertion that derives from another organism, via the use of recombinant DNA technology. [SO:bm]"
          },
          "SO:0001219": {
            "name": "retrogene"
          },
          "SO:0001220": {
            "name": "silenced_by_RNA_interference",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by RNA interference. [RSC:cb]"
          },
          "SO:0001221": {
            "name": "silenced_by_histone_modification",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone modification. [RSC:cb]"
          },
          "SO:0001222": {
            "name": "silenced_by_histone_methylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone methylation. [RSC:cb]"
          },
          "SO:0001223": {
            "name": "silenced_by_histone_deacetylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone deacetylation. [RSC:cb]"
          },
          "SO:0001224": {
            "name": "gene_silenced_by_RNA_interference",
            "def": "A gene that is silenced by RNA interference. [SO:xp]"
          },
          "SO:0001225": {
            "name": "gene_silenced_by_histone_modification",
            "def": "A gene that is silenced by histone modification. [SO:xp]"
          },
          "SO:0001226": {
            "name": "gene_silenced_by_histone_methylation",
            "def": "A gene that is silenced by histone methylation. [SO:xp]"
          },
          "SO:0001227": {
            "name": "gene_silenced_by_histone_deacetylation",
            "def": "A gene that is silenced by histone deacetylation. [SO:xp]"
          },
          "SO:0001228": {
            "name": "dihydrouridine",
            "def": "A modified RNA base in which the 5,6-dihydrouracil is bound to the ribose ring. [RSC:cb]"
          },
          "SO:0001229": {
            "name": "pseudouridine",
            "def": "A modified RNA base in which the 5- position of the uracil is bound to the ribose ring instead of the 4- position. [RSC:cb]"
          },
          "SO:0001230": {
            "name": "inosine",
            "def": "A modified RNA base in which hypoxanthine is bound to the ribose ring. [http://library.med.utah.edu/RNAmods/, RSC:cb]"
          },
          "SO:0001231": {
            "name": "seven_methylguanine",
            "def": "A modified RNA base in which guanine is methylated at the 7- position. [RSC:cb]"
          },
          "SO:0001232": {
            "name": "ribothymidine",
            "def": "A modified RNA base in which thymine is bound to the ribose ring. [RSC:cb]"
          },
          "SO:0001233": {
            "name": "methylinosine",
            "def": "A modified RNA base in which methylhypoxanthine is bound to the ribose ring. [RSC:cb]"
          },
          "SO:0001234": {
            "name": "mobile",
            "def": "An attribute describing a feature that has either intra-genome or intracellular mobility. [RSC:cb]"
          },
          "SO:0001235": {
            "name": "replicon",
            "def": "A region containing at least one unique origin of replication and a unique termination site. [ISBN:0716719207]"
          },
          "SO:0001236": {
            "name": "base",
            "def": "A base is a sequence feature that corresponds to a single unit of a nucleotide polymer. [SO:ke]"
          },
          "SO:0001237": {
            "name": "amino_acid",
            "def": "A sequence feature that corresponds to a single amino acid residue in a polypeptide. [RSC:cb]"
          },
          "SO:0001238": {
            "name": "major_TSS"
          },
          "SO:0001239": {
            "name": "minor_TSS"
          },
          "SO:0001240": {
            "name": "TSS_region",
            "def": "The region of a gene from the 5' most TSS to the 3' TSS. [BBOP:nw]"
          },
          "SO:0001241": {
            "name": "encodes_alternate_transcription_start_sites"
          },
          "SO:0001243": {
            "name": "miRNA_primary_transcript_region",
            "def": "A part of an miRNA primary_transcript. [SO:ke]"
          },
          "SO:0001244": {
            "name": "pre_miRNA",
            "def": "The 60-70 nucleotide region remain after Drosha processing of the primary transcript, that folds back upon itself to form a hairpin structure. [SO:ke]"
          },
          "SO:0001245": {
            "name": "miRNA_stem",
            "def": "The stem of the hairpin loop formed by folding of the pre-miRNA. [SO:ke]"
          },
          "SO:0001246": {
            "name": "miRNA_loop",
            "def": "The loop of the hairpin loop formed by folding of the pre-miRNA. [SO:ke]"
          },
          "SO:0001247": {
            "name": "synthetic_oligo",
            "def": "An oligo composed of synthetic nucleotides. [SO:ke]"
          },
          "SO:0001248": {
            "name": "assembly",
            "def": "A region of the genome of known length that is composed by ordering and aligning two or more different regions. [SO:ke]"
          },
          "SO:0001249": {
            "name": "fragment_assembly",
            "def": "A fragment assembly is a genome assembly that orders overlapping fragments of the genome based on landmark sequences. The base pair distance between the landmarks is known allowing additivity of lengths. [SO:ke]"
          },
          "SO:0001250": {
            "name": "fingerprint_map",
            "def": "A fingerprint_map is a physical map composed of restriction fragments. [SO:ke]"
          },
          "SO:0001251": {
            "name": "STS_map",
            "def": "An STS map is a physical map organized by the unique STS landmarks. [SO:ke]"
          },
          "SO:0001252": {
            "name": "RH_map",
            "def": "A radiation hybrid map is a physical map. [SO:ke]"
          },
          "SO:0001253": {
            "name": "sonicate_fragment",
            "def": "A DNA fragment generated by sonication. Sonication is a technique used to sheer DNA into smaller fragments. [SO:ke]"
          },
          "SO:0001254": {
            "name": "polyploid",
            "def": "A kind of chromosome variation where the chromosome complement is an exact multiple of the haploid number and is greater than the diploid number. [SO:ke]"
          },
          "SO:0001255": {
            "name": "autopolyploid",
            "def": "A polyploid where the multiple chromosome set was derived from the same organism. [SO:ke]"
          },
          "SO:0001256": {
            "name": "allopolyploid",
            "def": "A polyploid where the multiple chromosome set was derived from a different organism. [SO:ke]"
          },
          "SO:0001257": {
            "name": "homing_endonuclease_binding_site",
            "def": "The binding site (recognition site) of a homing endonuclease. The binding site is typically large. [SO:ke]"
          },
          "SO:0001258": {
            "name": "octamer_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters with sequence ATTGCAT that binds Pou-domain transcription factors. [GOC:dh, PMID:3095662]"
          },
          "SO:0001259": {
            "name": "apicoplast_chromosome",
            "def": "A chromosome originating in an apicoplast. [SO:xp]"
          },
          "SO:0001260": {
            "name": "sequence_collection",
            "def": "A collection of discontinuous sequences. [SO:ke]"
          },
          "SO:0001261": {
            "name": "overlapping_feature_set",
            "def": "A continuous region of sequence composed of the overlapping of multiple sequence_features, which ultimately provides evidence for another sequence_feature. [SO:ke]"
          },
          "SO:0001262": {
            "name": "overlapping_EST_set",
            "def": "A continous experimental result region extending the length of multiple overlapping EST's. [SO:ke]"
          },
          "SO:0001263": {
            "name": "ncRNA_gene"
          },
          "SO:0001264": {
            "name": "gRNA_gene"
          },
          "SO:0001265": {
            "name": "miRNA_gene"
          },
          "SO:0001266": {
            "name": "scRNA_gene"
          },
          "SO:0001267": {
            "name": "snoRNA_gene"
          },
          "SO:0001268": {
            "name": "snRNA_gene"
          },
          "SO:0001269": {
            "name": "SRP_RNA_gene"
          },
          "SO:0001271": {
            "name": "tmRNA_gene"
          },
          "SO:0001272": {
            "name": "tRNA_gene"
          },
          "SO:0001273": {
            "name": "modified_adenosine",
            "def": "A modified adenine is an adenine base feature that has been altered. [SO:ke]"
          },
          "SO:0001274": {
            "name": "modified_inosine",
            "def": "A modified inosine is an inosine base feature that has been altered. [SO:ke]"
          },
          "SO:0001275": {
            "name": "modified_cytidine",
            "def": "A modified cytidine is a cytidine base feature which has been altered. [SO:ke]"
          },
          "SO:0001276": {
            "name": "modified_guanosine"
          },
          "SO:0001277": {
            "name": "modified_uridine"
          },
          "SO:0001278": {
            "name": "one_methylinosine",
            "def": "1-methylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001279": {
            "name": "one_two_prime_O_dimethylinosine",
            "def": "1,2'-O-dimethylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001280": {
            "name": "two_prime_O_methylinosine",
            "def": "2'-O-methylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001281": {
            "name": "three_methylcytidine",
            "def": "3-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001282": {
            "name": "five_methylcytidine",
            "def": "5-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001283": {
            "name": "two_prime_O_methylcytidine",
            "def": "2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001284": {
            "name": "two_thiocytidine",
            "def": "2-thiocytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001285": {
            "name": "N4_acetylcytidine",
            "def": "N4-acetylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001286": {
            "name": "five_formylcytidine",
            "def": "5-formylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001287": {
            "name": "five_two_prime_O_dimethylcytidine",
            "def": "5,2'-O-dimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001288": {
            "name": "N4_acetyl_2_prime_O_methylcytidine",
            "def": "N4-acetyl-2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001289": {
            "name": "lysidine",
            "def": "Lysidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001290": {
            "name": "N4_methylcytidine",
            "def": "N4-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001291": {
            "name": "N4_2_prime_O_dimethylcytidine",
            "def": "N4,2'-O-dimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001292": {
            "name": "five_hydroxymethylcytidine",
            "def": "5-hydroxymethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001293": {
            "name": "five_formyl_two_prime_O_methylcytidine",
            "def": "5-formyl-2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001294": {
            "name": "N4_N4_2_prime_O_trimethylcytidine",
            "def": "N4_N4_2_prime_O_trimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001295": {
            "name": "one_methyladenosine",
            "def": "1_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001296": {
            "name": "two_methyladenosine",
            "def": "2_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001297": {
            "name": "N6_methyladenosine",
            "def": "N6_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001298": {
            "name": "two_prime_O_methyladenosine",
            "def": "2prime_O_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001299": {
            "name": "two_methylthio_N6_methyladenosine",
            "def": "2_methylthio_N6_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001300": {
            "name": "N6_isopentenyladenosine",
            "def": "N6_isopentenyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001301": {
            "name": "two_methylthio_N6_isopentenyladenosine",
            "def": "2_methylthio_N6_isopentenyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001302": {
            "name": "N6_cis_hydroxyisopentenyl_adenosine",
            "def": "N6_cis_hydroxyisopentenyl_adenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001303": {
            "name": "two_methylthio_N6_cis_hydroxyisopentenyl_adenosine",
            "def": "2_methylthio_N6_cis_hydroxyisopentenyl_adenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001304": {
            "name": "N6_glycinylcarbamoyladenosine",
            "def": "N6_glycinylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001305": {
            "name": "N6_threonylcarbamoyladenosine",
            "def": "N6_threonylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001306": {
            "name": "two_methylthio_N6_threonyl_carbamoyladenosine",
            "def": "2_methylthio_N6_threonyl_carbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001307": {
            "name": "N6_methyl_N6_threonylcarbamoyladenosine",
            "def": "N6_methyl_N6_threonylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001308": {
            "name": "N6_hydroxynorvalylcarbamoyladenosine",
            "def": "N6_hydroxynorvalylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001309": {
            "name": "two_methylthio_N6_hydroxynorvalyl_carbamoyladenosine",
            "def": "2_methylthio_N6_hydroxynorvalyl_carbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001310": {
            "name": "two_prime_O_ribosyladenosine_phosphate",
            "def": "2prime_O_ribosyladenosine_phosphate is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001311": {
            "name": "N6_N6_dimethyladenosine",
            "def": "N6_N6_dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001312": {
            "name": "N6_2_prime_O_dimethyladenosine",
            "def": "N6_2prime_O_dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001313": {
            "name": "N6_N6_2_prime_O_trimethyladenosine",
            "def": "N6_N6_2prime_O_trimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001314": {
            "name": "one_two_prime_O_dimethyladenosine",
            "def": "1,2'-O-dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001315": {
            "name": "N6_acetyladenosine",
            "def": "N6_acetyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001316": {
            "name": "seven_deazaguanosine",
            "def": "7-deazaguanosine is a modified guanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001317": {
            "name": "queuosine",
            "def": "Queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001318": {
            "name": "epoxyqueuosine",
            "def": "Epoxyqueuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001319": {
            "name": "galactosyl_queuosine",
            "def": "Galactosyl_queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001320": {
            "name": "mannosyl_queuosine",
            "def": "Mannosyl_queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001321": {
            "name": "seven_cyano_seven_deazaguanosine",
            "def": "7_cyano_7_deazaguanosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001322": {
            "name": "seven_aminomethyl_seven_deazaguanosine",
            "def": "7_aminomethyl_7_deazaguanosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001323": {
            "name": "archaeosine",
            "def": "Archaeosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001324": {
            "name": "one_methylguanosine",
            "def": "1_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001325": {
            "name": "N2_methylguanosine",
            "def": "N2_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001326": {
            "name": "seven_methylguanosine",
            "def": "7_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001327": {
            "name": "two_prime_O_methylguanosine",
            "def": "2prime_O_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001328": {
            "name": "N2_N2_dimethylguanosine",
            "def": "N2_N2_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001329": {
            "name": "N2_2_prime_O_dimethylguanosine",
            "def": "N2_2prime_O_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001330": {
            "name": "N2_N2_2_prime_O_trimethylguanosine",
            "def": "N2_N2_2prime_O_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001331": {
            "name": "two_prime_O_ribosylguanosine_phosphate",
            "def": "2prime_O_ribosylguanosine_phosphate is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001332": {
            "name": "wybutosine",
            "def": "Wybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001333": {
            "name": "peroxywybutosine",
            "def": "Peroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001334": {
            "name": "hydroxywybutosine",
            "def": "Hydroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001335": {
            "name": "undermodified_hydroxywybutosine",
            "def": "Undermodified_hydroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001336": {
            "name": "wyosine",
            "def": "Wyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001337": {
            "name": "methylwyosine",
            "def": "Methylwyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001338": {
            "name": "N2_7_dimethylguanosine",
            "def": "N2_7_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001339": {
            "name": "N2_N2_7_trimethylguanosine",
            "def": "N2_N2_7_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001340": {
            "name": "one_two_prime_O_dimethylguanosine",
            "def": "1_2prime_O_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001341": {
            "name": "four_demethylwyosine",
            "def": "4_demethylwyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001342": {
            "name": "isowyosine",
            "def": "Isowyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001343": {
            "name": "N2_7_2prirme_O_trimethylguanosine",
            "def": "N2_7_2prirme_O_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001344": {
            "name": "five_methyluridine",
            "def": "5_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001345": {
            "name": "two_prime_O_methyluridine",
            "def": "2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001346": {
            "name": "five_two_prime_O_dimethyluridine",
            "def": "5_2_prime_O_dimethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001347": {
            "name": "one_methylpseudouridine",
            "def": "1_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001348": {
            "name": "two_prime_O_methylpseudouridine",
            "def": "2prime_O_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001349": {
            "name": "two_thiouridine",
            "def": "2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001350": {
            "name": "four_thiouridine",
            "def": "4_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001351": {
            "name": "five_methyl_2_thiouridine",
            "def": "5_methyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001352": {
            "name": "two_thio_two_prime_O_methyluridine",
            "def": "2_thio_2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001353": {
            "name": "three_three_amino_three_carboxypropyl_uridine",
            "def": "3_3_amino_3_carboxypropyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001354": {
            "name": "five_hydroxyuridine",
            "def": "5_hydroxyuridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001355": {
            "name": "five_methoxyuridine",
            "def": "5_methoxyuridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001356": {
            "name": "uridine_five_oxyacetic_acid",
            "def": "Uridine_5_oxyacetic_acid is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001357": {
            "name": "uridine_five_oxyacetic_acid_methyl_ester",
            "def": "Uridine_5_oxyacetic_acid_methyl_ester is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001358": {
            "name": "five_carboxyhydroxymethyl_uridine",
            "def": "5_carboxyhydroxymethyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001359": {
            "name": "five_carboxyhydroxymethyl_uridine_methyl_ester",
            "def": "5_carboxyhydroxymethyl_uridine_methyl_ester is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001360": {
            "name": "five_methoxycarbonylmethyluridine",
            "def": "Five_methoxycarbonylmethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001361": {
            "name": "five_methoxycarbonylmethyl_two_prime_O_methyluridine",
            "def": "Five_methoxycarbonylmethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001362": {
            "name": "five_methoxycarbonylmethyl_two_thiouridine",
            "def": "5_methoxycarbonylmethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001363": {
            "name": "five_aminomethyl_two_thiouridine",
            "def": "5_aminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001364": {
            "name": "five_methylaminomethyluridine",
            "def": "5_methylaminomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001365": {
            "name": "five_methylaminomethyl_two_thiouridine",
            "def": "5_methylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001366": {
            "name": "five_methylaminomethyl_two_selenouridine",
            "def": "5_methylaminomethyl_2_selenouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001367": {
            "name": "five_carbamoylmethyluridine",
            "def": "5_carbamoylmethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001368": {
            "name": "five_carbamoylmethyl_two_prime_O_methyluridine",
            "def": "5_carbamoylmethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001369": {
            "name": "five_carboxymethylaminomethyluridine",
            "def": "5_carboxymethylaminomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001370": {
            "name": "five_carboxymethylaminomethyl_two_prime_O_methyluridine",
            "def": "5_carboxymethylaminomethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001371": {
            "name": "five_carboxymethylaminomethyl_two_thiouridine",
            "def": "5_carboxymethylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001372": {
            "name": "three_methyluridine",
            "def": "3_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001373": {
            "name": "one_methyl_three_three_amino_three_carboxypropyl_pseudouridine",
            "def": "1_methyl_3_3_amino_3_carboxypropyl_pseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001374": {
            "name": "five_carboxymethyluridine",
            "def": "5_carboxymethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001375": {
            "name": "three_two_prime_O_dimethyluridine",
            "def": "3_2prime_O_dimethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001376": {
            "name": "five_methyldihydrouridine",
            "def": "5_methyldihydrouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001377": {
            "name": "three_methylpseudouridine",
            "def": "3_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001378": {
            "name": "five_taurinomethyluridine",
            "def": "5_taurinomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001379": {
            "name": "five_taurinomethyl_two_thiouridine",
            "def": "5_taurinomethyl_2_thiouridineis a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001380": {
            "name": "five_isopentenylaminomethyl_uridine",
            "def": "5_isopentenylaminomethyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001381": {
            "name": "five_isopentenylaminomethyl_two_thiouridine",
            "def": "5_isopentenylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001382": {
            "name": "five_isopentenylaminomethyl_two_prime_O_methyluridine",
            "def": "5_isopentenylaminomethyl_2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001383": {
            "name": "histone_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues of a histone. [SO:ke]"
          },
          "SO:0001384": {
            "name": "CDS_fragment"
          },
          "SO:0001385": {
            "name": "modified_amino_acid_feature",
            "def": "A post translationally modified amino acid feature. [SO:ke]"
          },
          "SO:0001386": {
            "name": "modified_glycine",
            "def": "A post translationally modified glycine amino acid feature. [SO:ke]"
          },
          "SO:0001387": {
            "name": "modified_L_alanine",
            "def": "A post translationally modified alanine amino acid feature. [SO:ke]"
          },
          "SO:0001388": {
            "name": "modified_L_asparagine",
            "def": "A post translationally modified asparagine amino acid feature. [SO:ke]"
          },
          "SO:0001389": {
            "name": "modified_L_aspartic_acid",
            "def": "A post translationally modified aspartic acid amino acid feature. [SO:ke]"
          },
          "SO:0001390": {
            "name": "modified_L_cysteine",
            "def": "A post translationally modified cysteine amino acid feature. [SO:ke]"
          },
          "SO:0001391": {
            "name": "modified_L_glutamic_acid"
          },
          "SO:0001392": {
            "name": "modified_L_threonine",
            "def": "A post translationally modified threonine amino acid feature. [SO:ke]"
          },
          "SO:0001393": {
            "name": "modified_L_tryptophan",
            "def": "A post translationally modified tryptophan amino acid feature. [SO:ke]"
          },
          "SO:0001394": {
            "name": "modified_L_glutamine",
            "def": "A post translationally modified glutamine amino acid feature. [SO:ke]"
          },
          "SO:0001395": {
            "name": "modified_L_methionine",
            "def": "A post translationally modified methionine amino acid feature. [SO:ke]"
          },
          "SO:0001396": {
            "name": "modified_L_isoleucine",
            "def": "A post translationally modified isoleucine amino acid feature. [SO:ke]"
          },
          "SO:0001397": {
            "name": "modified_L_phenylalanine",
            "def": "A post translationally modified phenylalanine amino acid feature. [SO:ke]"
          },
          "SO:0001398": {
            "name": "modified_L_histidine",
            "def": "A post translationally modified histidine amino acid feature. [SO:ke]"
          },
          "SO:0001399": {
            "name": "modified_L_serine",
            "def": "A post translationally modified serine amino acid feature. [SO:ke]"
          },
          "SO:0001400": {
            "name": "modified_L_lysine",
            "def": "A post translationally modified lysine amino acid feature. [SO:ke]"
          },
          "SO:0001401": {
            "name": "modified_L_leucine",
            "def": "A post translationally modified leucine amino acid feature. [SO:ke]"
          },
          "SO:0001402": {
            "name": "modified_L_selenocysteine",
            "def": "A post translationally modified selenocysteine amino acid feature. [SO:ke]"
          },
          "SO:0001403": {
            "name": "modified_L_valine",
            "def": "A post translationally modified valine amino acid feature. [SO:ke]"
          },
          "SO:0001404": {
            "name": "modified_L_proline",
            "def": "A post translationally modified proline amino acid feature. [SO:ke]"
          },
          "SO:0001405": {
            "name": "modified_L_tyrosine",
            "def": "A post translationally modified tyrosine amino acid feature. [SO:ke]"
          },
          "SO:0001406": {
            "name": "modified_L_arginine",
            "def": "A post translationally modified arginine amino acid feature. [SO:ke]"
          },
          "SO:0001407": {
            "name": "peptidyl",
            "def": "An attribute describing the nature of a proteinaceous polymer, where by the amino acid units are joined by peptide bonds. [SO:ke]"
          },
          "SO:0001408": {
            "name": "cleaved_for_gpi_anchor_region",
            "def": "The C-terminal residues of a polypeptide which are exchanged for a GPI-anchor. [EBI:rh]"
          },
          "SO:0001409": {
            "name": "biomaterial_region",
            "def": "A region which is intended for use in an experiment. [SO:cb]"
          },
          "SO:0001410": {
            "name": "experimental_feature",
            "def": "A region which is the result of some arbitrary experimental procedure. The procedure may be carried out with biological material or inside a computer. [SO:cb]"
          },
          "SO:0001411": {
            "name": "biological_region",
            "def": "A region defined by its disposition to be involved in a biological process. [SO:cb]"
          },
          "SO:0001412": {
            "name": "topologically_defined_region",
            "def": "A region that is defined according to its relations with other regions within the same sequence. [SO:cb]"
          },
          "SO:0001413": {
            "name": "translocation_breakpoint",
            "def": "The point within a chromosome where a translocation begins or ends. [SO:cb]"
          },
          "SO:0001414": {
            "name": "insertion_breakpoint",
            "def": "The point within a chromosome where a insertion begins or ends. [SO:cb]"
          },
          "SO:0001415": {
            "name": "deletion_breakpoint",
            "def": "The point within a chromosome where a deletion begins or ends. [SO:cb]"
          },
          "SO:0001416": {
            "name": "five_prime_flanking_region",
            "def": "A flanking region located five prime of a specific region. [SO:chado]"
          },
          "SO:0001417": {
            "name": "three_prime_flanking_region",
            "def": "A flanking region located three prime of a specific region. [SO:chado]"
          },
          "SO:0001418": {
            "name": "transcribed_fragment",
            "def": "An experimental region, defined by a tiling array experiment to be transcribed at some level. [SO:ke]"
          },
          "SO:0001419": {
            "name": "cis_splice_site",
            "def": "Intronic 2 bp region bordering exon. A splice_site that adjacent_to exon and overlaps intron. [SO:cjm, SO:ke]"
          },
          "SO:0001420": {
            "name": "trans_splice_site",
            "def": "Primary transcript region bordering trans-splice junction. [SO:ke]"
          },
          "SO:0001421": {
            "name": "splice_junction",
            "def": "The boundary between an intron and an exon. [SO:ke]"
          },
          "SO:0001422": {
            "name": "conformational_switch",
            "def": "A region of a polypeptide, involved in the transition from one conformational state to another. [SO:ke]"
          },
          "SO:0001423": {
            "name": "dye_terminator_read",
            "def": "A read produced by the dye terminator method of sequencing. [SO:ke]"
          },
          "SO:0001424": {
            "name": "pyrosequenced_read",
            "def": "A read produced by pyrosequencing technology. [SO:ke]"
          },
          "SO:0001425": {
            "name": "ligation_based_read",
            "def": "A read produced by ligation based sequencing technologies. [SO:ke]"
          },
          "SO:0001426": {
            "name": "polymerase_synthesis_read",
            "def": "A read produced by the polymerase based sequence by synthesis method. [SO:ke]"
          },
          "SO:0001427": {
            "name": "cis_regulatory_frameshift_element",
            "def": "A structural region in an RNA molecule which promotes ribosomal frameshifting of cis coding sequence. [RFAM:jd]"
          },
          "SO:0001428": {
            "name": "expressed_sequence_assembly",
            "def": "A sequence assembly derived from expressed sequences. [SO:ke]"
          },
          "SO:0001429": {
            "name": "DNA_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with DNA. [SO:ke]"
          },
          "SO:0001431": {
            "name": "cryptic_gene",
            "def": "A gene that is not transcribed under normal conditions and is not critical to normal cellular functioning. [SO:ke]"
          },
          "SO:0001432": {
            "name": "sequence_variant_affecting_polyadenylation"
          },
          "SO:0001433": {
            "name": "three_prime_RACE_clone",
            "def": "A three prime RACE (Rapid Amplification of cDNA Ends) clone is a cDNA clone copied from the 3' end of an mRNA (using a poly-dT primer to capture the polyA tail and a gene-specific or randomly primed 5' primer), and spliced into a vector for propagation in a suitable host. [modENCODE:nlw]"
          },
          "SO:0001434": {
            "name": "cassette_pseudogene",
            "def": "A cassette pseudogene is a kind of gene in an inactive form which may recombine at a telomeric locus to form a functional copy. [SO:ke]"
          },
          "SO:0001435": {
            "name": "alanine"
          },
          "SO:0001436": {
            "name": "valine"
          },
          "SO:0001437": {
            "name": "leucine"
          },
          "SO:0001438": {
            "name": "isoleucine"
          },
          "SO:0001439": {
            "name": "proline"
          },
          "SO:0001440": {
            "name": "tryptophan"
          },
          "SO:0001441": {
            "name": "phenylalanine"
          },
          "SO:0001442": {
            "name": "methionine"
          },
          "SO:0001443": {
            "name": "glycine"
          },
          "SO:0001444": {
            "name": "serine"
          },
          "SO:0001445": {
            "name": "threonine"
          },
          "SO:0001446": {
            "name": "tyrosine"
          },
          "SO:0001447": {
            "name": "cysteine"
          },
          "SO:0001448": {
            "name": "glutamine"
          },
          "SO:0001449": {
            "name": "asparagine"
          },
          "SO:0001450": {
            "name": "lysine"
          },
          "SO:0001451": {
            "name": "arginine"
          },
          "SO:0001452": {
            "name": "histidine"
          },
          "SO:0001453": {
            "name": "aspartic_acid"
          },
          "SO:0001454": {
            "name": "glutamic_acid"
          },
          "SO:0001455": {
            "name": "selenocysteine"
          },
          "SO:0001456": {
            "name": "pyrrolysine"
          },
          "SO:0001457": {
            "name": "transcribed_cluster",
            "def": "A region defined by a set of transcribed sequences from the same gene or expressed pseudogene. [SO:ke]"
          },
          "SO:0001458": {
            "name": "unigene_cluster",
            "def": "A kind of transcribed_cluster defined by a set of transcribed sequences from the a unique gene. [SO:ke]"
          },
          "SO:0001459": {
            "name": "CRISPR",
            "def": "Clustered Palindromic Repeats interspersed with bacteriophage derived spacer sequences. [RFAM:jd]"
          },
          "SO:0001460": {
            "name": "insulator_binding_site",
            "def": "A binding site that, in an insulator region of a nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
          },
          "SO:0001461": {
            "name": "enhancer_binding_site",
            "def": "A binding site that, in the enhancer region of a nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
          },
          "SO:0001462": {
            "name": "contig_collection",
            "def": "A collection of contigs. [SO:ke]"
          },
          "SO:0001463": {
            "name": "lincRNA",
            "def": "A multiexonic non-coding RNA transcribed by RNA polymerase II. [PMID:19182780, SO:ke]"
          },
          "SO:0001464": {
            "name": "UST",
            "def": "An EST spanning part or all of the untranslated regions of a protein-coding transcript. [SO:nlw]"
          },
          "SO:0001465": {
            "name": "three_prime_UST",
            "def": "A UST located in the 3'UTR of a protein-coding transcript. [SO:nlw]"
          },
          "SO:0001466": {
            "name": "five_prime_UST",
            "def": "An UST located in the 5'UTR of a protein-coding transcript. [SO:nlw]"
          },
          "SO:0001467": {
            "name": "RST",
            "def": "A tag produced from a single sequencing read from a RACE product; typically a few hundred base pairs long. [SO:nlw]"
          },
          "SO:0001468": {
            "name": "three_prime_RST",
            "def": "A tag produced from a single sequencing read from a 3'-RACE product; typically a few hundred base pairs long. [SO:nlw]"
          },
          "SO:0001469": {
            "name": "five_prime_RST",
            "def": "A tag produced from a single sequencing read from a 5'-RACE product; typically a few hundred base pairs long. [SO:nlw]"
          },
          "SO:0001470": {
            "name": "UST_match",
            "def": "A match against an UST sequence. [SO:nlw]"
          },
          "SO:0001471": {
            "name": "RST_match",
            "def": "A match against an RST sequence. [SO:nlw]"
          },
          "SO:0001472": {
            "name": "primer_match",
            "def": "A nucleotide match to a primer sequence. [SO:nlw]"
          },
          "SO:0001473": {
            "name": "miRNA_antiguide",
            "def": "A region of the pri miRNA that base pairs with the guide to form the hairpin. [SO:ke]"
          },
          "SO:0001474": {
            "name": "trans_splice_junction",
            "def": "The boundary between the spliced leader and the first exon of the mRNA. [SO:ke]"
          },
          "SO:0001475": {
            "name": "outron",
            "def": "A region of a primary transcript, that is removed via trans splicing. [PMID:16401417, SO:ke]"
          },
          "SO:0001476": {
            "name": "natural_plasmid",
            "def": "A plasmid that occurs naturally. [SO:xp]"
          },
          "SO:0001477": {
            "name": "gene_trap_construct",
            "def": "A gene trap construct is a type of engineered plasmid which is designed to integrate into a genome and produce a fusion transcript between exons of the gene into which it inserts and a reporter element in the construct. Gene traps contain a splice acceptor, do not contain promoter elements for the reporter, and are mutagenic. Gene traps may be bicistronic with the second cassette containing a promoter driving an a selectable marker. [ZFIN:dh]"
          },
          "SO:0001478": {
            "name": "promoter_trap_construct",
            "def": "A promoter trap construct is a type of engineered plasmid which is designed to integrate into a genome and express a reporter when inserted in close proximity to a promoter element. Promoter traps typically do not contain promoter elements and are mutagenic. [ZFIN:dh]"
          },
          "SO:0001479": {
            "name": "enhancer_trap_construct",
            "def": "An enhancer trap construct is a type of engineered plasmid which is designed to integrate into a genome and express a reporter when the expression from a basic minimal promoter is enhanced by genomic enhancer elements. Enhancer traps contain promoter elements and are not usually mutagenic. [ZFIN:dh]"
          },
          "SO:0001480": {
            "name": "PAC_end",
            "def": "A region of sequence from the end of a PAC clone that may provide a highly specific marker. [ZFIN:mh]"
          },
          "SO:0001481": {
            "name": "RAPD",
            "def": "RAPD is a 'PCR product' where a sequence variant is identified through the use of PCR with random primers. [ZFIN:mh]"
          },
          "SO:0001482": {
            "name": "shadow_enhancer"
          },
          "SO:0001483": {
            "name": "SNV",
            "def": "SNVs are single nucleotide positions in genomic DNA at which different sequence alternatives exist. [SO:bm]"
          },
          "SO:0001484": {
            "name": "X_element_combinatorial_repeat",
            "def": "An X element combinatorial repeat is a repeat region located between the X element and the telomere or adjacent Y' element. [http://www.yeastgenome.org/help/glossary.html]"
          },
          "SO:0001485": {
            "name": "Y_prime_element",
            "def": "A Y' element is a repeat region (SO:0000657) located adjacent to telomeric repeats or X element combinatorial repeats, either as a single copy or tandem repeat of two to four copies. [http:http://www.yeastgenome.org/help/glossary.html]"
          },
          "SO:0001486": {
            "name": "standard_draft",
            "def": "The status of a whole genome sequence, where the data is minimally filtered or un-filtered, from any number of sequencing platforms, and is assembled into contigs. Genome sequence of this quality may harbour regions of poor quality and can be relatively incomplete. [DOI:10.1126]"
          },
          "SO:0001487": {
            "name": "high_quality_draft",
            "def": "The status of a whole genome sequence, where overall coverage represents at least 90 percent of the genome. [DOI:10.1126]"
          },
          "SO:0001488": {
            "name": "improved_high_quality_draft",
            "def": "The status of a whole genome sequence, where additional work has been performed, using either manual or automated methods, such as gap resolution. [DOI:10.1126]"
          },
          "SO:0001489": {
            "name": "annotation_directed_improved_draft",
            "def": "The status of a whole genome sequence,where annotation, and verification of coding regions has occurred. [DOI:10.1126]"
          },
          "SO:0001490": {
            "name": "noncontiguous_finished",
            "def": "The status of a whole genome sequence, where the assembly is high quality, closure approaches have been successful for most gaps, misassemblies and low quality regions. [DOI:10.1126]"
          },
          "SO:0001491": {
            "name": "finished_genome",
            "def": "The status of a whole genome sequence, with less than 1 error per 100,000 base pairs. [DOI:10.1126]"
          },
          "SO:0001492": {
            "name": "intronic_regulatory_region",
            "def": "A regulatory region that is part of an intron. [SO:ke]"
          },
          "SO:0001493": {
            "name": "centromere_DNA_Element_I",
            "def": "A centromere DNA Element I (CDEI) is a conserved region, part of the centromere, consisting of a consensus region composed of 8-11bp which enables binding by the centromere binding factor 1(Cbf1p). [PMID:11222754]"
          },
          "SO:0001494": {
            "name": "centromere_DNA_Element_II",
            "def": "A centromere DNA Element II (CDEII) is part a conserved region of the centromere, consisting of a consensus region that is AT-rich and ~ 75-100 bp in length. [PMID:11222754]"
          },
          "SO:0001495": {
            "name": "centromere_DNA_Element_III",
            "def": "A centromere DNA Element I (CDEI) is a conserved region, part of the centromere, consisting of a consensus region that consists of a 25-bp which enables binding by the centromere DNA binding factor 3 (CBF3) complex. [PMID:11222754]"
          },
          "SO:0001496": {
            "name": "telomeric_repeat",
            "def": "The telomeric repeat is a repeat region, part of the chromosome, which in yeast, is a G-rich terminal sequence of the form (TG(1-3))n or more precisely ((TG)(1-6)TG(2-3))n. [PMID:8720065]"
          },
          "SO:0001497": {
            "name": "X_element",
            "def": "The X element is a conserved region, of the telomere, of ~475 bp that contains an ARS sequence and in most cases an Abf1p binding site. [http://www.yeastgenome.org/help/glossary.html#xelemcoresequence, PMID:7785338, PMID:8005434]"
          },
          "SO:0001498": {
            "name": "YAC_end",
            "def": "A region of sequence from the end of a YAC clone that may provide a highly specific marker. [SO:ke]"
          },
          "SO:0001499": {
            "name": "whole_genome_sequence_status",
            "def": "The status of whole genome sequence. [DOI:10.1126]"
          },
          "SO:0001500": {
            "name": "heritable_phenotypic_marker",
            "def": "A biological_region characterized as a single heritable trait in a phenotype screen. The heritable phenotype may be mapped to a chromosome but generally has not been characterized to a specific gene locus. [JAX:hdene]"
          },
          "SO:0001501": {
            "name": "peptide_collection",
            "def": "A collection of peptide sequences. [BBOP:nlw]"
          },
          "SO:0001502": {
            "name": "high_identity_region",
            "def": "An experimental feature with high sequence identity to another sequence. [SO:ke]"
          },
          "SO:0001503": {
            "name": "processed_transcript",
            "def": "A transcript for which no open reading frame has been identified and for which no other function has been determined. [MGI:hdeen]"
          },
          "SO:0001504": {
            "name": "assortment_derived_variation",
            "def": "A chromosome variation derived from an event during meiosis. [SO:ke]"
          },
          "SO:0001505": {
            "name": "reference_genome",
            "def": "A collection of sequences (often chromosomes) taken as the standard for a given organism and genome assembly. [SO:ke]"
          },
          "SO:0001506": {
            "name": "variant_genome",
            "def": "A collection of sequences (often chromosomes) of an individual. [SO:ke]"
          },
          "SO:0001507": {
            "name": "variant_collection",
            "def": "A collection of one or more sequences of an individual. [SO:ke]"
          },
          "SO:0001508": {
            "name": "alteration_attribute"
          },
          "SO:0001509": {
            "name": "chromosomal_variation_attribute"
          },
          "SO:0001510": {
            "name": "intrachromosomal"
          },
          "SO:0001511": {
            "name": "interchromosomal"
          },
          "SO:0001512": {
            "name": "insertion_attribute",
            "def": "A quality of a chromosomal insertion,. [SO:ke]"
          },
          "SO:0001513": {
            "name": "tandem"
          },
          "SO:0001514": {
            "name": "direct",
            "def": "A quality of an insertion where the insert is not in a cytologically inverted orientation. [SO:ke]"
          },
          "SO:0001515": {
            "name": "inverted",
            "def": "A quality of an insertion where the insert is in a cytologically inverted orientation. [SO:ke]"
          },
          "SO:0001516": {
            "name": "free",
            "def": "The quality of a duplication where the new region exists independently of the original. [SO:ke]"
          },
          "SO:0001517": {
            "name": "inversion_attribute"
          },
          "SO:0001518": {
            "name": "pericentric"
          },
          "SO:0001519": {
            "name": "paracentric"
          },
          "SO:0001520": {
            "name": "translocaton_attribute"
          },
          "SO:0001521": {
            "name": "reciprocal"
          },
          "SO:0001522": {
            "name": "insertional"
          },
          "SO:0001523": {
            "name": "duplication_attribute"
          },
          "SO:0001524": {
            "name": "chromosomally_aberrant_genome"
          },
          "SO:0001525": {
            "name": "assembly_error_correction",
            "def": "A region of sequence where the final nucleotide assignment differs from the original assembly due to an improvement that replaces a mistake. [SO:ke]"
          },
          "SO:0001526": {
            "name": "base_call_error_correction",
            "def": "A region of sequence where the final nucleotide assignment is different from that given by the base caller due to an improvement that replaces a mistake. [SO:ke]"
          },
          "SO:0001527": {
            "name": "peptide_localization_signal",
            "def": "A region of peptide sequence used to target the polypeptide molecule to a specific organelle. [SO:ke]"
          },
          "SO:0001528": {
            "name": "nuclear_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the nucleus. [SO:ke]"
          },
          "SO:0001529": {
            "name": "endosomal_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the endosome. [SO:ke]"
          },
          "SO:0001530": {
            "name": "lysosomal_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the lysosome. [SO:ke]"
          },
          "SO:0001531": {
            "name": "nuclear_export_signal",
            "def": "A polypeptide region that targets a polypeptide to he cytoplasm. [SO:ke]"
          },
          "SO:0001532": {
            "name": "recombination_signal_sequence",
            "def": "A region recognized by a recombinase. [SO:ke]"
          },
          "SO:0001533": {
            "name": "cryptic_splice_site",
            "def": "A splice site that is in part of the transcript not normally spliced. They occur via mutation or transcriptional error. [SO:ke]"
          },
          "SO:0001534": {
            "name": "nuclear_rim_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the nuclear rim. [SO:ke]"
          },
          "SO:0001535": {
            "name": "p_element",
            "def": "A P_element is a DNA transposon responsible for hybrid dysgenesis. [SO:ke]"
          },
          "SO:0001536": {
            "name": "functional_variant",
            "def": "A sequence variant in which the function of a gene product is altered with respect to a reference. [SO:ke]"
          },
          "SO:0001537": {
            "name": "structural_variant",
            "def": "A sequence variant that changes one or more sequence features. [SO:ke]"
          },
          "SO:0001538": {
            "name": "transcript_function_variant",
            "def": "A sequence variant which alters the functioning of a transcript with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001539": {
            "name": "translational_product_function_variant",
            "def": "A sequence variant that affects the functioning of a translational product with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001540": {
            "name": "level_of_transcript_variant",
            "def": "A sequence variant which alters the level of a transcript. [SO:ke]"
          },
          "SO:0001541": {
            "name": "decreased_transcript_level_variant",
            "def": "A sequence variant that increases the level of mature, spliced and processed RNA with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001542": {
            "name": "increased_transcript_level_variant",
            "def": "A sequence variant that increases the level of mature, spliced and processed RNA with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001543": {
            "name": "transcript_processing_variant",
            "def": "A sequence variant that affects the post transcriptional processing of a transcript with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001544": {
            "name": "editing_variant",
            "def": "A transcript processing variant whereby the process of editing is disrupted with respect to the reference. [SO:ke]"
          },
          "SO:0001545": {
            "name": "polyadenylation_variant",
            "def": "A sequence variant that changes polyadenylation with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001546": {
            "name": "transcript_stability_variant",
            "def": "A variant that changes the stability of a transcript with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001547": {
            "name": "decreased_transcript_stability_variant",
            "def": "A sequence variant that decreases transcript stability with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001548": {
            "name": "increased_transcript_stability_variant",
            "def": "A sequence variant that increases transcript stability with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001549": {
            "name": "transcription_variant",
            "def": "A variant that changes alters the transcription of a transcript with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001550": {
            "name": "rate_of_transcription_variant",
            "def": "A sequence variant that changes the rate of transcription with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001551": {
            "name": "increased_transcription_rate_variant",
            "def": "A sequence variant that increases the rate of transcription with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001552": {
            "name": "decreased_transcription_rate_variant",
            "def": "A sequence variant that decreases the rate of transcription with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001553": {
            "name": "translational_product_level_variant",
            "def": "A functional variant that changes the translational product level with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001554": {
            "name": "polypeptide_function_variant",
            "def": "A sequence variant which changes polypeptide functioning with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001555": {
            "name": "decreased_translational_product_level",
            "def": "A sequence variant which decreases the translational product level with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001556": {
            "name": "increased_translational_product_level",
            "def": "A sequence variant which increases the translational product level with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001557": {
            "name": "polypeptide_gain_of_function_variant",
            "def": "A sequence variant which causes gain of polypeptide function with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001558": {
            "name": "polypeptide_localization_variant",
            "def": "A sequence variant which changes the localization of a polypeptide with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001559": {
            "name": "polypeptide_loss_of_function_variant",
            "def": "A sequence variant that causes the loss of a polypeptide function with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001560": {
            "name": "inactive_ligand_binding_site",
            "def": "A sequence variant that causes the inactivation of a ligand binding site with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001561": {
            "name": "polypeptide_partial_loss_of_function",
            "def": "A sequence variant that causes some but not all loss of polypeptide function with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001562": {
            "name": "polypeptide_post_translational_processing_variant",
            "def": "A sequence variant that causes a change in post translational processing of the peptide with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001563": {
            "name": "copy_number_change",
            "def": "A sequence variant where copies of a feature (CNV) are either increased or decreased. [SO:ke]"
          },
          "SO:0001564": {
            "name": "gene_variant",
            "def": "A sequence variant where the structure of the gene is changed. [SO:ke]"
          },
          "SO:0001565": {
            "name": "gene_fusion",
            "def": "A sequence variant whereby a two genes have become joined. [SO:ke]"
          },
          "SO:0001566": {
            "name": "regulatory_region_variant",
            "def": "A sequence variant located within a regulatory region. [SO:ke]"
          },
          "SO:0001567": {
            "name": "stop_retained_variant",
            "def": "A sequence variant where at least one base in the terminator codon is changed, but the terminator remains. [SO:ke]"
          },
          "SO:0001568": {
            "name": "splicing_variant",
            "def": "A sequence variant that changes the process of splicing. [SO:ke]"
          },
          "SO:0001569": {
            "name": "cryptic_splice_site_variant",
            "def": "A sequence variant causing a new (functional) splice site. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:0001570": {
            "name": "cryptic_splice_acceptor",
            "def": "A sequence variant whereby a new splice site is created due to the activation of a new acceptor. [SO:ke]"
          },
          "SO:0001571": {
            "name": "cryptic_splice_donor",
            "def": "A sequence variant whereby a new splice site is created due to the activation of a new donor. [SO:ke]"
          },
          "SO:0001572": {
            "name": "exon_loss_variant",
            "def": "A sequence variant whereby an exon is lost from the transcript. [SO:ke]"
          },
          "SO:0001573": {
            "name": "intron_gain_variant",
            "def": "A sequence variant whereby an intron is gained by the processed transcript; usually a result of an alteration of the donor or acceptor. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:0001574": {
            "name": "splice_acceptor_variant",
            "def": "A splice variant that changes the 2 base region at the 3' end of an intron. [SO:ke]"
          },
          "SO:0001575": {
            "name": "splice_donor_variant",
            "def": "A splice variant that changes the 2 base pair region at the 5' end of an intron. [SO:ke]"
          },
          "SO:0001576": {
            "name": "transcript_variant",
            "def": "A sequence variant that changes the structure of the transcript. [SO:ke]"
          },
          "SO:0001577": {
            "name": "complex_transcript_variant",
            "def": "A transcript variant with a complex INDEL- Insertion or deletion that spans an exon/intron border or a coding sequence/UTR border. [http://ensembl.org/info/docs/variation/index.html]"
          },
          "SO:0001578": {
            "name": "stop_lost",
            "def": "A sequence variant where at least one base of the terminator codon (stop) is changed, resulting in an elongated transcript. [SO:ke]"
          },
          "SO:0001579": {
            "name": "transcript_sequence_variant"
          },
          "SO:0001580": {
            "name": "coding_sequence_variant",
            "def": "A sequence variant that changes the coding sequence. [SO:ke]"
          },
          "SO:0001582": {
            "name": "initiator_codon_variant",
            "def": "A codon variant that changes at least one base of the first codon of a transcript. [SO:ke]"
          },
          "SO:0001583": {
            "name": "missense_variant",
            "def": "A sequence variant, that changes one or more bases, resulting in a different amino acid sequence but where the length is preserved. [EBI:fc, EBI:gr, SO:ke]"
          },
          "SO:0001585": {
            "name": "conservative_missense_variant",
            "def": "A sequence variant whereby at least one base of a codon is changed resulting in a codon that encodes for a different but similar amino acid. These variants may or may not be deleterious. [SO:ke]"
          },
          "SO:0001586": {
            "name": "non_conservative_missense_variant",
            "def": "A sequence variant whereby at least one base of a codon is changed resulting in a codon that encodes for an amino acid with different biochemical properties. [SO:ke]"
          },
          "SO:0001587": {
            "name": "stop_gained",
            "def": "A sequence variant whereby at least one base of a codon is changed, resulting in a premature stop codon, leading to a shortened transcript. [SO:ke]"
          },
          "SO:0001589": {
            "name": "frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, because the number of nucleotides inserted or deleted is not a multiple of three. [SO:ke]"
          },
          "SO:0001590": {
            "name": "terminator_codon_variant",
            "def": "A sequence variant whereby at least one of the bases in the terminator codon is changed. [SO:ke]"
          },
          "SO:0001591": {
            "name": "frame_restoring_variant",
            "def": "A sequence variant that reverts the sequence of a previous frameshift mutation back to the initial frame. [SO:ke]"
          },
          "SO:0001592": {
            "name": "minus_1_frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, by shifting one base ahead. [http://arjournals.annualreviews.org/doi/pdf/10.1146/annurev.ge.08.120174.001535]"
          },
          "SO:0001593": {
            "name": "minus_2_frameshift_variant"
          },
          "SO:0001594": {
            "name": "plus_1_frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, by shifting one base backward. [http://arjournals.annualreviews.org/doi/pdf/10.1146/annurev.ge.08.120174.001535]"
          },
          "SO:0001595": {
            "name": "plus_2_frameshift_variant"
          },
          "SO:0001596": {
            "name": "transcript_secondary_structure_variant",
            "def": "A sequence variant within a transcript that changes the secondary structure of the RNA product. [SO:ke]"
          },
          "SO:0001597": {
            "name": "compensatory_transcript_secondary_structure_variant",
            "def": "A secondary structure variant that compensate for the change made by a previous variant. [SO:ke]"
          },
          "SO:0001598": {
            "name": "translational_product_structure_variant",
            "def": "A sequence variant within the transcript that changes the structure of the translational product. [SO:ke]"
          },
          "SO:0001599": {
            "name": "3D_polypeptide_structure_variant",
            "def": "A sequence variant that changes the resulting polypeptide structure. [SO:ke]"
          },
          "SO:0001600": {
            "name": "complex_3D_structural_variant",
            "def": "A sequence variant that changes the resulting polypeptide structure. [SO:ke]"
          },
          "SO:0001601": {
            "name": "conformational_change_variant",
            "def": "A sequence variant in the CDS region that causes a conformational change in the resulting polypeptide sequence. [SO:ke]"
          },
          "SO:0001602": {
            "name": "complex_change_of_translational_product_variant"
          },
          "SO:0001603": {
            "name": "polypeptide_sequence_variant",
            "def": "A sequence variant with in the CDS that causes a change in the resulting polypeptide sequence. [SO:ke]"
          },
          "SO:0001604": {
            "name": "amino_acid_deletion",
            "def": "A sequence variant within a CDS resulting in the loss of an amino acid from the resulting polypeptide. [SO:ke]"
          },
          "SO:0001605": {
            "name": "amino_acid_insertion",
            "def": "A sequence variant within a CDS resulting in the gain of an amino acid to the resulting polypeptide. [SO:ke]"
          },
          "SO:0001606": {
            "name": "amino_acid_substitution",
            "def": "A sequence variant of a codon resulting in the substitution of one amino acid for another in the resulting polypeptide. [SO:ke]"
          },
          "SO:0001607": {
            "name": "conservative_amino_acid_substitution",
            "def": "A sequence variant of a codon causing the substitution of a similar amino acid for another in the resulting polypeptide. [SO:ke]"
          },
          "SO:0001608": {
            "name": "non_conservative_amino_acid_substitution",
            "def": "A sequence variant of a codon causing the substitution of a non conservative amino acid for another in the resulting polypeptide. [SO:ke]"
          },
          "SO:0001609": {
            "name": "elongated_polypeptide",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence. [SO:ke]"
          },
          "SO:0001610": {
            "name": "elongated_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
          },
          "SO:0001611": {
            "name": "elongated_polypeptide_N_terminal",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
          },
          "SO:0001612": {
            "name": "elongated_in_frame_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes in frame elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
          },
          "SO:0001613": {
            "name": "elongated_out_of_frame_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes out of frame elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
          },
          "SO:0001614": {
            "name": "elongated_in_frame_polypeptide_N_terminal_elongation",
            "def": "A sequence variant with in the CDS that causes in frame elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
          },
          "SO:0001615": {
            "name": "elongated_out_of_frame_polypeptide_N_terminal",
            "def": "A sequence variant with in the CDS that causes out of frame elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
          },
          "SO:0001616": {
            "name": "polypeptide_fusion",
            "def": "A sequence variant that causes a fusion of two polypeptide sequences. [SO:ke]"
          },
          "SO:0001617": {
            "name": "polypeptide_truncation",
            "def": "A sequence variant of the CD that causes a truncation of the resulting polypeptide. [SO:ke]"
          },
          "SO:0001618": {
            "name": "inactive_catalytic_site",
            "def": "A sequence variant that causes the inactivation of a catalytic site with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001619": {
            "name": "non_coding_transcript_variant",
            "def": "A transcript variant of a non coding RNA gene. [SO:ke]"
          },
          "SO:0001620": {
            "name": "mature_miRNA_variant",
            "def": "A transcript variant located with the sequence of the mature miRNA. [SO:ke]"
          },
          "SO:0001621": {
            "name": "NMD_transcript_variant",
            "def": "A variant in a transcript that is the target of NMD. [SO:ke]"
          },
          "SO:0001622": {
            "name": "UTR_variant",
            "def": "A transcript variant that is located within the UTR. [SO:ke]"
          },
          "SO:0001623": {
            "name": "5_prime_UTR_variant",
            "def": "A UTR variant of the 5' UTR. [SO:ke]"
          },
          "SO:0001624": {
            "name": "3_prime_UTR_variant",
            "def": "A UTR variant of the 3' UTR. [SO:ke]"
          },
          "SO:0001626": {
            "name": "incomplete_terminal_codon_variant",
            "def": "A sequence variant where at least one base of the final codon of an incompletely annotated transcript is changed. [SO:ke]"
          },
          "SO:0001627": {
            "name": "intron_variant",
            "def": "A transcript variant occurring within an intron. [SO:ke]"
          },
          "SO:0001628": {
            "name": "intergenic_variant",
            "def": "A sequence variant located in the intergenic region, between genes. [SO:ke]"
          },
          "SO:0001629": {
            "name": "splice_site_variant",
            "def": "A sequence variant that changes the first two or last two bases of an intron, or the 5th base from the start of the intron in the orientation of the transcript. [http://ensembl.org/info/docs/variation/index.html]"
          },
          "SO:0001630": {
            "name": "splice_region_variant",
            "def": "A sequence variant in which a change has occurred within the region of the splice site, either within 1-3 bases of the exon or 3-8 bases of the intron. [http://ensembl.org/info/docs/variation/index.html]"
          },
          "SO:0001631": {
            "name": "upstream_gene_variant",
            "def": "A sequence variant located 5' of a gene. [SO:ke]"
          },
          "SO:0001632": {
            "name": "downstream_gene_variant",
            "def": "A sequence variant located 3' of a gene. [SO:ke]"
          },
          "SO:0001633": {
            "name": "5KB_downstream_variant",
            "def": "A sequence variant located within 5 KB of the end of a gene. [SO:ke]"
          },
          "SO:0001634": {
            "name": "500B_downstream_variant",
            "def": "A sequence variant located within a half KB of the end of a gene. [SO:ke]"
          },
          "SO:0001635": {
            "name": "5KB_upstream_variant",
            "def": "A sequence variant located within 5KB 5' of a gene. [SO:ke]"
          },
          "SO:0001636": {
            "name": "2KB_upstream_variant",
            "def": "A sequence variant located within 2KB 5' of a gene. [SO:ke]"
          },
          "SO:0001637": {
            "name": "rRNA_gene",
            "def": "A gene that encodes for ribosomal RNA. [SO:ke]"
          },
          "SO:0001638": {
            "name": "piRNA_gene",
            "def": "A gene that encodes for an piwi associated RNA. [SO:ke]"
          },
          "SO:0001639": {
            "name": "RNase_P_RNA_gene",
            "def": "A gene that encodes an RNase P RNA. [SO:ke]"
          },
          "SO:0001640": {
            "name": "RNase_MRP_RNA_gene",
            "def": "A gene that encodes a RNase_MRP_RNA. [SO:ke]"
          },
          "SO:0001641": {
            "name": "lincRNA_gene",
            "def": "A gene that encodes large intervening non-coding RNA. [SO:ke]"
          },
          "SO:0001642": {
            "name": "mathematically_defined_repeat",
            "def": "A mathematically defined repeat (MDR) is a experimental feature that is determined by querying overlapping oligomers of length k against a database of shotgun sequence data and identifying regions in the query sequence that exceed a statistically determined threshold of repetitiveness. [SO:jestill]"
          },
          "SO:0001643": {
            "name": "telomerase_RNA_gene",
            "def": "A telomerase RNA gene is a non coding RNA gene the RNA product of which is a component of telomerase. [SO:ke]"
          },
          "SO:0001644": {
            "name": "targeting_vector",
            "def": "An engineered vector that is able to take part in homologous recombination in a host with the intent of introducing site specific genomic modifications. [MGD:tm, PMID:10354467]"
          },
          "SO:0001645": {
            "name": "genetic_marker",
            "def": "A measurable sequence feature that varies within a population. [SO:db]"
          },
          "SO:0001646": {
            "name": "DArT_marker",
            "def": "A genetic marker, discovered using Diversity Arrays Technology (DArT) technology. [SO:ke]"
          },
          "SO:0001647": {
            "name": "kozak_sequence",
            "def": "A kind of ribosome entry site, specific to Eukaryotic organisms that overlaps part of both 5' UTR and CDS sequence. [SO:ke]"
          },
          "SO:0001648": {
            "name": "nested_transposon",
            "def": "A transposon that is disrupted by the insertion of another element. [SO:ke]"
          },
          "SO:0001649": {
            "name": "nested_repeat",
            "def": "A repeat that is disrupted by the insertion of another element. [SO:ke]"
          },
          "SO:0001650": {
            "name": "inframe_variant",
            "def": "A sequence variant which does not cause a disruption of the translational reading frame. [SO:ke]"
          },
          "SO:0001653": {
            "name": "retinoic_acid_responsive_element",
            "def": "A transcription factor binding site of variable direct repeats of the sequence PuGGTCA spaced by five nucleotides (DR5) found in the promoters of retinoic acid-responsive genes, to which retinoic acid receptors bind. [PMID:11327309, PMID:19917671]"
          },
          "SO:0001654": {
            "name": "nucleotide_to_protein_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
          },
          "SO:0001655": {
            "name": "nucleotide_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with nucleotide residues. [SO:cb]"
          },
          "SO:0001656": {
            "name": "metal_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with metal ions. [SO:cb]"
          },
          "SO:0001657": {
            "name": "ligand_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with a small molecule such as a drug, or hormone. [SO:ke]"
          },
          "SO:0001658": {
            "name": "nested_tandem_repeat",
            "def": "An NTR is a nested repeat of two distinct tandem motifs interspersed with each other. [SO:AF]"
          },
          "SO:0001659": {
            "name": "promoter_element"
          },
          "SO:0001660": {
            "name": "core_promoter_element"
          },
          "SO:0001661": {
            "name": "RNA_polymerase_II_TATA_box",
            "def": "A TATA box core promoter of a gene transcribed by RNA polymerase II. [PMID:16858867]"
          },
          "SO:0001662": {
            "name": "RNA_polymerase_III_TATA_box",
            "def": "A TATA box core promoter of a gene transcribed by RNA polymerase III. [SO:ke]"
          },
          "SO:0001663": {
            "name": "BREd_motif",
            "def": "A core TRNA polymerase II promoter element with consensus (G/A)T(T/G/A)(T/A)(G/T)(T/G)(T/G). [PMID:16858867]"
          },
          "SO:0001664": {
            "name": "DCE",
            "def": "A discontinuous core element of RNA polymerase II transcribed genes, situated downstream of the TSS. It is composed of three sub elements: SI, SII and SIII. [PMID:16858867]"
          },
          "SO:0001665": {
            "name": "DCE_SI",
            "def": "A sub element of the DCE core promoter element, with consensus sequence CTTC. [PMID:16858867, SO:ke]"
          },
          "SO:0001666": {
            "name": "DCE_SII",
            "def": "A sub element of the DCE core promoter element with consensus sequence CTGT. [PMID:16858867, SO:ke]"
          },
          "SO:0001667": {
            "name": "DCE_SIII",
            "def": "A sub element of the DCE core promoter element with consensus sequence AGC. [PMID:16858867, SO:ke]"
          },
          "SO:0001668": {
            "name": "proximal_promoter_element",
            "def": "DNA segment that ranges from about -250 to -40 relative to +1 of RNA transcription start site, where sequence specific DNA-binding transcription factors binds, such as Sp1, CTF (CCAAT-binding transcription factor), and CBF (CCAAT-box binding factor). [PMID:12515390, PMID:9679020, SO:ml]"
          },
          "SO:0001669": {
            "name": "RNApol_II_core_promoter",
            "def": "The minimal portion of the promoter required to properly initiate transcription in RNA polymerase II transcribed genes. [PMID:16858867]"
          },
          "SO:0001670": {
            "name": "distal_promoter_element"
          },
          "SO:0001671": {
            "name": "bacterial_RNApol_promoter_sigma_70"
          },
          "SO:0001672": {
            "name": "bacterial_RNApol_promoter_sigma54"
          },
          "SO:0001673": {
            "name": "minus_12_signal",
            "def": "A conserved region about 12-bp upstream of the start point of bacterial transcription units, involved with sigma factor 54. [PMID:18331472]"
          },
          "SO:0001674": {
            "name": "minus_24_signal",
            "def": "A conserved region about 12-bp upstream of the start point of bacterial transcription units, involved with sigma factor 54. [PMID:18331472]"
          },
          "SO:0001675": {
            "name": "A_box_type_1",
            "def": "An A box within an RNA polymerase III type 1 promoter. [SO:ke]"
          },
          "SO:0001676": {
            "name": "A_box_type_2",
            "def": "An A box within an RNA polymerase III type 2 promoter. [SO:ke]"
          },
          "SO:0001677": {
            "name": "intermediate_element",
            "def": "A core promoter region of RNA polymerase III type 1 promoters. [PMID:12381659]"
          },
          "SO:0001678": {
            "name": "regulatory_promoter_element",
            "def": "A promoter element that is not part of the core promoter, but provides the promoter with a specific regulatory region. [PMID:12381659]"
          },
          "SO:0001679": {
            "name": "transcription_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of transcription. [SO:ke]"
          },
          "SO:0001680": {
            "name": "translation_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of translation. [SO:ke]"
          },
          "SO:0001681": {
            "name": "recombination_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of recombination. [SO:ke]"
          },
          "SO:0001682": {
            "name": "replication_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of nucleotide replication. [SO:ke]"
          },
          "SO:0001683": {
            "name": "sequence_motif",
            "def": "A sequence motif is a nucleotide or amino-acid sequence pattern that may have biological significance. [http://en.wikipedia.org/wiki/Sequence_motif]"
          },
          "SO:0001684": {
            "name": "experimental_feature_attribute",
            "def": "An attribute of an experimentally derived feature. [SO:ke]"
          },
          "SO:0001685": {
            "name": "score",
            "def": "The score of an experimentally derived feature such as a p-value. [SO:ke]"
          },
          "SO:0001686": {
            "name": "quality_value",
            "def": "An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score. [SO:ke]"
          },
          "SO:0001687": {
            "name": "restriction_enzyme_recognition_site",
            "def": "The nucleotide region (usually a palindrome) that is recognized by a restriction enzyme. This may or may not be equal to the restriction enzyme binding site. [SO:ke]"
          },
          "SO:0001688": {
            "name": "restriction_enzyme_cleavage_junction",
            "def": "The boundary at which a restriction enzyme breaks the nucleotide sequence. [SO:ke]"
          },
          "SO:0001689": {
            "name": "five_prime_restriction_enzyme_junction",
            "def": "The restriction enzyme cleavage junction on the 5' strand of the nucleotide sequence. [SO:ke]"
          },
          "SO:0001690": {
            "name": "three_prime_restriction_enzyme_junction"
          },
          "SO:0001691": {
            "name": "blunt_end_restriction_enzyme_cleavage_site"
          },
          "SO:0001692": {
            "name": "sticky_end_restriction_enzyme_cleavage_site"
          },
          "SO:0001693": {
            "name": "blunt_end_restriction_enzyme_cleavage_junction",
            "def": "A restriction enzyme cleavage site where both strands are cut at the same position. [SO:ke]"
          },
          "SO:0001694": {
            "name": "single_strand_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme cleavage site whereby only one strand is cut. [SO:ke]"
          },
          "SO:0001695": {
            "name": "restriction_enzyme_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended. [SO:ke]"
          },
          "SO:0001696": {
            "name": "experimentally_defined_binding_region",
            "def": "A region that has been implicated in binding although the exact coordinates of binding may be unknown. [SO:ke]"
          },
          "SO:0001697": {
            "name": "ChIP_seq_region",
            "def": "A region of sequence identified by CHiP seq technology to contain a protein binding site. [SO:ke]"
          },
          "SO:0001698": {
            "name": "ASPE_primer",
            "def": "\\A primer containing an SNV at the 3' end for accurate genotyping. [http://www.ncbi.nlm.nih.gov/pubmed/11252801]"
          },
          "SO:0001699": {
            "name": "dCAPS_primer",
            "def": "A primer with one or more mismatches to the DNA template corresponding to a position within a restriction enzyme recognition site. [http://www.ncbi.nlm.nih.gov/pubmed/9628033]"
          },
          "SO:0001700": {
            "name": "histone_modification",
            "def": "Histone modification is a post translationally modified region whereby residues of the histone protein are modified by methylation, acetylation, phosphorylation, ubiquitination, sumoylation, citrullination, or ADP-ribosylation. [http:en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001701": {
            "name": "histone_methylation_site",
            "def": "A histone modification site where the modification is the methylation of the residue. [SO:ke]"
          },
          "SO:0001702": {
            "name": "histone_acetylation_site",
            "def": "A histone modification where the modification is the acylation of the residue. [SO:ke]"
          },
          "SO:0001703": {
            "name": "H3K9_acetylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is acylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001704": {
            "name": "H3K14_acetylation_site",
            "def": "A kind of histone modification site, whereby the 14th residue (a lysine), from the start of the H3 histone protein is acylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001705": {
            "name": "H3K4_monomethylation_site",
            "def": "A kind of histone modification, whereby the 4th residue (a lysine), from the start of the H3 protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001706": {
            "name": "H3K4_trimethylation",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001707": {
            "name": "H3K9_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001708": {
            "name": "H3K27_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001709": {
            "name": "H3K27_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001710": {
            "name": "H3K79_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is mono- methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001711": {
            "name": "H3K79_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is di-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001712": {
            "name": "H3K79_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001713": {
            "name": "H4K20_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H4histone protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001714": {
            "name": "H2BK5_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H2B protein is methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001715": {
            "name": "ISRE",
            "def": "An ISRE is a transcriptional cis regulatory region, containing the consensus region: YAGTTTC(A/T)YTTTYCC, responsible for increased transcription via interferon binding. [http://genesdev.cshlp.org/content/2/4/383.abstrac]"
          },
          "SO:0001716": {
            "name": "histone_ubiqitination_site",
            "def": "A histone modification site where ubiquitin may be added. [SO:ke]"
          },
          "SO:0001717": {
            "name": "H2B_ubiquitination_site",
            "def": "A histone modification site on H2B where ubiquitin may be added. [SO:ke]"
          },
          "SO:0001718": {
            "name": "H3K18_acetylation_site",
            "def": "A kind of histone modification site, whereby the 14th residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
          },
          "SO:0001719": {
            "name": "H3K23_acylation_site",
            "def": "A kind of histone modification, whereby the 23rd residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
          },
          "SO:0001720": {
            "name": "epigenetically_modified_region",
            "def": "A biological region implicated in inherited changes caused by mechanisms other than changes in the underlying DNA sequence. [http://en.wikipedia.org/wiki/Epigenetics, SO:ke]"
          },
          "SO:0001721": {
            "name": "H3K27_acylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
          },
          "SO:0001722": {
            "name": "H3K36_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [SO:ke]"
          },
          "SO:0001723": {
            "name": "H3K36_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is dimethylated. [SO:ke]"
          },
          "SO:0001724": {
            "name": "H3K36_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [SO:ke]"
          },
          "SO:0001725": {
            "name": "H3K4_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 histone protein is di-methylated. [SO:ke]"
          },
          "SO:0001726": {
            "name": "H3K27_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is di-methylated. [SO:ke]"
          },
          "SO:0001727": {
            "name": "H3K9_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [SO:ke]"
          },
          "SO:0001728": {
            "name": "H3K9_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein may be dimethylated. [SO:ke]"
          },
          "SO:0001729": {
            "name": "H4K16_acylation_site",
            "def": "A kind of histone modification site, whereby the 16th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:ke]"
          },
          "SO:0001730": {
            "name": "H4K5_acylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:ke]"
          },
          "SO:0001731": {
            "name": "H4K8_acylation_site",
            "def": "A kind of histone modification site, whereby the 8th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:KE]"
          },
          "SO:0001732": {
            "name": "H3K27_methylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
          },
          "SO:0001733": {
            "name": "H3K36_methylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
          },
          "SO:0001734": {
            "name": "H3K4_methylation_site",
            "def": "A kind of histone modification, whereby the 4th residue (a lysine), from the start of the H3 protein is methylated. [SO:ke]"
          },
          "SO:0001735": {
            "name": "H3K79_methylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
          },
          "SO:0001736": {
            "name": "H3K9_methylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
          },
          "SO:0001737": {
            "name": "histone_acylation_region",
            "def": "A histone modification, whereby the histone protein is acylated at multiple sites in a region. [SO:ke]"
          },
          "SO:0001738": {
            "name": "H4K_acylation_region",
            "def": "A region of the H4 histone whereby multiple lysines are acylated. [SO:ke]"
          },
          "SO:0001739": {
            "name": "gene_with_non_canonical_start_codon",
            "def": "A gene with a start codon other than AUG. [SO:xp]"
          },
          "SO:0001740": {
            "name": "gene_with_start_codon_CUG",
            "def": "A gene with a translational start codon of CUG. [SO:mc]"
          },
          "SO:0001741": {
            "name": "pseudogenic_gene_segment",
            "def": "A gene segment which when incorporated by somatic recombination in the final gene transcript results in a nonfunctional product. [SO:hd]"
          },
          "SO:0001742": {
            "name": "copy_number_gain",
            "def": "A sequence alteration whereby the copy number of a given regions is greater than the reference sequence. [SO:ke]"
          },
          "SO:0001743": {
            "name": "copy_number_loss",
            "def": "A sequence alteration whereby the copy number of a given region is less than the reference sequence. [SO:ke]"
          },
          "SO:0001744": {
            "name": "UPD",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from one parent and no copies of the same chromosome or region from the other parent. [SO:BM]"
          },
          "SO:0001745": {
            "name": "maternal_uniparental_disomy",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from the mother and no copies of the same chromosome or region from the father. [SO:bm]"
          },
          "SO:0001746": {
            "name": "paternal_uniparental_disomy",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from the father and no copies of the same chromosome or region from the mother. [SO:bm]"
          },
          "SO:0001747": {
            "name": "open_chromatin_region",
            "def": "A DNA sequence that in the normal state of the chromosome corresponds to an unfolded, un-complexed stretch of double-stranded DNA. [SO:cb]"
          },
          "SO:0001748": {
            "name": "SL3_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL3 RNA leader sequence to the 5' end of an mRNA. SL3 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001749": {
            "name": "SL4_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL4 RNA leader sequence to the 5' end of an mRNA. SL4 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001750": {
            "name": "SL5_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL5 RNA leader sequence to the 5' end of an mRNA. SL5 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001751": {
            "name": "SL6_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL6 RNA leader sequence to the 5' end of an mRNA. SL6 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001752": {
            "name": "SL7_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL7 RNA leader sequence to the 5' end of an mRNA. SL7 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001753": {
            "name": "SL8_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL8 RNA leader sequence to the 5' end of an mRNA. SL8 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001754": {
            "name": "SL9_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL9 RNA leader sequence to the 5' end of an mRNA. SL9 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001755": {
            "name": "SL10_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL10 RNA leader sequence to the 5' end of an mRNA. SL10 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001756": {
            "name": "SL11_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL11 RNA leader sequence to the 5' end of an mRNA. SL11 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001757": {
            "name": "SL12_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL12 RNA leader sequence to the 5' end of an mRNA. SL12 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001758": {
            "name": "duplicated_pseudogene",
            "def": "A pseudogene that arose via gene duplication. Generally duplicated pseudogenes have the same structure as the original gene, including intron-exon structure and some regulatory sequence. [http://en.wikipedia.org/wiki/Pseudogene]"
          },
          "SO:0001759": {
            "name": "unitary_pseudogene",
            "def": "A pseudogene, deactivated from original state by mutation, fixed in a population. [http://en.wikipedia.org/wiki/Pseudogene, SO:ke]"
          },
          "SO:0001760": {
            "name": "non_processed_pseudogene",
            "def": "A pseudogene that arose from a means other than retrotransposition. [SO:ke]"
          },
          "SO:0001761": {
            "name": "variant_quality",
            "def": "A dependent entity that inheres in a bearer, a sequence variant. [PMID:17597783, SO:ke]"
          },
          "SO:0001762": {
            "name": "variant_origin",
            "def": "A quality inhering in a variant by virtue of its origin. [PMID:17597783, SO:ke]"
          },
          "SO:0001763": {
            "name": "variant_frequency",
            "def": "A physical quality which inheres to the variant by virtue of the number instances of the variant within a population. [PMID:17597783, SO:ke]"
          },
          "SO:0001764": {
            "name": "unique_variant",
            "def": "A physical quality which inheres to the variant by virtue of the number instances of the variant within a population. [SO:ke]"
          },
          "SO:0001765": {
            "name": "rare_variant"
          },
          "SO:0001766": {
            "name": "polymorphic_variant"
          },
          "SO:0001767": {
            "name": "common_variant"
          },
          "SO:0001768": {
            "name": "fixed_variant"
          },
          "SO:0001769": {
            "name": "variant_phenotype",
            "def": "A quality inhering in a variant by virtue of its phenotype. [PMID:17597783, SO:ke]"
          },
          "SO:0001770": {
            "name": "benign_variant"
          },
          "SO:0001771": {
            "name": "disease_associated_variant"
          },
          "SO:0001772": {
            "name": "disease_causing_variant"
          },
          "SO:0001773": {
            "name": "lethal_variant"
          },
          "SO:0001774": {
            "name": "quantitative_variant"
          },
          "SO:0001775": {
            "name": "maternal_variant"
          },
          "SO:0001776": {
            "name": "paternal_variant"
          },
          "SO:0001777": {
            "name": "somatic_variant"
          },
          "SO:0001778": {
            "name": "germline_variant"
          },
          "SO:0001779": {
            "name": "pedigree_specific_variant"
          },
          "SO:0001780": {
            "name": "population_specific_variant"
          },
          "SO:0001781": {
            "name": "de_novo_variant"
          },
          "SO:0001782": {
            "name": "TF_binding_site_variant",
            "def": "A sequence variant located within a transcription factor binding site. [EBI:fc]"
          },
          "SO:0001784": {
            "name": "complex_structural_alteration",
            "def": "A structural sequence alteration or rearrangement encompassing one or more genome fragments, with 4 or more breakpoints. [FB:reference_manual, NCBI:th, SO:ke]"
          },
          "SO:0001785": {
            "name": "structural_alteration"
          },
          "SO:0001786": {
            "name": "loss_of_heterozygosity",
            "def": "A functional variant whereby the sequence alteration causes a loss of function of one allele of a gene. [SO:ke]"
          },
          "SO:0001787": {
            "name": "splice_donor_5th_base_variant",
            "def": "A sequence variant that causes a change at the 5th base pair after the start of the intron in the orientation of the transcript. [EBI:gr]"
          },
          "SO:0001788": {
            "name": "U_box",
            "def": "An U-box is a conserved T-rich region upstream of a retroviral polypurine tract that is involved in PPT primer creation during reverse transcription. [PMID:10556309, PMID:11577982, PMID:9649446]"
          },
          "SO:0001789": {
            "name": "mating_type_region",
            "def": "A specialized region in the genomes of some yeast and fungi, the genes of which regulate mating type. [SO:ke]"
          },
          "SO:0001790": {
            "name": "paired_end_fragment",
            "def": "An assembly region that has been sequenced from both ends resulting in a read_pair (mate_pair). [SO:ke]"
          },
          "SO:0001791": {
            "name": "exon_variant",
            "def": "A sequence variant that changes exon sequence. [SO:ke]"
          },
          "SO:0001792": {
            "name": "non_coding_transcript_exon_variant",
            "def": "A sequence variant that changes non-coding exon sequence in a non-coding transcript. [EBI:fc, SO:ke]"
          },
          "SO:0001793": {
            "name": "clone_end",
            "def": "A read from an end of the clone sequence. [SO:ke]"
          },
          "SO:0001794": {
            "name": "point_centromere",
            "def": "A point centromere is a relatively small centromere (about 125 bp DNA) in discrete sequence, found in some yeast including S. cerevisiae. [PMID:7502067, SO:vw]"
          },
          "SO:0001795": {
            "name": "regional_centromere",
            "def": "A regional centromere is a large modular centromere found in fission yeast and higher eukaryotes. It consist of a central core region flanked by inverted inner and outer repeat regions. [PMID:7502067, SO:vw]"
          },
          "SO:0001796": {
            "name": "regional_centromere_central_core",
            "def": "A conserved region within the central region of a modular centromere, where the kinetochore is formed. [SO:vw]"
          },
          "SO:0001797": {
            "name": "centromeric_repeat",
            "def": "A repeat region found within the modular centromere. [SO:ke]"
          },
          "SO:0001798": {
            "name": "regional_centromere_inner_repeat_region",
            "def": "The inner inverted repeat region of a modular centromere and part of the central core surrounding a non-conserved central region. This region is adjacent to the central core, on each chromosome arm. [SO:vw]"
          },
          "SO:0001799": {
            "name": "regional_centromere_outer_repeat_region",
            "def": "The heterochromatic outer repeat region of a modular centromere. These repeats exist in tandem arrays on both chromosome arms. [SO:vw]"
          },
          "SO:0001800": {
            "name": "tasiRNA",
            "def": "The sequence of a 21 nucleotide double stranded, polyadenylated non coding RNA, transcribed from the TAS gene. [PMID:16145017]"
          },
          "SO:0001801": {
            "name": "tasiRNA_primary_transcript",
            "def": "A primary transcript encoding a tasiRNA. [PMID:16145017]"
          },
          "SO:0001802": {
            "name": "increased_polyadenylation_variant",
            "def": "A transcript processing variant whereby polyadenylation of the encoded transcript is increased with respect to the reference. [SO:ke]"
          },
          "SO:0001803": {
            "name": "decreased_polyadenylation_variant",
            "def": "A transcript processing variant whereby polyadenylation of the encoded transcript is decreased with respect to the reference. [SO:ke]"
          },
          "SO:0001804": {
            "name": "DDB_box",
            "def": "A conserved polypeptide motif that mediates protein-protein interaction and defines adaptor proteins for DDB1/cullin 4 ubiquitin ligases. [PMID:18794354, PMID:19818632]"
          },
          "SO:0001805": {
            "name": "destruction_box",
            "def": "A conserved polypeptide motif that can be recognized by both Fizzy/Cdc20- and FZR/Cdh1-activated anaphase-promoting complex/cyclosome (APC/C) and targets a protein for ubiquitination and subsequent degradation by the APC/C. The consensus sequence is RXXLXXXXN. [PMID:12208841, PMID:1842691]"
          },
          "SO:0001806": {
            "name": "ER_retention_signal",
            "def": "A C-terminal tetrapeptide motif that mediates retention of a protein in (or retrieval to) the endoplasmic reticulum. In mammals the sequence is KDEL, and in fungi HDEL or DDEL. [doi:10.1093/jxb/50.331.157, PMID:2077689]"
          },
          "SO:0001807": {
            "name": "KEN_box",
            "def": "A conserved polypeptide motif that can be recognized by FZR/Cdh1-activated anaphase-promoting complex/cyclosome (APC/C) and targets a protein for ubiquitination and subsequent degradation by the APC/C. The consensus sequence is KENXXXN. [PMID:10733526, PMID:1220884, PMID:18426916]"
          },
          "SO:0001808": {
            "name": "mitochondrial_targeting_signal",
            "def": "A polypeptide region that targets a polypeptide to the mitochondrion. [PomBase:mah]"
          },
          "SO:0001809": {
            "name": "signal_anchor",
            "def": "A signal sequence that is not cleaved from the polypeptide. Anchors a Type II membrane protein to the membrane. [http://www.cbs.dtu.dk/services/SignalP/background/biobackground.php]"
          },
          "SO:0001810": {
            "name": "PIP_box",
            "def": "A polypeptide region that mediates binding to PCNA. The consensus sequence is QXX(hh)XX(aa), where (h) denotes residues with moderately hydrophobic side chains and (a) denotes residues with highly hydrophobic aromatic side chains. [PMID:9631646]"
          },
          "SO:0001811": {
            "name": "phosphorylation_site",
            "def": "A post-translationally modified region in which residues of the protein are modified by phosphorylation. [PomBase:mah]"
          },
          "SO:0001812": {
            "name": "transmembrane_helix",
            "def": "A region that traverses the lipid bilayer and adopts a helical secondary structure. [PomBase:mah]"
          },
          "SO:0001813": {
            "name": "vacuolar_sorting_signal",
            "def": "A polypeptide region that targets a polypeptide to the vacuole. [PomBase:mah]"
          },
          "SO:0001814": {
            "name": "coding_variant_quality"
          },
          "SO:0001815": {
            "name": "synonymous"
          },
          "SO:0001816": {
            "name": "non_synonymous"
          },
          "SO:0001817": {
            "name": "inframe",
            "def": "An attribute describing a sequence that contains a mutation involving the deletion or insertion of one or more bases, where this number is divisible by 3. [SO:ke]"
          },
          "SO:0001818": {
            "name": "protein_altering_variant",
            "def": "A sequence_variant which is predicted to change the protein encoded in the coding sequence. [EBI:gr]"
          },
          "SO:0001819": {
            "name": "synonymous_variant",
            "def": "A sequence variant where there is no resulting change to the encoded amino acid. [SO:ke]"
          },
          "SO:0001820": {
            "name": "inframe_indel",
            "def": "A coding sequence variant where the change does not alter the frame of the transcript. [SO:ke]"
          },
          "SO:0001821": {
            "name": "inframe_insertion",
            "def": "An inframe non synonymous variant that inserts bases into in the coding sequence. [EBI:gr]"
          },
          "SO:0001822": {
            "name": "inframe_deletion",
            "def": "An inframe non synonymous variant that deletes bases from the coding sequence. [EBI:gr]"
          },
          "SO:0001823": {
            "name": "conservative_inframe_insertion",
            "def": "An inframe increase in cds length that inserts one or more codons into the coding sequence between existing codons. [EBI:gr]"
          },
          "SO:0001824": {
            "name": "disruptive_inframe_insertion",
            "def": "An inframe increase in cds length that inserts one or more codons into the coding sequence within an existing codon. [EBI:gr]"
          },
          "SO:0001825": {
            "name": "conservative_inframe_deletion",
            "def": "An inframe decrease in cds length that deletes one or more entire codons from the coding sequence but does not change any remaining codons. [EBI:gr]"
          },
          "SO:0001826": {
            "name": "disruptive_inframe_deletion",
            "def": "An inframe decrease in cds length that deletes bases from the coding sequence starting within an existing codon. [EBI:gr]"
          },
          "SO:0001827": {
            "name": "mRNA_read",
            "def": "A sequencer read of an mRNA substrate. [SO:ke]"
          },
          "SO:0001828": {
            "name": "genomic_DNA_read",
            "def": "A sequencer read of a genomic DNA substrate. [SO:ke]"
          },
          "SO:0001829": {
            "name": "mRNA_contig",
            "def": "A contig composed of mRNA_reads. [SO:ke]"
          },
          "SO:0001830": {
            "name": "AFLP_fragment",
            "def": "A PCR product obtained by applying the AFLP technique, based on a restriction enzyme digestion of genomic DNA and an amplification of the resulting fragments. [GMOD:ea]"
          },
          "SO:0001831": {
            "name": "protein_hmm_match",
            "def": "A match to a protein HMM such as pfam. [SO:ke]"
          },
          "SO:0001832": {
            "name": "immunoglobulin_region",
            "def": "A region of immunoglobulin sequence, either constant or variable. [SO:ke]"
          },
          "SO:0001833": {
            "name": "V_region",
            "def": "The variable region of an immunoglobulin polypeptide sequence. [SO:ke]"
          },
          "SO:0001834": {
            "name": "C_region",
            "def": "The constant region of an immunoglobulin polypeptide sequence. [SO:ke]"
          },
          "SO:0001835": {
            "name": "N_region",
            "def": "Extra nucleotides inserted between rearranged immunoglobulin segments. [SO:ke]"
          },
          "SO:0001836": {
            "name": "S_region",
            "def": "The switch region of immunoglobulin heavy chains; it is involved in the rearrangement of heavy chain DNA leading to the expression of a different immunoglobulin classes from the same B-cell. [SO:ke]"
          },
          "SO:0001837": {
            "name": "mobile_element_insertion",
            "def": "A kind of insertion where the inserted sequence is a mobile element. [EBI:dvga]"
          },
          "SO:0001838": {
            "name": "novel_sequence_insertion",
            "def": "An insertion the sequence of which cannot be mapped to the reference genome. [NCBI:th]"
          },
          "SO:0001839": {
            "name": "CSL_response_element",
            "def": "A promoter element with consensus sequence GTGRGAA, bound by CSL (CBF1/RBP-JK/Suppressor of Hairless/LAG-1) transcription factors. [PMID:19101542]"
          },
          "SO:0001840": {
            "name": "GATA_box",
            "def": "A GATA transcription factor element containing the consensus sequence WGATAR (in which W indicates A/T and R indicates A/G). [PMID:8321208]"
          },
          "SO:0001841": {
            "name": "polymorphic_pseudogene",
            "def": "Pseudogene owing to a SNP/DIP but in other individuals/haplotypes/strains the gene is translated. [JAX:hd]"
          },
          "SO:0001842": {
            "name": "AP_1_binding_site",
            "def": "A promoter element with consensus sequence TGACTCA, bound by AP-1 and related transcription factors. [PMID:1899230, PMID:3034432, PMID:3125983]"
          },
          "SO:0001843": {
            "name": "CRE",
            "def": "A promoter element with consensus sequence TGACGTCA; bound by the ATF/CREB family of transcription factors. [PMID:11483355, PMID:11483993]"
          },
          "SO:0001844": {
            "name": "CuRE",
            "def": "A promoter element bound by copper ion-sensing transcription factors such as S. cerevisiae Mac1p or S. pombe Cuf1; the consensus sequence is HTHNNGCTGD (more specifically TTTGCKCR in budding yeast). [PMID:10593913, PMID:9188496, PMID:9211922]"
          },
          "SO:0001845": {
            "name": "DRE",
            "def": "A promoter element with consensus sequence CGWGGWNGMM, bound by transcription factors related to RecA and found in promoters of genes expressed following several types of DNA damage or inhibition of DNA synthesis. [PMID:11073995, PMID:8668127]"
          },
          "SO:0001846": {
            "name": "FLEX_element",
            "def": "A promoter element that has consensus sequence GTAAACAAACAAAM and contains a heptameric core GTAAACA, bound by transcription factors with a forkhead DNA-binding domain. [PMID:10747048, PMID:14871934]"
          },
          "SO:0001847": {
            "name": "forkhead_motif",
            "def": "A promoter element with consensus sequence TTTRTTTACA, bound by transcription factors with a forkhead DNA-binding domain. [PMID:15195092]"
          },
          "SO:0001848": {
            "name": "homol_D_box",
            "def": "A core promoter element that has the consensus sequence CAGTCACA (or its inverted form TGTGACTG), and plays the role of a TATA box in promoters that do not contain a canonical TATA sequence. [PMID:7501449, PMID:8458332]"
          },
          "SO:0001849": {
            "name": "homol_E_box",
            "def": "A core promoter element that has the consensus sequence ACCCTACCCT (or its inverted form AGGGTAGGGT), and is found near the homol D box in some promoters that use a homol D box instead of a canonical TATA sequence. [PMID:7501449]"
          },
          "SO:0001850": {
            "name": "HSE",
            "def": "A promoter element that consists of at least three copies of the pentanucleotide NGAAN, bound by the heat shock transcription factor HSF. [PMID:17347150, PMID:8689565]"
          },
          "SO:0001851": {
            "name": "iron_repressed_GATA_element",
            "def": "A GATA promoter element with consensus sequence WGATAA, found in promoters of genes repressed in the presence of iron. [PMID:11956219, PMID:17211681]"
          },
          "SO:0001852": {
            "name": "mating_type_M_box",
            "def": "A promoter element with consensus sequence ACAAT, found in promoters of mating type M-specific genes in fission yeast and bound by the transcription factor Mat1-Mc. [PMID:9233811]"
          },
          "SO:0001853": {
            "name": "androgen_response_element",
            "def": "A non-palindromic sequence found in the promoters of genes whose expression is regulated in response to androgen. [PMID:21796522]"
          },
          "SO:0001854": {
            "name": "smFISH_probe",
            "def": "A smFISH is a probe that binds RNA in a single molecule in situ hybridization experiment. [PMID:18806792]"
          },
          "SO:0001855": {
            "name": "MCB",
            "def": "A promoter element with consensus sequence ACGCGT, bound by the transcription factor complex MBF (MCB-binding factor) and found in promoters of genes expressed during the G1/S transition of the cell cycle. [PMID:16285853]"
          },
          "SO:0001856": {
            "name": "CCAAT_motif",
            "def": "A promoter element with consensus sequence CCAAT, bound by a protein complex that represses transcription in response to low iron levels. [PMID:16963626]"
          },
          "SO:0001857": {
            "name": "Ace2_UAS",
            "def": "A promoter element with consensus sequence CCAGCC, bound by the fungal transcription factor Ace2. [PMID:16678171]"
          },
          "SO:0001858": {
            "name": "TR_box",
            "def": "A promoter element with consensus sequence TTCTTTGTTY, bound an HMG-box transcription factor such as S. pombe Ste11, and found in promoters of genes up-regulated early in meiosis. [PMID:1657709]"
          },
          "SO:0001859": {
            "name": "STREP_motif",
            "def": "A promoter element with consensus sequence CCCCTC, bound by the PKA-responsive zinc finger transcription factor Rst2. [PMID:11739717]"
          },
          "SO:0001860": {
            "name": "rDNA_intergenic_spacer_element",
            "def": "A DNA motif that contains a core consensus sequence AGGTAAGGGTAATGCAC, is found in the intergenic regions of rDNA repeats, and is bound by an RNA polymerase I transcription termination factor (e.g. S. pombe Reb1). [PMID:9016645]"
          },
          "SO:0001861": {
            "name": "sterol_regulatory_element",
            "def": "A 10-bp promoter element bound by sterol regulatory element binding proteins (SREBPs), found in promoters of genes involved in sterol metabolism. Many variants of the sequence ATCACCCCAC function as SREs. [GO:mah, PMID:11111080, PMID:16537923]"
          },
          "SO:0001862": {
            "name": "GT_dinucleotide_repeat",
            "def": "A dinucleotide repeat region composed of GT repeating elements. [SO:ke]"
          },
          "SO:0001863": {
            "name": "GTT_trinucleotide_repeat",
            "def": "A trinucleotide repeat region composed of GTT repeating elements. [SO:ke]"
          },
          "SO:0001864": {
            "name": "Sap1_recognition_motif",
            "def": "A DNA motif to which the S. pombe Sap1 protein binds. The consensus sequence is 5'-TARGCAGNTNYAACGMG-3'; it is found at the mating type locus, where it is important for mating type switching, and at replication fork barriers in rDNA repeats. [PMID:16166653, PMID:7651412]"
          },
          "SO:0001865": {
            "name": "CDRE_motif",
            "def": "An RNA polymerase II promoter element found in the promoters of genes regulated by calcineurin. The consensus sequence is GNGGCKCA. [PMID:16928959]"
          },
          "SO:0001866": {
            "name": "BAC_read_contig",
            "def": "A contig of BAC reads. [GMOD:ea]"
          },
          "SO:0001867": {
            "name": "candidate_gene",
            "def": "A gene suspected of being involved in the expression of a trait. [GMOD:ea]"
          },
          "SO:0001868": {
            "name": "positional_candidate_gene",
            "def": "A candidate gene whose association with a trait is based on the gene's location on a chromosome. [GMOD:ea]"
          },
          "SO:0001869": {
            "name": "functional_candidate_gene",
            "def": "A candidate gene whose function has something in common biologically with the trait under investigation. [GMOD:ea]"
          },
          "SO:0001870": {
            "name": "enhancerRNA",
            "def": "A short ncRNA that is transcribed from an enhancer. May have a regulatory function. [doi:10.1038/465173a, SO:cjm]"
          },
          "SO:0001871": {
            "name": "PCB",
            "def": "A promoter element with consensus sequence GNAACR, bound by the transcription factor complex PBF (PCB-binding factor) and found in promoters of genes expressed during the M/G1 transition of the cell cycle. [GO:mah, PMID:12411492]"
          },
          "SO:0001872": {
            "name": "rearrangement_region",
            "def": "A region of a chromosome, where the chromosome has undergone a large structural rearrangement that altered the genome organization. There is no longer synteny to the reference genome. [NCBI:th, PMID:18564416]"
          },
          "SO:0001873": {
            "name": "interchromosomal_breakpoint",
            "def": "A rearrangement breakpoint between two different chromosomes. [NCBI:th]"
          },
          "SO:0001874": {
            "name": "intrachromosomal_breakpoint",
            "def": "A rearrangement breakpoint within the same chromosome. [NCBI:th]"
          },
          "SO:0001875": {
            "name": "unassigned_supercontig",
            "def": "A supercontig that is not been assigned to any ultracontig during a genome assembly project. [GMOD:ea]"
          },
          "SO:0001876": {
            "name": "partial_genomic_sequence_assembly",
            "def": "A partial DNA sequence assembly of a chromosome or full genome, which contains gaps that are filled with N's. [GMOD:ea]"
          },
          "SO:0001877": {
            "name": "lnc_RNA",
            "def": "A non-coding RNA over 200nucleotides in length. [HGNC:mw]"
          },
          "SO:0001878": {
            "name": "feature_variant",
            "def": "A sequence variant that falls entirely or partially within a genomic feature. [EBI:fc, SO:ke]"
          },
          "SO:0001879": {
            "name": "feature_ablation",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the deletion, is greater than the extent of the underlying genomic features. [SO:ke]"
          },
          "SO:0001880": {
            "name": "feature_amplification",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the structural change, an amplification of sequence, is greater than the extent of the underlying genomic features. [SO:ke]"
          },
          "SO:0001881": {
            "name": "feature_translocation",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the structural change, a translocation, is greater than the extent of the underlying genomic features. [SO:ke]"
          },
          "SO:0001882": {
            "name": "feature_fusion",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where a deletion fuses genomic features. [SO:ke]"
          },
          "SO:0001883": {
            "name": "transcript_translocation",
            "def": "A feature translocation where the region contains a transcript. [SO:ke]"
          },
          "SO:0001884": {
            "name": "regulatory_region_translocation",
            "def": "A feature translocation where the region contains a regulatory region. [SO:ke]"
          },
          "SO:0001885": {
            "name": "TFBS_translocation",
            "def": "A feature translocation where the region contains a transcription factor binding site. [SO:ke]"
          },
          "SO:0001886": {
            "name": "transcript_fusion",
            "def": "A feature fusion where the deletion brings together transcript regions. [SO:ke]"
          },
          "SO:0001887": {
            "name": "regulatory_region_fusion",
            "def": "A feature fusion where the deletion brings together regulatory regions. [SO:ke]"
          },
          "SO:0001888": {
            "name": "TFBS_fusion",
            "def": "A fusion where the deletion brings together transcription factor binding sites. [SO:ke]"
          },
          "SO:0001889": {
            "name": "transcript_amplification",
            "def": "A feature amplification of a region containing a transcript. [SO:ke]"
          },
          "SO:0001890": {
            "name": "transcript_regulatory_region_fusion",
            "def": "A feature fusion where the deletion brings together a regulatory region and a transcript region. [SO:ke]"
          },
          "SO:0001891": {
            "name": "regulatory_region_amplification",
            "def": "A feature amplification of a region containing a regulatory region. [SO:ke]"
          },
          "SO:0001892": {
            "name": "TFBS_amplification",
            "def": "A feature amplification of a region containing a transcription factor binding site. [SO:ke]"
          },
          "SO:0001893": {
            "name": "transcript_ablation",
            "def": "A feature ablation whereby the deleted region includes a transcript feature. [SO:ke]"
          },
          "SO:0001894": {
            "name": "regulatory_region_ablation",
            "def": "A feature ablation whereby the deleted region includes a regulatory region. [SO:ke]"
          },
          "SO:0001895": {
            "name": "TFBS_ablation",
            "def": "A feature ablation whereby the deleted region includes a transcription factor binding site. [SO:ke]"
          },
          "SO:0001896": {
            "name": "transposable_element_CDS",
            "def": "A CDS that is part of a transposable element. [SO:ke]"
          },
          "SO:0001897": {
            "name": "transposable_element_pseudogene",
            "def": "A pseudogene contained within a transposable element. [SO:ke]"
          },
          "SO:0001898": {
            "name": "dg_repeat",
            "def": "A repeat region which is part of the regional centromere outer repeat region. [PMID:16407326, SO:vw]"
          },
          "SO:0001899": {
            "name": "dh_repeat",
            "def": "A repeat region which is part of the regional centromere outer repeat region. [PMID:16407326, SO:vw]"
          },
          "SO:0001900": {
            "name": "M26_binding_site",
            "def": "A promoter element that contains a core sequence TGACGT, bound by a protein complex that regulates transcription of genes encoding PKA pathway components. [PMID:15448137]"
          },
          "SO:0001901": {
            "name": "AACCCT_box",
            "def": "A conserved 17-bp sequence (5'-ATCA(C/A)AACCCTAACCCT-3') commonly present upstream of the start site of histone transcription units functioning as a transcription factor binding site. [PMID:17452352, PMID:4092687]"
          },
          "SO:0001902": {
            "name": "splice_region",
            "def": "A region surrounding a cis_splice site, either within 1-3 bases of the exon or 3-8 bases of the intron. [SO:bm]"
          },
          "SO:0001903": {
            "name": "intronic_lncRNA",
            "def": "A lnc_RNA totally contained within an intron. [PMID:19071207, SO:ke]"
          },
          "SO:0001904": {
            "name": "antisense_lncRNA",
            "def": "Non-coding RNA transcribed from the opposite DNA strand compared with other transcripts and overlap in part with sense RNA. [PMID:19638999]"
          },
          "SO:0001905": {
            "name": "regional_centromere_outer_repeat_transcript",
            "def": "A transcript that is transcribed from the outer repeat region of a regional centromere. [PomBase:mah]"
          },
          "SO:0001906": {
            "name": "feature_truncation",
            "def": "A sequence variant that causes the reduction of a genomic feature, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0001907": {
            "name": "feature_elongation",
            "def": "A sequence variant that causes the extension of a genomic feature, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0001908": {
            "name": "internal_feature_elongation",
            "def": "A sequence variant that causes the extension of a genomic feature from within the feature rather than from the terminus of the feature, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0001909": {
            "name": "frameshift_elongation",
            "def": "A frameshift variant that causes the translational reading frame to be extended relative to the reference feature. [SO:ke]"
          },
          "SO:0001910": {
            "name": "frameshift_truncation",
            "def": "A frameshift variant that causes the translational reading frame to be shortened relative to the reference feature. [SO:ke]"
          },
          "SO:0001911": {
            "name": "copy_number_increase",
            "def": "A sequence variant where copies of a feature are increased relative to the reference. [SO:ke]"
          },
          "SO:0001912": {
            "name": "copy_number_decrease",
            "def": "A sequence variant where copies of a feature are decreased relative to the reference. [SO:ke]"
          },
          "SO:0001913": {
            "name": "bacterial_RNApol_promoter_sigma_ecf",
            "def": "A bacterial promoter with sigma ecf factor binding dependency. This is a type of bacterial promoters that requires a sigma ECF factor to bind to identified -10 and -35 sequence regions in order to mediate binding of the RNA polymerase to the promoter region as part of transcription initiation. [Invitrogen:kc]"
          },
          "SO:0001914": {
            "name": "rDNA_replication_fork_barrier",
            "def": "A DNA motif that is found in eukaryotic rDNA repeats, and is a site of replication fork pausing. [PMID:14645529]"
          },
          "SO:0001915": {
            "name": "transcription_start_cluster",
            "def": "A region defined by a cluster of experimentally determined transcription starting sites. [PMID:19624849, PMID:21372179, SO:andrewgibson]"
          },
          "SO:0001916": {
            "name": "CAGE_tag",
            "def": "A CAGE tag is a sequence tag hat corresponds to 5' ends of mRNA at cap sites, produced by cap analysis gene expression and used to identify transcriptional start sites. [SO:andrewgibson]"
          },
          "SO:0001917": {
            "name": "CAGE_cluster",
            "def": "A kind of transcription_initiation_cluster defined by the clustering of CAGE tags on a sequence region. [PMID:16645617, SO:andrewgibson]"
          },
          "SO:0001918": {
            "name": "5_methylcytosine",
            "def": "A cytosine methylated at the 5 carbon. [SO:rtapella]"
          },
          "SO:0001919": {
            "name": "4_methylcytosine",
            "def": "A cytosine methylated at the 4 nitrogen. [SO:rtapella]"
          },
          "SO:0001920": {
            "name": "N6_methyladenine",
            "def": "An adenine methylated at the 6 nitrogen. [SO:rtapella]"
          },
          "SO:0001921": {
            "name": "mitochondrial_contig",
            "def": "A contig of mitochondria derived sequences. [GMOD:ea]"
          },
          "SO:0001922": {
            "name": "mitochondrial_supercontig",
            "def": "A scaffold composed of mitochondrial contigs. [GMOD:ea]"
          },
          "SO:0001923": {
            "name": "TERRA",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts contain G rich telomeric RNA repeats and RNA tracts corresponding to adjacent subtelomeric sequences. They are 100-9000 bases long. [PMID:22139915]"
          },
          "SO:0001924": {
            "name": "ARRET",
            "def": "A non coding RNA transcript, complementary to subtelomeric tract of TERRA transcript but devoid of the repeats. [PMID:2139915]"
          },
          "SO:0001925": {
            "name": "ARIA",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts consist of C rich repeats. [PMID:22139915]"
          },
          "SO:0001926": {
            "name": "anti_ARRET",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts are antisense of ARRET transcripts. [PMID:22139915]"
          },
          "SO:0001927": {
            "name": "telomeric_transcript",
            "def": "A non-coding transcript derived from the transcript of the telomere. [PMID:22139915]"
          },
          "SO:0001928": {
            "name": "distal_duplication",
            "def": "A duplication of the distal region of a chromosome. [SO:bm]"
          },
          "SO:0001929": {
            "name": "mitochondrial_DNA_read",
            "def": "A sequencer read of a mitochondrial DNA sample. [GMOD:ea]"
          },
          "SO:0001930": {
            "name": "chloroplast_DNA_read",
            "def": "A sequencer read of a chloroplast DNA sample. [GMOD:ea]"
          },
          "SO:0001931": {
            "name": "consensus_gDNA",
            "def": "Genomic DNA sequence produced from some base calling or alignment algorithm which uses aligned or assembled multiple gDNA sequences as input. [GMOD:ea]"
          },
          "SO:0001932": {
            "name": "restriction_enzyme_five_prime_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended and the exposed single strand terminates at the 5' end. [SO:ke]"
          },
          "SO:0001933": {
            "name": "restriction_enzyme_three_prime_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended and the exposed single strand terminates at the 3' end. [SO:ke]"
          },
          "SO:0001934": {
            "name": "monomeric_repeat",
            "def": "A repeat_region containing repeat_units of 1 bp that is repeated multiple times in tandem. [SO:ke]"
          },
          "SO:0001935": {
            "name": "H3K20_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H3 protein is tri-methylated. [EBI:nj]"
          },
          "SO:0001936": {
            "name": "H3K36_acetylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is acylated. [EBI:nj]"
          },
          "SO:0001937": {
            "name": "H2BK12_acetylation_site",
            "def": "A kind of histone modification site, whereby the 12th residue (a lysine), from the start of the H2B protein is methylated. [EBI:nj]"
          },
          "SO:0001938": {
            "name": "H2AK5_acetylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H2A histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001939": {
            "name": "H4K12_acetylation_site",
            "def": "A kind of histone modification site, whereby the 12th residue (a lysine), from the start of the H4 histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001940": {
            "name": "H2BK120_acetylation_site",
            "def": "A kind of histone modification site, whereby the 120th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001941": {
            "name": "H4K91_acetylation_site",
            "def": "A kind of histone modification site, whereby the 91st residue (a lysine), from the start of the H4 histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001942": {
            "name": "H2BK20_acetylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001943": {
            "name": "H3K4ac_acetylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001944": {
            "name": "H2AK9_acetylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H2A histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001945": {
            "name": "H3K56_acetylation_site",
            "def": "A kind of histone modification site, whereby the 56th residue (a lysine), from the start of the H3 histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001946": {
            "name": "H2BK15_acetylation_site",
            "def": "A kind of histone modification site, whereby the 15th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001947": {
            "name": "H3R2_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 2nd residue (an arginine), from the start of the H3 protein is mono-methylated. [EBI:nj]"
          },
          "SO:0001948": {
            "name": "H3R2_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 2nd residue (an arginine), from the start of the H3 protein is di-methylated. [EBI:nj]"
          },
          "SO:0001949": {
            "name": "H4R3_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 3nd residue (an arginine), from the start of the H4 protein is di-methylated. [EBI:nj]"
          },
          "SO:0001950": {
            "name": "H4K4_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H4 protein is tri-methylated. [EBI:nj]"
          },
          "SO:0001951": {
            "name": "H3K23_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 23rd residue (a lysine), from the start of the H3 protein is di-methylated. [EBI:nj]"
          },
          "SO:0001952": {
            "name": "promoter_flanking_region",
            "def": "A region immediately adjacent to a promoter which may or may not contain transcription factor binding sites. [EBI:nj]"
          },
          "SO:0001953": {
            "name": "restriction_enzyme_assembly_scar",
            "def": "A region of DNA sequence formed from the ligation of two sticky ends where the palindrome is broken and no longer comprises the recognition site and thus cannot be re-cut by the restriction enzymes used to create the sticky ends. [SO:ke]"
          },
          "SO:0001954": {
            "name": "restriction_enzyme_region",
            "def": "A region related to restriction enzyme function. [SO:ke]"
          },
          "SO:0001955": {
            "name": "protein_stability_element",
            "def": "A polypeptide region that proves structure in a protein that affects the stability of the protein. [SO:ke]"
          },
          "SO:0001956": {
            "name": "protease_site",
            "def": "A polypeptide_region that  codes for a protease cleavage site. [SO:ke]"
          },
          "SO:0001957": {
            "name": "RNA_stability_element",
            "def": "RNA secondary structure that affects the stability of an RNA molecule. [SO:ke]"
          },
          "SO:0001958": {
            "name": "lariat_intron",
            "def": "A kind of intron whereby the excision is driven by lariat formation. [SO:ke]"
          },
          "SO:0001959": {
            "name": "TCT_motif",
            "def": "A cis-regulatory element, conserved sequence YYC+1TTTYY, and spans -2 to +6 relative to +1 TSS. It is present in most ribosomal protein genes in Drosophila and mammals but not in the yeast Saccharomyces cerevisiae. Resembles the initiator (TCAKTY in Drosophila) but functionally distinct from initiator. [PMID:20801935, SO:myl]"
          },
          "SO:0001960": {
            "name": "5_hydroxymethylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a hydroxymethyl group at the 5 carbon. [SO:ke]"
          },
          "SO:0001961": {
            "name": "5_formylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a formyl group at the 5 carbon. [SO:ke]"
          },
          "SO:0001962": {
            "name": "modified_adenine",
            "def": "A modified adenine DNA base feature. [SO:ke]"
          },
          "SO:0001963": {
            "name": "modified_cytosine",
            "def": "A modified cytosine DNA base feature. [SO:ke]"
          },
          "SO:0001964": {
            "name": "modified_guanine",
            "def": "A modified guanine DNA base feature. [SO:ke]"
          },
          "SO:0001965": {
            "name": "8_oxoguanine",
            "def": "A modified DNA guanine base,at the 8 carbon, often the product of DNA damage. [SO:ke]"
          },
          "SO:0001966": {
            "name": "5_carboxylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a carboxy group at the 5 carbon. [SO:ke]"
          },
          "SO:0001967": {
            "name": "8_oxoadenine",
            "def": "A modified DNA adenine base,at the 8 carbon, often the product of DNA damage. [SO:ke]"
          },
          "SO:0001968": {
            "name": "coding_transcript_variant",
            "def": "A transcript variant of a protein coding gene. [SO:ke]"
          },
          "SO:0001969": {
            "name": "coding_transcript_intron_variant",
            "def": "A transcript variant occurring within an intron of a coding transcript. [SO:ke]"
          },
          "SO:0001970": {
            "name": "non_coding_transcript_intron_variant",
            "def": "A transcript variant occurring within an intron of a non coding transcript. [SO:ke]"
          },
          "SO:0001971": {
            "name": "zinc_finger_binding_site"
          },
          "SO:0001972": {
            "name": "histone_4_acylation_site",
            "def": "A histone 4 modification where the modification is the acylation of the residue. [EBI:nj, SO:ke]"
          },
          "SO:0001973": {
            "name": "histone_3_acetylation_site",
            "def": "A histone 3 modification where the modification is the acylation of the residue. [EBI:nj, SO:ke]"
          },
          "SO:0001974": {
            "name": "CTCF_binding_site",
            "def": "A transcription factor binding site with consensus sequence CCGCGNGGNGGCAG, bound by CCCTF-binding factor. [EBI:nj]"
          },
          "SO:0001975": {
            "name": "five_prime_sticky_end_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme recognition site that, when cleaved, results in 5 prime overhangs. [SO:ke]"
          },
          "SO:0001976": {
            "name": "three_prime_sticky_end_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme recognition site that, when cleaved, results in 3 prime overhangs. [SO:ke]"
          },
          "SO:0001977": {
            "name": "ribonuclease_site",
            "def": "A region of a transcript encoding the cleavage site for a ribonuclease enzyme. [SO:ke]"
          },
          "SO:0001978": {
            "name": "signature",
            "def": "A region of  sequence where developer information is encoded. [SO:ke]"
          },
          "SO:0001979": {
            "name": "RNA_stability_element",
            "def": "A motif that affects the stability of RNA. [PMID:22495308, SO:ke]"
          },
          "SO:0001980": {
            "name": "G_box",
            "def": "A regulatory promoter element identified in mutation experiments, with consensus sequence: CACGTG. Present in promoters, intergenic regions, coding regions, and introns. They are involved in gene expression responses to light and interact with G-box binding factor and I-box binding factor 1a. [PMID:19249238, PMID:8571452, SO:ml]"
          },
          "SO:0001981": {
            "name": "L_box",
            "def": "An orientation dependent  regulatory promoter element, with consensus sequence of TTGCACAN4TTGCACA, found in plants. [PMID:17381552, PMID:2902624, SO:ml]"
          },
          "SO:0001982": {
            "name": "I-box",
            "def": "A plant regulatory promoter motif,  composed of a highly conserved hexamer GATAAG (I-box core). [PMID:2347304, PMID:2902624, SO:ml]"
          },
          "SO:0001983": {
            "name": "5_prime_UTR_premature_start_codon_variant",
            "def": "A 5' UTR variant where a premature start codon is introduced, moved or lost. [SANGER:am]"
          },
          "SO:0001984": {
            "name": "silent_mating_type_cassette_array",
            "def": "A gene cassette array that corresponds to a silenced version of a mating type region. [PomBase:mah]"
          },
          "SO:0001985": {
            "name": "Okazaki_fragment",
            "def": "Any of the DNA segments produced by discontinuous synthesis of the lagging strand during DNA replication. [ISBN:0805350152]"
          },
          "SO:0001986": {
            "name": "upstream_transcript_variant",
            "def": "A feature variant, where the alteration occurs upstream of the transcript TSS. [EBI:gr]"
          },
          "SO:0001987": {
            "name": "downstream_transcript_variant"
          },
          "SO:0001988": {
            "name": "5_prime_UTR_premature_start_codon_gain_variant",
            "def": "A 5' UTR variant where a premature start codon is gained. [Sanger:am]"
          },
          "SO:0001989": {
            "name": "5_prime_UTR_premature_start_codon_loss_variant",
            "def": "A 5' UTR variant where a premature start codon is lost. [SANGER:am]"
          },
          "SO:0001990": {
            "name": "five_prime_UTR_premature_start_codon_location_variant",
            "def": "A 5' UTR variant where a premature start codon is moved. [SANGER:am]"
          },
          "SO:0001991": {
            "name": "consensus_AFLP_fragment",
            "def": "A consensus AFLP fragment is an AFLP sequence produced from any alignment algorithm which uses assembled multiple AFLP sequences as input. [GMOD:ea]"
          },
          "SO:0001992": {
            "name": "nonsynonymous_variant",
            "def": "A non-synonymous variant is an inframe, protein altering variant, resulting in a codon change. [SO:ke]"
          },
          "SO:0001993": {
            "name": "extended_cis_splice_site",
            "def": "Intronic positions associated with cis-splicing. Contains the first and second positions immediately before the exon and the first, second and fifth positions immediately after. [SANGER:am]"
          },
          "SO:0001994": {
            "name": "intron_base_5",
            "def": "Fifth intronic position after the intron exon boundary, close to the 5' edge of the intron. [SANGER:am]"
          },
          "SO:0001995": {
            "name": "extended_intronic_splice_region_variant",
            "def": "A sequence variant occurring in the intron, within 10 bases of exon. [sanger:am]"
          },
          "SO:0001996": {
            "name": "extended_intronic_splice_region",
            "def": "Region of intronic sequence within 10 bases of an exon. [SANGER:am]"
          },
          "SO:0001997": {
            "name": "subtelomere",
            "def": "A heterochromatic region of the chromosome,  adjacent to the telomere (on the centromeric side) that contains repetitive DNA and sometimes genes and it is transcribed. [POMBE:al]"
          },
          "SO:0001998": {
            "name": "sgRNA",
            "def": "A small RNA oligo, typically about 20 bases, that guides the cas nuclease to a target DNA sequence in the CRISPR/cas mutagenesis method. [PMID:23934893]"
          },
          "SO:0001999": {
            "name": "mating_type_region_motif",
            "def": "DNA motif that is a component of a mating type region. [SO:ke]"
          },
          "SO:0002001": {
            "name": "Y_region",
            "def": "A segment of non-homology between a and alpha mating alleles, found at all three mating loci (HML, MAT, and HMR), has two forms (Ya and Yalpha). [SGD:jd]"
          },
          "SO:0002002": {
            "name": "Z1_region",
            "def": "A mating type region motif, one of two segments of homology found at all three mating loci (HML, MAT, and HMR). [SGD:jd]"
          },
          "SO:0002003": {
            "name": "Z2_region",
            "def": "A mating type region motif, the rightmost segment of homology in the HML and MAT mating loci (not present in HMR). [SGD:jd]"
          },
          "SO:0002004": {
            "name": "ARS_consensus_sequence",
            "def": "The ACS is an 11-bp sequence of the form 5'-WTTTAYRTTTW-3' which is at the core of every yeast ARS, and is necessary but not sufficient for recognition and binding by the origin recognition complex (ORC). Functional ARSs require an ACS, as well as other cis elements in the 5' (C domain) and 3' (B domain) flanking sequences of the ACS. [SGD:jd]"
          },
          "SO:0002005": {
            "name": "DSR_motif",
            "def": "The determinant of selective removal (DSR) motif consists of repeats of U(U/C)AAAC. The motif targets meiotic transcripts for removal during mitosis via the exosome. [PMID:22645662]"
          },
          "SO:0002006": {
            "name": "zinc_repressed_element",
            "def": "A promoter element that has the consensus sequence GNMGATC, and is found in promoters of genes repressed in the presence of zinc. [PMID:24003116, POMBE:mh]"
          },
          "SO:0002007": {
            "name": "MNV",
            "def": "An MNV is a multiple nucleotide variant (substitution) in which the inserted sequence is the same length as the replaced sequence. [NCBI:th]"
          },
          "SO:0002008": {
            "name": "rare_amino_acid_variant",
            "def": "A sequence variant whereby at least one base of a codon encoding a rare amino acid is changed, resulting in a different encoded amino acid. [SO:ke]"
          },
          "SO:0002009": {
            "name": "selenocysteine_loss",
            "def": "A sequence variant whereby at least one base of a codon encoding selenocysteine  is changed, resulting in a different encoded amino acid. [SO:ke]"
          },
          "SO:0002010": {
            "name": "pyrrolysine_loss",
            "def": "A sequence variant whereby at least one base of a codon encoding pyrrolysine is changed, resulting in a different encoded amino acid. [SO:ke]"
          },
          "SO:0002011": {
            "name": "intragenic_variant",
            "def": "A variant that occurs within a gene but falls outside of all transcript features. This occurs when alternate transcripts of a gene do not share overlapping  sequence. [SO:ke]"
          },
          "SO:0002012": {
            "name": "start_lost",
            "def": "A codon variant that changes at least one base of the canonical start codon. [SO:ke]"
          },
          "SO:0002013": {
            "name": "5_prime_UTR_truncation",
            "def": "A sequence variant that causes the reduction of a the 5'UTR  with regard to the reference sequence. [SO:ke]"
          },
          "SO:0002014": {
            "name": "5_prime_UTR_elongation",
            "def": "A sequence variant that causes the extension of 5' UTR, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0002015": {
            "name": "3_prime_UTR_truncation",
            "def": "A sequence variant that causes the reduction of a the 3' UTR  with regard to the reference sequence. [SO:ke]"
          },
          "SO:0002016": {
            "name": "3_prime_UTR_elongation",
            "def": "A sequence variant that causes the extension of 3' UTR, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0002017": {
            "name": "conserved_intergenic_variant",
            "def": "A sequence variant located in a conserved intergenic region, between genes. [SO:ke]"
          },
          "SO:0002018": {
            "name": "conserved_intron_variant",
            "def": "A transcript variant occurring within a conserved region of an intron. [SO:ke]"
          },
          "SO:0002019": {
            "name": "start_retained_variant",
            "def": "A sequence variant where at least one base in the start codon is changed, but the start remains. [SO:ke]"
          },
          "SO:0002020": {
            "name": "boundary_element",
            "def": "Boundary elements are DNA motifs that prevent heterochromatin from spreading into neighboring euchromatic regions. [PMID:24013502]"
          },
          "SO:0002021": {
            "name": "mating_type_region_replication_fork_barrier",
            "def": "A DNA motif that is found in eukaryotic rDNA repeats, and is a site of replication fork pausing. [PMID:17614787]"
          },
          "SO:0002022": {
            "name": "priRNA",
            "def": "A small RNA molecule, 22-23 nt in size, that is the product of a longer RNA. The production of priRNAs is independent of dicer and involves binding of RNA by argonaute and trimming by triman. In fission yeast, priRNAs trigger the establishment of heterochromatin. PriRNAs are primarily generated from centromeric transcripts (dg and dh repeats), but may also be produced from degradation products of primary transcripts. [PMID:20178743, PMID:24095277, PomBase:al]"
          },
          "SO:0002023": {
            "name": "multiplexing_sequence_identifier",
            "def": "A nucleic tag which is used in a ligation step of library preparation process to allow pooling of samples while maintaining ability to identify individual source material and creation of a multiplexed library. [OBO:prs, PMID:22574170]"
          },
          "SO:0002024": {
            "name": "W_region",
            "def": "The leftmost segment of homology in the HML and MAT mating loci,  but not present in HMR. [SGD:jd]"
          },
          "SO:0002025": {
            "name": "cis_acting_homologous_chromosome_pairing_region",
            "def": "A genome region where chromosome pairing occurs preferentially during homologous chromosome pairing during early meiotic prophase of Meiosis I. [PMID:22582262, PMID:23117617, PMID:24173580, PomBase:vw]"
          },
          "SO:0002026": {
            "name": "intein_encoding_region",
            "def": "The nucleotide sequence which encodes the intein portion of the precursor gene. [PMID:8165123]"
          },
          "SO:0002027": {
            "name": "uORF",
            "def": "A short open reading frame that is found in the 5' untranslated region of an mRNA and plays a role in translational regulation. [PMID:12890013, PMID:16153175, POMBASE:mah]"
          },
          "SO:0002028": {
            "name": "sORF",
            "def": "An open reading frame that encodes a peptide of less than 100 amino acids. [PMID:23970561, PMID:24705786, POMBASE:mah]"
          },
          "SO:0002029": {
            "name": "tnaORF",
            "def": "A translated ORF encoded entirely within the antisense strand of a known protein coding gene. [POMBASE:vw]"
          },
          "SO:0002030": {
            "name": "X_region",
            "def": "One of two segments of homology found at all three mating loci (HML, MAT and HMR). [SGD:jd]"
          },
          "SO:0002031": {
            "name": "shRNA",
            "def": "A short hairpin RNA (shRNA) is an RNA transcript that makes a tight hairpin turn that can be used to silence target gene expression via RNA interference. [PMID:6699500, SO:ke]"
          },
          "SO:0002032": {
            "name": "moR",
            "def": "A non-coding transcript encoded by sequences adjacent to the ends of the 5' and 3' miR-encoding sequences that abut the loop in precursor miRNA. [SO:ke]"
          },
          "SO:0002033": {
            "name": "loR",
            "def": "A short, non coding transcript of loop-derived sequences encoded in precursor miRNA. [SO:ke]"
          },
          "SO:0002034": {
            "name": "miR_encoding_snoRNA_primary_transcript",
            "def": "A snoRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002035": {
            "name": "lncRNA_primary_transcript",
            "def": "A primary transcript encoding a  lncRNA. [SO:ke]"
          },
          "SO:0002036": {
            "name": "miR_encoding_lncRNA_primary_transcript",
            "def": "A lncRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002037": {
            "name": "miR_encoding_tRNA_primary_transcript",
            "def": "A tRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002038": {
            "name": "shRNA_primary_transcript",
            "def": "A primary transcript encoding an shRNA. [SO:ke]"
          },
          "SO:0002039": {
            "name": "miR_encoding_shRNA_primary_transcript",
            "def": "A shRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002040": {
            "name": "vaultRNA_primary_transcript",
            "def": "A primary transcript encoding a  vaultRNA. [SO:ke]"
          },
          "SO:0002041": {
            "name": "miR_encoding_vaultRNA_primary_transcript",
            "def": "A vaultRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002042": {
            "name": "Y_RNA_primary_transcript",
            "def": "A primary transcript encoding a  Y-RNA. [SO:ke]"
          },
          "SO:0002043": {
            "name": "miR_encoding_Y_RNA_primary_transcript",
            "def": "A Y-RNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002044": {
            "name": "TCS_element",
            "def": "A TCS element is a (yeast) transcription factor binding site, bound by the TEA DNA binding domain (DBD) of transcription factors. The consensus site is CATTCC or CATTCT. [PMID:1489142, PMID:20118212, SO:ke]"
          },
          "SO:0002045": {
            "name": "pheromone_response_element",
            "def": "A PRE is a (yeast) TFBS with consensus site [TGAAAC(A/G)]. [PMID:1489142, SO:ke]"
          },
          "SO:0002046": {
            "name": "FRE",
            "def": "A FRE is an enhancer element necessary and sufficient to confer filamentation associated expression in S. cerevisiae. [PMID:1489142, SO:ke]"
          },
          "SO:0002047": {
            "name": "transcription_pause_site",
            "def": "Transcription pause sites are regions of a gene where RNA polymerase may pause during transcription. The functional role of pausing may be to facilitate factor recruitment, RNA folding, and synchronization with translation. Consensus transcription pause site have been observed in E. coli. [PMID:24789973, SO:ke]"
          },
          "SO:0002048": {
            "name": "disabled_reading_frame",
            "def": "A reading frame that could encode a full-length protein but which contains obvious mid-sequence disablements (frameshifts or premature stop codons). [SGD:se]"
          },
          "SO:0002049": {
            "name": "H3K27_acetylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is acetylated. [SO:rs]"
          },
          "SO:0002050": {
            "name": "constitutive_promoter",
            "def": "A promoter that allows for continual transcription of gene. [SO:ke]"
          },
          "SO:0002051": {
            "name": "inducible_promoter",
            "def": "A promoter whereby activity is induced by the presence or absence of biotic or abiotic factors. [SO:ke]"
          },
          "SO:0002052": {
            "name": "dominant_negative_variant",
            "def": "A variant where the mutated gene product adversely affects the other (wild type) gene product. [SO:ke]"
          },
          "SO:0002053": {
            "name": "gain_of_function_variant",
            "def": "A sequence variant whereby new or enhanced function is conferred on the gene product. [SO:ke]"
          },
          "SO:0002054": {
            "name": "loss_of_function_variant",
            "def": "A sequence variant whereby the gene product has diminished or abolished function. [SO:ke]"
          },
          "SO:0002055": {
            "name": "null_mutation",
            "def": "A variant whereby the gene product is not functional or the gene product is not produced. [SO:ke]"
          },
          "SO:0002056": {
            "name": "intronic_splicing_silencer",
            "def": "An intronic  splicing regulatory element that functions to recruit trans acting splicing factors suppress the transcription of the gene or genes they control. [PMID:23241926, SO:ke]"
          },
          "SO:0002057": {
            "name": "intronic_splicing_enhancer"
          },
          "SO:0002058": {
            "name": "exonic_splicing_silencer",
            "def": "An exonic  splicing regulatory element that functions to recruit trans acting splicing factors suppress the transcription of the gene or genes they control. [PMID:23241926, SO:ke]"
          },
          "SO:0002059": {
            "name": "recombination_enhancer",
            "def": "A regulatory_region that promotes or induces the process of recombination. [PMID:8861911, SGD:se]"
          },
          "SO:0002060": {
            "name": "interchomosomal_translocation",
            "def": "A translocation where the regions involved are from different chromosomes. [NCBI:th]"
          },
          "SO:0002061": {
            "name": "intrachomosomal_translocation",
            "def": "A translocation where the regions involved are from the same chromosome. [NCBI:th]"
          },
          "SO:0002062": {
            "name": "complex_chromosomal_rearrangement",
            "def": "A contiguous cluster of translocations, usually the result of a single catastrophic event such as chromothripsis or chromoanasynthesis. [NCBI:th]"
          },
          "SO:0002063": {
            "name": "alu_insertion",
            "def": "An insertion of sequence from the Alu family of mobile elements. [NCBI:th]"
          },
          "SO:0002064": {
            "name": "LINE1_insertion",
            "def": "An insertion from the Line1 family of mobile elements. [NCBI:th]"
          },
          "SO:0002065": {
            "name": "SVA_insertion",
            "def": "An insertion of sequence from the SVA family of mobile elements. [NCBI:th]"
          },
          "SO:0005836": {
            "name": "regulatory_region",
            "def": "A region of sequence that is involved in the control of a biological process. [SO:ke]"
          },
          "SO:0005837": {
            "name": "U14_snoRNA_primary_transcript",
            "def": "The primary transcript of an evolutionarily conserved eukaryotic low molecular weight RNA capable of intermolecular hybridization with both homologous and heterologous 18S rRNA. [PMID:2251119]"
          },
          "SO:0005841": {
            "name": "methylation_guide_snoRNA",
            "def": "A snoRNA that specifies the site of 2'-O-ribose methylation in an RNA molecule by base pairing with a short sequence around the target residue. [GOC:mah, PMID:12457565]"
          },
          "SO:0005843": {
            "name": "rRNA_cleavage_RNA",
            "def": "An ncRNA that is part of a ribonucleoprotein that cleaves the primary pre-rRNA transcript in the process of producing mature rRNA molecules. [GOC:kgc]"
          },
          "SO:0005845": {
            "name": "exon_of_single_exon_gene",
            "def": "An exon that is the only exon in a gene. [RSC:cb]"
          },
          "SO:0005847": {
            "name": "cassette_array_member"
          },
          "SO:0005848": {
            "name": "gene_cassette_member"
          },
          "SO:0005849": {
            "name": "gene_subarray_member"
          },
          "SO:0005850": {
            "name": "primer_binding_site",
            "def": "Non-covalent primer binding site for initiation of replication, transcription, or reverse transcription. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0005851": {
            "name": "gene_array",
            "def": "An array includes two or more genes, or two or more gene subarrays, contiguously arranged where the individual genes, or subarrays, are either identical in sequence, or essentially so. [SO:ma]"
          },
          "SO:0005852": {
            "name": "gene_subarray",
            "def": "A subarray is, by defintition, a member of a gene array (SO:0005851); the members of a subarray may differ substantially in sequence, but are closely related in function. [SO:ma]"
          },
          "SO:0005853": {
            "name": "gene_cassette",
            "def": "A gene that can be substituted for a related gene at a different site in the genome. [SGD:se]"
          },
          "SO:0005854": {
            "name": "gene_cassette_array",
            "def": "An array of non-functional genes whose members, when captured by recombination form functional genes. [SO:ma]"
          },
          "SO:0005855": {
            "name": "gene_group",
            "def": "A collection of related genes. [SO:ma]"
          },
          "SO:0005856": {
            "name": "selenocysteine_tRNA_primary_transcript",
            "def": "A primary transcript encoding seryl tRNA (SO:000269). [SO:ke]"
          },
          "SO:0005857": {
            "name": "selenocysteinyl_tRNA",
            "def": "A tRNA sequence that has a selenocysteine anticodon, and a 3' selenocysteine binding region. [SO:ke]"
          },
          "SO:0005858": {
            "name": "syntenic_region",
            "def": "A region in which two or more pairs of homologous markers occur on the same chromosome in two or more species. [http://www.informatics.jax.org/silverbook/glossary.shtml]"
          },
          "SO:0100001": {
            "name": "biochemical_region_of_peptide",
            "def": "A region of a peptide that is involved in a biochemical function. [EBIBS:GAR]"
          },
          "SO:0100002": {
            "name": "molecular_contact_region",
            "def": "A region that is involved a contact with another molecule. [EBIBS:GAR]"
          },
          "SO:0100003": {
            "name": "intrinsically_unstructured_polypeptide_region",
            "def": "A region of polypeptide chain with high conformational flexibility. [EBIBS:GAR]"
          },
          "SO:0100004": {
            "name": "catmat_left_handed_three",
            "def": "A motif of 3 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -75 bounds -100 to -50, res i+1: psi 140 bounds 110 to 170. An extra restriction of the length of the O to O distance would be useful, that it be less than 5 Angstrom. More precisely these two oxygens are the main chain carbonyl oxygen atoms of residues i-1 and i+1. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100005": {
            "name": "catmat_left_handed_four",
            "def": "A motif of 4 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i psi -10 bounds -50 to 30, res i+1: phi -90 bounds -120 to -60, res i+1: psi -10 bounds -50 to 30, res i+2: phi -75 bounds -100 to -50, res i+2: psi 140 bounds 110 to 170.  The extra restriction of the length of the O to O distance is similar, that it be less than 5 Angstrom. In this case these two Oxygen atoms are the main chain carbonyl oxygen atoms of residues i-1 and i+2. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100006": {
            "name": "catmat_right_handed_three",
            "def": "A motif of 3 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -75 bounds -100 to -50, res i+1: psi 140 bounds 110 to 170. An extra restriction of the length of the O to O distance would be useful, that it be less than 5 Angstrom. More precisely these two oxygens are the main chain carbonyl oxygen atoms of residues i-1 and i+1. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100007": {
            "name": "catmat_right_handed_four",
            "def": "A motif of 4 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -90 bounds -120 to -60, res i+1: psi -10 bounds -50 to 30, res i+2: phi -75 bounds -100 to -50, res i+2: psi 140 bounds 110 to 170. The extra restriction of the length of the O to O distance is similar, that it be less than 5 Angstrom. In this case these two Oxygen atoms are the main chain carbonyl oxygen atoms of residues i-1 and i+2. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100008": {
            "name": "alpha_beta_motif",
            "def": "A motif of five consecutive residues and two H-bonds in which: H-bond between CO of residue(i) and NH of residue(i+4), H-bond between CO of residue(i) and NH of residue(i+3),Phi angles of residues(i+1), (i+2) and (i+3) are negative. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100009": {
            "name": "lipoprotein_signal_peptide",
            "def": "A peptide that acts as a signal for both membrane translocation and lipid attachment in prokaryotes. [EBIBS:GAR]"
          },
          "SO:0100010": {
            "name": "no_output",
            "def": "An experimental region wherean analysis has been run and not produced any annotation. [EBIBS:GAR]"
          },
          "SO:0100011": {
            "name": "cleaved_peptide_region",
            "def": "The cleaved_peptide_region is the region of a peptide sequence that is cleaved during maturation. [EBIBS:GAR]"
          },
          "SO:0100012": {
            "name": "peptide_coil",
            "def": "Irregular, unstructured regions of a protein's backbone, as distinct from the regular region (namely alpha helix and beta strand - characterised by specific patterns of main-chain hydrogen bonds). [EBIBS:GAR]"
          },
          "SO:0100013": {
            "name": "hydrophobic_region_of_peptide",
            "def": "Hydrophobic regions are regions with a low affinity for water. [EBIBS:GAR]"
          },
          "SO:0100014": {
            "name": "n_terminal_region",
            "def": "The amino-terminal positively-charged region of a signal peptide (approx 1-5 aa). [EBIBS:GAR]"
          },
          "SO:0100015": {
            "name": "c_terminal_region",
            "def": "The more polar, carboxy-terminal region of the signal peptide (approx 3-7 aa). [EBIBS:GAR]"
          },
          "SO:0100016": {
            "name": "central_hydrophobic_region_of_signal_peptide",
            "def": "The central, hydrophobic region of the signal peptide (approx 7-15 aa). [EBIBS:GAR]"
          },
          "SO:0100017": {
            "name": "polypeptide_conserved_motif",
            "def": "A conserved motif is a short (up to 20 amino acids) region of biological interest that is conserved in different proteins. They may or may not have functional or structural significance within the proteins in which they are found. [EBIBS:GAR]"
          },
          "SO:0100018": {
            "name": "polypeptide_binding_motif",
            "def": "A polypeptide binding motif is a short (up to 20 amino acids) polypeptide region of biological interest that contains one or more amino acids experimentally shown to bind to a ligand. [EBIBS:GAR]"
          },
          "SO:0100019": {
            "name": "polypeptide_catalytic_motif",
            "def": "A polypeptide catalytic motif is a short (up to 20 amino acids) polypeptide region that contains one or more active site residues. [EBIBS:GAR]"
          },
          "SO:0100020": {
            "name": "polypeptide_DNA_contact",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with DNA. [EBIBS:GAR, SO:ke]"
          },
          "SO:0100021": {
            "name": "polypeptide_conserved_region",
            "def": "A subsection of sequence with biological interest that is conserved in different proteins. They may or may not have functional or structural significance within the proteins in which they are found. [EBIBS:GAR]"
          },
          "SO:1000002": {
            "name": "substitution",
            "def": "A sequence alteration where the length of the change in the variant is the same as that of the reference. [SO:ke]"
          },
          "SO:1000005": {
            "name": "complex_substitution",
            "def": "When no simple or well defined DNA mutation event describes the observed DNA change, the keyword \\complex\\ should be used. Usually there are multiple equally plausible explanations for the change. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000008": {
            "name": "point_mutation",
            "def": "A single nucleotide change which has occurred at the same position of a corresponding nucleotide in a reference sequence. [SO:immuno_workshop]"
          },
          "SO:1000009": {
            "name": "transition",
            "def": "Change of a pyrimidine nucleotide, C or T, into an other pyrimidine nucleotide, or change of a purine nucleotide, A or G, into an other purine nucleotide. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000010": {
            "name": "pyrimidine_transition",
            "def": "A substitution of a pyrimidine, C or T, for another pyrimidine. [SO:ke]"
          },
          "SO:1000011": {
            "name": "C_to_T_transition",
            "def": "A transition of a cytidine to a thymine. [SO:ke]"
          },
          "SO:1000012": {
            "name": "C_to_T_transition_at_pCpG_site",
            "def": "The transition of cytidine to thymine occurring at a pCpG site as a consequence of the spontaneous deamination of 5'-methylcytidine. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000013": {
            "name": "T_to_C_transition"
          },
          "SO:1000014": {
            "name": "purine_transition",
            "def": "A substitution of a purine, A or G, for another purine. [SO:ke]"
          },
          "SO:1000015": {
            "name": "A_to_G_transition",
            "def": "A transition of an adenine to a guanine. [SO:ke]"
          },
          "SO:1000016": {
            "name": "G_to_A_transition",
            "def": "A transition of a guanine to an adenine. [SO:ke]"
          },
          "SO:1000017": {
            "name": "transversion",
            "def": "Change of a pyrimidine nucleotide, C or T, into a purine nucleotide, A or G, or vice versa. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000018": {
            "name": "pyrimidine_to_purine_transversion",
            "def": "Change of a pyrimidine nucleotide, C or T, into a purine nucleotide, A or G. [SO:ke]"
          },
          "SO:1000019": {
            "name": "C_to_A_transversion",
            "def": "A transversion from cytidine to adenine. [SO:ke]"
          },
          "SO:1000020": {
            "name": "C_to_G_transversion"
          },
          "SO:1000021": {
            "name": "T_to_A_transversion",
            "def": "A transversion from T to A. [SO:ke]"
          },
          "SO:1000022": {
            "name": "T_to_G_transversion",
            "def": "A transversion from T to G. [SO:ke]"
          },
          "SO:1000023": {
            "name": "purine_to_pyrimidine_transversion",
            "def": "Change of a purine nucleotide, A or G , into a pyrimidine nucleotide C or T. [SO:ke]"
          },
          "SO:1000024": {
            "name": "A_to_C_transversion",
            "def": "A transversion from adenine to cytidine. [SO:ke]"
          },
          "SO:1000025": {
            "name": "A_to_T_transversion",
            "def": "A transversion from adenine to thymine. [SO:ke]"
          },
          "SO:1000026": {
            "name": "G_to_C_transversion",
            "def": "A transversion from guanine to cytidine. [SO:ke]"
          },
          "SO:1000027": {
            "name": "G_to_T_transversion",
            "def": "A transversion from guanine to thymine. [SO:ke]"
          },
          "SO:1000028": {
            "name": "intrachromosomal_mutation",
            "def": "A chromosomal structure variation within a single chromosome. [SO:ke]"
          },
          "SO:1000029": {
            "name": "chromosomal_deletion",
            "def": "An incomplete chromosome. [SO:ke]"
          },
          "SO:1000030": {
            "name": "chromosomal_inversion",
            "def": "An interchromosomal mutation where a region of the chromosome is inverted with respect to wild type. [SO:ke]"
          },
          "SO:1000031": {
            "name": "interchromosomal_mutation",
            "def": "A chromosomal structure variation whereby more than one chromosome is involved. [SO:ke]"
          },
          "SO:1000032": {
            "name": "indel",
            "def": "A sequence alteration which included an insertion and a deletion, affecting 2 or more bases. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html, http:http://www.hgvs.org/mutnomen/recs-DNA.html#indel]"
          },
          "SO:1000035": {
            "name": "duplication",
            "def": "An insertion which derives from, or is identical in sequence to, nucleotides present at a known location in the genome. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html, NCBI:th]"
          },
          "SO:1000036": {
            "name": "inversion",
            "def": "A continuous nucleotide sequence is inverted in the same position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000037": {
            "name": "chromosomal_duplication",
            "def": "An extra chromosome. [SO:ke]"
          },
          "SO:1000038": {
            "name": "intrachromosomal_duplication",
            "def": "A duplication that occurred within a chromosome. [SO:ke]"
          },
          "SO:1000039": {
            "name": "direct_tandem_duplication",
            "def": "A tandem duplication where the individual regions are in the same orientation. [SO:ke]"
          },
          "SO:1000040": {
            "name": "inverted_tandem_duplication",
            "def": "A tandem duplication where the individual regions are not in the same orientation. [SO:ke]"
          },
          "SO:1000041": {
            "name": "intrachromosomal_transposition",
            "def": "A chromosome structure variation whereby a transposition occurred within a chromosome. [SO:ke]"
          },
          "SO:1000042": {
            "name": "compound_chromosome",
            "def": "A chromosome structure variant where a monocentric element is caused by the fusion of two chromosome arms. [SO:ke]"
          },
          "SO:1000043": {
            "name": "Robertsonian_fusion",
            "def": "A non reciprocal translocation whereby the participating chromosomes break at their centromeres and the long arms fuse to form a single chromosome with a single centromere. [http://en.wikipedia.org/wiki/Robertsonian_translocation]"
          },
          "SO:1000044": {
            "name": "chromosomal_translocation",
            "def": "An interchromosomal mutation. Rearrangements that alter the pairing of telomeres are classified as translocations. [FB:reference_manual]"
          },
          "SO:1000045": {
            "name": "ring_chromosome",
            "def": "A ring chromosome is a chromosome whose arms have fused together to form a ring, often with the loss of the ends of the chromosome. [http://en.wikipedia.org/wiki/Ring_chromosome]"
          },
          "SO:1000046": {
            "name": "pericentric_inversion",
            "def": "A chromosomal inversion that includes the centromere. [FB:reference_manual]"
          },
          "SO:1000047": {
            "name": "paracentric_inversion",
            "def": "A chromosomal inversion that does not include the centromere. [FB:reference_manual]"
          },
          "SO:1000048": {
            "name": "reciprocal_chromosomal_translocation",
            "def": "A chromosomal translocation with two breaks; two chromosome segments have simply been exchanged. [FB:reference_manual]"
          },
          "SO:1000049": {
            "name": "sequence_variation_affecting_transcript",
            "def": "Any change in mature, spliced and processed, RNA that results from a change in the corresponding DNA sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000050": {
            "name": "sequence_variant_causing_no_change_in_transcript",
            "def": "No effect on the state of the RNA. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000054": {
            "name": "sequence_variation_affecting_coding_sequence",
            "def": "Any of the amino acid coding triplets of a gene are affected by the DNA mutation. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000055": {
            "name": "sequence_variant_causing_initiator_codon_change_in_transcript",
            "def": "The DNA mutation changes, usually destroys, the first coding triplet of a gene. Usually prevents translation although another initiator codon may be used. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000056": {
            "name": "sequence_variant_causing_amino_acid_coding_codon_change_in_transcript",
            "def": "The DNA mutation affects the amino acid coding sequence of a gene; this region includes both the initiator and terminator codons. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000057": {
            "name": "sequence_variant_causing_synonymous_codon_change_in_transcript",
            "def": "The changed codon has the same translation product as the original codon. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000058": {
            "name": "sequence_variant_causing_non_synonymous_codon_change_in_transcript",
            "def": "A DNA point mutation that causes a substitution of an amino acid by an other. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000059": {
            "name": "sequence_variant_causing_missense_codon_change_in_transcript",
            "def": "The nucleotide change in the codon leads to a new codon coding for a new amino acid. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000060": {
            "name": "sequence_variant_causing_conservative_missense_codon_change_in_transcript",
            "def": "The amino acid change following from the codon change does not change the gross properties (size, charge, hydrophobicity) of the amino acid at that position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000061": {
            "name": "sequence_variant_causing_nonconservative_missense_codon_change_in_transcript",
            "def": "The amino acid change following from the codon change changes the gross properties (size, charge, hydrophobicity) of the amino acid in that position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000062": {
            "name": "sequence_variant_causing_nonsense_codon_change_in_transcript",
            "def": "The nucleotide change in the codon triplet creates a terminator codon. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000063": {
            "name": "sequence_variant_causing_terminator_codon_change_in_transcript",
            "def": "The nucleotide change in the codon triplet changes the stop codon, causing an elongated transcript sequence. [SO:ke]"
          },
          "SO:1000064": {
            "name": "sequence_variation_affecting_reading_frame",
            "def": "An umbrella term for terms describing an effect of a sequence variation on the frame of translation. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000065": {
            "name": "frameshift_sequence_variation",
            "def": "A mutation causing a disruption of the translational reading frame, because the number of nucleotides inserted or deleted is not a multiple of three. [SO:ke]"
          },
          "SO:1000066": {
            "name": "sequence_variant_causing_plus_1_frameshift_mutation",
            "def": "A mutation causing a disruption of the translational reading frame, due to the insertion of a nucleotide. [SO:ke]"
          },
          "SO:1000067": {
            "name": "sequence_variant_causing_minus_1_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the deletion of a nucleotide. [SO:ke]"
          },
          "SO:1000068": {
            "name": "sequence_variant_causing_plus_2_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the insertion of two nucleotides. [SO:ke]"
          },
          "SO:1000069": {
            "name": "sequence_variant_causing_minus_2_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the deletion of two nucleotides. [SO:ke]"
          },
          "SO:1000070": {
            "name": "sequence_variant_affecting_transcript_processing",
            "def": "Sequence variant affects the way in which the primary transcriptional product is processed to form the mature transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000071": {
            "name": "sequence_variant_affecting_splicing",
            "def": "A sequence_variant_effect where the way in which the primary transcriptional product is processed to form the mature transcript, specifically by the removal (splicing) of intron sequences is changed. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000072": {
            "name": "sequence_variant_affecting_splice_donor",
            "def": "A sequence_variant_effect that changes the splice donor sequence. [SO:ke]"
          },
          "SO:1000073": {
            "name": "sequence_variant_affecting_splice_acceptor",
            "def": "A sequence_variant_effect that changes the splice acceptor sequence. [SO:ke]"
          },
          "SO:1000074": {
            "name": "sequence_variant_causing_cryptic_splice_activation",
            "def": "A sequence variant causing a new (functional) splice site. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000075": {
            "name": "sequence_variant_affecting_editing",
            "def": "Sequence variant affects the editing of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000076": {
            "name": "sequence_variant_affecting_transcription",
            "def": "Mutation affects the process of transcription, its initiation, progression or termination. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000078": {
            "name": "sequence_variant_decreasing_rate_of_transcription",
            "def": "A sequence variation that decreases the rate a which transcription of the sequence occurs. [SO:ke]"
          },
          "SO:1000079": {
            "name": "sequence_variation_affecting_transcript_sequence"
          },
          "SO:1000080": {
            "name": "sequence_variant_increasing_rate_of_transcription"
          },
          "SO:1000081": {
            "name": "sequence_variant_affecting_rate_of_transcription",
            "def": "A mutation that alters the rate a which transcription of the sequence occurs. [SO:ke]"
          },
          "SO:1000082": {
            "name": "sequence variant_affecting_transcript_stability",
            "def": "Sequence variant affects the stability of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000083": {
            "name": "sequence_variant_increasing_transcript_stability",
            "def": "Sequence variant increases the stability (half-life) of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000084": {
            "name": "sequence_variant_decreasing_transcript_stability",
            "def": "Sequence variant decreases the stability (half-life) of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000085": {
            "name": "sequence_variation_affecting_level_of_transcript",
            "def": "A sequence variation that causes a change in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
          },
          "SO:1000086": {
            "name": "sequence_variation_decreasing_level_of_transcript",
            "def": "A sequence variation that causes a decrease in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
          },
          "SO:1000087": {
            "name": "sequence_variation_increasing_level_of_transcript",
            "def": "A sequence_variation that causes an increase in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
          },
          "SO:1000088": {
            "name": "sequence_variant_affecting_translational_product",
            "def": "A sequence variant causing a change in primary translation product of a transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000089": {
            "name": "sequence_variant_causing_no_change_of_translational_product",
            "def": "The sequence variant at RNA level does not lead to any change in polypeptide. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000092": {
            "name": "sequence_variant_causing_complex_change_of_translational_product",
            "def": "Any sequence variant effect that is known at nucleotide level but cannot be explained by using other key terms. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000093": {
            "name": "sequence_variant_causing_amino_acid_substitution",
            "def": "The replacement of a single amino acid by another. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000094": {
            "name": "sequence_variant_causing_conservative_amino_acid_substitution"
          },
          "SO:1000095": {
            "name": "sequence_variant_causing_nonconservative_amino_acid_substitution"
          },
          "SO:1000096": {
            "name": "sequence_variant_causing_amino_acid_insertion",
            "def": "The insertion of one or more amino acids from the polypeptide, without affecting the surrounding sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000097": {
            "name": "sequence_variant_causing_amino_acid_deletion",
            "def": "The deletion of one or more amino acids from the polypeptide, without affecting the surrounding sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000098": {
            "name": "sequence_variant_causing_polypeptide_truncation",
            "def": "The translational product is truncated at its C-terminus, usually a result of a nonsense codon change in transcript (SO:1000062). [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000099": {
            "name": "sequence_variant_causing_polypeptide_elongation",
            "def": "The extension of the translational product at either (or both) the N-terminus and/or the C-terminus. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000100": {
            "name": "mutation_causing_polypeptide_N_terminal_elongation",
            "def": ". [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000101": {
            "name": "mutation_causing_polypeptide_C_terminal_elongation",
            "def": ". [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000102": {
            "name": "sequence_variant_affecting_level_of_translational_product"
          },
          "SO:1000103": {
            "name": "sequence_variant_decreasing_level_of_translation_product"
          },
          "SO:1000104": {
            "name": "sequence_variant_increasing_level_of_translation_product"
          },
          "SO:1000105": {
            "name": "sequence_variant_affecting_polypeptide_amino_acid_sequence"
          },
          "SO:1000106": {
            "name": "mutation_causing_inframe_polypeptide_N_terminal_elongation"
          },
          "SO:1000107": {
            "name": "mutation_causing_out_of_frame_polypeptide_N_terminal_elongation"
          },
          "SO:1000108": {
            "name": "mutaton_causing_inframe_polypeptide_C_terminal_elongation"
          },
          "SO:1000109": {
            "name": "mutation_causing_out_of_frame_polypeptide_C_terminal_elongation"
          },
          "SO:1000110": {
            "name": "frame_restoring_sequence_variant",
            "def": "A mutation that reverts the sequence of a previous frameshift mutation back to the initial frame. [SO:ke]"
          },
          "SO:1000111": {
            "name": "sequence_variant_affecting_3D_structure_of_polypeptide",
            "def": "A mutation that changes the amino acid sequence of the peptide in such a way that it changes the 3D structure of the molecule. [SO:ke]"
          },
          "SO:1000112": {
            "name": "sequence_variant_causing_no_3D_structural_change"
          },
          "SO:1000115": {
            "name": "sequence_variant_causing_complex_3D_structural_change"
          },
          "SO:1000116": {
            "name": "sequence_variant_causing_conformational_change"
          },
          "SO:1000117": {
            "name": "sequence_variant_affecting_polypeptide_function"
          },
          "SO:1000118": {
            "name": "sequence_variant_causing_loss_of_function_of_polypeptide"
          },
          "SO:1000119": {
            "name": "sequence_variant_causing_inactive_ligand_binding_site"
          },
          "SO:1000120": {
            "name": "sequence_variant_causing_inactive_catalytic_site"
          },
          "SO:1000121": {
            "name": "sequence_variant_causing_polypeptide_localization_change"
          },
          "SO:1000122": {
            "name": "sequence_variant_causing_polypeptide_post_translational_processing_change"
          },
          "SO:1000123": {
            "name": "polypeptide_post_translational_processing_affected"
          },
          "SO:1000124": {
            "name": "sequence_variant_causing_partial_loss_of_function_of_polypeptide"
          },
          "SO:1000125": {
            "name": "sequence_variant_causing_gain_of_function_of_polypeptide"
          },
          "SO:1000126": {
            "name": "sequence_variant_affecting_transcript_secondary_structure",
            "def": "A sequence variant that affects the secondary structure (folding) of the RNA transcript molecule. [SO:ke]"
          },
          "SO:1000127": {
            "name": "sequence_variant_causing_compensatory_transcript_secondary_structure_mutation"
          },
          "SO:1000132": {
            "name": "sequence_variant_effect",
            "def": "The effect of a change in nucleotide sequence. [SO:ke]"
          },
          "SO:1000134": {
            "name": "sequence_variant_causing_polypeptide_fusion"
          },
          "SO:1000136": {
            "name": "autosynaptic_chromosome",
            "def": "An autosynaptic chromosome is the aneuploid product of recombination between a pericentric inversion and a cytologically wild-type chromosome. [PMID:6804304]"
          },
          "SO:1000138": {
            "name": "homo_compound_chromosome",
            "def": "A compound chromosome whereby two copies of the same chromosomal arm attached to a common centromere. The chromosome is diploid for the arm involved. [SO:ke]"
          },
          "SO:1000140": {
            "name": "hetero_compound_chromosome",
            "def": "A compound chromosome whereby two arms from different chromosomes are connected through the centromere of one of them. [FB:reference_manual, SO:ke]"
          },
          "SO:1000141": {
            "name": "chromosome_fission",
            "def": "A chromosome that occurred by the division of a larger chromosome. [SO:ke]"
          },
          "SO:1000142": {
            "name": "dexstrosynaptic_chromosome",
            "def": "An autosynaptic chromosome carrying the two right (D = dextro) telomeres. [FB:manual]"
          },
          "SO:1000143": {
            "name": "laevosynaptic_chromosome",
            "def": "LS is an autosynaptic chromosome carrying the two left (L = levo) telomeres. [FB:manual]"
          },
          "SO:1000144": {
            "name": "free_duplication",
            "def": "A chromosome structure variation whereby the duplicated sequences are carried as a free centric element. [FB:reference_manual]"
          },
          "SO:1000145": {
            "name": "free_ring_duplication",
            "def": "A ring chromosome which is a copy of another chromosome. [SO:ke]"
          },
          "SO:1000147": {
            "name": "deficient_translocation",
            "def": "A chromosomal deletion whereby a translocation occurs in which one of the four broken ends loses a segment before re-joining. [FB:reference_manual]"
          },
          "SO:1000148": {
            "name": "inversion_cum_translocation",
            "def": "A chromosomal translocation whereby the first two breaks are in the same chromosome, and the region between them is rejoined in inverted order to the other side of the first break, such that both sides of break one are present on the same chromosome. The remaining free ends are joined as a translocation with those resulting from the third break. [FB:reference_manual]"
          },
          "SO:1000149": {
            "name": "bipartite_duplication",
            "def": "An interchromosomal mutation whereby the (large) region between the first two breaks listed is lost, and the two flanking segments (one of them centric) are joined as a translocation to the free ends resulting from the third break. [FB:reference_manual]"
          },
          "SO:1000150": {
            "name": "cyclic_translocation",
            "def": "A chromosomal translocation whereby three breaks occurred in three different chromosomes. The centric segment resulting from the first break listed is joined to the acentric segment resulting from the second, rather than the third. [FB:reference_manual]"
          },
          "SO:1000151": {
            "name": "bipartite_inversion",
            "def": "A chromosomal inversion caused by three breaks in the same chromosome; both central segments are inverted in place (i.e., they are not transposed). [FB:reference_manual]"
          },
          "SO:1000152": {
            "name": "uninverted_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
          },
          "SO:1000153": {
            "name": "inverted_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segments. [FB:reference_manual]"
          },
          "SO:1000154": {
            "name": "insertional_duplication",
            "def": "A chromosome duplication involving the insertion of a duplicated region (as opposed to a free duplication). [SO:ke]"
          },
          "SO:1000155": {
            "name": "interchromosomal_transposition",
            "def": "A chromosome structure variation whereby a transposition occurred between chromosomes. [SO:ke]"
          },
          "SO:1000156": {
            "name": "inverted_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segment. [FB:reference_manual]"
          },
          "SO:1000157": {
            "name": "uninverted_interchromosomal_transposition",
            "def": "An interchromosomal transition where the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
          },
          "SO:1000158": {
            "name": "inverted_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segments. [FB:reference_manual]"
          },
          "SO:1000159": {
            "name": "uninverted_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
          },
          "SO:1000160": {
            "name": "unoriented_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
          },
          "SO:1000161": {
            "name": "unoriented_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a copy of the segment between the first two breaks listed is inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
          },
          "SO:1000162": {
            "name": "unoriented_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
          },
          "SO:1000170": {
            "name": "uncharacterized_chromosomal_mutation"
          },
          "SO:1000171": {
            "name": "deficient_inversion",
            "def": "A chromosomal deletion whereby three breaks occur in the same chromosome; one central region is lost, and the other is inverted. [FB:reference_manual, SO:ke]"
          },
          "SO:1000173": {
            "name": "tandem_duplication",
            "def": "A duplication consisting of 2 identical adjacent regions. [SO:ke]"
          },
          "SO:1000175": {
            "name": "partially_characterized_chromosomal_mutation"
          },
          "SO:1000180": {
            "name": "sequence_variant_affecting_gene_structure",
            "def": "A sequence_variant_effect that changes the gene structure. [SO:ke]"
          },
          "SO:1000181": {
            "name": "sequence_variant_causing_gene_fusion",
            "def": "A sequence_variant_effect that changes the gene structure by causing a fusion to another gene. [SO:ke]"
          },
          "SO:1000182": {
            "name": "chromosome_number_variation",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number. [SO:ke]"
          },
          "SO:1000183": {
            "name": "chromosome_structure_variation"
          },
          "SO:1000184": {
            "name": "sequence_variant_causes_exon_loss",
            "def": "A sequence variant affecting splicing and causes an exon loss. [SO:ke]"
          },
          "SO:1000185": {
            "name": "sequence_variant_causes_intron_gain",
            "def": "A sequence variant effect, causing an intron to be gained by the processed transcript; usually a result of a donor acceptor mutation (SO:1000072). [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000186": {
            "name": "sequence_variant_causing_cryptic_splice_donor_activation"
          },
          "SO:1001186": {
            "name": "sequence_variant_causing_cryptic_splice_acceptor_activation"
          },
          "SO:1001187": {
            "name": "alternatively_spliced_transcript",
            "def": "A transcript that is alternatively spliced. [SO:xp]"
          },
          "SO:1001188": {
            "name": "encodes_1_polypeptide",
            "def": "A gene that is alternately spliced, but encodes only one polypeptide. [SO:ke]"
          },
          "SO:1001189": {
            "name": "encodes_greater_than_1_polypeptide",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide. [SO:ke]"
          },
          "SO:1001190": {
            "name": "encodes_different_polypeptides_different_stop",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different stop codons. [SO:ke]"
          },
          "SO:1001191": {
            "name": "encodes_overlapping_peptides_different_start",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different start codons. [SO:ke]"
          },
          "SO:1001192": {
            "name": "encodes_disjoint_polypeptides",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that do not have overlapping peptide sequences. [SO:ke]"
          },
          "SO:1001193": {
            "name": "encodes_overlapping_polypeptides_different_start_and_stop",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different start and stop codons. [SO:ke]"
          },
          "SO:1001194": {
            "name": "alternatively_spliced_gene_encoding_greater_than_1_polypeptide_coding_regions_overlapping"
          },
          "SO:1001195": {
            "name": "encodes_overlapping_peptides",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences. [SO:ke]"
          },
          "SO:1001196": {
            "name": "cryptogene",
            "def": "A maxicircle gene so extensively edited that it cannot be matched to its edited mRNA sequence. [SO:ma]"
          },
          "SO:1001197": {
            "name": "dicistronic_primary_transcript",
            "def": "A primary transcript that has the quality dicistronic. [SO:xp]"
          },
          "SO:1001217": {
            "name": "member_of_regulon"
          },
          "SO:1001244": {
            "name": "alternatively_spliced_transcript_encoding_greater_than_1_polypeptide_different_start_codon_different_stop_codon_coding_regions_non_overlapping"
          },
          "SO:1001246": {
            "name": "CDS_independently_known",
            "def": "A CDS with the evidence status of being independently known. [SO:xp]"
          },
          "SO:1001247": {
            "name": "orphan_CDS",
            "def": "A CDS whose predicted amino acid sequence is unsupported by any experimental evidence or by any match with any other known sequence. [SO:ma]"
          },
          "SO:1001249": {
            "name": "CDS_supported_by_domain_match_data",
            "def": "A CDS that is supported by domain similarity. [SO:xp]"
          },
          "SO:1001251": {
            "name": "CDS_supported_by_sequence_similarity_data",
            "def": "A CDS that is supported by sequence similarity data. [SO:xp]"
          },
          "SO:1001254": {
            "name": "CDS_predicted",
            "def": "A CDS that is predicted. [SO:ke]"
          },
          "SO:1001255": {
            "name": "status_of_coding_sequence"
          },
          "SO:1001259": {
            "name": "CDS_supported_by_EST_or_cDNA_data",
            "def": "A CDS that is supported by similarity to EST or cDNA data. [SO:xp]"
          },
          "SO:1001260": {
            "name": "internal_Shine_Dalgarno_sequence",
            "def": "A Shine-Dalgarno sequence that stimulates recoding through interactions with the anti-Shine-Dalgarno in the RNA of small ribosomal subunits of translating ribosomes. The signal is only operative in Bacteria. [PMID:12519954, SO:ke]"
          },
          "SO:1001261": {
            "name": "recoded_mRNA",
            "def": "The sequence of a mature mRNA transcript, modified before translation or during translation, usually by special cis-acting signals. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8811194&dopt=Abstract]"
          },
          "SO:1001262": {
            "name": "minus_1_translationally_frameshifted",
            "def": "An attribute describing a translational frameshift of -1. [SO:ke]"
          },
          "SO:1001263": {
            "name": "plus_1_translationally_frameshifted",
            "def": "An attribute describing a translational frameshift of +1. [SO:ke]"
          },
          "SO:1001264": {
            "name": "mRNA_recoded_by_translational_bypass",
            "def": "A recoded_mRNA where translation was suspended at a particular codon and resumed at a particular non-overlapping downstream codon. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8811194&dopt=Abstract]"
          },
          "SO:1001265": {
            "name": "mRNA_recoded_by_codon_redefinition",
            "def": "A recoded_mRNA that was modified by an alteration of codon meaning. [SO:ma]"
          },
          "SO:1001266": {
            "name": "stop_codon_redefinition_as_selenocysteine"
          },
          "SO:1001267": {
            "name": "stop_codon_readthrough"
          },
          "SO:1001268": {
            "name": "recoding_stimulatory_region",
            "def": "A site in an mRNA sequence that stimulates the recoding of a region in the same mRNA. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=12519954&dopt=Abstract]"
          },
          "SO:1001269": {
            "name": "four_bp_start_codon",
            "def": "A non-canonical start codon with 4 base pairs. [SO:ke]"
          },
          "SO:1001270": {
            "name": "stop_codon_redefinition_as_pyrrolysine"
          },
          "SO:1001271": {
            "name": "archaeal_intron",
            "def": "An intron characteristic of Archaeal tRNA and rRNA genes, where intron transcript generates a bulge-helix-bulge motif that is recognised by a splicing endoribonuclease. [PMID:9301331, SO:ma]"
          },
          "SO:1001272": {
            "name": "tRNA_intron",
            "def": "An intron found in tRNA that is spliced via endonucleolytic cleavage and ligation rather than transesterification. [SO:ke]"
          },
          "SO:1001273": {
            "name": "CTG_start_codon",
            "def": "A non-canonical start codon of sequence CTG. [SO:ke]"
          },
          "SO:1001274": {
            "name": "SECIS_element",
            "def": "The incorporation of selenocysteine into a protein sequence is directed by an in-frame UGA codon (usually a stop codon) within the coding region of the mRNA. Selenoprotein mRNAs contain a conserved secondary structure in the 3' UTR that is required for the distinction of UGA stop from UGA selenocysteine. The selenocysteine insertion sequence (SECIS) is around 60 nt in length and adopts a hairpin structure which is sufficiently well-defined and conserved to act as a computational screen for selenoprotein genes. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00031]"
          },
          "SO:1001275": {
            "name": "retron",
            "def": "Sequence coding for a short, single-stranded, DNA sequence via a retrotransposed RNA intermediate; characteristic of some microbial genomes. [SO:ma]"
          },
          "SO:1001277": {
            "name": "three_prime_recoding_site",
            "def": "The recoding stimulatory signal located downstream of the recoding site. [SO:ke]"
          },
          "SO:1001279": {
            "name": "three_prime_stem_loop_structure",
            "def": "A recoding stimulatory region, the stem-loop secondary structural element is downstream of the redefined region. [PMID:12519954, SO:ke]"
          },
          "SO:1001280": {
            "name": "five_prime_recoding_site",
            "def": "The recoding stimulatory signal located upstream of the recoding site. [SO:ke]"
          },
          "SO:1001281": {
            "name": "flanking_three_prime_quadruplet_recoding_signal",
            "def": "Four base pair sequence immediately downstream of the redefined region. The redefined region is a frameshift site. The quadruplet is 2 overlapping codons. [PMID:12519954, SO:ke]"
          },
          "SO:1001282": {
            "name": "UAG_stop_codon_signal",
            "def": "A stop codon signal for a UAG stop codon redefinition. [SO:ke]"
          },
          "SO:1001283": {
            "name": "UAA_stop_codon_signal",
            "def": "A stop codon signal for a UAA stop codon redefinition. [SO:ke]"
          },
          "SO:1001284": {
            "name": "regulon",
            "def": "A group of genes, whether linked as a cluster or not, that respond to a common regulatory signal. [ISBN:0198506732]"
          },
          "SO:1001285": {
            "name": "UGA_stop_codon_signal",
            "def": "A stop codon signal for a UGA stop codon redefinition. [SO:ke]"
          },
          "SO:1001286": {
            "name": "three_prime_repeat_recoding_signal",
            "def": "A recoding stimulatory signal, downstream sequence important for recoding that contains repetitive elements. [PMID:12519954, SO:ke]"
          },
          "SO:1001287": {
            "name": "distant_three_prime_recoding_signal",
            "def": "A recoding signal that is found many hundreds of nucleotides 3' of a redefined stop codon. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8709208&dopt=Abstract]"
          },
          "SO:1001288": {
            "name": "stop_codon_signal",
            "def": "A recoding stimulatory signal that is a stop codon and has effect on efficiency of recoding. [PMID:12519954, SO:ke]"
          },
          "SO:2000061": {
            "name": "databank_entry",
            "def": "The sequence referred to by an entry in a databank such as GenBank or SwissProt. [SO:ke]"
          },
          "SO:3000000": {
            "name": "gene_segment",
            "def": "A gene component region which acts as a recombinational unit of a gene whose functional form is generated through somatic recombination. [GOC:add]"
          }
        };
      })(sequenceOntology = exports.sequenceOntology || (exports.sequenceOntology = {}));
    }
  });

  // node_modules/rdfoo-prov/node_modules/bioterms/dist/index.js
  var require_dist3 = __commonJS({
    "node_modules/rdfoo-prov/node_modules/bioterms/dist/index.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.uriToName = exports.sequenceOntology = exports.Specifiers = exports.Predicates = exports.Types = exports.prefixify = exports.Prefixes = void 0;
      var Prefixes_1 = require_Prefixes2();
      Object.defineProperty(exports, "Prefixes", { enumerable: true, get: function() {
        return Prefixes_1.Prefixes;
      } });
      Object.defineProperty(exports, "prefixify", { enumerable: true, get: function() {
        return Prefixes_1.prefixify;
      } });
      var Types_1 = require_Types2();
      Object.defineProperty(exports, "Types", { enumerable: true, get: function() {
        return Types_1.Types;
      } });
      var Predicates_1 = require_Predicates2();
      Object.defineProperty(exports, "Predicates", { enumerable: true, get: function() {
        return Predicates_1.Predicates;
      } });
      var Specifiers_1 = require_Specifiers2();
      Object.defineProperty(exports, "Specifiers", { enumerable: true, get: function() {
        return Specifiers_1.Specifiers;
      } });
      var sequenceOntology_1 = require_sequenceOntology2();
      Object.defineProperty(exports, "sequenceOntology", { enumerable: true, get: function() {
        return sequenceOntology_1.sequenceOntology;
      } });
      Object.defineProperty(exports, "uriToName", { enumerable: true, get: function() {
        return sequenceOntology_1.uriToName;
      } });
    }
  });

  // node_modules/rdfoo-prov/dist/prov/ProvFacade.js
  var require_ProvFacade = __commonJS({
    "node_modules/rdfoo-prov/dist/prov/ProvFacade.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var rdfoo_1 = require_dist();
      var ProvFacade = class extends rdfoo_1.Facade {
        constructor(view, subject) {
          super(view.graph, subject);
          this.view = view;
        }
      };
      exports.default = ProvFacade;
    }
  });

  // node_modules/rdfoo-prov/dist/prov/Agent.js
  var require_Agent = __commonJS({
    "node_modules/rdfoo-prov/dist/prov/Agent.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist3();
      var ProvFacade_1 = require_ProvFacade();
      var Agent = class extends ProvFacade_1.default {
        constructor(view, uri) {
          super(view, uri);
        }
        get facadeType() {
          return bioterms_1.Types.Prov.Agent;
        }
      };
      exports.default = Agent;
    }
  });

  // node_modules/rdfoo-prov/dist/prov/Plan.js
  var require_Plan = __commonJS({
    "node_modules/rdfoo-prov/dist/prov/Plan.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist3();
      var ProvFacade_1 = require_ProvFacade();
      var Plan = class extends ProvFacade_1.default {
        constructor(view, uri) {
          super(view, uri);
        }
        get facadeType() {
          return bioterms_1.Types.Prov.Plan;
        }
      };
      exports.default = Plan;
    }
  });

  // node_modules/rdfoo-prov/dist/prov/Association.js
  var require_Association = __commonJS({
    "node_modules/rdfoo-prov/dist/prov/Association.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var Agent_1 = require_Agent();
      var Plan_1 = require_Plan();
      var bioterms_1 = require_dist3();
      var ProvFacade_1 = require_ProvFacade();
      var Association = class extends ProvFacade_1.default {
        constructor(view, uri) {
          super(view, uri);
        }
        get facadeType() {
          return bioterms_1.Types.Prov.Association;
        }
        get agent() {
          let agent = this.getProperty(bioterms_1.Predicates.Prov.agent);
          if (!agent) {
            return void 0;
          }
          return new Agent_1.default(this.view, agent);
        }
        set agent(agent) {
          if (agent === void 0) {
            this.deleteProperty(bioterms_1.Predicates.Prov.agent);
          } else {
            this.setProperty(bioterms_1.Predicates.Prov.agent, agent.subject);
          }
        }
        get plan() {
          let plan = this.getProperty(bioterms_1.Predicates.Prov.hadPlan);
          if (!plan) {
            return void 0;
          }
          return new Plan_1.default(this.view, plan);
        }
        set plan(plan) {
          if (plan === void 0) {
            this.deleteProperty(bioterms_1.Predicates.Prov.hadPlan);
          } else {
            this.setProperty(bioterms_1.Predicates.Prov.hadPlan, plan.subject);
          }
        }
        get role() {
          return this.getUriProperty(bioterms_1.Predicates.Prov.hadRole);
        }
        set role(role) {
          this.setUriProperty(bioterms_1.Predicates.Prov.hadRole, role);
        }
      };
      exports.default = Association;
    }
  });

  // node_modules/rdfoo-prov/dist/prov/Usage.js
  var require_Usage = __commonJS({
    "node_modules/rdfoo-prov/dist/prov/Usage.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist3();
      var ProvFacade_1 = require_ProvFacade();
      var Usage = class extends ProvFacade_1.default {
        constructor(view, uri) {
          super(view, uri);
        }
        get facadeType() {
          return bioterms_1.Types.Prov.Usage;
        }
        get entity() {
          let entity = this.getProperty(bioterms_1.Predicates.Prov.entity);
          if (entity === void 0)
            return void 0;
          return this.view.subjectToFacade(entity);
        }
        set entity(entity) {
          if (entity === void 0) {
            this.deleteProperty(bioterms_1.Predicates.Prov.entity);
          } else {
            this.setProperty(bioterms_1.Predicates.Prov.entity, entity.subject);
          }
        }
        get role() {
          return this.getUriProperty(bioterms_1.Predicates.Prov.hadRole);
        }
        set role(role) {
          this.setUriProperty(bioterms_1.Predicates.Prov.hadRole, role);
        }
      };
      exports.default = Usage;
    }
  });

  // node_modules/rdfoo-prov/dist/prov/Activity.js
  var require_Activity = __commonJS({
    "node_modules/rdfoo-prov/dist/prov/Activity.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var Association_1 = require_Association();
      var bioterms_1 = require_dist3();
      var Plan_1 = require_Plan();
      var Usage_1 = require_Usage();
      var ProvFacade_1 = require_ProvFacade();
      var Activity = class extends ProvFacade_1.default {
        constructor(view, uri) {
          super(view, uri);
        }
        get facadeType() {
          return bioterms_1.Types.Prov.Activity;
        }
        get associations() {
          return this.getProperties(bioterms_1.Predicates.Prov.qualifiedAssociation).map((uri) => new Association_1.default(this.view, uri));
        }
        get plan() {
          let plan = this.getProperty(bioterms_1.Predicates.Prov.hadPlan);
          if (!plan) {
            return void 0;
          }
          return new Plan_1.default(this.view, plan);
        }
        set plan(plan) {
          if (plan === void 0) {
            this.deleteProperty(bioterms_1.Predicates.Prov.hadPlan);
          } else {
            this.setProperty(bioterms_1.Predicates.Prov.hadPlan, plan.subject);
          }
        }
        get usage() {
          let usage = this.getProperty(bioterms_1.Predicates.Prov.qualifiedUsage);
          if (!usage) {
            return void 0;
          }
          return new Usage_1.default(this.view, usage);
        }
        set usage(usage) {
          if (usage === void 0) {
            this.deleteProperty(bioterms_1.Predicates.Prov.qualifiedUsage);
          } else {
            this.setProperty(bioterms_1.Predicates.Prov.qualifiedUsage, usage.subject);
          }
        }
        get association() {
          let association = this.getProperty(bioterms_1.Predicates.Prov.qualifiedAssociation);
          if (!association) {
            return void 0;
          }
          return new Association_1.default(this.view, association);
        }
        set association(association) {
          if (association === void 0) {
            this.deleteProperty(bioterms_1.Predicates.Prov.qualifiedAssociation);
          } else {
            this.setProperty(bioterms_1.Predicates.Prov.qualifiedAssociation, association.subject);
          }
        }
      };
      exports.default = Activity;
    }
  });

  // node_modules/rdfoo-prov/dist/prov/ProvView.js
  var require_ProvView = __commonJS({
    "node_modules/rdfoo-prov/dist/prov/ProvView.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist3();
      var Activity_1 = require_Activity();
      var Usage_1 = require_Usage();
      var Agent_1 = require_Agent();
      var Plan_1 = require_Plan();
      var Association_1 = require_Association();
      var ProvView2 = class extends rdfoo_1.GraphViewBasic {
        subjectToFacade(subject) {
          let types = this.getTypes(subject);
          for (let type of types) {
            if (type === bioterms_1.Types.Prov.Activity) {
              return new Activity_1.default(this, subject);
            }
            if (type === bioterms_1.Types.Prov.Agent) {
              return new Agent_1.default(this, subject);
            }
            if (type === bioterms_1.Types.Prov.Association) {
              return new Association_1.default(this, subject);
            }
            if (type === bioterms_1.Types.Prov.Plan) {
              return new Plan_1.default(this, subject);
            }
            if (type === bioterms_1.Types.Prov.Usage) {
              return new Usage_1.default(this, subject);
            }
          }
        }
        get activities() {
          return this.instancesOfType(bioterms_1.Types.Prov.Activity).map((uri) => new Activity_1.default(this, uri));
        }
        get agents() {
          return this.instancesOfType(bioterms_1.Types.Prov.Agent).map((uri) => new Agent_1.default(this, uri));
        }
        get associations() {
          return this.instancesOfType(bioterms_1.Types.Prov.Association).map((uri) => new Association_1.default(this, uri));
        }
        get plans() {
          return this.instancesOfType(bioterms_1.Types.Prov.Plan).map((uri) => new Plan_1.default(this, uri));
        }
        get usages() {
          return this.instancesOfType(bioterms_1.Types.Prov.Usage).map((uri) => new Usage_1.default(this, uri));
        }
      };
      exports.default = ProvView2;
    }
  });

  // node_modules/rdfoo-prov/dist/index.js
  var require_dist4 = __commonJS({
    "node_modules/rdfoo-prov/dist/index.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Usage = exports.ProvView = exports.Plan = exports.Association = exports.Agent = exports.Activity = void 0;
      var Activity_1 = require_Activity();
      exports.Activity = Activity_1.default;
      var Agent_1 = require_Agent();
      exports.Agent = Agent_1.default;
      var Association_1 = require_Association();
      exports.Association = Association_1.default;
      var Plan_1 = require_Plan();
      exports.Plan = Plan_1.default;
      var ProvView_1 = require_ProvView();
      exports.ProvView = ProvView_1.default;
      var Usage_1 = require_Usage();
      exports.Usage = Usage_1.default;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Implementation.js
  var require_S2Implementation = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Implementation.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var bioterms_1 = require_dist2();
      var __1 = require_dist5();
      var rdfoo_prov_1 = require_dist4();
      var S2Implementation = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.Implementation;
        }
        get built() {
          let built = this.getProperty(bioterms_1.Predicates.SBOL2.built);
          if (!built) {
            return void 0;
          }
          let builtObj = this.view.subjectToFacade(built);
          if (builtObj instanceof __1.S2ComponentDefinition)
            return builtObj;
          if (builtObj instanceof __1.S2ModuleDefinition)
            return builtObj;
          throw new Error("built has wrong type");
        }
        set built(built) {
          if (built === void 0) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.built);
          } else {
            this.setProperty(bioterms_1.Predicates.SBOL2.built, built.subject);
          }
        }
        get activity() {
          let activity = this.getProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
          if (!activity) {
            return void 0;
          }
          return new rdfoo_prov_1.Activity(new rdfoo_prov_1.ProvView(this.graph), activity);
        }
        set activity(activity) {
          if (activity === void 0) {
            this.deleteProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
          } else {
            this.setProperty(bioterms_1.Predicates.Prov.wasGeneratedBy, activity.subject);
          }
        }
        get design() {
          let design_subject = this.getProperty(bioterms_1.Predicates.Prov.wasDerivedFrom);
          if (!design_subject) {
            return void 0;
          }
          return new S2Identified_1.default(this.view, design_subject);
        }
        set design(design) {
          if (design === void 0) {
            this.deleteProperty(bioterms_1.Predicates.Prov.wasDerivedFrom);
          } else {
            this.setProperty(bioterms_1.Predicates.Prov.wasDerivedFrom, design.subject);
          }
        }
        get displayType() {
          return "Construct";
        }
      };
      exports.default = S2Implementation;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2ExperimentalData.js
  var require_S2ExperimentalData = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2ExperimentalData.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var bioterms_1 = require_dist2();
      var S2ExperimentalData = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.ExperimentalData;
        }
      };
      exports.default = S2ExperimentalData;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2Experiment.js
  var require_S2Experiment = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2Experiment.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var S2ExperimentalData_1 = require_S2ExperimentalData();
      var rdfoo_prov_1 = require_dist4();
      var bioterms_1 = require_dist2();
      var S2Implementation_1 = require_S2Implementation();
      var S2Experiment = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.Experiment;
        }
        get experimentalData() {
          let result = [];
          let expDataURIs = this.getProperties(bioterms_1.Predicates.SBOL2.experimentalData);
          for (let uri of expDataURIs) {
            result.push(new S2ExperimentalData_1.default(this.view, uri));
          }
          return result;
        }
        addExperimentalData(member) {
          this.insertProperty(bioterms_1.Predicates.SBOL2.experimentalData, member.subject);
        }
        get activity() {
          let activity = this.getProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
          if (!activity) {
            return void 0;
          }
          return new rdfoo_prov_1.Activity(new rdfoo_prov_1.ProvView(this.graph), activity);
        }
        set activity(activity) {
          if (activity === void 0) {
            this.deleteProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
          } else {
            this.setProperty(bioterms_1.Predicates.Prov.wasGeneratedBy, activity.subject);
          }
        }
        get construct() {
          let construct_uri = this.getProperty(bioterms_1.Predicates.Prov.wasDerivedFrom);
          if (!construct_uri) {
            return void 0;
          }
          return new S2Implementation_1.default(this.view, construct_uri);
        }
        addConstruct(construct) {
          this.insertProperty(bioterms_1.Predicates.Prov.wasDerivedFrom, construct.subject);
        }
        get displayType() {
          return "Experiment";
        }
      };
      exports.default = S2Experiment;
    }
  });

  // node_modules/sboljs/dist/conversion/fromSBOL1/toSBOL2.js
  var require_toSBOL2 = __commonJS({
    "node_modules/sboljs/dist/conversion/fromSBOL1/toSBOL2.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var rdfoo_1 = require_dist();
      var SBOL1GraphView_1 = require_SBOL1GraphView();
      var SBOL2GraphView_1 = require_SBOL2GraphView();
      var bioterms_1 = require_dist2();
      var S2SequenceConstraint_1 = require_S2SequenceConstraint();
      var S2Sequence_1 = require_S2Sequence();
      var S2ComponentDefinition_1 = require_S2ComponentDefinition();
      var S2ComponentInstance_1 = require_S2ComponentInstance();
      var S2SequenceAnnotation_1 = require_S2SequenceAnnotation();
      var S2Range_1 = require_S2Range();
      var S2GenericLocation_1 = require_S2GenericLocation();
      var S2Collection_1 = require_S2Collection();
      var URIUtils_1 = require_URIUtils();
      function convert1to2(graph2) {
        var _a;
        const map = /* @__PURE__ */ new Map();
        let graph1 = new SBOL1GraphView_1.default(graph2);
        let newGraph = new rdfoo_1.Graph();
        let graph22 = new SBOL2GraphView_1.default(newGraph);
        for (let sequence of graph1.dnaSequences) {
          let sequence2 = new S2Sequence_1.default(graph22, sequence.subject);
          sequence2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Sequence);
          copyNonSBOLProperties(sequence, sequence2);
          sequence2.encoding = bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
          sequence2.elements = sequence.nucleotides;
        }
        for (let dnaComponent of graph1.dnaComponents) {
          let component2 = new S2ComponentDefinition_1.default(graph22, dnaComponent.subject);
          component2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.ComponentDefinition);
          copyNonSBOLProperties(dnaComponent, component2);
          component2.addType(bioterms_1.Specifiers.SBOL2.Type.DNA);
          component2.name = dnaComponent.name;
          component2.description = dnaComponent.description;
          copyDisplayId(dnaComponent, component2);
          if (dnaComponent.dnaSequence) {
            component2.insertProperty(bioterms_1.Predicates.SBOL2.sequence, dnaComponent.dnaSequence.subject);
          }
          for (let type of dnaComponent.getUriProperties(bioterms_1.Predicates.a)) {
            if (type.indexOf(bioterms_1.Prefixes.sbol1) === 0) {
              continue;
            }
            component2.addRole(type);
          }
          let precedesN = 0;
          for (let anno of dnaComponent.annotations) {
            let anno2 = new S2SequenceAnnotation_1.default(graph22, anno.subject);
            anno2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.SequenceAnnotation);
            component2.insertProperty(bioterms_1.Predicates.SBOL2.sequenceAnnotation, anno2.subject);
            copyNonSBOLProperties(anno, anno2);
            let subComponent = anno.subComponent;
            if (subComponent || graph2.hasMatch(null, bioterms_1.Predicates.SBOL1.precedes, anno.subject) || graph2.hasMatch(anno.subject, bioterms_1.Predicates.SBOL1.precedes, null)) {
              let subComponent2 = new S2ComponentInstance_1.default(graph22, rdfoo_1.node.createUriNode(URIUtils_1.default.addSuffix(anno.subject.value, "/component")));
              subComponent2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Component);
              if (subComponent !== void 0) {
                subComponent2.setProperty(bioterms_1.Predicates.SBOL2.definition, subComponent.subject);
              } else {
                subComponent2.setUriProperty(bioterms_1.Predicates.SBOL2.definition, "http://sboltools.org/terms/stub");
              }
              anno2.insertProperty(bioterms_1.Predicates.SBOL2.component, subComponent2.subject);
              component2.insertProperty(bioterms_1.Predicates.SBOL2.component, subComponent2.subject);
            }
          }
          for (let anno of dnaComponent.annotations) {
            let anno2 = new S2SequenceAnnotation_1.default(graph22, anno.subject);
            anno2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.SequenceAnnotation);
            copyNonSBOLProperties(anno, anno2);
            let start = anno.bioStart;
            let end = anno.bioEnd;
            let strand = anno.strand;
            if (strand === "+")
              strand = bioterms_1.Specifiers.SBOL2.Orientation.Inline;
            else if (strand === "-")
              strand = bioterms_1.Specifiers.SBOL2.Orientation.ReverseComplement;
            else
              strand = void 0;
            if (start !== void 0 || end !== void 0) {
              let range = new S2Range_1.default(graph22, rdfoo_1.node.createUriNode(URIUtils_1.default.addSuffix(anno.subject.value, "/location")));
              range.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Range);
              range.start = start;
              range.end = end;
              range.orientation = strand;
              anno2.insertProperty(bioterms_1.Predicates.SBOL2.location, range.subject);
            } else {
              let genericLocation = new S2GenericLocation_1.default(graph22, rdfoo_1.node.createUriNode(URIUtils_1.default.addSuffix(anno.subject.value, "/location")));
              genericLocation.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.GenericLocation);
              if (strand !== void 0)
                genericLocation.orientation = strand;
              anno2.insertProperty(bioterms_1.Predicates.SBOL2.location, genericLocation.subject);
            }
            for (let precedes of anno.precedes) {
              let constraint = new S2SequenceConstraint_1.default(graph22, rdfoo_1.node.createUriNode(URIUtils_1.default.addSuffix(dnaComponent.subject.value, "/precedes" + ++precedesN)));
              constraint.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.SequenceConstraint);
              component2.insertProperty(bioterms_1.Predicates.SBOL2.sequenceConstraint, constraint.constraintSubject.subject);
              let obj = new S2SequenceAnnotation_1.default(graph22, anno.subject);
              let c2 = obj.component;
              if (!c2) {
                throw new Error("???");
              }
              let precedes2 = new S2SequenceAnnotation_1.default(graph22, precedes.subject);
              if (!precedes2.component) {
                throw new Error("???");
              }
              constraint.setProperty(bioterms_1.Predicates.SBOL2.subject, c2.subject);
              constraint.setProperty(bioterms_1.Predicates.SBOL2.restriction, rdfoo_1.node.createUriNode(bioterms_1.Specifiers.SBOL2.SequenceConstraint.Precedes));
              constraint.setProperty(bioterms_1.Predicates.SBOL2.object, (_a = precedes2.component) === null || _a === void 0 ? void 0 : _a.subject);
            }
          }
        }
        for (let collection of graph1.collections) {
          let collection2 = new S2Collection_1.default(graph22, collection.subject);
          collection2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Collection);
          collection2.name = collection.name;
          collection2.description = collection.description;
          copyDisplayId(collection, collection2);
          for (let component of collection.components) {
            collection2.addMember(new S2ComponentDefinition_1.default(graph22, component.subject));
          }
        }
        for (let typeTriple of graph2.match(null, bioterms_1.Predicates.a, null)) {
          if (typeTriple.object.value.indexOf(bioterms_1.Prefixes.sbol1) === 0) {
            graph2.removeMatches(typeTriple.subject, null, null);
          }
        }
        graph2.addAll(newGraph);
        function copyDisplayId(a, b) {
          let oldDisplayId = a.getStringProperty(bioterms_1.Predicates.SBOL1.displayId);
          if (oldDisplayId === void 0) {
            return;
          }
          let newDisplayId = oldDisplayId === null || oldDisplayId === void 0 ? void 0 : oldDisplayId.replace(/[^A-z_]/g, "_");
          b.setStringProperty(bioterms_1.Predicates.SBOL2.displayId, newDisplayId);
          if (oldDisplayId === newDisplayId) {
            return;
          }
          b.setStringProperty("http://sboltools.org/backport#sbol1displayId", oldDisplayId);
        }
        function copyNonSBOLProperties(a, b) {
          for (let t of graph2.match(a.subject, null, null)) {
            if (t.subject.value.indexOf(bioterms_1.Prefixes.sbol1) == 0) {
              continue;
            }
            b.insertProperty(t.predicate.value, t.object);
          }
        }
      }
      exports.default = convert1to2;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Facade.js
  var require_S3Facade = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Facade.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var SBOLFacade_1 = require_SBOLFacade();
      var S3Facade = class extends SBOLFacade_1.default {
        constructor(view, subject) {
          super(view.graph, view, subject);
          this.view = view;
        }
      };
      exports.default = S3Facade;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Measure.js
  var require_S3Measure = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Measure.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var bioterms_1 = require_dist2();
      var S3Measure = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.Measure.Measure;
        }
        get value() {
          return this.getFloatProperty(bioterms_1.Predicates.Measure.hasNumericalValue);
        }
        set value(v) {
          if (v === void 0)
            this.deleteProperty(bioterms_1.Predicates.Measure.hasNumericalValue);
          else
            this.setFloatProperty(bioterms_1.Predicates.Measure.hasNumericalValue, v);
        }
        get unit() {
          return this.getUriProperty(bioterms_1.Predicates.Measure.hasUnit);
        }
        set unit(unit) {
          this.setUriProperty(bioterms_1.Predicates.Measure.hasUnit, unit);
        }
      };
      exports.default = S3Measure;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Identified.js
  var require_S3Identified = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Identified.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var S3Facade_1 = require_S3Facade();
      var URIUtils_1 = require_URIUtils();
      var S3Identified3 = class extends S3Facade_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          throw new Error("base called");
        }
        get name() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL3.name);
        }
        get displayName() {
          return this.name || this.getStringProperty(bioterms_1.Predicates.SBOL3.displayId) || this.subject.value;
        }
        set name(name) {
          this.setStringProperty(bioterms_1.Predicates.SBOL3.name, name);
        }
        get description() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL3.description);
        }
        set description(desc) {
          this.setStringProperty(bioterms_1.Predicates.SBOL3.description, desc);
        }
        get displayDescription() {
          return this.description;
        }
        get displayId() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL3.displayId);
        }
        set displayId(displayId) {
          this.setStringProperty(bioterms_1.Predicates.SBOL3.displayId, displayId);
        }
        get uriPrefix() {
          return URIUtils_1.default.getPrefix(this.subject.value);
        }
        get namespace() {
          return this.getRequiredUriProperty(bioterms_1.Predicates.SBOL3.hasNamespace);
        }
        set namespace(namespace3) {
          this.setUriProperty(bioterms_1.Predicates.SBOL3.hasNamespace, namespace3);
        }
        get measures() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.measure).map((measure) => new S3Measure_1.default(this.view, measure));
        }
      };
      exports.default = S3Identified3;
      var S3Measure_1 = require_S3Measure();
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Constraint.js
  var require_S3Constraint = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Constraint.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var S3SubComponent_1 = require_S3SubComponent();
      var bioterms_1 = require_dist2();
      var S3Constraint = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.Constraint;
        }
        get containingObject() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasConstraint, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("SeqCons has no containing object?");
          }
          return this.view.uriToIdentified(subject);
        }
        get containingComponent() {
          return this.containingObject;
        }
        get constraintRestriction() {
          const restriction = this.getUriProperty(bioterms_1.Predicates.SBOL3.restriction);
          if (restriction === void 0) {
            throw new Error("SeqCons has no restriction?");
          }
          return restriction;
        }
        set constraintRestriction(subject) {
          this.setUriProperty(bioterms_1.Predicates.SBOL3.restriction, subject);
        }
        get constraintSubject() {
          const subject = this.getProperty(bioterms_1.Predicates.SBOL3.subject);
          if (subject === void 0) {
            throw new Error("SeqCons has no subject?");
          }
          return new S3SubComponent_1.default(this.view, subject);
        }
        set constraintSubject(sc) {
          this.setProperty(bioterms_1.Predicates.SBOL3.subject, sc.subject);
        }
        get constraintObject() {
          const object = this.getProperty(bioterms_1.Predicates.SBOL3.object);
          if (object === void 0) {
            throw new Error("SeqCons has no object?");
          }
          return new S3SubComponent_1.default(this.view, object);
        }
        set constraintObject(sc) {
          this.setProperty(bioterms_1.Predicates.SBOL3.object, sc.subject);
        }
      };
      exports.default = S3Constraint;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3SubComponent.js
  var require_S3SubComponent = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3SubComponent.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Feature_1 = require_S3Feature();
      var S3Component_1 = require_S3Component();
      var S3Constraint_1 = require_S3Constraint();
      var bioterms_1 = require_dist2();
      var S3Location_1 = require_S3Location();
      var S3Measure_1 = require_S3Measure();
      var S3SubComponent = class extends S3Feature_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.SubComponent;
        }
        get displayName() {
          let name = this.name;
          if (name)
            return name;
          try {
            let instanceOf = this.instanceOf;
            let instanceOfName = instanceOf.name;
            if (instanceOfName) {
              return instanceOfName;
            }
          } catch (e) {
          }
          return this.getStringProperty(bioterms_1.Predicates.SBOL3.displayId) || this.subject.value;
        }
        get instanceOf() {
          const subject = this.getProperty(bioterms_1.Predicates.SBOL3.instanceOf);
          if (subject === void 0) {
            throw new Error("subcomponent has no instanceOf?");
          }
          return new S3Component_1.default(this.view, subject);
        }
        set instanceOf(def) {
          this.setProperty(bioterms_1.Predicates.SBOL3.instanceOf, def.subject);
        }
        get containingObject() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasFeature, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("subcomponent has no containing object?");
          }
          return this.view.uriToIdentified(subject);
        }
        get containingComponent() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasFeature, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("subcomponent has no containing object?");
          }
          return this.view.subjectToFacade(subject);
        }
        get sequenceConstraints() {
          return this.view.graph.match(null, bioterms_1.Predicates.SBOL3.subject, this.subject).map((t) => t.subject).map((subject) => new S3Constraint_1.default(this.view, subject));
        }
        createAfter(component) {
          const container = this.containingComponent;
          const sc = container.createSubComponent(component);
          let existingConstraints = this.getConstraintsWithThisSubject();
          container.createConstraint(this, bioterms_1.Specifiers.SBOL3.Constraint.Precedes, sc);
          for (let c of existingConstraints) {
            if (c.constraintRestriction === bioterms_1.Specifiers.SBOL3.Constraint.Precedes) {
              c.constraintSubject = sc;
            }
          }
          return sc;
        }
        createBefore(component) {
          const container = this.containingComponent;
          const sc = container.createSubComponent(component);
          let existingConstraints = this.getConstraintsWithThisObject();
          container.createConstraint(sc, bioterms_1.Specifiers.SBOL3.Constraint.Precedes, this);
          for (let c of existingConstraints) {
            if (c.constraintRestriction === bioterms_1.Specifiers.SBOL3.Constraint.Precedes) {
              c.constraintObject = sc;
            }
          }
          return sc;
        }
        getConstraintsWithThisSubject() {
          return this.view.graph.match(null, bioterms_1.Predicates.SBOL3.subject, this.subject).map((t) => t.subject).map((subject) => new S3Constraint_1.default(this.view, subject));
        }
        getConstraintsWithThisObject() {
          return this.view.graph.match(null, bioterms_1.Predicates.SBOL3.object, this.subject).map((t) => t.subject).map((subject) => new S3Constraint_1.default(this.view, subject));
        }
        getConstraints() {
          return this.getConstraintsWithThisSubject().concat(this.getConstraintsWithThisObject());
        }
        swapWith(otherSubComponent) {
          let a = this.getConstraintsWithThisObject();
          let b = this.getConstraintsWithThisSubject();
          let c = otherSubComponent.getConstraintsWithThisObject();
          let d = otherSubComponent.getConstraintsWithThisSubject();
          for (let sc of a) {
            sc.constraintObject = otherSubComponent;
          }
          for (let sc of b) {
            sc.constraintSubject = otherSubComponent;
          }
          for (let sc of c) {
            sc.constraintObject = this;
          }
          for (let sc of d) {
            sc.constraintSubject = this;
          }
        }
        createInteractionWith(other, id, interactionType, ourRole, theirRole) {
          if (!other.isSiblingOf(this)) {
            throw new Error("???");
          }
          let container = this.containingComponent;
          if (!container) {
            throw new Error("???");
          }
          let interaction = container.createInteraction(id);
          interaction.type = interactionType;
          interaction.createParticipationWithParticipantAndRole("ourParticipation", this, ourRole);
          interaction.createParticipationWithParticipantAndRole("theirParticipation", other, theirRole);
          return interaction;
        }
        createProduct(id) {
          let product = this.view.createComponent(this.uriPrefix, id);
          let container = this.containingComponent;
          let productSC = container.createSubComponent(product);
          let interaction = this.createInteractionWith(productSC, "production", bioterms_1.Prefixes.sbo + "SBO:0000589", bioterms_1.Prefixes.sbo + "SBO:0000645", bioterms_1.Prefixes.sbo + "SBO:0000011");
          return productSC;
        }
        getInteractions() {
          let container = this.containingComponent;
          return container.interactions.filter((interaction) => {
            return interaction.hasParticipant(this);
          });
        }
        getProducts() {
          let interactions = this.getInteractions();
          let productionInteractions = interactions.filter((interaction) => {
            return interaction.hasType(bioterms_1.Prefixes.sbo + "SBO:0000589");
          });
          let products = [];
          for (let i of productionInteractions) {
            for (let p of i.participations) {
              if (p.hasRole(bioterms_1.Prefixes.sbo + "SBO:0000011")) {
                let participant = p.participant;
                if (participant === void 0) {
                  throw new Error("???");
                }
                products.push(participant);
              }
            }
          }
          return products;
        }
        dissolve() {
          let containingComponent = this.containingComponent;
          let def = this.instanceOf;
          for (let subcomponent of def.subComponents) {
            let newSC = containingComponent.createSubComponent(subcomponent.instanceOf);
          }
          this.destroy();
        }
        get sourceLocation() {
          let uri = this.getProperty(bioterms_1.Predicates.SBOL3.sourceLocation);
          if (uri === void 0)
            return void 0;
          let obj = this.view.subjectToFacade(uri);
          if (!(obj instanceof S3Location_1.default)) {
            throw new Error("sourceLocation was not a location");
          }
          return obj;
        }
        set sourceLocation(location) {
          if (location !== void 0)
            this.setProperty(bioterms_1.Predicates.SBOL3.sourceLocation, location.subject);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.sourceLocation);
        }
        get measure() {
          let measure = this.getProperty(bioterms_1.Predicates.SBOL3.hasMeasure);
          if (measure === void 0)
            return;
          return new S3Measure_1.default(this.view, measure);
        }
        set measure(measure) {
          if (measure === void 0)
            this.deleteProperty(bioterms_1.Predicates.SBOL3.hasMeasure);
          else
            this.setProperty(bioterms_1.Predicates.SBOL3.hasMeasure, measure.subject);
        }
      };
      exports.default = S3SubComponent;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Participation.js
  var require_S3Participation = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Participation.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var S3SubComponent_1 = require_S3SubComponent();
      var S3Interaction_1 = require_S3Interaction();
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S3Measure_1 = require_S3Measure();
      var S3Participation = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.Participation;
        }
        get participant() {
          const subject = this.getProperty(bioterms_1.Predicates.SBOL3.participant);
          if (subject) {
            return new S3SubComponent_1.default(this.view, subject);
          }
        }
        set participant(c) {
          if (c) {
            this.setProperty(bioterms_1.Predicates.SBOL3.participant, c.subject);
          } else {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.participant);
          }
        }
        get interaction() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasParticipation, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (subject) {
            return new S3Interaction_1.default(this.view, subject);
          }
        }
        get containingObject() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasParticipation, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("Participation has no containing object?");
          }
          return this.view.uriToIdentified(subject);
        }
        hasRole(subject) {
          return this.view.graph.hasMatch(this.subject, bioterms_1.Predicates.SBOL3.role, rdfoo_1.node.createUriNode(subject));
        }
        addRole(role) {
          this.insertProperty(bioterms_1.Predicates.SBOL3.role, rdfoo_1.node.createUriNode(role));
        }
        removeRole(role) {
          this.view.graph.removeMatches(this.subject, bioterms_1.Predicates.SBOL3.role, rdfoo_1.node.createUriNode(role));
        }
        get roles() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL3.role);
        }
        setParticipant(participant) {
          this.setProperty(bioterms_1.Predicates.SBOL3.participant, participant.subject);
        }
        get measure() {
          let measure = this.getProperty(bioterms_1.Predicates.SBOL3.hasMeasure);
          if (measure === void 0)
            return;
          return new S3Measure_1.default(this.view, measure);
        }
        set measure(measure) {
          if (measure === void 0)
            this.deleteProperty(bioterms_1.Predicates.SBOL3.hasMeasure);
          else
            this.setProperty(bioterms_1.Predicates.SBOL3.hasMeasure, measure.subject);
        }
      };
      exports.default = S3Participation;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3IdentifiedFactory.js
  var require_S3IdentifiedFactory = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3IdentifiedFactory.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var bioterms_1 = require_dist2();
      var rdfoo_1 = require_dist();
      var S3IdentifiedFactory = class {
        static createTopLevel(view, type, uriPrefix, displayId, name) {
          displayId = displayId ? nameToID(displayId) : "anon";
          const subject = rdfoo_1.node.createUriNode(view.graph.generateURI(uriPrefix + displayId + "$n?$"));
          view.graph.insertProperties(subject, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(type),
            [bioterms_1.Predicates.SBOL3.displayId]: rdfoo_1.node.createStringNode(displayId),
            [bioterms_1.Predicates.SBOL3.hasNamespace]: rdfoo_1.node.createUriNode(uriPrefix)
          });
          if (name !== void 0) {
            view.graph.insertProperties(subject, {
              [bioterms_1.Predicates.Dcterms.title]: rdfoo_1.node.createStringNode(name)
            });
          }
          return new S3Identified_1.default(view, subject);
        }
        static createChild(view, type, parent, ownershipPredicate, displayId, name) {
          displayId = displayId ? nameToID(displayId) : "anon";
          const subject = rdfoo_1.node.createUriNode(view.graph.generateURI(parent.namespace + parent.displayId + "/" + displayId + "$n?$"));
          view.graph.insertProperties(subject, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(type),
            [bioterms_1.Predicates.SBOL3.displayId]: rdfoo_1.node.createStringNode(displayId),
            [bioterms_1.Predicates.SBOL3.hasNamespace]: rdfoo_1.node.createUriNode(parent.namespace)
          });
          if (name !== void 0) {
            view.graph.insertProperties(subject, {
              [bioterms_1.Predicates.Dcterms.title]: rdfoo_1.node.createStringNode(name)
            });
          }
          view.graph.insertProperties(parent.subject, {
            [ownershipPredicate]: subject
          });
          return new S3Identified_1.default(view, subject);
        }
      };
      exports.default = S3IdentifiedFactory;
      function nameToID(name) {
        return name.replace(/\s/, "_");
      }
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Interaction.js
  var require_S3Interaction = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Interaction.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var S3Participation_1 = require_S3Participation();
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S3IdentifiedFactory_1 = require_S3IdentifiedFactory();
      var S3Measure_1 = require_S3Measure();
      var S3Component_1 = require_S3Component();
      var S3Interaction = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.Interaction;
        }
        get type() {
          const typeUri = this.getUriProperty(bioterms_1.Predicates.SBOL3.type);
          if (!typeUri)
            throw new Error(this.subject.value + " has no type?");
          return typeUri;
        }
        get types() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL3.type);
        }
        set type(subject) {
          this.setUriProperty(bioterms_1.Predicates.SBOL3.type, subject);
        }
        addType(type) {
          this.insertProperty(bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
        }
        hasType(type) {
          return this.view.graph.hasMatch(this.subject, bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
        }
        get participations() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.hasParticipation).map((subject) => new S3Participation_1.default(this.view, subject));
        }
        get participants() {
          const participants = this.participations.map((participation) => participation.participant);
          return participants.filter((el) => !!el);
        }
        hasParticipant(participant) {
          return this.participants.map((p) => p.subject).indexOf(participant.subject) !== -1;
        }
        get containingModule() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasInteraction, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("Interaction " + this.subject.value + " not contained by a Module?");
          }
          return new S3Component_1.default(this.view, subject);
        }
        get containingObject() {
          return this.containingModule;
        }
        createParticipation(id, version) {
          const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.Participation, this, bioterms_1.Predicates.SBOL3.hasParticipation, id, void 0);
          const participation = new S3Participation_1.default(this.view, identified.subject);
          return participation;
        }
        createParticipationWithParticipantAndRole(id, participant, role, version) {
          let participation = this.createParticipation(id, version);
          participation.addRole(role);
          participation.setParticipant(participant);
          return participation;
        }
        get measure() {
          let measure = this.getProperty(bioterms_1.Predicates.SBOL3.hasMeasure);
          if (measure === void 0)
            return;
          return new S3Measure_1.default(this.view, measure);
        }
        set measure(measure) {
          if (measure === void 0)
            this.deleteProperty(bioterms_1.Predicates.SBOL3.hasMeasure);
          else
            this.setProperty(bioterms_1.Predicates.SBOL3.hasMeasure, measure.subject);
        }
      };
      exports.default = S3Interaction;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3SequenceFeature.js
  var require_S3SequenceFeature = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3SequenceFeature.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Feature_1 = require_S3Feature();
      var S3SequenceFeature = class extends S3Feature_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
      };
      exports.default = S3SequenceFeature;
    }
  });

  // node_modules/sboljs/dist/extractTerm.js
  var require_extractTerm = __commonJS({
    "node_modules/sboljs/dist/extractTerm.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      function extractTerm(subject) {
        let uri = subject.value;
        let purl1 = "http://purl.org/obo/owl/SO#";
        let purl2 = "http://purl.obolibrary.org/obo/";
        let idorg = "http://identifiers.org/so/";
        if (uri.indexOf(purl1) === 0) {
          return uri.slice(purl1.length).replace(/_/g, ":");
        } else if (uri.indexOf(purl2) === 0) {
          return uri.slice(purl2.length).replace(/_/g, ":");
        } else if (uri.indexOf(idorg) === 0) {
          return uri.slice(idorg.length);
        }
      }
      exports.default = extractTerm;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3LocalSubComponent.js
  var require_S3LocalSubComponent = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3LocalSubComponent.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Feature_1 = require_S3Feature();
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S3LocalSubComponent = class extends S3Feature_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.LocalSubComponent;
        }
        get types() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL3.type);
        }
        hasType(type) {
          return this.view.graph.hasMatch(this.subject, bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
        }
        addType(type) {
          this.view.graph.insertTriple(this.subject, bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
        }
        removeType(type) {
          this.view.graph.removeMatches(this.subject, bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
        }
        get definition() {
          return this.getRequiredUriProperty(bioterms_1.Predicates.SBOL3.definition);
        }
        set definition(d) {
          this.setUriProperty(bioterms_1.Predicates.SBOL3.definition, d);
        }
      };
      exports.default = S3LocalSubComponent;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3ExternallyDefined.js
  var require_S3ExternallyDefined = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3ExternallyDefined.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Feature_1 = require_S3Feature();
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S3ExternallyDefined = class extends S3Feature_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.ExternallyDefined;
        }
        get types() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL3.type);
        }
        hasType(type) {
          return this.view.graph.hasMatch(this.subject, bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
        }
        addType(type) {
          this.view.graph.insertTriple(this.subject, bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
        }
        removeType(type) {
          this.view.graph.removeMatches(this.subject, bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
        }
      };
      exports.default = S3ExternallyDefined;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Component.js
  var require_S3Component = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Component.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var S3SubComponent_1 = require_S3SubComponent();
      var S3Interaction_1 = require_S3Interaction();
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S3Sequence_1 = require_S3Sequence();
      var S3Constraint_1 = require_S3Constraint();
      var S3SequenceFeature_1 = require_S3SequenceFeature();
      var S3IdentifiedFactory_1 = require_S3IdentifiedFactory();
      var extractTerm_1 = require_extractTerm();
      var S3Interface_1 = require_S3Interface();
      var S3LocalSubComponent_1 = require_S3LocalSubComponent();
      var S3ExternallyDefined_1 = require_S3ExternallyDefined();
      var S3Component2 = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.Component;
        }
        get types() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL3.type);
        }
        hasType(type) {
          return this.view.graph.hasMatch(this.subject, bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
        }
        addType(type) {
          this.view.graph.insertTriple(this.subject, bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
        }
        removeType(type) {
          this.view.graph.removeMatches(this.subject, bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
        }
        get roles() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL3.role);
        }
        hasRole(role) {
          return this.view.graph.hasMatch(this.subject, bioterms_1.Predicates.SBOL3.role, rdfoo_1.node.createUriNode(role));
        }
        addRole(role) {
          this.view.graph.insertTriple(this.subject, bioterms_1.Predicates.SBOL3.role, rdfoo_1.node.createUriNode(role));
        }
        removeRole(role) {
          this.view.graph.removeMatches(this.subject, bioterms_1.Predicates.SBOL3.role, rdfoo_1.node.createUriNode(role));
        }
        get soTerms() {
          let terms = [];
          for (let role of this.roles) {
            let term = (0, extractTerm_1.default)(rdfoo_1.node.createUriNode(role));
            if (term)
              terms.push(term);
          }
          return terms;
        }
        get sequences() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.hasSequence).map((subject) => new S3Sequence_1.default(this.view, subject));
        }
        get subComponents() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.hasFeature).filter((subject) => this.graph.hasMatch(subject, bioterms_1.Predicates.a, rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL3.SubComponent))).map((subject) => new S3SubComponent_1.default(this.view, subject));
        }
        get localSubComponents() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.hasFeature).filter((subject) => this.graph.hasMatch(subject, bioterms_1.Predicates.a, rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL3.LocalSubComponent))).map((subject) => new S3LocalSubComponent_1.default(this.view, subject));
        }
        get externalDefinitions() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.hasFeature).filter((subject) => this.graph.hasMatch(subject, bioterms_1.Predicates.a, rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL3.ExternallyDefined))).map((subject) => new S3ExternallyDefined_1.default(this.view, subject));
        }
        get interactions() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.hasInteraction).map((subject) => new S3Interaction_1.default(this.view, subject));
        }
        get interfaces() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.hasInterface).map((subject) => new S3Interface_1.default(this.view, subject));
        }
        get containingObject() {
          return void 0;
        }
        get sequenceConstraints() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.hasConstraint).map((subject) => new S3Constraint_1.default(this.view, subject));
        }
        get sequenceFeatures() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.hasFeature).filter((subject) => this.graph.hasMatch(subject, bioterms_1.Predicates.a, rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL3.SequenceFeature))).map((subject) => new S3SequenceFeature_1.default(this.view, subject));
        }
        get containedObjects() {
          return this.subComponents.concat(this.interactions).concat(this.sequenceConstraints).concat(this.sequenceFeatures);
        }
        get annotatedLocations() {
          const all = [];
          this.subComponents.forEach((sc) => {
            Array.prototype.push.apply(all, sc.locations);
          });
          this.sequenceFeatures.forEach((f) => {
            Array.prototype.push.apply(all, f.locations);
          });
          return all;
        }
        get thingsWithLocations() {
          return this.subComponents.concat(this.sequenceFeatures);
        }
        isPlasmidBackbone() {
          return this.hasRole(bioterms_1.Specifiers.SO.PlasmidBackbone);
        }
        createSubComponent(definition) {
          const id = definition.displayId;
          const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.SubComponent, this, bioterms_1.Predicates.SBOL3.hasFeature, id, void 0);
          const module2 = new S3SubComponent_1.default(this.view, identified.subject);
          module2.instanceOf = definition;
          return module2;
        }
        createFeature(name) {
          const id = "feature_" + name;
          const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.SequenceFeature, this, bioterms_1.Predicates.SBOL3.hasFeature, id, void 0);
          return new S3SequenceFeature_1.default(this.view, identified.subject);
        }
        createFeatureWithRange(start, end, name) {
          const feature = this.createFeature(name);
          feature.addRange(start, end);
          return feature;
        }
        wrap(wrapperId) {
          const wrapper = this.view.createComponent(this.uriPrefix, wrapperId || this.displayName + "_wrapper");
          for (let type of this.types) {
            wrapper.addType(type);
          }
          wrapper.createSubComponent(this);
          return wrapper;
        }
        createConstraint(subject, restriction, object) {
          const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.Constraint, this, bioterms_1.Predicates.SBOL3.hasConstraint, "constraint_" + subject.displayId + "_" + object.displayId, void 0);
          const constraint = new S3Constraint_1.default(this.view, identified.subject);
          constraint.constraintSubject = subject;
          constraint.constraintRestriction = restriction;
          constraint.constraintObject = object;
          return constraint;
        }
        createSequence() {
          const seq = this.view.createSequence(this.uriPrefix, this.displayName + "_sequence");
          this.addSequence(seq);
          return seq;
        }
        addSequence(seq) {
          this.view.graph.insertProperties(this.subject, {
            [bioterms_1.Predicates.SBOL3.hasSequence]: seq.subject
          });
        }
        createInteraction(id, version) {
          const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.Interaction, this, bioterms_1.Predicates.SBOL3.hasInteraction, id, void 0);
          const interaction = new S3Interaction_1.default(this.view, identified.subject);
          return interaction;
        }
        addModel(model) {
          this.insertProperty(bioterms_1.Predicates.SBOL3.hasModel, model.subject);
        }
        get instances() {
          return this.graph.match(null, bioterms_1.Predicates.SBOL3.instanceOf, this.subject).map((t) => this.view.subjectToFacade(t.subject)).map((f) => f);
        }
        dissolve() {
          let instances = this.instances;
          for (let inst of instances) {
            inst.dissolve();
          }
          this.destroy();
        }
      };
      exports.default = S3Component2;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Sequence.js
  var require_S3Sequence = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Sequence.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var bioterms_1 = require_dist2();
      var S3Component_1 = require_S3Component();
      var S3Range_1 = require_S3Range();
      var S3Sequence = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.Sequence;
        }
        get elements() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL3.elements);
        }
        set elements(elements) {
          if (elements === void 0) {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.elements);
          } else {
            this.setStringProperty(bioterms_1.Predicates.SBOL3.elements, elements);
          }
        }
        prependFragment(fragment) {
          this.elements = fragment + this.elements;
        }
        appendFragment(fragment) {
          this.elements = this.elements + fragment;
        }
        insertFragment(pos, fragment) {
          const elements = this.elements;
          if (elements === void 0)
            throw new Error("???");
          if (pos === elements.length) {
            this.appendFragment(fragment);
          }
          if (pos < 0 || pos >= elements.length)
            return;
          const containingModules = this.view.graph.match(null, bioterms_1.Predicates.SBOL3.hasSequence, this.subject).map((t) => t.subject).map((subject) => new S3Component_1.default(this.view, subject));
          containingModules.forEach((module2) => {
            module2.sequenceFeatures.forEach((sa) => {
              sa.locations.forEach((location) => {
                updateLocation(location);
              });
            });
            module2.subComponents.forEach((sm) => {
              sm.locations.forEach((location) => {
                updateLocation(location);
              });
            });
            function updateLocation(location) {
              if (location instanceof S3Range_1.default) {
                const range = location;
                const start = range.start;
                const end = range.end;
                if (start === void 0 || end === void 0)
                  throw new Error("???");
                if (pos >= start && pos <= end) {
                  range.end = end + fragment.length;
                } else if (pos < start) {
                  range.start = start + fragment.length;
                  range.end = end + fragment.length;
                }
              }
            }
          });
          const slices = [
            elements.substring(0, pos),
            fragment,
            elements.substring(pos)
          ];
          this.elements = slices.join("");
        }
        deleteFragment(pos, n) {
          const elements = this.elements;
          if (elements === void 0)
            throw new Error("???");
          if (pos < 0 || pos >= elements.length)
            return;
          const containingCDs = this.view.graph.match(null, bioterms_1.Predicates.SBOL3.hasSequence, this.subject).map((t) => t.subject).map((subject) => new S3Component_1.default(this.view, subject));
          containingCDs.forEach((cd) => {
            cd.sequenceFeatures.forEach((sa) => {
              sa.locations.forEach((location) => {
                updateLocation(location);
              });
            });
            cd.subComponents.forEach((sm) => {
              sm.locations.forEach((location) => {
                updateLocation(location);
              });
            });
            function updateLocation(location) {
              if (location instanceof S3Range_1.default) {
                const range = location;
                const start = range.start;
                const end = range.end;
                if (start === void 0 || end === void 0)
                  throw new Error("???");
                if (pos >= start && pos <= end) {
                  range.end = end - n;
                } else if (pos < start) {
                  range.start = start - n;
                  range.end = end - n;
                }
              }
            }
          });
          const slices = [
            elements.substring(0, pos),
            elements.substring(pos + n)
          ];
          this.elements = slices.join("");
        }
        get encoding() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL3.encoding);
        }
        set encoding(encoding2) {
          if (encoding2 === void 0) {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.encoding);
          } else {
            this.setUriProperty(bioterms_1.Predicates.SBOL3.encoding, encoding2);
          }
        }
        get containingObject() {
          return void 0;
        }
        get referencingComponents() {
          return this.graph.match(null, bioterms_1.Predicates.SBOL3.hasSequence, this.subject).map((t) => t.subject).map((subject) => new S3Component_1.default(this.view, subject));
        }
      };
      exports.default = S3Sequence;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Location.js
  var require_S3Location = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Location.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var bioterms_1 = require_dist2();
      var S3Sequence_1 = require_S3Sequence();
      var S3Location = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get containingObject() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasLocation, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("Location has no containing object?");
          }
          return this.view.uriToIdentified(subject);
        }
        isFixed() {
          return this.facadeType === bioterms_1.Types.SBOL3.Range;
        }
        get displayName() {
          const name = this.name;
          if (name !== void 0)
            return name;
          const containingObject = this.containingObject;
          if (containingObject === void 0) {
            throw new Error("???");
          }
          return containingObject.displayName;
        }
        get sequence() {
          let uri = this.getProperty(bioterms_1.Predicates.SBOL3.hasSequence);
          if (uri === void 0)
            return void 0;
          let obj = this.view.subjectToFacade(uri);
          if (!(obj instanceof S3Sequence_1.default)) {
            throw new Error("sequence was not a sequence");
          }
          return obj;
        }
        set sequence(sequence) {
          if (sequence !== void 0)
            this.setProperty(bioterms_1.Predicates.SBOL2.sequence, sequence.subject);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.sequence);
        }
      };
      exports.default = S3Location;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3OrientedLocation.js
  var require_S3OrientedLocation = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3OrientedLocation.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var S3Location_1 = require_S3Location();
      var S3OrientedLocation = class extends S3Location_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get orientation() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL3.orientation);
        }
        set orientation(orientation) {
          this.setUriProperty(bioterms_1.Predicates.SBOL3.orientation, orientation);
        }
        isFixed() {
          return false;
        }
      };
      exports.default = S3OrientedLocation;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Range.js
  var require_S3Range = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Range.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3OrientedLocation_1 = require_S3OrientedLocation();
      var bioterms_1 = require_dist2();
      var S3Range = class extends S3OrientedLocation_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.Range;
        }
        get start() {
          return this.getIntProperty(bioterms_1.Predicates.SBOL3.start);
        }
        set start(n) {
          if (n !== void 0) {
            this.setIntProperty(bioterms_1.Predicates.SBOL3.start, n);
          } else {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.start);
          }
        }
        get end() {
          return this.getIntProperty(bioterms_1.Predicates.SBOL3.end);
        }
        set end(n) {
          if (n !== void 0) {
            this.setIntProperty(bioterms_1.Predicates.SBOL3.end, n);
          } else {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.end);
          }
        }
        isFixed() {
          return true;
        }
      };
      exports.default = S3Range;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Feature.js
  var require_S3Feature = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Feature.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var S3Feature = class extends S3Identified_1.default {
        get roles() {
          return this.getUriProperties(bioterms_1.Predicates.SBOL3.role);
        }
        hasRole(role) {
          return this.view.graph.hasMatch(this.subject, bioterms_1.Predicates.SBOL3.role, rdfoo_1.node.createUriNode(role));
        }
        addRole(role) {
          this.insertProperty(bioterms_1.Predicates.SBOL3.role, rdfoo_1.node.createUriNode(role));
        }
        removeRole(role) {
          this.view.graph.removeMatches(this.subject, bioterms_1.Predicates.SBOL3.role, rdfoo_1.node.createUriNode(role));
        }
        get soTerms() {
          let terms = [];
          for (let role of this.roles) {
            let term = (0, extractTerm_1.default)(rdfoo_1.node.createUriNode(role));
            if (term)
              terms.push(term);
          }
          return terms;
        }
        get containingObject() {
          var _a;
          const subject = (_a = this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasFeature, this.subject)) === null || _a === void 0 ? void 0 : _a.subject;
          if (!subject) {
            throw new Error("has no containing object?");
          }
          return this.view.uriToIdentified(subject);
        }
        get containingComponent() {
          return this.containingObject;
        }
        get locations() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.hasLocation).map((subject) => this.view.subjectToFacade(subject));
        }
        get rangeLocations() {
          return this.locations.filter((location) => {
            return location.objectType === bioterms_1.Types.SBOL3.Range;
          }).map((identified) => {
            return new S3Range_1.default(this.view, identified.subject);
          });
        }
        get rangeMin() {
          var n = Number.MAX_VALUE;
          this.rangeLocations.forEach((range) => {
            const start = range.start;
            const end = range.end;
            if (start !== void 0 && start < n)
              n = start;
            if (end !== void 0 && end < n)
              n = end;
          });
          return n === Number.MAX_VALUE ? null : n;
        }
        get rangeMax() {
          var n = Number.MIN_VALUE;
          this.rangeLocations.forEach((range) => {
            const start = range.start;
            const end = range.end;
            if (start !== void 0 && start > n)
              n = start;
            if (end !== void 0 && end > n)
              n = end;
          });
          return n === Number.MIN_VALUE ? null : n;
        }
        hasFixedLocation() {
          const locations = this.locations;
          for (var i = 0; i < locations.length; ++i) {
            if (locations[i].isFixed())
              return true;
          }
          return false;
        }
        addRange(start, end) {
          const id = "range";
          const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.Range, this, bioterms_1.Predicates.SBOL3.hasLocation, id, void 0);
          const range = new S3Range_1.default(this.view, identified.subject);
          range.start = start;
          range.end = end;
          return range;
        }
        addOrientedLocation() {
          const loc = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.OrientedLocation, this, bioterms_1.Predicates.SBOL3.hasLocation, "location", void 0);
          return new S3OrientedLocation_1.default(loc.view, loc.subject);
        }
        get orientation() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL3.orientation);
        }
        set orientation(orientation) {
          this.setUriProperty(bioterms_1.Predicates.SBOL3.orientation, orientation);
        }
        get containingInterface() {
          let ifaces = this.graph.match(null, bioterms_1.Predicates.SBOL3.input, this.subject).concat(this.graph.match(null, bioterms_1.Predicates.SBOL3.output, this.subject)).concat(this.graph.match(null, bioterms_1.Predicates.SBOL3.nondirectional, this.subject)).map((t) => t.subject);
          if (ifaces.length === 0) {
            return void 0;
          }
          if (ifaces.length !== 1) {
            throw new Error("??");
          }
          return new S3Interface_1.default(this.view, ifaces[0]);
        }
      };
      exports.default = S3Feature;
      var S3Interface_1 = require_S3Interface();
      var S3Range_1 = require_S3Range();
      var S3IdentifiedFactory_1 = require_S3IdentifiedFactory();
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S3OrientedLocation_1 = require_S3OrientedLocation();
      var extractTerm_1 = require_extractTerm();
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Interface.js
  var require_S3Interface = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Interface.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var S3Feature_1 = require_S3Feature();
      var S3Interface = class extends S3Feature_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.Interface;
        }
        get inputs() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.input).map((subject) => this.view.uriToIdentified(subject));
        }
        get outputs() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.output).map((subject) => this.view.uriToIdentified(subject));
        }
        get nondirectionals() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.nondirectional).map((subject) => this.view.uriToIdentified(subject));
        }
      };
      exports.default = S3Interface;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Collection.js
  var require_S3Collection = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Collection.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var bioterms_1 = require_dist2();
      var S3Collection = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.Collection;
        }
        get members() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.member).map((subject) => this.view.subjectToFacade(subject)).filter((r) => r !== void 0);
        }
        addMember(member) {
          this.insertProperties({
            [bioterms_1.Predicates.SBOL3.member]: member.subject
          });
        }
      };
      exports.default = S3Collection;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Model.js
  var require_S3Model = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Model.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var bioterms_1 = require_dist2();
      var S3Model = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.Model;
        }
        get framework() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL3.framework);
        }
        set framework(framework) {
          this.setUriProperty(bioterms_1.Predicates.SBOL3.framework, framework);
        }
        get language() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL3.language);
        }
        set language(language) {
          this.setUriProperty(bioterms_1.Predicates.SBOL3.language, language);
        }
        get source() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL3.source);
        }
        set source(source) {
          this.setUriProperty(bioterms_1.Predicates.SBOL3.source, source);
        }
      };
      exports.default = S3Model;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Implementation.js
  var require_S3Implementation = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Implementation.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var bioterms_1 = require_dist2();
      var S3Component_1 = require_S3Component();
      var rdfoo_prov_1 = require_dist4();
      var S3Implementation = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.Implementation;
        }
        get built() {
          let built = this.getProperty(bioterms_1.Predicates.SBOL2.built);
          if (!built) {
            return void 0;
          }
          let builtObj = this.view.subjectToFacade(built);
          if (builtObj instanceof S3Component_1.default)
            return builtObj;
          throw new Error("built has wrong type");
        }
        set built(built) {
          if (built === void 0) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.built);
          } else {
            this.setProperty(bioterms_1.Predicates.SBOL2.built, built.subject);
          }
        }
        get activity() {
          let activity = this.getProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
          if (!activity) {
            return void 0;
          }
          return new rdfoo_prov_1.Activity(new rdfoo_prov_1.ProvView(this.graph), activity);
        }
        set activity(activity) {
          if (activity === void 0) {
            this.deleteProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
          } else {
            this.setProperty(bioterms_1.Predicates.Prov.wasGeneratedBy, activity.subject);
          }
        }
        get design() {
          let design_subject = this.getProperty(bioterms_1.Predicates.Prov.wasDerivedFrom);
          if (!design_subject) {
            return void 0;
          }
          return new S3Identified_1.default(this.view, design_subject);
        }
        set design(design) {
          if (design === void 0) {
            this.deleteProperty(bioterms_1.Predicates.Prov.wasDerivedFrom);
          } else {
            this.setProperty(bioterms_1.Predicates.Prov.wasDerivedFrom, design.subject);
          }
        }
        get displayType() {
          return "Construct";
        }
      };
      exports.default = S3Implementation;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3ExperimentalData.js
  var require_S3ExperimentalData = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3ExperimentalData.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var bioterms_1 = require_dist2();
      var S3ExperimentalData = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.ExperimentalData;
        }
      };
      exports.default = S3ExperimentalData;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Experiment.js
  var require_S3Experiment = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Experiment.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var rdfoo_1 = require_dist();
      var S3ExperimentalData_1 = require_S3ExperimentalData();
      var rdfoo_prov_1 = require_dist4();
      var bioterms_1 = require_dist2();
      var S3Implementation_1 = require_S3Implementation();
      var S3Experiment = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.Experiment;
        }
        get experimentalData() {
          let result = [];
          let expDataURIs = this.getUriProperties(bioterms_1.Predicates.SBOL3.experimentalData);
          for (let uri of expDataURIs) {
            result.push(new S3ExperimentalData_1.default(this.view, rdfoo_1.node.createUriNode(uri)));
          }
          return result;
        }
        addExperimentalData(member) {
          this.insertProperty(bioterms_1.Predicates.SBOL3.experimentalData, member.subject);
        }
        get activity() {
          let activity = this.getProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
          if (!activity) {
            return void 0;
          }
          return new rdfoo_prov_1.Activity(new rdfoo_prov_1.ProvView(this.graph), activity);
        }
        set activity(activity) {
          if (activity === void 0) {
            this.deleteProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
          } else {
            this.setProperty(bioterms_1.Predicates.Prov.wasGeneratedBy, activity.subject);
          }
        }
        get construct() {
          let construct_subject = this.getProperty(bioterms_1.Predicates.Prov.wasDerivedFrom);
          if (!construct_subject) {
            return void 0;
          }
          return new S3Implementation_1.default(this.view, construct_subject);
        }
        addConstruct(construct) {
          this.insertProperty(bioterms_1.Predicates.Prov.wasDerivedFrom, construct.subject);
        }
        get displayType() {
          return "Experiment";
        }
      };
      exports.default = S3Experiment;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Attachment.js
  var require_S3Attachment = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Attachment.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var bioterms_1 = require_dist2();
      var S3Attachment = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.Attachment;
        }
        get source() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL3.source);
        }
        set source(source) {
          if (source)
            this.setUriProperty(bioterms_1.Predicates.SBOL3.source, source);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.source);
        }
        get format() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL3.format);
        }
        set format(format) {
          if (format)
            this.setUriProperty(bioterms_1.Predicates.SBOL3.format, format);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.format);
        }
        get size() {
          return this.getIntProperty(bioterms_1.Predicates.SBOL3.size);
        }
        set size(size) {
          if (size)
            this.setIntProperty(bioterms_1.Predicates.SBOL3.size, size);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.size);
        }
        get hash() {
          return this.getStringProperty(bioterms_1.Predicates.SBOL3.hash);
        }
        set hash(hash) {
          if (hash)
            this.setStringProperty(bioterms_1.Predicates.SBOL3.hash, hash);
          else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.hash);
        }
      };
      exports.default = S3Attachment;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3VariableFeature.js
  var require_S3VariableFeature = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3VariableFeature.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var bioterms_1 = require_dist2();
      var S3Component_1 = require_S3Component();
      var S3Collection_1 = require_S3Collection();
      var S3CombinatorialDerivation_1 = require_S3CombinatorialDerivation();
      var __1 = require_dist5();
      var S3VariableFeature = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.VariableFeature;
        }
        get cardinality() {
          return this.getRequiredUriProperty("http://sbols.org/v3#cardinality");
        }
        set cardinality(cardinality) {
          this.setUriProperty("http://sbols.org/v3#cardinality", cardinality);
        }
        get variants() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.variant).map((subject) => new S3Component_1.default(this.view, subject));
        }
        get variantCollections() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.variantCollection).map((subject) => new S3Collection_1.default(this.view, subject));
        }
        get variantDerivations() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.variantDerivation).map((subject) => new S3CombinatorialDerivation_1.default(this.view, subject));
        }
        get variable() {
          return new __1.S3SubComponent(this.view, this.getProperty(bioterms_1.Predicates.SBOL3.variable));
        }
      };
      exports.default = S3VariableFeature;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3CombinatorialDerivation.js
  var require_S3CombinatorialDerivation = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3CombinatorialDerivation.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Identified_1 = require_S3Identified();
      var bioterms_1 = require_dist2();
      var S3Component_1 = require_S3Component();
      var S3VariableFeature_1 = require_S3VariableFeature();
      var S3CombinatorialDerivation = class extends S3Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.CombinatorialDerivation;
        }
        get strategy() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL3.strategy);
        }
        set strategy(strategy) {
          if (strategy === void 0) {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.strategy);
          } else {
            this.setUriProperty(bioterms_1.Predicates.SBOL3.strategy, strategy);
          }
        }
        get template() {
          const subject = this.getProperty(bioterms_1.Predicates.SBOL3.template);
          if (!subject) {
            throw new Error("CombinatorialDerivation " + this.subject.value + " has no template");
          }
          return new S3Component_1.default(this.view, subject);
        }
        set template(def) {
          this.setProperty(bioterms_1.Predicates.SBOL3.template, def.subject);
        }
        get variableFeatures() {
          return this.getProperties(bioterms_1.Predicates.SBOL3.hasVariableFeature).map((subject) => new S3VariableFeature_1.default(this.view, subject));
        }
      };
      exports.default = S3CombinatorialDerivation;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2CombinatorialDerivation.js
  var require_S2CombinatorialDerivation = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2CombinatorialDerivation.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var bioterms_1 = require_dist2();
      var S2ComponentDefinition_1 = require_S2ComponentDefinition();
      var S2VariableComponent_1 = require_S2VariableComponent();
      var S2CombinatorialDerivation = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.CombinatorialDerivation;
        }
        get strategy() {
          return this.getUriProperty(bioterms_1.Predicates.SBOL2.strategy);
        }
        set strategy(strategy) {
          if (strategy === void 0) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.strategy);
          } else {
            this.setUriProperty(bioterms_1.Predicates.SBOL2.strategy, strategy);
          }
        }
        get template() {
          const subject = this.getProperty(bioterms_1.Predicates.SBOL2.template);
          if (!subject) {
            throw new Error("CombinatorialDerivation " + this.subject.value + " has no template");
          }
          return new S2ComponentDefinition_1.default(this.view, subject);
        }
        set template(def) {
          this.setProperty(bioterms_1.Predicates.SBOL2.template, def.subject);
        }
        get variableComponents() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.variableComponent).map((subject) => new S2VariableComponent_1.default(this.view, subject));
        }
      };
      exports.default = S2CombinatorialDerivation;
    }
  });

  // node_modules/sboljs/dist/sbol2/S2VariableComponent.js
  var require_S2VariableComponent = __commonJS({
    "node_modules/sboljs/dist/sbol2/S2VariableComponent.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S2Identified_1 = require_S2Identified();
      var bioterms_1 = require_dist2();
      var S2ComponentDefinition_1 = require_S2ComponentDefinition();
      var __1 = require_dist5();
      var S2CombinatorialDerivation_1 = require_S2CombinatorialDerivation();
      var S2VariableComponent = class extends S2Identified_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL2.VariableComponent;
        }
        get operator() {
          return this.getRequiredUriProperty("http://sbols.org/v2#operator");
        }
        set operator(operator) {
          this.setUriProperty("http://sbols.org/v2#operator", operator);
        }
        get variants() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.variant).map((subject) => new S2ComponentDefinition_1.default(this.view, subject));
        }
        get variantCollections() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.variantCollection).map((subject) => new __1.S2Collection(this.view, subject));
        }
        get variantDerivations() {
          return this.getProperties(bioterms_1.Predicates.SBOL2.variantDerivation).map((subject) => new S2CombinatorialDerivation_1.default(this.view, subject));
        }
        get variable() {
          return new __1.S2ComponentInstance(this.view, this.getProperty(bioterms_1.Predicates.SBOL2.variable));
        }
      };
      exports.default = S2VariableComponent;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3ComponentReference.js
  var require_S3ComponentReference = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3ComponentReference.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var S3Feature_1 = require_S3Feature();
      var S3ComponentReference = class extends S3Feature_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Prefixes.sbol3 + "ComponentReference";
        }
        get inChildOf() {
          const inChildOf = this.getProperty(bioterms_1.Prefixes.sbol3 + "inChildOf");
          if (inChildOf === void 0) {
            throw new Error("??");
          }
          let c = this.view.uriToIdentified(inChildOf);
          if (!c) {
            throw new Error("??");
          }
          return c;
        }
        get refersTo() {
          const refersTo = this.getProperty(bioterms_1.Prefixes.sbol3 + "refersTo");
          if (refersTo === void 0) {
            throw new Error("??");
          }
          let f = this.view.uriToIdentified(refersTo);
          if (!f) {
            throw new Error("??");
          }
          return f;
        }
      };
      exports.default = S3ComponentReference;
    }
  });

  // node_modules/sboljs/dist/conversion/fromSBOL2/toSBOL3.js
  var require_toSBOL3 = __commonJS({
    "node_modules/sboljs/dist/conversion/fromSBOL2/toSBOL3.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3Component_1 = require_S3Component();
      var S3SequenceFeature_1 = require_S3SequenceFeature();
      var S2Range_1 = require_S2Range();
      var S2GenericLocation_1 = require_S2GenericLocation();
      var S3SubComponent_1 = require_S3SubComponent();
      var S3Collection_1 = require_S3Collection();
      var S3Sequence_1 = require_S3Sequence();
      var S3Interaction_1 = require_S3Interaction();
      var S3Participation_1 = require_S3Participation();
      var S2ModuleInstance_1 = require_S2ModuleInstance();
      var S3Model_1 = require_S3Model();
      var S3Experiment_1 = require_S3Experiment();
      var S3ExperimentalData_1 = require_S3ExperimentalData();
      var bioterms_1 = require_dist2();
      var rdfoo_1 = require_dist();
      var SBOL3GraphView_1 = require_SBOL3GraphView();
      var SBOL2GraphView_1 = require_SBOL2GraphView();
      var __1 = require_dist5();
      var S3Attachment_1 = require_S3Attachment();
      var S3Implementation_1 = require_S3Implementation();
      var S3CombinatorialDerivation_1 = require_S3CombinatorialDerivation();
      var S2VariableComponent_1 = require_S2VariableComponent();
      var S3VariableFeature_1 = require_S3VariableFeature();
      var S3Interface_1 = require_S3Interface();
      var S3ComponentReference_1 = require_S3ComponentReference();
      function convert2to3(graph2) {
        const map = /* @__PURE__ */ new Map();
        let sbol2View = new SBOL2GraphView_1.default(graph2);
        let newGraph = new rdfoo_1.Graph();
        let sbol3View = new SBOL3GraphView_1.default(newGraph);
        for (let cd of sbol2View.componentDefinitions) {
          cdTo3Component(cd);
        }
        for (let md of sbol2View.moduleDefinitions) {
          mdTo3Component(md);
        }
        for (let model of sbol2View.models) {
          modelToModel(model);
        }
        for (let seq of sbol2View.sequences) {
          convertSeq(seq);
        }
        for (let ed of sbol2View.experimentalData) {
          convertED(ed);
        }
        for (let ex of sbol2View.experiments) {
          convertExp(ex);
        }
        for (let att of sbol2View.attachments) {
          convertAttachment(att);
        }
        for (let cd of sbol2View.combinatorialDerivations) {
          convertCombinatorialDerivation(cd);
        }
        for (let sm of sbol2View.instancesOfType(bioterms_1.Types.SBOL2.Module).map((subject) => sbol2View.subjectToFacade(subject))) {
          if (!(sm instanceof S2ModuleInstance_1.default)) {
            throw new Error("???");
          }
          let _subModule = map.get(sm.subject.value);
          if (!(_subModule instanceof S3SubComponent_1.default)) {
            console.warn(sm.subject.value + " did not map to a subcomponent");
            if (_subModule)
              console.warn("it mapped to " + _subModule.constructor.name);
          }
          const subModule = _subModule;
          for (let mapsTo of sm.mappings) {
            if (!mapsTo.local || !mapsTo.remote) {
              throw new Error("???");
            }
            let a = map.get(mapsTo.local.subject.value);
            if (!a) {
              console.warn("Local side of MapsTo " + mapsTo.local.subject.value + " in submodule " + sm.subject.value + " was not found");
              a = new S3SubComponent_1.default(sbol3View, mapsTo.local.subject);
            }
            let b = map.get(mapsTo.remote.subject.value);
            if (!b) {
              console.warn("Remote side of MapsTo " + mapsTo.remote.subject.value + " in submodule " + sm.subject.value + " was not found");
              b = new S3SubComponent_1.default(sbol3View, mapsTo.remote.subject);
            }
            let constraint = new __1.S3Constraint(sbol3View, mapsTo.subject);
            let cR = new S3ComponentReference_1.default(sbol3View, rdfoo_1.node.createUriNode(mapsTo.subject + "_reference"));
            cR.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Prefixes.sbol3 + "ComponentReference");
            subModule.insertProperty(bioterms_1.Predicates.SBOL3.hasFeature, cR.subject);
            cR.setProperty(bioterms_1.Predicates.SBOL3 + "inChildOf", sm.subject);
            cR.setProperty(bioterms_1.Predicates.SBOL3 + "remote", b.subject);
            switch (mapsTo.refinement) {
              case bioterms_1.Specifiers.SBOL2.MapsToRefinement.UseRemote:
              default:
                break;
              case bioterms_1.Specifiers.SBOL2.MapsToRefinement.UseLocal:
                break;
              case bioterms_1.Prefixes.sbol2 + "verifyIdentical":
                break;
            }
          }
        }
        for (let collection of sbol2View.collections) {
          const col3 = new S3Collection_1.default(sbol3View, collection.subject);
          col3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Collection);
          copyIdentifiedProperties(collection, col3);
          for (let member of collection.members) {
            const converted = map.get(member.subject.value);
            if (converted !== void 0) {
              col3.addMember(converted);
            }
          }
        }
        for (let impl of sbol2View.implementations) {
          const impl3 = new S3Implementation_1.default(sbol3View, impl.subject);
          impl3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Implementation);
          copyIdentifiedProperties(impl, impl3);
          impl3.setProperty(bioterms_1.Predicates.SBOL3.built, impl.getProperty(bioterms_1.Predicates.SBOL2.built));
        }
        function convertSeq(seq) {
          const existing = map.get(seq.subject.value);
          if (existing)
            return existing;
          const xseq = new S3Sequence_1.default(sbol3View, seq.subject);
          xseq.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Sequence);
          copyIdentifiedProperties(seq, xseq);
          map.set(seq.subject.value, xseq);
          xseq.encoding = seq.encoding;
          xseq.elements = seq.elements;
          return xseq;
        }
        function modelToModel(model) {
          const existing = map.get(model.subject.value);
          if (existing)
            return existing;
          const xmodel = new S3Model_1.default(sbol3View, model.subject);
          xmodel.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Model);
          copyIdentifiedProperties(model, xmodel);
          xmodel.framework = model.framework;
          xmodel.source = model.source;
          xmodel.language = model.language;
          map.set(model.subject.value, xmodel);
          return xmodel;
        }
        function convertED(obj) {
          const existing = map.get(obj.subject.value);
          if (existing)
            return existing;
          const objx = new S3ExperimentalData_1.default(sbol3View, obj.subject);
          objx.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.ExperimentalData);
          copyIdentifiedProperties(obj, objx);
          map.set(obj.subject.value, objx);
          return objx;
        }
        function convertExp(obj) {
          const existing = map.get(obj.subject.value);
          if (existing)
            return existing;
          const objx = new S3Experiment_1.default(sbol3View, obj.subject);
          objx.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Experiment);
          copyIdentifiedProperties(obj, objx);
          for (let ed of obj.experimentalData) {
            objx.insertUriProperty(bioterms_1.Predicates.SBOL3.experimentalData, ed.subject.value);
          }
          map.set(obj.subject.value, objx);
          return objx;
        }
        function convertAttachment(obj) {
          const existing = map.get(obj.subject.value);
          if (existing)
            return existing;
          const objx = new S3Attachment_1.default(sbol3View, obj.subject);
          objx.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Attachment);
          copyIdentifiedProperties(obj, objx);
          objx.source = obj.source;
          objx.format = obj.format;
          objx.hash = obj.hash;
          objx.size = obj.size;
          map.set(obj.subject.value, objx);
          return objx;
        }
        function convertCombinatorialDerivation(obj) {
          const existing = map.get(obj.subject.value);
          if (existing)
            return existing;
          const objx = new S3CombinatorialDerivation_1.default(sbol3View, obj.subject);
          objx.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.CombinatorialDerivation);
          copyIdentifiedProperties(obj, objx);
          if (obj.strategy) {
            objx.strategy = obj.strategy.split(bioterms_1.Prefixes.sbol2).join(bioterms_1.Prefixes.sbol3);
          }
          objx.insertProperty(bioterms_1.Predicates.SBOL3.template, obj.template.subject);
          for (let ed of obj.variableComponents) {
            objx.insertUriProperty(bioterms_1.Predicates.SBOL3.hasVariableFeature, ed.subject.value);
            convertVariableComponent(new S2VariableComponent_1.default(sbol2View, ed.subject));
          }
          map.set(obj.subject.value, objx);
          return objx;
        }
        function convertVariableComponent(obj) {
          const existing = map.get(obj.subject.value);
          if (existing)
            return existing;
          const objx = new S3VariableFeature_1.default(sbol3View, obj.subject);
          objx.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.VariableFeature);
          copyIdentifiedProperties(obj, objx);
          objx.cardinality = obj.operator.split(bioterms_1.Prefixes.sbol2).join(bioterms_1.Prefixes.sbol3);
          for (let variant of obj.variants) {
            objx.insertProperty(bioterms_1.Predicates.SBOL3.variant, variant.subject);
          }
          for (let coll of obj.variantCollections) {
            objx.insertProperty(bioterms_1.Predicates.SBOL3.variantCollection, coll.subject);
          }
          for (let d of obj.variantDerivations) {
            objx.insertProperty(bioterms_1.Predicates.SBOL3.variantDerivation, d.subject);
          }
          objx.setProperty(bioterms_1.Predicates.SBOL3.variable, obj.variable.subject);
          map.set(obj.subject.value, objx);
          return objx;
        }
        function cdTo3Component(cd) {
          const existing = map.get(cd.subject.value);
          if (existing)
            return existing;
          const component3 = new S3Component_1.default(sbol3View, cd.subject);
          component3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Component);
          copyIdentifiedProperties(cd, component3);
          component3.setUriProperty("http://sboltools.org/backport#sbol2type", bioterms_1.Types.SBOL2.ComponentDefinition);
          map.set(cd.subject.value, component3);
          for (let role of cd.roles) {
            component3.addRole(role);
          }
          for (let type of cd.types) {
            component3.addType(type);
          }
          for (let sc of cd.components) {
            const def = cdTo3Component(sc.definition);
            const subComponent3 = new S3SubComponent_1.default(sbol3View, sc.subject);
            subComponent3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.SubComponent);
            copyIdentifiedProperties(sc, subComponent3);
            subComponent3.setUriProperty("http://sboltools.org/backport#sbol2type", bioterms_1.Types.SBOL2.Component);
            subComponent3.name = sc.name;
            subComponent3.instanceOf = def;
            if (sc.sourceLocation) {
              subComponent3.setUriProperty(bioterms_1.Predicates.SBOL3.sourceLocation, sc.sourceLocation.subject.value);
            }
            component3.insertUriProperty(bioterms_1.Predicates.SBOL3.hasFeature, subComponent3.subject.value);
            map.set(sc.subject.value, subComponent3);
          }
          for (let sa of cd.sequenceAnnotations) {
            if (!sa.component) {
              const feature = new S3SequenceFeature_1.default(sbol3View, sa.subject);
              feature.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.SequenceFeature);
              copyIdentifiedProperties(sa, feature);
              component3.insertUriProperty(bioterms_1.Predicates.SBOL3.hasFeature, feature.subject.value);
              feature.name = sa.name;
              for (let role of sa.roles) {
                feature.addRole(role);
              }
              copyLocations(sa, feature);
            } else {
              const found = map.get(sa.component.subject.value);
              if (!found)
                throw new Error("???");
              const sc = found;
              copyLocations(sa, sc);
              copyNonSBOLProperties(sa, sc);
              sc.setStringProperty("http://sboltools.org/backport#sequenceAnnotationDisplayId", sa.displayId);
            }
          }
          for (let seq of cd.sequences) {
            component3.addSequence(convertSeq(seq));
          }
          let interfaceRequired = cd.components.filter((fc) => fc.access !== bioterms_1.Specifiers.SBOL2.Access.PrivateAccess).length > 0;
          if (interfaceRequired) {
            let iface = new S3Interface_1.default(sbol3View, rdfoo_1.node.createUriNode(component3.subject.value + "/interface"));
            iface.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Interface);
            component3.insertProperty(bioterms_1.Predicates.SBOL3.hasInterface, iface.subject);
            for (let c of cd.components) {
              iface.insertProperty(bioterms_1.Predicates.SBOL3.nondirectional, c.subject);
            }
          }
          return component3;
        }
        function mdTo3Component(md) {
          const existing = map.get(md.subject.value);
          if (existing)
            return existing;
          const component3 = new S3Component_1.default(sbol3View, md.subject);
          component3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Component);
          copyIdentifiedProperties(md, component3);
          component3.setUriProperty("http://sboltools.org/backport#sbol2type", bioterms_1.Types.SBOL2.ModuleDefinition);
          map.set(md.subject.value, component3);
          for (let sm of md.modules) {
            let subComponent3 = new S3SubComponent_1.default(sbol3View, sm.subject);
            subComponent3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.SubComponent);
            copyIdentifiedProperties(sm, subComponent3);
            subComponent3.setUriProperty("http://sboltools.org/backport#sbol2type", bioterms_1.Types.SBOL2.Module);
            let def = map.get(sm.definition.subject.value);
            if (def && def instanceof S3Component_1.default) {
              subComponent3.instanceOf = def;
            } else {
              subComponent3.setUriProperty(bioterms_1.Predicates.SBOL3.instanceOf, sm.definition.subject.value);
            }
            component3.insertUriProperty(bioterms_1.Predicates.SBOL3.hasFeature, subComponent3.subject.value);
            if (sm.measure) {
              subComponent3.setUriProperty(bioterms_1.Predicates.SBOL3.hasMeasure, sm.measure.subject.value);
            }
            map.set(sm.subject.value, subComponent3);
          }
          for (let sc of md.functionalComponents) {
            let subComponent3 = new S3SubComponent_1.default(sbol3View, sc.subject);
            subComponent3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.SubComponent);
            copyIdentifiedProperties(sc, subComponent3);
            subComponent3.setUriProperty("http://sboltools.org/backport#sbol2type", bioterms_1.Types.SBOL2.FunctionalComponent);
            let def = map.get(sc.definition.subject.value);
            if (def && def instanceof S3Component_1.default) {
              subComponent3.instanceOf = def;
            } else {
              subComponent3.setProperty(bioterms_1.Predicates.SBOL3.instanceOf, sc.definition.subject);
            }
            component3.insertProperty(bioterms_1.Predicates.SBOL3.hasFeature, subComponent3.subject);
            if (sc.measure) {
              subComponent3.setProperty(bioterms_1.Predicates.SBOL3.hasMeasure, sc.measure.subject);
            }
            map.set(sc.subject.value, subComponent3);
          }
          for (let int of md.interactions) {
            let newInt = new S3Interaction_1.default(sbol3View, int.subject);
            newInt.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Interaction);
            copyIdentifiedProperties(int, newInt);
            component3.insertProperty(bioterms_1.Predicates.SBOL3.hasInteraction, newInt.subject);
            for (let type of int.types) {
              newInt.insertUriProperty(bioterms_1.Predicates.SBOL3.type, type);
            }
            if (int.measure) {
              newInt.setProperty(bioterms_1.Predicates.SBOL3.hasMeasure, int.measure.subject);
            }
            for (let type of int.types)
              newInt.addType(type);
            for (let participation of int.participations) {
              let newParticipation = new S3Participation_1.default(sbol3View, participation.subject);
              newParticipation.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Participation);
              copyIdentifiedProperties(participation, newParticipation);
              if (participation.measure) {
                newParticipation.setProperty(bioterms_1.Predicates.SBOL3.hasFeature, participation.measure.subject);
              }
              newInt.insertProperty(bioterms_1.Predicates.SBOL3.hasParticipation, newParticipation.subject);
              if (participation.participant) {
                let participant = map.get(participation.participant.subject.value);
                if (!participant || !(participant instanceof S3SubComponent_1.default)) {
                  console.warn("participant not instanceof S3SubComponent");
                  if (participant)
                    console.warn(participant.constructor.name);
                  throw new Error("???");
                }
                newParticipation.setParticipant(participant);
              }
              for (let role of participation.roles) {
                newParticipation.addRole(role);
              }
            }
          }
          for (let model of md.models) {
            component3.addModel(modelToModel(model));
          }
          let interfaceRequired = md.functionalComponents.filter((fc) => fc.direction !== bioterms_1.Specifiers.SBOL2.Direction.None).length > 0;
          if (interfaceRequired) {
            let iface = new S3Interface_1.default(sbol3View, rdfoo_1.node.createUriNode(component3.subject.value + "/interface"));
            iface.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Interface);
            component3.insertProperty(bioterms_1.Predicates.SBOL3.hasInterface, iface.subject);
            for (let fc of md.functionalComponents) {
              switch (fc.direction) {
                case bioterms_1.Specifiers.SBOL2.Direction.Input:
                  iface.insertProperty(bioterms_1.Predicates.SBOL3.input, fc.subject);
                  break;
                case bioterms_1.Specifiers.SBOL2.Direction.Output:
                  iface.insertProperty(bioterms_1.Predicates.SBOL3.output, fc.subject);
                  break;
                case bioterms_1.Specifiers.SBOL2.Direction.InputAndOutput:
                  iface.insertProperty(bioterms_1.Predicates.SBOL3.nondirectional, fc.subject);
                  break;
                case bioterms_1.Specifiers.SBOL2.Direction.None:
                  break;
              }
            }
          }
          return component3;
        }
        for (let typeTriple of graph2.match(null, bioterms_1.Predicates.a, null)) {
          if (typeTriple.object.value.indexOf(bioterms_1.Prefixes.sbol2) === 0) {
            graph2.removeMatches(typeTriple.subject, null, null);
          }
        }
        graph2.replaceSubject(rdfoo_1.node.createUriNode(bioterms_1.Predicates.SBOL2.displayId), rdfoo_1.node.createUriNode(bioterms_1.Predicates.SBOL3.displayId));
        graph2.replaceSubject(rdfoo_1.node.createUriNode(bioterms_1.Predicates.SBOL2.version), rdfoo_1.node.createUriNode("http://sboltools.org/backport#sbol2version"));
        for (let m of newGraph.match(null, "http://sboltools.org/backport#sbol3identity", null)) {
          let currentUri = rdfoo_1.triple.subjectUri(m);
          let actualUri = rdfoo_1.triple.objectUri(m);
          if (currentUri !== actualUri) {
            newGraph.removeMatches(rdfoo_1.node.createUriNode(currentUri), bioterms_1.Predicates.SBOL3.displayId, null);
          }
          newGraph.replaceSubject(rdfoo_1.node.createUriNode(currentUri), rdfoo_1.node.createUriNode(actualUri));
        }
        for (let m of newGraph.match(null, "http://sboltools.org/backport#type", rdfoo_1.node.createUriNode("http://sboltools.org/backport#SplitComponentComposition"))) {
          newGraph.purgeSubject(rdfoo_1.node.createUriNode(rdfoo_1.triple.subjectUri(m)));
        }
        newGraph.removeMatches(null, "http://sboltools.org/backport#sbol3identity", null);
        newGraph.removeMatches(null, "http://sboltools.org/backport#type", null);
        graph2.addAll(newGraph);
        function copyIdentifiedProperties(a, b) {
          let measure = a.getUriProperty(bioterms_1.Predicates.SBOL2.measure);
          if (measure !== void 0) {
            b.setUriProperty(bioterms_1.Predicates.SBOL2.measure, measure);
          }
          let aTriples = graph2.match(a.subject, null, null);
          for (let triple6 of aTriples) {
            let p = triple6.predicate.value;
            if (p === bioterms_1.Predicates.a) {
              continue;
            }
            if (p === bioterms_1.Predicates.Dcterms.title) {
              newGraph.insertTriple(b.subject, bioterms_1.Predicates.SBOL3.name, triple6.object);
              continue;
            }
            if (p === bioterms_1.Predicates.Dcterms.description) {
              newGraph.insertTriple(b.subject, bioterms_1.Predicates.SBOL3.description, triple6.object);
              continue;
            }
            if (p.indexOf(bioterms_1.Prefixes.sbol2) !== 0) {
              newGraph.insertTriple(b.subject, triple6.predicate, triple6.object);
            }
            if (p === bioterms_1.Predicates.SBOL2.persistentIdentity) {
              newGraph.insertTriple(b.subject, "http://sboltools.org/backport#sbol2persistentIdentity", triple6.object);
            } else if (p == bioterms_1.Predicates.SBOL2.displayId) {
              newGraph.insertTriple(b.subject, bioterms_1.Predicates.SBOL3.displayId, triple6.object);
            } else if (p == bioterms_1.Predicates.SBOL2.version) {
              newGraph.insertTriple(b.subject, "http://sboltools.org/backport#sbol2version", triple6.object);
            } else if (p === "http://sboltools.org/backport#sbol3namespace") {
              b.namespace = triple6.object.value;
            }
          }
          if (!b.hasProperty(bioterms_1.Predicates.SBOL3.hasNamespace)) {
            let pid = a.persistentIdentity;
            let did = a.displayId;
            if (pid && did) {
              b.namespace = pid.split(did).join("");
            }
          }
          if (!b.hasProperty(bioterms_1.Predicates.SBOL3.hasNamespace)) {
            let did = a.displayId;
            if (did) {
              let lio = a.uri.lastIndexOf(did);
              b.namespace = a.uri.slice(0, lio);
            }
          }
          if (!b.hasProperty(bioterms_1.Predicates.SBOL3.hasNamespace)) {
            throw new Error("could not work out namespace for " + b.subject.value);
          }
        }
        function copyNonSBOLProperties(a, b) {
          let aTriples = graph2.match(a.subject, null, null);
          for (let triple6 of aTriples) {
            let p = triple6.predicate.value;
            if (p === bioterms_1.Predicates.a) {
              continue;
            }
            if (p === bioterms_1.Predicates.Dcterms.title || p === bioterms_1.Predicates.Dcterms.description) {
              continue;
            }
            if (p.indexOf(bioterms_1.Prefixes.sbol2) !== 0) {
              newGraph.insertTriple(b.subject, triple6.predicate, triple6.object);
            }
          }
        }
        function copyLocations(a, b) {
          for (let location of a.locations) {
            if (location.getUriProperty("http://sboltools.org/backport#type") === "http://sboltools.org/backport#FeatureOrientation") {
              b.orientation = location.orientation;
              continue;
            }
            if (location instanceof S2Range_1.default) {
              const range = location;
              let loc = new __1.S3OrientedLocation(sbol3View, range.subject);
              loc.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Range);
              copyIdentifiedProperties(location, loc);
              copyNonSBOLProperties(location, loc);
              b.insertProperty(bioterms_1.Predicates.SBOL3.hasLocation, loc.subject);
              if (location.sequence) {
                loc.setProperty(bioterms_1.Predicates.SBOL3.hasSequence, location.sequence.subject);
              }
              const start = range.start;
              const end = range.end;
              if (start !== void 0) {
                loc.setIntProperty(bioterms_1.Predicates.SBOL3.start, start);
              }
              if (end !== void 0) {
                loc.setIntProperty(bioterms_1.Predicates.SBOL3.end, end);
              }
              copyOrientation(range, loc);
            } else if (location instanceof __1.S2Cut) {
              const cut = location;
              let loc = new __1.S3OrientedLocation(sbol3View, cut.subject);
              loc.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Cut);
              copyIdentifiedProperties(location, loc);
              b.insertProperty(bioterms_1.Predicates.SBOL3.hasLocation, loc.subject);
              if (location.sequence) {
                loc.setProperty(bioterms_1.Predicates.SBOL3.hasSequence, location.sequence.subject);
              }
              const at = cut.at;
              if (at !== void 0) {
                loc.setIntProperty(bioterms_1.Predicates.SBOL3.at, at);
              }
              copyOrientation(cut, loc);
            } else if (location instanceof S2GenericLocation_1.default) {
              let loc = new __1.S3OrientedLocation(sbol3View, location.subject);
              loc.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.OrientedLocation);
              copyIdentifiedProperties(location, loc);
              b.insertProperty(bioterms_1.Predicates.SBOL3.hasLocation, loc.subject);
              if (location.sequence) {
                loc.setProperty(bioterms_1.Predicates.SBOL3.hasSequence, location.sequence.subject);
              }
              copyOrientation(location, loc);
            } else {
              console.warn("not implemented location type: " + location.subject);
            }
          }
          function copyOrientation(a2, b2) {
            let o = a2.getUriProperty(bioterms_1.Predicates.SBOL2.orientation);
            if (o !== void 0) {
              let o2 = o;
              if (o2 === bioterms_1.Specifiers.SBOL2.Orientation.Inline)
                o2 = bioterms_1.Specifiers.SBOL3.Orientation.Inline;
              else if (o2 === bioterms_1.Specifiers.SBOL2.Orientation.ReverseComplement)
                o2 = bioterms_1.Specifiers.SBOL3.Orientation.ReverseComplement;
              b2.setUriProperty(bioterms_1.Predicates.SBOL3.orientation, o2);
            }
          }
        }
      }
      exports.default = convert2to3;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3EntireSequence.js
  var require_S3EntireSequence = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3EntireSequence.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3OrientedLocation_1 = require_S3OrientedLocation();
      var bioterms_1 = require_dist2();
      var S3EntireSequence = class extends S3OrientedLocation_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.EntireSequence;
        }
        get at() {
          return this.getIntProperty(bioterms_1.Predicates.SBOL3.at);
        }
        set at(n) {
          if (n !== void 0) {
            this.setIntProperty(bioterms_1.Predicates.SBOL3.at, n);
          } else {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.at);
          }
        }
        isFixed() {
          return true;
        }
      };
      exports.default = S3EntireSequence;
    }
  });

  // node_modules/sboljs/dist/sbol3/S3Cut.js
  var require_S3Cut = __commonJS({
    "node_modules/sboljs/dist/sbol3/S3Cut.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var S3OrientedLocation_1 = require_S3OrientedLocation();
      var bioterms_1 = require_dist2();
      var S3Cut = class extends S3OrientedLocation_1.default {
        constructor(view, subject) {
          super(view, subject);
        }
        get facadeType() {
          return bioterms_1.Types.SBOL3.Cut;
        }
        get at() {
          return this.getIntProperty(bioterms_1.Predicates.SBOL3.at);
        }
        set at(n) {
          if (n !== void 0) {
            this.setIntProperty(bioterms_1.Predicates.SBOL3.at, n);
          } else {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.at);
          }
        }
        isFixed() {
          return true;
        }
      };
      exports.default = S3Cut;
    }
  });

  // node_modules/sboljs/dist/SBOL3GraphView.js
  var require_SBOL3GraphView = __commonJS({
    "node_modules/sboljs/dist/SBOL3GraphView.js"(exports) {
      "use strict";
      init_shim();
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sbol3 = void 0;
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S3Interface_1 = require_S3Interface();
      var S3Identified_1 = require_S3Identified();
      var S3Sequence_1 = require_S3Sequence();
      var S3Component_1 = require_S3Component();
      var S3SubComponent_1 = require_S3SubComponent();
      var S3OrientedLocation_1 = require_S3OrientedLocation();
      var S3SequenceFeature_1 = require_S3SequenceFeature();
      var S3Range_1 = require_S3Range();
      var S3Participation_1 = require_S3Participation();
      var S3Interaction_1 = require_S3Interaction();
      var S3Collection_1 = require_S3Collection();
      var S3Model_1 = require_S3Model();
      var S3Implementation_1 = require_S3Implementation();
      var S3Experiment_1 = require_S3Experiment();
      var S3ExperimentalData_1 = require_S3ExperimentalData();
      var S3Measure_1 = require_S3Measure();
      var S3IdentifiedFactory_1 = require_S3IdentifiedFactory();
      var rdfoo_2 = require_dist();
      var toSBOL2_1 = require_toSBOL2();
      var toSBOL3_1 = require_toSBOL3();
      var SBOL2GraphView_1 = require_SBOL2GraphView();
      var rdfoo_prov_1 = require_dist4();
      var isOwnershipRelation_1 = require_isOwnershipRelation();
      var S3Attachment_1 = require_S3Attachment();
      var S3EntireSequence_1 = require_S3EntireSequence();
      var S3Cut_1 = require_S3Cut();
      var S3CombinatorialDerivation_1 = require_S3CombinatorialDerivation();
      var S3VariableFeature_1 = require_S3VariableFeature();
      var S3LocalSubComponent_1 = require_S3LocalSubComponent();
      var S3ExternallyDefined_1 = require_S3ExternallyDefined();
      var S3ComponentReference_1 = require_S3ComponentReference();
      var SBOL3GraphView16 = class extends rdfoo_1.GraphViewHybrid {
        constructor(graph2) {
          super(graph2);
          this.addView(new SBOL3(this));
          this.addView(new rdfoo_prov_1.ProvView(graph2));
        }
        createComponent(uriPrefix, id) {
          const identified = S3IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL3.Component, uriPrefix, id, void 0);
          return new S3Component_1.default(this, identified.subject);
        }
        createCollection(uriPrefix, id) {
          const identified = S3IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL3.Collection, uriPrefix, id, void 0);
          return new S3Collection_1.default(this, identified.subject);
        }
        createSequence(uriPrefix, id) {
          const identified = S3IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL3.Sequence, uriPrefix, id, void 0);
          const seq = new S3Sequence_1.default(this, identified.subject);
          seq.encoding = bioterms_1.Specifiers.SBOL3.SequenceEncoding.NucleicAcid;
          seq.elements = "";
          return seq;
        }
        createModel(uriPrefix, id) {
          const identified = S3IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.Model, uriPrefix, id, void 0);
          const model = new S3Model_1.default(this, identified.subject);
          return model;
        }
        get sequences() {
          return this.instancesOfType(bioterms_1.Types.SBOL3.Sequence).map((subject) => new S3Sequence_1.default(this, subject));
        }
        get components() {
          return this.instancesOfType(bioterms_1.Types.SBOL3.Component).map((subject) => new S3Component_1.default(this, subject));
        }
        get collections() {
          return this.instancesOfType(bioterms_1.Types.SBOL3.Collection).map((subject) => new S3Collection_1.default(this, subject));
        }
        get rootComponents() {
          return this.instancesOfType(bioterms_1.Types.SBOL3.Component).filter((subject) => {
            return !this.graph.hasMatch(null, bioterms_1.Predicates.SBOL3.instanceOf, subject);
          }).map((subject) => new S3Component_1.default(this, subject));
        }
        getInstancesOfComponent(component) {
          return this.graph.match(null, bioterms_1.Predicates.SBOL3.instanceOf, component.subject).map((t) => t.subject).map((subject) => new S3SubComponent_1.default(this, subject));
        }
        getExperiment(subject) {
          if (this.getType(subject) !== bioterms_1.Types.SBOL3.Experiment)
            return null;
          return new S3Experiment_1.default(this, subject);
        }
        get experiments() {
          return this.instancesOfType(bioterms_1.Types.SBOL3.Experiment).map((subject) => new S3Experiment_1.default(this, subject));
        }
        getExperimentalData(subject) {
          if (this.getType(subject) !== bioterms_1.Types.SBOL3.ExperimentalData)
            return null;
          return new S3ExperimentalData_1.default(this, subject);
        }
        get experimentalData() {
          return this.instancesOfType(bioterms_1.Types.SBOL3.ExperimentalData).map((subject) => new S3ExperimentalData_1.default(this, subject));
        }
        get implementations() {
          return this.instancesOfType(bioterms_1.Types.SBOL3.Implementation).map((subject) => new S3Implementation_1.default(this, subject));
        }
        get attachments() {
          return this.instancesOfType(bioterms_1.Types.SBOL3.Attachment).map((subject) => new S3Attachment_1.default(this, subject));
        }
        get measures() {
          return this.instancesOfType(bioterms_1.Types.Measure.Measure).map((subject) => new S3Measure_1.default(this, subject));
        }
        get combinatorialDerivations() {
          return this.instancesOfType(bioterms_1.Types.SBOL3.CombinatorialDerivation).map((subject) => new S3CombinatorialDerivation_1.default(this, subject));
        }
        static loadString(data, defaultURIPrefix, mimeType) {
          return __awaiter(this, void 0, void 0, function* () {
            let graph2 = new SBOL3GraphView16(new rdfoo_1.Graph());
            yield graph2.loadString(data, defaultURIPrefix, mimeType);
            return graph2;
          });
        }
        loadString(data, defaultURIPrefix, mimeType) {
          return __awaiter(this, void 0, void 0, function* () {
            let filetype = (0, rdfoo_2.identifyFiletype)(data, mimeType || null);
            if (filetype === rdfoo_2.Filetype.RDFXML || filetype === rdfoo_2.Filetype.NTriples) {
              yield (0, rdfoo_1.parseRDF)(this.graph, data, filetype);
              (0, toSBOL2_1.default)(this.graph);
              (0, toSBOL3_1.default)(this.graph);
              return;
            }
            defaultURIPrefix = defaultURIPrefix || "http://converted/";
            if (filetype === rdfoo_2.Filetype.FASTA || filetype == rdfoo_2.Filetype.GenBank) {
              let g2 = yield SBOL2GraphView_1.default.loadString(data, defaultURIPrefix, mimeType);
              this.graph.addAll(g2.graph);
              (0, toSBOL3_1.default)(this.graph);
              return;
            }
            throw new Error("Unknown format");
          });
        }
        serializeXML() {
          let defaultPrefixes = [
            ["rdf", bioterms_1.Prefixes.rdf],
            ["dcterms", bioterms_1.Prefixes.dcterms],
            ["prov", bioterms_1.Prefixes.prov],
            ["sbol", bioterms_1.Prefixes.sbol2],
            ["sbol1", bioterms_1.Prefixes.sbol1],
            ["sbol3", bioterms_1.Prefixes.sbol3],
            ["backport", "http://sboltools.org/backport#"],
            ["om", bioterms_1.Prefixes.measure],
            ["synbiohub", "http://wiki.synbiohub.org/wiki/Terms/synbiohub#"],
            ["igem", "http://wiki.synbiohub.org/wiki/Terms/igem#"],
            ["dc", "http://purl.org/dc/elements/1.1/"]
          ];
          return (0, rdfoo_1.serialize)(this.graph, new Map(defaultPrefixes), (t) => (0, isOwnershipRelation_1.default)(this.graph, t), bioterms_1.Prefixes.sbol3);
        }
        get topLevels() {
          const topLevels = [];
          Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL3.Component));
          Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL3.Sequence));
          Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL3.Collection));
          return topLevels.map((topLevel) => this.subjectToFacade(topLevel));
        }
        get uriPrefixes() {
          let topLevels = this.topLevels;
          let prefixes = {};
          topLevels.forEach((topLevel) => {
            let prefix = topLevel.uriPrefix;
            if (prefixes[prefix] === void 0)
              prefixes[prefix] = 1;
            else
              ++prefixes[prefix];
          });
          return Object.keys(prefixes).sort((a, b) => {
            return prefixes[b] - prefixes[a];
          });
        }
        get mostPopularUriPrefix() {
          return this.uriPrefixes[0];
        }
        getTopLevelsWithPrefix(prefix) {
          const topLevels = this.topLevels;
          return this.topLevels.filter((topLevel) => {
            return topLevel.subject.value.indexOf(prefix) === 0;
          });
        }
        uriToIdentified(subject) {
          let f = this.subjectToFacade(subject);
          if (f instanceof S3Identified_1.default)
            return f;
          else
            return void 0;
        }
        findClosestTopLevel(_subject) {
          var subject = _subject;
          var subjectTypes = this.getTypes(subject);
          while (!isTopLevel()) {
            let identified = subject && this.uriToIdentified(subject);
            if (identified === void 0)
              throw new Error("???");
            identified = identified.owningObject;
            if (identified === void 0) {
              return void 0;
            }
            subject = identified.subject;
            subjectTypes = this.getTypes(subject);
          }
          return subject;
          function isTopLevel() {
            return subjectTypes.indexOf(bioterms_1.Types.SBOL3.Component) !== -1 || subjectTypes.indexOf(bioterms_1.Types.SBOL3.Sequence) !== -1;
          }
        }
        changeURIPrefix(newPrefix) {
          let topLevels = /* @__PURE__ */ new Set([
            bioterms_1.Types.SBOL3.Collection,
            bioterms_1.Types.SBOL3.Component,
            bioterms_1.Types.SBOL3.Sequence,
            bioterms_1.Types.SBOL3.Model,
            bioterms_1.Types.SBOL3.CombinatorialDerivation,
            bioterms_1.Types.Prov.Plan,
            bioterms_1.Types.Prov.Agent,
            bioterms_1.Types.Prov.Activity
          ]);
          return (0, rdfoo_1.changeURIPrefix)(this.graph, topLevels, newPrefix);
        }
        nameToDisplayId(name) {
          return name.replace(/\s/, "_");
        }
        printTree() {
          for (let cd of this.components) {
            console.log("component:" + cd.subject + " (" + cd.displayId + ")");
            for (let c of cd.subComponents) {
              console.log(indent22(1) + "sc-> " + c.instanceOf.subject);
            }
          }
          function indent22(n) {
            return "        ".slice(8 - n);
          }
        }
        get namespaces() {
          return new Set(this.graph.match(null, bioterms_1.Predicates.SBOL3.hasNamespace, null).map((t) => t.object).map((n) => n.value));
        }
      };
      exports.default = SBOL3GraphView16;
      var SBOL3 = class extends rdfoo_1.GraphViewBasic {
        constructor(view) {
          super(view.graph);
          this.view = view;
        }
        subjectToFacade(subject) {
          if (!subject)
            return void 0;
          const types = this.getTypes(subject);
          for (var i = 0; i < types.length; ++i) {
            let type = types[i];
            if (type === bioterms_1.Types.SBOL3.Component)
              return new S3Component_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.SubComponent)
              return new S3SubComponent_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.Interaction)
              return new S3Interaction_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.Participation)
              return new S3Participation_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.Range)
              return new S3Range_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.Cut)
              return new S3Cut_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.EntireSequence)
              return new S3EntireSequence_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.OrientedLocation)
              return new S3OrientedLocation_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.SequenceFeature)
              return new S3SequenceFeature_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.Sequence)
              return new S3Sequence_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.Collection)
              return new S3Collection_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.Model)
              return new S3Model_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.Implementation)
              return new S3Implementation_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.Experiment)
              return new S3Experiment_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.ExperimentalData)
              return new S3ExperimentalData_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.Attachment)
              return new S3Attachment_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.CombinatorialDerivation)
              return new S3CombinatorialDerivation_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.VariableFeature)
              return new S3VariableFeature_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.Interface)
              return new S3Interface_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.LocalSubComponent)
              return new S3LocalSubComponent_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL3.ExternallyDefined)
              return new S3ExternallyDefined_1.default(this.view, subject);
            if (type === bioterms_1.Prefixes.sbol3 + "ComponentReference")
              return new S3ComponentReference_1.default(this.view, subject);
          }
          return super.subjectToFacade(subject);
        }
      };
      function sbol33(graph2) {
        return new SBOL3GraphView16(graph2);
      }
      exports.sbol3 = sbol33;
    }
  });

  // node_modules/sboljs/dist/conversion/fromSBOL3/toSBOL2.js
  var require_toSBOL22 = __commonJS({
    "node_modules/sboljs/dist/conversion/fromSBOL3/toSBOL2.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var SBOL2GraphView_1 = require_SBOL2GraphView();
      var SBOL3GraphView_1 = require_SBOL3GraphView();
      var S2ComponentDefinition_1 = require_S2ComponentDefinition();
      var S3Range_1 = require_S3Range();
      var S3OrientedLocation_1 = require_S3OrientedLocation();
      var S2ModuleDefinition_1 = require_S2ModuleDefinition();
      var S2FunctionalComponent_1 = require_S2FunctionalComponent();
      var S2SequenceAnnotation_1 = require_S2SequenceAnnotation();
      var S2GenericLocation_1 = require_S2GenericLocation();
      var S2Experiment_1 = require_S2Experiment();
      var S2ExperimentalData_1 = require_S2ExperimentalData();
      var S2Range_1 = require_S2Range();
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S2IdentifiedFactory_1 = require_S2IdentifiedFactory();
      var URIUtils_1 = require_URIUtils();
      var S2Sequence_1 = require_S2Sequence();
      var __1 = require_dist5();
      var S3Cut_1 = require_S3Cut();
      var S2CombinatorialDerivation_1 = require_S2CombinatorialDerivation();
      var S2VariableComponent_1 = require_S2VariableComponent();
      function convert3to2(graph2) {
        let newGraph = new rdfoo_1.Graph();
        let sbol3View = new SBOL3GraphView_1.default(graph2);
        let sbol2View = new SBOL2GraphView_1.default(newGraph);
        let dontPrune = /* @__PURE__ */ new Set();
        for (let ed of sbol3View.experimentalData) {
          let ed2 = new S2ExperimentalData_1.default(sbol2View, ed.subject);
          ed2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.ExperimentalData);
          copyIdentifiedProperties(ed, ed2);
        }
        for (let ex of sbol3View.experiments) {
          let ex2 = new S2Experiment_1.default(sbol2View, ex.subject);
          ex2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Experiment);
          copyIdentifiedProperties(ex, ex2);
          for (let ed of ex.experimentalData) {
            ex2.insertProperty(bioterms_1.Predicates.SBOL2.experimentalData, ed.subject);
          }
        }
        for (let seq of sbol3View.sequences) {
          let seq2 = new S2Sequence_1.default(sbol2View, seq.subject);
          seq2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Sequence);
          copyIdentifiedProperties(seq, seq2);
          seq2.elements = seq.elements;
          seq2.encoding = seq.encoding;
        }
        for (let att of sbol3View.attachments) {
          let att2 = new __1.S2Attachment(sbol2View, att.subject);
          att2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Attachment);
          copyIdentifiedProperties(att, att2);
          att2.source = att.source;
          att2.format = att.format;
          att2.hash = att.hash;
          att2.size = att.size;
        }
        for (let cd of sbol3View.combinatorialDerivations) {
          let cd2 = new S2CombinatorialDerivation_1.default(sbol2View, cd.subject);
          cd2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.CombinatorialDerivation);
          copyIdentifiedProperties(cd, cd2);
          if (cd.strategy)
            cd2.strategy = cd.strategy.split(bioterms_1.Prefixes.sbol3).join(bioterms_1.Prefixes.sbol2);
          cd2.insertProperty(bioterms_1.Predicates.SBOL2.template, cd.template.subject);
          for (let vc of cd.variableFeatures) {
            cd2.insertProperty(bioterms_1.Predicates.SBOL2.variableComponent, vc.subject);
            let vc2 = new S2VariableComponent_1.default(sbol2View, vc.subject);
            vc2.insertUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.VariableComponent);
            copyIdentifiedProperties(vc, vc2);
            vc2.operator = vc.cardinality.split(bioterms_1.Prefixes.sbol3).join(bioterms_1.Prefixes.sbol2);
            for (let variant of vc.variants) {
              vc2.insertProperty(bioterms_1.Predicates.SBOL2.variant, variant.subject);
            }
            for (let coll of vc.variantCollections) {
              vc2.insertProperty(bioterms_1.Predicates.SBOL2.variantCollection, coll.subject);
            }
            for (let d of vc.variantDerivations) {
              vc2.insertProperty(bioterms_1.Predicates.SBOL2.variantCollection, d.subject);
            }
            vc2.setProperty(bioterms_1.Predicates.SBOL2.variable, vc.variable.subject);
          }
        }
        let componentToCDandMD = /* @__PURE__ */ new Map();
        let subcomponentToFC = /* @__PURE__ */ new Map();
        function getCDandMD(componentsubject) {
          let mapping = componentToCDandMD.get(componentsubject.value);
          if (!mapping) {
            console.warn(componentsubject.value + " has no cd/md mapping?");
          }
          return mapping;
        }
        for (let component of sbol3View.components) {
          let cdUri = component.subject.value;
          let mdUri = component.subject.value;
          let cdSuffix = "_component";
          let mdSuffix = "_module";
          let backportType = component.getUriProperty("http://sboltools.org/backport#sbol2type");
          if (backportType) {
            switch (backportType) {
              case bioterms_1.Types.SBOL2.ModuleDefinition:
                mdSuffix = "";
                break;
              case bioterms_1.Types.SBOL2.ComponentDefinition:
              default:
                cdSuffix = "";
                break;
            }
          }
          if (mdSuffix && cdSuffix) {
            if (component.interactions.length > 0) {
              mdSuffix = "";
            } else {
              cdSuffix = "";
            }
          }
          if (cdSuffix !== "")
            cdUri = URIUtils_1.default.addSuffix(cdUri, cdSuffix);
          if (mdSuffix !== "")
            mdUri = URIUtils_1.default.addSuffix(mdUri, mdSuffix);
          switch (component.getUriProperty("http://sboltools.org/backport#sbol2type")) {
            case bioterms_1.Types.SBOL2.ModuleDefinition:
              dontPrune.add(mdUri);
              break;
            case bioterms_1.Types.SBOL2.ComponentDefinition:
              dontPrune.add(cdUri);
              break;
          }
          let cd = new S2ComponentDefinition_1.default(sbol2View, rdfoo_1.node.createUriNode(cdUri));
          cd.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.ComponentDefinition);
          copyIdentifiedProperties(component, cd);
          cd.displayId = displayId(component) + cdSuffix;
          let md = new S2ModuleDefinition_1.default(sbol2View, rdfoo_1.node.createUriNode(mdUri));
          md.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.ModuleDefinition);
          copyIdentifiedProperties(component, md);
          md.displayId = displayId(component) + mdSuffix;
          md.setProperty("http://sboltools.org/backport#sbol3identity", component.subject);
          cd.setProperty("http://sboltools.org/backport#sbol3identity", component.subject);
          if (md.persistentIdentity && mdSuffix)
            md.persistentIdentity = URIUtils_1.default.addSuffix(md.persistentIdentity, mdSuffix);
          if (cd.persistentIdentity && cdSuffix)
            cd.persistentIdentity = URIUtils_1.default.addSuffix(cd.persistentIdentity, cdSuffix);
          let fcUri = (md.persistentIdentity || md.subject.value) + "/" + displayId(component);
          let fc = new S2FunctionalComponent_1.default(sbol2View, rdfoo_1.node.createUriNode(fcUri));
          fc.insertUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.FunctionalComponent);
          fc.setStringProperty(bioterms_1.Predicates.SBOL2.displayId, displayId(component));
          fc.setProperty(bioterms_1.Predicates.SBOL2.definition, cd.subject);
          fc.insertUriProperty("http://sboltools.org/backport#type", "http://sboltools.org/backport#SplitComponentComposition");
          md.addFunctionalComponent(fc);
          for (let role of component.roles) {
            cd.addRole(role);
          }
          for (let type of component.types) {
            cd.addType(type);
          }
          for (let seq of component.sequences) {
            cd.insertProperty(bioterms_1.Predicates.SBOL2.sequence, seq.subject);
          }
          for (let feature of component.sequenceFeatures) {
            let sa = new S2SequenceAnnotation_1.default(sbol2View, feature.subject);
            sa.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.SequenceAnnotation);
            copyIdentifiedProperties(feature, sa);
            cd.insertProperty(bioterms_1.Predicates.SBOL2.sequenceAnnotation, sa.subject);
            for (let role of feature.roles) {
              sa.addRole(role);
            }
            copyLocations(sbol2View, feature, sa);
          }
          componentToCDandMD.set(component.subject.value, { cd, md, fc, mdSuffix, cdSuffix });
        }
        for (let component of sbol3View.components) {
          let mapping = getCDandMD(component.subject);
          if (!mapping) {
            throw new Error("???");
          }
          let { cd, md, fc } = mapping;
          for (let subcomponent of component.subComponents) {
            let instanceOf = subcomponent.instanceOf;
            let newDefOfSubcomponent = getCDandMD(instanceOf.subject);
            if (newDefOfSubcomponent === void 0) {
              throw new Error("???");
            }
            var cdSubcomponentURI, mdSubcomponentURI, mdSubmoduleURI;
            switch (subcomponent.getUriProperty("http://sboltools.org/backport#sbol2type")) {
              case bioterms_1.Types.SBOL2.Module:
                mdSubmoduleURI = subcomponent.subject.value;
                cdSubcomponentURI = URIUtils_1.default.addSuffix(subcomponent.subject.value, "_c");
                mdSubcomponentURI = URIUtils_1.default.addSuffix(subcomponent.subject.value, "_fc");
                break;
              case bioterms_1.Types.SBOL2.FunctionalComponent:
                mdSubcomponentURI = subcomponent.subject.value;
                cdSubcomponentURI = URIUtils_1.default.addSuffix(subcomponent.subject.value, "_c");
                mdSubmoduleURI = URIUtils_1.default.addSuffix(subcomponent.subject.value, "_m");
                break;
              case bioterms_1.Types.SBOL2.Component:
              default:
                cdSubcomponentURI = subcomponent.subject.value;
                mdSubcomponentURI = URIUtils_1.default.addSuffix(subcomponent.subject.value, "_fc");
                mdSubmoduleURI = URIUtils_1.default.addSuffix(subcomponent.subject.value, "_m");
                break;
            }
            let cdSubcomponent = new __1.S2ComponentInstance(sbol2View, rdfoo_1.node.createUriNode(cdSubcomponentURI));
            cdSubcomponent.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Component);
            cdSubcomponent.definition = newDefOfSubcomponent.cd;
            cdSubcomponent.setProperty("http://sboltools.org/backport#sbol3identity", subcomponent.subject);
            cd.insertProperty(bioterms_1.Predicates.SBOL2.component, cdSubcomponent.subject);
            let mdSubcomponent = new S2FunctionalComponent_1.default(sbol2View, rdfoo_1.node.createUriNode(mdSubcomponentURI));
            mdSubcomponent.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.FunctionalComponent);
            mdSubcomponent.definition = newDefOfSubcomponent.cd;
            mdSubcomponent.setProperty("http://sboltools.org/backport#sbol3identity", subcomponent.subject);
            md.insertProperty(bioterms_1.Predicates.SBOL2.functionalComponent, mdSubcomponent.subject);
            let mdSubmodule = new __1.S2ModuleInstance(sbol2View, rdfoo_1.node.createUriNode(mdSubmoduleURI));
            mdSubmodule.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Module);
            mdSubmodule.definition = newDefOfSubcomponent.md;
            mdSubmodule.setProperty("http://sboltools.org/backport#sbol3identity", subcomponent.subject);
            md.insertProperty(bioterms_1.Predicates.SBOL2.module, mdSubmodule.subject);
            let iface = subcomponent.containingInterface;
            if (!iface) {
              cdSubcomponent.setUriProperty(bioterms_1.Predicates.SBOL2.access, bioterms_1.Specifiers.SBOL2.Access.PrivateAccess);
              mdSubcomponent.setUriProperty(bioterms_1.Prefixes.sbol2 + "direction", bioterms_1.Specifiers.SBOL2.Direction.None);
            } else {
              cdSubcomponent.setUriProperty(bioterms_1.Predicates.SBOL2.access, bioterms_1.Specifiers.SBOL2.Access.PublicAccess);
              let isInput = graph2.hasMatch(iface.subject, bioterms_1.Predicates.SBOL3.input, subcomponent.subject);
              let isOutput = graph2.hasMatch(iface.subject, bioterms_1.Predicates.SBOL3.output, subcomponent.subject);
              let isNondir = graph2.hasMatch(iface.subject, bioterms_1.Predicates.SBOL3.nondirectional, subcomponent.subject);
              if (isInput) {
                mdSubcomponent.setUriProperty(bioterms_1.Prefixes.sbol2 + "direction", bioterms_1.Specifiers.SBOL2.Direction.Input);
              } else if (isOutput) {
                mdSubcomponent.setUriProperty(bioterms_1.Prefixes.sbol2 + "direction", bioterms_1.Specifiers.SBOL2.Direction.Output);
              } else {
                mdSubcomponent.setUriProperty(bioterms_1.Prefixes.sbol2 + "direction", bioterms_1.Specifiers.SBOL2.Direction.InputAndOutput);
              }
            }
            switch (subcomponent.getUriProperty("http://sboltools.org/backport#sbol2type")) {
              case bioterms_1.Types.SBOL2.Module:
                copyIdentifiedProperties(subcomponent, mdSubmodule);
                break;
              case bioterms_1.Types.SBOL2.FunctionalComponent:
                copyIdentifiedProperties(subcomponent, mdSubcomponent);
                break;
              case bioterms_1.Types.SBOL2.Component:
                copyIdentifiedProperties(subcomponent, cdSubcomponent);
                break;
              default:
                copyIdentifiedProperties(subcomponent, mdSubcomponent);
                copyIdentifiedProperties(subcomponent, cdSubcomponent);
                break;
            }
            subcomponentToFC.set(subcomponent.subject.value, mdSubcomponent);
            if (subcomponent.measure)
              mdSubcomponent.setProperty(bioterms_1.Predicates.SBOL2.measure, subcomponent.measure.subject);
            if (subcomponent.sourceLocation) {
              cdSubcomponent.setProperty(bioterms_1.Predicates.SBOL3.sourceLocation, subcomponent.sourceLocation.subject);
            }
            if (subcomponent.locations.length > 0 || subcomponent.orientation) {
              let saDisplayId = subcomponent.getStringProperty("http://sboltools.org/backport#sequenceAnnotationDisplayId");
              if (!saDisplayId) {
                saDisplayId = displayId(subcomponent) + "_anno";
              }
              let saIdent = S2IdentifiedFactory_1.default.createChild(sbol2View, bioterms_1.Types.SBOL2.SequenceAnnotation, cd, bioterms_1.Predicates.SBOL2.sequenceAnnotation, saDisplayId, subcomponent.getStringProperty(bioterms_1.Predicates.SBOL2.version));
              let sa = new S2SequenceAnnotation_1.default(sbol2View, saIdent.subject);
              sa.setProperty(bioterms_1.Predicates.SBOL2.component, subcomponent.subject);
              let orientLoc = sa.addLocationGeneric(subcomponent.orientation);
              orientLoc.setUriProperty("http://sboltools.org/backport#type", "http://sboltools.org/backport#FeatureOrientation");
              copyLocations(sbol2View, subcomponent, sa);
            }
          }
          for (let localSc of component.localSubComponents) {
            let localCd = sbol2View.createComponentDefinition(cd.uriPrefix, localSc.displayName || "local", "1");
            localCd.setUriProperty("http://sboltools.org/backport#type", "http://sboltools.org/backport#LocalSubComponentDefinition");
            for (let type of localSc.types) {
              localCd.addType(type);
            }
            cd.addComponentByDefinition(localCd);
            md.createFunctionalComponent(localCd);
          }
          for (let extDef of component.externalDefinitions) {
          }
        }
        for (let component of sbol3View.components) {
          let mapping = getCDandMD(component.subject);
          if (!mapping) {
            throw new Error("???");
          }
          let { cd, md, fc, cdSuffix, mdSuffix } = mapping;
          for (let interaction of component.interactions) {
            let newInteraction = md.createInteraction(displayId(interaction), interaction.getStringProperty(bioterms_1.Predicates.SBOL2.version));
            copyIdentifiedProperties(interaction, newInteraction);
            if (interaction.measure) {
              newInteraction.setProperty(bioterms_1.Predicates.SBOL2.measure, interaction.measure.subject);
            }
            for (let type of interaction.types) {
              newInteraction.insertUriProperty(bioterms_1.Predicates.SBOL2.type, type);
            }
            for (let participation of interaction.participations) {
              let newParticipation = newInteraction.createParticipation(displayId(participation), participation.getStringProperty(bioterms_1.Predicates.SBOL2.version));
              copyIdentifiedProperties(participation, newParticipation);
              if (participation.measure) {
                newParticipation.setProperty(bioterms_1.Predicates.SBOL2.measure, participation.measure.subject);
              }
              for (let role of participation.roles) {
                newParticipation.addRole(role);
              }
              let participant = participation.participant;
              if (participant) {
                let newParticipant = subcomponentToFC.get(participant.subject.value);
                newParticipation.participant = newParticipant;
              }
            }
          }
        }
        for (let impl of sbol3View.implementations) {
          const impl2 = new __1.S2Implementation(sbol2View, impl.subject);
          impl2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Implementation);
          copyIdentifiedProperties(impl, impl2);
          impl2.setUriProperty(bioterms_1.Predicates.SBOL2.built, impl.getUriProperty(bioterms_1.Predicates.SBOL3.built));
        }
        for (let coll of sbol3View.collections) {
          let coll2 = new __1.S2Collection(sbol2View, coll.subject);
          coll2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Collection);
          copyIdentifiedProperties(coll, coll2);
          for (let member of coll.members) {
            coll2.insertProperty(bioterms_1.Predicates.SBOL2.member, member.subject);
            let cdAndMdMapping = componentToCDandMD.get(member.subject.value);
            if (cdAndMdMapping) {
              coll2.insertProperty(bioterms_1.Predicates.SBOL2.member, cdAndMdMapping.cd.subject);
              coll2.insertProperty(bioterms_1.Predicates.SBOL2.member, cdAndMdMapping.md.subject);
            }
          }
        }
        for (let c of sbol3View.components) {
          let hadInterface = false;
          for (let iface of c.interfaces) {
            hadInterface = true;
            for (let input of iface.inputs) {
              let fc = subcomponentToFC.get(input.subject.value);
              fc.direction = bioterms_1.Specifiers.SBOL2.Direction.Input;
            }
            for (let output of iface.outputs) {
              let fc = subcomponentToFC.get(output.subject.value);
              if (fc.direction === bioterms_1.Specifiers.SBOL2.Direction.Input) {
                fc.direction = bioterms_1.Specifiers.SBOL2.Direction.InputAndOutput;
              } else if (fc.direction != bioterms_1.Specifiers.SBOL2.Direction.InputAndOutput) {
                fc.direction = bioterms_1.Specifiers.SBOL2.Direction.Output;
              }
            }
            for (let nd of iface.nondirectionals) {
              console.log("sc to fc get " + nd.subject.value);
              let fc = subcomponentToFC.get(nd.subject.value);
              fc.direction = bioterms_1.Specifiers.SBOL2.Direction.None;
            }
          }
          if (!hadInterface) {
            for (let sc of c.subComponents) {
              let fc = subcomponentToFC.get(sc.subject.value);
              fc.setUriProperty("http://sbols.org/v2#direction", bioterms_1.Specifiers.SBOL2.Direction.InputAndOutput);
            }
          }
        }
        for (let mapping of componentToCDandMD) {
          let componentUri = mapping[0];
          let { md, cd, fc, cdSuffix, mdSuffix } = mapping[1];
          let mdPruned = false, cdPruned = false;
          if (!dontPrune.has(md.subject.value)) {
            if (md.interactions.length === 0 && md.models.length === 0 && md.measures.length === 0) {
              md.destroy();
              mdPruned = true;
            }
          }
          if (!mdPruned && !dontPrune.has(cd.subject.value)) {
            if (cd.containedObjects.length === 0) {
              cd.destroy();
              cdPruned = true;
            }
          }
          if (mdPruned && !cdPruned) {
            if (cdSuffix.length > 0) {
              if (!cd.subject.value.endsWith(cdSuffix)) {
                throw new Error("wrong suffix");
              }
              if (!cd.displayId.endsWith(cdSuffix)) {
                throw new Error("wrong suffix");
              }
              let newDisplayid = cd.displayId.substr(0, cd.displayId.length - cdSuffix.length);
              cd.displayId = newDisplayid;
              let newUri = cd.subject.value.substr(0, cd.subject.value.length - cdSuffix.length);
              newGraph.replaceSubject(cd.subject, rdfoo_1.node.createUriNode(newUri));
            }
          } else if (cdPruned && !mdPruned) {
            if (mdSuffix.length > 0) {
              if (!md.subject.value.endsWith(mdSuffix)) {
                throw new Error("wrong suffix");
              }
              if (!md.displayId.endsWith(mdSuffix)) {
                throw new Error("wrong suffix");
              }
              let newDisplayid = md.displayId.substr(0, md.displayId.length - mdSuffix.length);
              md.displayId = newDisplayid;
              let newUri = md.subject.value.substr(0, md.subject.value.length - mdSuffix.length);
              newGraph.replaceSubject(md.subject, rdfoo_1.node.createUriNode(newUri));
            }
          }
        }
        for (let typeTriple of graph2.match(null, bioterms_1.Predicates.a, null)) {
          if (typeTriple.object.value.indexOf(bioterms_1.Prefixes.sbol3) === 0) {
            graph2.removeMatches(typeTriple.subject, null, null);
          }
        }
        graph2.replaceSubject(rdfoo_1.node.createUriNode(bioterms_1.Predicates.SBOL3.persistentIdentity), rdfoo_1.node.createUriNode(bioterms_1.Predicates.SBOL2.persistentIdentity));
        graph2.replaceSubject(rdfoo_1.node.createUriNode(bioterms_1.Predicates.SBOL3.displayId), rdfoo_1.node.createUriNode(bioterms_1.Predicates.SBOL2.displayId));
        graph2.replaceSubject(rdfoo_1.node.createUriNode("http://sboltools.org/backport#sbol2version"), rdfoo_1.node.createUriNode(bioterms_1.Predicates.SBOL2.version));
        graph2.addAll(newGraph);
        function copyIdentifiedProperties(a, b) {
          if (a.hasProperty("http://sboltools.org/backport#sbol2persistentIdentity")) {
            b.setUriProperty(bioterms_1.Predicates.SBOL2.persistentIdentity, a.getUriProperty("http://sboltools.org/backport#sbol2persistentIdentity"));
          } else {
            b.setUriProperty(bioterms_1.Predicates.SBOL2.persistentIdentity, a.subject.value);
          }
          if (a.namespace)
            b.setUriProperty("http://sboltools.org/backport#sbol3namespace", a.namespace);
          let aTriples = graph2.match(a.subject, null, null);
          for (let triple6 of aTriples) {
            let p = triple6.predicate.value;
            if (p === bioterms_1.Predicates.a) {
              continue;
            }
            if (p === bioterms_1.Predicates.SBOL3.displayId) {
              b.graph.insertTriple(b.subject, bioterms_1.Predicates.SBOL2.displayId, triple6.object);
              continue;
            }
            if (p === bioterms_1.Predicates.SBOL3.name) {
              b.graph.insertTriple(b.subject, bioterms_1.Predicates.Dcterms.title, triple6.object);
              continue;
            }
            if (p === bioterms_1.Predicates.SBOL3.description) {
              b.graph.insertTriple(b.subject, bioterms_1.Predicates.Dcterms.description, triple6.object);
              continue;
            }
            if (p === bioterms_1.Predicates.SBOL3.hasMeasure) {
              b.graph.insertTriple(b.subject, bioterms_1.Predicates.SBOL2.measure, triple6.object);
              continue;
            }
            if (p === "http://sboltools.org/backport#sbol2version") {
              b.graph.insertTriple(b.subject, bioterms_1.Predicates.SBOL2.version, triple6.object);
              continue;
            }
            if (p.indexOf("http://sboltools.org/backport") !== -1) {
              continue;
            }
            if (p.indexOf(bioterms_1.Prefixes.sbol3) !== 0) {
              b.graph.insertTriple(b.subject, triple6.predicate, triple6.object);
            }
          }
        }
        function copyLocations(sbol2View2, oldThing, newThing) {
          for (let location of oldThing.locations) {
            let copyOrientation = function(a, b) {
              let o = a.getUriProperty(bioterms_1.Predicates.SBOL3.orientation);
              if (o !== void 0) {
                let o2 = o;
                if (o2 === bioterms_1.Specifiers.SBOL3.Orientation.Inline)
                  o2 = bioterms_1.Specifiers.SBOL2.Orientation.Inline;
                else if (o2 === bioterms_1.Specifiers.SBOL3.Orientation.ReverseComplement)
                  o2 = bioterms_1.Specifiers.SBOL2.Orientation.ReverseComplement;
                b.setUriProperty(bioterms_1.Predicates.SBOL2.orientation, o2);
              }
            };
            if (location instanceof S3Range_1.default) {
              let newLoc = new S2Range_1.default(sbol2View2, location.subject);
              newLoc.insertUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Range);
              copyIdentifiedProperties(location, newLoc);
              newThing.insertProperty(bioterms_1.Predicates.SBOL2.location, newLoc.subject);
              if (location.sequence) {
                newLoc.setProperty(bioterms_1.Predicates.SBOL2.sequence, location.sequence.subject);
              }
              newLoc.start = location.start;
              newLoc.end = location.end;
              copyOrientation(location, newLoc);
            } else if (location instanceof S3Cut_1.default) {
              let newLoc = new __1.S2Cut(sbol2View2, location.subject);
              newLoc.insertUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Cut);
              copyIdentifiedProperties(location, newLoc);
              newThing.insertProperty(bioterms_1.Predicates.SBOL2.location, newLoc.subject);
              if (location.sequence) {
                newLoc.setProperty(bioterms_1.Predicates.SBOL2.sequence, location.sequence.subject);
              }
              newLoc.at = location.at;
              newLoc.orientation = location.orientation === bioterms_1.Specifiers.SBOL3.Orientation.ReverseComplement ? bioterms_1.Specifiers.SBOL2.Orientation.ReverseComplement : bioterms_1.Specifiers.SBOL2.Orientation.Inline;
              copyOrientation(location, newLoc);
            } else if (location instanceof S3OrientedLocation_1.default) {
              let newLoc = new S2GenericLocation_1.default(sbol2View2, location.subject);
              newLoc.insertUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.GenericLocation);
              copyIdentifiedProperties(location, newLoc);
              newThing.insertProperty(bioterms_1.Predicates.SBOL2.location, newLoc.subject);
              if (location.sequence) {
                newLoc.setProperty(bioterms_1.Predicates.SBOL2.sequence, location.sequence.subject);
              }
              copyOrientation(location, newLoc);
            } else {
              throw new Error("not implemented location type");
            }
          }
        }
      }
      exports.default = convert3to2;
      function displayId(obj) {
        let displayId2 = obj.displayId;
        if (displayId2) {
          return displayId2;
        }
        let hasSlash = obj.subject.value.indexOf("/") !== -1;
        let hasHash = obj.subject.value.indexOf("#") !== -1;
        let slash = hasSlash && obj.subject.value.split("/").pop() || "";
        let hash = hasHash && obj.subject.value.split("#").pop() || "";
        return slash.length > hash.length ? slash : hash;
      }
    }
  });

  // node_modules/sboljs/dist/conversion/enforceURICompliance.js
  var require_enforceURICompliance = __commonJS({
    "node_modules/sboljs/dist/conversion/enforceURICompliance.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var bioterms_1 = require_dist2();
      var URIUtils_1 = require_URIUtils();
      var SBOL2GraphView_1 = require_SBOL2GraphView();
      var rdfoo_1 = require_dist();
      function enforceURICompliance(g, uriPrefix) {
        var p_id, p_version, p_persistentIdentity;
        if (g instanceof SBOL2GraphView_1.default) {
          p_id = bioterms_1.Predicates.SBOL2.displayId;
          p_version = bioterms_1.Predicates.SBOL2.version;
          p_persistentIdentity = bioterms_1.Predicates.SBOL2.persistentIdentity;
        } else {
          throw new Error("sbol3 not supported");
        }
        for (let topLevel of g.topLevels) {
          let version = topLevel.version;
          if (version === void 0) {
            topLevel.version = version = "1";
          }
          addMissingProperties(topLevel, version);
        }
        for (let topLevel of g.topLevels) {
          replaceURIs(topLevel, uriPrefix);
        }
        function replaceURIs(object, prefix) {
          let persistentIdentity = prefix + object.getStringProperty(p_id);
          let newURI = persistentIdentity + "/" + object.getStringProperty(p_version);
          object.persistentIdentity = persistentIdentity;
          let contained = object.containedObjects;
          g.graph.replaceSubject(object.subject, rdfoo_1.node.createUriNode(newURI));
          for (let child of contained) {
            replaceURIs(child, persistentIdentity + "/");
          }
        }
        function addMissingProperties(object, version) {
          object.version = version;
          let id = object.getStringProperty(p_id);
          if (id === void 0) {
            object.setStringProperty(p_id, makeUpID(object));
          }
          for (let child of object.containedObjects) {
            addMissingProperties(child, version);
          }
        }
        function makeUpID(object) {
          let name = object.name;
          if (name) {
            name = sanitize(name);
            if (name && name !== "") {
              return name;
            }
          }
          name = sanitize(URIUtils_1.default.getSuffix(object.subject.value));
          if (name && name !== "") {
            return name;
          }
          return (object.facadeType.split("#").pop() || "anon").toLowerCase();
          function sanitize(s) {
            return s.replace(/[^A-Za-z0-9]/g, "");
          }
        }
      }
      exports.default = enforceURICompliance;
    }
  });

  // node_modules/sboljs/dist/SBOL2GraphView.js
  var require_SBOL2GraphView = __commonJS({
    "node_modules/sboljs/dist/SBOL2GraphView.js"(exports) {
      "use strict";
      init_shim();
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sbol2 = void 0;
      var rdfoo_1 = require_dist();
      var bioterms_1 = require_dist2();
      var S2ComponentDefinition_1 = require_S2ComponentDefinition();
      var S2ComponentInstance_1 = require_S2ComponentInstance();
      var S2ModuleDefinition_1 = require_S2ModuleDefinition();
      var S2ModuleInstance_1 = require_S2ModuleInstance();
      var S2Identified_1 = require_S2Identified();
      var S2FunctionalComponent_1 = require_S2FunctionalComponent();
      var S2Range_1 = require_S2Range();
      var S2Sequence_1 = require_S2Sequence();
      var S2Collection_1 = require_S2Collection();
      var S2Model_1 = require_S2Model();
      var S2Measure_1 = require_S2Measure();
      var S2Interaction_1 = require_S2Interaction();
      var S2SequenceAnnotation_1 = require_S2SequenceAnnotation();
      var S2Participation_1 = require_S2Participation();
      var S2MapsTo_1 = require_S2MapsTo();
      var S2GenericLocation_1 = require_S2GenericLocation();
      var S2IdentifiedFactory_1 = require_S2IdentifiedFactory();
      var S2Cut_1 = require_S2Cut();
      var rdfoo_2 = require_dist();
      var rdfoo_3 = require_dist();
      var fastaToSBOL2_1 = require_fastaToSBOL2();
      var genbankToSBOL2_1 = require_genbankToSBOL2();
      var S2Implementation_1 = require_S2Implementation();
      var S2Experiment_1 = require_S2Experiment();
      var S2ExperimentalData_1 = require_S2ExperimentalData();
      var _1 = require_dist5();
      var toSBOL2_1 = require_toSBOL2();
      var toSBOL2_2 = require_toSBOL22();
      var enforceURICompliance_1 = require_enforceURICompliance();
      var rdfoo_prov_1 = require_dist4();
      var isOwnershipRelation_1 = require_isOwnershipRelation();
      var S2SequenceConstraint_1 = require_S2SequenceConstraint();
      var S2VariableComponent_1 = require_S2VariableComponent();
      var S2CombinatorialDerivation_1 = require_S2CombinatorialDerivation();
      var SBOL2GraphView19 = class extends rdfoo_1.GraphViewHybrid {
        constructor(graph2) {
          super(graph2);
          this._cachedUriPrefixes = null;
          this.addView(new SBOL2(this));
          this.addView(new rdfoo_prov_1.ProvView(graph2));
        }
        createComponentDefinition(uriPrefix, id, version) {
          console.dir(arguments);
          if (arguments.length < 3)
            version = "1";
          const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.ComponentDefinition, uriPrefix, id, void 0, version);
          return new S2ComponentDefinition_1.default(this, identified.subject);
        }
        createModuleDefinition(uriPrefix, id, version) {
          if (arguments.length < 3)
            version = "1";
          const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.ModuleDefinition, uriPrefix, id, void 0, version);
          return new S2ModuleDefinition_1.default(this, identified.subject);
        }
        createCollection(uriPrefix, id, version) {
          if (arguments.length < 3)
            version = "1";
          const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.Collection, uriPrefix, id, void 0, version);
          return new S2Collection_1.default(this, identified.subject);
        }
        createSequence(uriPrefix, id, version) {
          if (arguments.length < 3)
            version = "1";
          const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.Sequence, uriPrefix, id, void 0, version);
          const seq = new S2Sequence_1.default(this, identified.subject);
          seq.encoding = bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
          seq.elements = "";
          return seq;
        }
        createModel(uriPrefix, id, version) {
          if (arguments.length < 3)
            version = "1";
          const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.Model, uriPrefix, id, void 0, version);
          const model = new S2Model_1.default(this, identified.subject);
          return model;
        }
        createImplementation(uriPrefix, id, version) {
          if (arguments.length < 3)
            version = "1";
          const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.Implementation, uriPrefix, id, void 0, version);
          return new S2Implementation_1.default(this, identified.subject);
        }
        createExperiment(uriPrefix, id, version) {
          if (arguments.length < 3)
            version = "1";
          const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.Experiment, uriPrefix, id, void 0, version);
          return new S2Experiment_1.default(this, identified.subject);
        }
        createExperimentalData(uriPrefix, id, version) {
          if (arguments.length < 3)
            version = "1";
          const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.ExperimentalData, uriPrefix, id, void 0, version);
          return new S2ExperimentalData_1.default(this, identified.subject);
        }
        get sequences() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.Sequence).map((subject) => new S2Sequence_1.default(this, subject));
        }
        get componentDefinitions() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.ComponentDefinition).map((subject) => new S2ComponentDefinition_1.default(this, subject));
        }
        get collections() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.Collection).map((subject) => new S2Collection_1.default(this, subject));
        }
        get models() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.Model).map((subject) => new S2Model_1.default(this, subject));
        }
        componentDefinition(subject) {
          return new S2ComponentDefinition_1.default(this, subject);
        }
        getComponentDefinition(subject) {
          if (this.getType(subject) !== bioterms_1.Types.SBOL2.ComponentDefinition)
            return null;
          return new S2ComponentDefinition_1.default(this, subject);
        }
        get componentInstances() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.Component).map((subject) => new S2ComponentInstance_1.default(this, subject));
        }
        moduleDefinition(subject) {
          return new S2ModuleDefinition_1.default(this, subject);
        }
        get moduleDefinitions() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.ModuleDefinition).map((subject) => new S2ModuleDefinition_1.default(this, subject));
        }
        getModuleDefinition(subject) {
          if (this.getType(subject) !== bioterms_1.Types.SBOL2.ModuleDefinition)
            return null;
          return new S2ModuleDefinition_1.default(this, subject);
        }
        getActivity(subject) {
          if (this.getType(subject) !== bioterms_1.Types.Prov.Activity)
            return null;
          return new rdfoo_prov_1.Activity(new rdfoo_prov_1.ProvView(this.graph), subject);
        }
        getExperiment(subject) {
          if (this.getType(subject) !== bioterms_1.Types.SBOL2.Experiment)
            return null;
          return new S2Experiment_1.default(this, subject);
        }
        get experiments() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.Experiment).map((subject) => new S2Experiment_1.default(this, subject));
        }
        get attachments() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.Attachment).map((subject) => new _1.S2Attachment(this, subject));
        }
        getExperimentalData(subject) {
          if (this.getType(subject) !== bioterms_1.Types.SBOL2.ExperimentalData)
            return null;
          return new S2ExperimentalData_1.default(this, subject);
        }
        get experimentalData() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.ExperimentalData).map((subject) => new S2ExperimentalData_1.default(this, subject));
        }
        get implementations() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.Implementation).map((subject) => new S2Implementation_1.default(this, subject));
        }
        get combinatorialDerivations() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.CombinatorialDerivation).map((subject) => new S2CombinatorialDerivation_1.default(this, subject));
        }
        get rootComponentDefinitions() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.ComponentDefinition).filter((subject) => {
            return !this.graph.hasMatch(null, bioterms_1.Predicates.SBOL2.definition, subject);
          }).map((subject) => new S2ComponentDefinition_1.default(this, subject));
        }
        get structurallyRootComponentDefinitions() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.ComponentDefinition).filter((subject) => {
            const instantiations = this.graph.match(null, bioterms_1.Predicates.SBOL2.definition, subject).map((t) => t.subject);
            for (var i = 0; i < instantiations.length; ++i) {
              const instantiation = instantiations[i];
              if (this.hasType(instantiation, bioterms_1.Types.SBOL2.Component)) {
                return false;
              }
            }
            return true;
          }).map((subject) => new S2ComponentDefinition_1.default(this, subject));
        }
        get rootModuleDefinitions() {
          return this.instancesOfType(bioterms_1.Types.SBOL2.ModuleDefinition).filter((subject) => {
            return !this.graph.hasMatch(null, bioterms_1.Predicates.SBOL2.definition, subject);
          }).map((subject) => new S2ModuleDefinition_1.default(this, subject));
        }
        get provPlans() {
          return this.instancesOfType(bioterms_1.Types.Prov.Plan).map((subject) => new rdfoo_prov_1.Plan(new rdfoo_prov_1.ProvView(this.graph), subject));
        }
        get measures() {
          return this.instancesOfType(bioterms_1.Types.Measure.Measure).map((subject) => new S2Measure_1.default(this, subject));
        }
        static loadString(data, defaultURIPrefix, mimeType) {
          return __awaiter(this, void 0, void 0, function* () {
            let graph2 = new SBOL2GraphView19(new rdfoo_1.Graph());
            yield graph2.loadString(data, defaultURIPrefix, mimeType);
            return graph2;
          });
        }
        loadString(data, defaultURIPrefix, mimeType) {
          return __awaiter(this, void 0, void 0, function* () {
            let filetype = (0, rdfoo_3.identifyFiletype)(data, mimeType || null);
            if (filetype === rdfoo_3.Filetype.RDFXML || filetype === rdfoo_3.Filetype.NTriples) {
              yield (0, rdfoo_2.parseRDF)(this.graph, data, filetype);
              (0, toSBOL2_2.default)(this.graph);
              (0, toSBOL2_1.default)(this.graph);
              return;
            }
            defaultURIPrefix = defaultURIPrefix || "http://converted/";
            if (filetype === rdfoo_3.Filetype.FASTA) {
              (0, fastaToSBOL2_1.default)(this, defaultURIPrefix, data);
              return;
            }
            if (filetype === rdfoo_3.Filetype.GenBank) {
              (0, genbankToSBOL2_1.default)(this, defaultURIPrefix, data);
              return;
            }
            throw new Error("Unknown format");
          });
        }
        serializeXML() {
          let defaultPrefixes = [
            ["rdf", bioterms_1.Prefixes.rdf],
            ["dcterms", bioterms_1.Prefixes.dcterms],
            ["prov", bioterms_1.Prefixes.prov],
            ["sbol", bioterms_1.Prefixes.sbol2],
            ["sbol1", bioterms_1.Prefixes.sbol1],
            ["sbol3", bioterms_1.Prefixes.sbol3],
            ["backport", "http://sboltools.org/backport#"],
            ["om", bioterms_1.Prefixes.measure],
            ["synbiohub", "http://wiki.synbiohub.org/wiki/Terms/synbiohub#"],
            ["igem", "http://wiki.synbiohub.org/wiki/Terms/igem#"],
            ["dc", "http://purl.org/dc/elements/1.1/"]
          ];
          return (0, rdfoo_1.serialize)(this.graph, new Map(defaultPrefixes), (t) => (0, isOwnershipRelation_1.default)(this.graph, t), bioterms_1.Prefixes.sbol2);
        }
        get topLevels() {
          const topLevels = [];
          Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL2.ComponentDefinition));
          Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL2.ModuleDefinition));
          Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL2.Sequence));
          Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL2.Collection));
          Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL2.Implementation));
          return topLevels.map((topLevel) => this.subjectToFacade(topLevel));
        }
        get uriPrefixes() {
          if (this._cachedUriPrefixes !== null)
            return this._cachedUriPrefixes;
          const topLevels = this.topLevels;
          var prefixes = {};
          topLevels.forEach((topLevel) => {
            const prefix = topLevel.uriPrefix;
            if (prefixes[prefix] === void 0)
              prefixes[prefix] = true;
          });
          this._cachedUriPrefixes = Object.keys(prefixes);
          return this._cachedUriPrefixes;
        }
        getTopLevelsWithPrefix(prefix) {
          const topLevels = this.topLevels;
          return this.topLevels.filter((topLevel) => {
            return topLevel.subject.value.indexOf(prefix) === 0;
          });
        }
        uriToIdentified(subject) {
          let f = this.subjectToFacade(subject);
          if (f instanceof S2Identified_1.default)
            return f;
          else
            return void 0;
        }
        findClosestTopLevel(_subject) {
          var subject = _subject;
          const origSubject = subject;
          var subjectTypes = this.getTypes(subject);
          while (!isTopLevel()) {
            let identified = this.uriToIdentified(subject);
            if (identified === void 0)
              throw new Error("???");
            identified = identified.containingObject;
            if (identified === void 0) {
              return void 0;
            }
            subject = identified.subject;
            subjectTypes = this.getTypes(subject);
          }
          return subject;
          function isTopLevel() {
            return subjectTypes.indexOf(bioterms_1.Types.SBOL2.ComponentDefinition) !== -1 || subjectTypes.indexOf(bioterms_1.Types.SBOL2.ModuleDefinition) !== -1;
          }
        }
        nameToDisplayId(name) {
          return name.replace(/\s/, "_");
        }
        changeURIPrefix(newPrefix) {
          let topLevels = /* @__PURE__ */ new Set([
            bioterms_1.Types.SBOL2.Collection,
            bioterms_1.Types.SBOL2.ComponentDefinition,
            bioterms_1.Types.SBOL2.ModuleDefinition,
            bioterms_1.Types.SBOL2.Sequence,
            bioterms_1.Types.SBOL2.Model,
            bioterms_1.Types.Prov.Plan,
            bioterms_1.Types.Prov.Agent,
            bioterms_1.Types.Prov.Activity
          ]);
          (0, rdfoo_1.changeURIPrefix)(this.graph, topLevels, newPrefix);
        }
        printTree() {
          for (let cd of this.componentDefinitions) {
            console.log("component:" + cd.subject);
            for (let c of cd.components) {
              console.log(indent22(1) + "c-> " + c.definition.subject);
            }
          }
          for (let md of this.moduleDefinitions) {
            console.log("module:" + md.subject);
            for (let c of md.functionalComponents) {
              console.log(indent22(1) + "c-> " + c.definition.subject);
            }
            for (let m of md.modules) {
              console.log(indent22(1) + "m-> " + m.definition.subject);
            }
          }
          function indent22(n) {
            return "        ".slice(8 - n);
          }
        }
        enforceURICompliance(uriPrefix) {
          (0, enforceURICompliance_1.default)(this, uriPrefix);
        }
      };
      exports.default = SBOL2GraphView19;
      var SBOL2 = class extends rdfoo_1.GraphViewBasic {
        constructor(view) {
          super(view.graph);
          this.view = view;
        }
        subjectToFacade(subject) {
          if (!subject)
            return void 0;
          const types = this.getTypes(subject);
          for (var i = 0; i < types.length; ++i) {
            let type = types[i];
            if (type === bioterms_1.Types.SBOL2.ComponentDefinition)
              return new S2ComponentDefinition_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Component)
              return new S2ComponentInstance_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.FunctionalComponent)
              return new S2FunctionalComponent_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Implementation)
              return new S2Implementation_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Experiment)
              return new S2Experiment_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.ExperimentalData)
              return new S2ExperimentalData_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Attachment)
              return new _1.S2Attachment(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Interaction)
              return new S2Interaction_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.MapsTo)
              return new S2MapsTo_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.ModuleDefinition)
              return new S2ModuleDefinition_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Module)
              return new S2ModuleInstance_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Participation)
              return new S2Participation_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Range)
              return new S2Range_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Cut)
              return new S2Cut_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.GenericLocation)
              return new S2GenericLocation_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.SequenceAnnotation)
              return new S2SequenceAnnotation_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.SequenceConstraint)
              return new S2SequenceConstraint_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Sequence)
              return new S2Sequence_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Collection)
              return new S2Collection_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Model)
              return new S2Model_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.Attachment)
              return new _1.S2Attachment(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.CombinatorialDerivation)
              return new S2CombinatorialDerivation_1.default(this.view, subject);
            if (type === bioterms_1.Types.SBOL2.VariableComponent)
              return new S2VariableComponent_1.default(this.view, subject);
            if (type === bioterms_1.Types.Measure.Measure)
              return new S2Measure_1.default(this.view, subject);
          }
          return super.subjectToFacade(subject);
        }
      };
      function sbol22(graph2) {
        return new SBOL2GraphView19(graph2);
      }
      exports.sbol2 = sbol22;
    }
  });

  // node_modules/sboljs/dist/SBOL2Repository.js
  var require_SBOL2Repository = __commonJS({
    "node_modules/sboljs/dist/SBOL2Repository.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SearchResult = exports.SearchQuery = void 0;
      var SearchQuery = class {
        constructor() {
          this.criteria = [];
        }
        add(key, value) {
          this.criteria.push({ key, value });
        }
        addObjectType(name) {
          this.add("objectType", name);
        }
        addRole(subject) {
          this.add("role", "<" + subject.value + ">");
        }
      };
      exports.SearchQuery = SearchQuery;
      var SearchResult = class {
      };
      exports.SearchResult = SearchResult;
      var Repository = class {
        constructor(url) {
          this.url = url;
        }
      };
      exports.default = Repository;
    }
  });

  // node_modules/sboljs/dist/conversion/fromSBOL2/toSBOL1.js
  var require_toSBOL1 = __commonJS({
    "node_modules/sboljs/dist/conversion/fromSBOL2/toSBOL1.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var rdfoo_1 = require_dist();
      var __1 = require_dist5();
      var bioterms_1 = require_dist2();
      function convert2to1(graph2) {
        var _a;
        let sbol2View = new __1.SBOL2GraphView(graph2);
        let newGraph = new rdfoo_1.Graph();
        let sbol1View = new __1.SBOL1GraphView(newGraph);
        for (let cd of sbol2View.componentDefinitions) {
          if (cd.type !== bioterms_1.Specifiers.SBOL2.Type.DNA) {
            continue;
          }
          newGraph.insertProperties(cd.subject, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.DnaComponent)
          });
          copyIdentifiedProperties(cd);
          for (let role of cd.roles) {
            newGraph.insertProperties(cd.subject, {
              [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(role)
            });
          }
          if (cd.hasProperty(bioterms_1.Predicates.SBOL2.sequence)) {
            newGraph.insertProperties(cd.subject, {
              [bioterms_1.Predicates.SBOL1.dnaSequence]: (_a = cd.sequences[0]) === null || _a === void 0 ? void 0 : _a.subject
            });
          }
          for (let sa of cd.sequenceAnnotations) {
            newGraph.insertProperties(sa.subject, {
              [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.SequenceAnnotation)
            });
            newGraph.insertProperties(cd.subject, {
              [bioterms_1.Predicates.SBOL1.annotation]: sa.subject
            });
            copyIdentifiedProperties(sa);
            for (let location of sa.locations) {
              if (location instanceof __1.S2Range) {
                if (location.hasProperty(bioterms_1.Predicates.SBOL2.start)) {
                  newGraph.insertProperties(sa.subject, {
                    [bioterms_1.Predicates.SBOL1.bioStart]: rdfoo_1.node.createIntNode(location.start)
                  });
                }
                if (location.hasProperty(bioterms_1.Predicates.SBOL2.end)) {
                  newGraph.insertProperties(sa.subject, {
                    [bioterms_1.Predicates.SBOL1.bioEnd]: rdfoo_1.node.createIntNode(location.end)
                  });
                }
                break;
              }
            }
            for (let location of sa.locations) {
              if (location instanceof __1.S2OrientedLocation) {
                if (location.hasProperty(bioterms_1.Predicates.SBOL2.orientation)) {
                  newGraph.insertProperties(sa.subject, {
                    [bioterms_1.Predicates.SBOL1.strand]: rdfoo_1.node.createStringNode(location.orientation === bioterms_1.Specifiers.SBOL2.Orientation.ReverseComplement ? "-" : "+")
                  });
                }
              }
            }
            if (sa.hasProperty(bioterms_1.Predicates.SBOL2.component)) {
              newGraph.insertProperties(sa.subject, {
                [bioterms_1.Predicates.SBOL1.subComponent]: sa.component.definition.subject
              });
            }
          }
          for (let c of cd.components) {
            if (c.sequenceAnnotations.length > 0) {
              continue;
            }
            newGraph.insertProperties(c.subject, {
              [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.SequenceAnnotation)
            });
            cd.insertProperty(bioterms_1.Predicates.SBOL1.annotation, c.subject);
            copyIdentifiedProperties(c);
            newGraph.insertProperties(c.subject, {
              [bioterms_1.Predicates.SBOL1.subComponent]: c.definition.subject
            });
          }
          for (let sc of cd.sequenceConstraints) {
            if (sc.constraintRestriction === bioterms_1.Specifiers.SBOL2.SequenceConstraint.Precedes) {
              let subjSA = sc.constraintSubject.sequenceAnnotations.length > 0 ? sc.constraintSubject.sequenceAnnotations[0] : sc.constraintSubject;
              let objSA = sc.constraintObject.sequenceAnnotations.length > 0 ? sc.constraintObject.sequenceAnnotations[0] : sc.constraintObject;
              newGraph.insertProperties(subjSA.subject, {
                [bioterms_1.Predicates.SBOL1.precedes]: objSA.subject
              });
            }
          }
        }
        for (let coll of sbol2View.collections) {
          newGraph.insertProperties(coll.subject, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.Collection)
          });
          copyIdentifiedProperties(coll);
          for (let member of coll.members) {
            newGraph.insertProperties(coll.subject, {
              [bioterms_1.Predicates.SBOL1.component]: member.subject
            });
          }
        }
        for (let seq of sbol2View.sequences) {
          if (seq.encoding !== bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid)
            continue;
          newGraph.insertProperties(seq.subject, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.DnaSequence)
          });
          copyIdentifiedProperties(seq);
          if (seq.hasProperty(bioterms_1.Predicates.SBOL2.elements)) {
            newGraph.insertProperties(seq.subject, {
              [bioterms_1.Predicates.SBOL1.nucleotides]: rdfoo_1.node.createStringNode(seq.elements)
            });
          }
        }
        for (let typeTriple of graph2.match(null, bioterms_1.Predicates.a, null)) {
          if (typeTriple.object.value.indexOf(bioterms_1.Prefixes.sbol2) === 0) {
            graph2.removeMatches(typeTriple.subject, null, null);
          }
        }
        graph2.addAll(newGraph);
        function copyIdentifiedProperties(identified) {
          if (identified.hasProperty("http://sboltools.org/backport#sbol1displayId")) {
            newGraph.insertProperties(identified.subject, {
              [bioterms_1.Predicates.SBOL1.displayId]: rdfoo_1.node.createStringNode(identified.getStringProperty("http://sboltools.org/backport#sbol1displayId"))
            });
          } else {
            if (identified.hasProperty(bioterms_1.Predicates.SBOL2.displayId)) {
              newGraph.insertProperties(identified.subject, {
                [bioterms_1.Predicates.SBOL1.displayId]: rdfoo_1.node.createStringNode(identified.displayId)
              });
            }
          }
          if (identified.hasProperty(bioterms_1.Predicates.Dcterms.title)) {
            newGraph.insertProperties(identified.subject, {
              [bioterms_1.Predicates.SBOL1.name]: rdfoo_1.node.createStringNode(identified.name)
            });
          }
          if (identified.hasProperty(bioterms_1.Predicates.Dcterms.description)) {
            newGraph.insertProperties(identified.subject, {
              [bioterms_1.Predicates.SBOL1.description]: rdfoo_1.node.createStringNode(identified.description)
            });
          }
        }
      }
      exports.default = convert2to1;
    }
  });

  // node_modules/sboljs/dist/SBOLConverter.js
  var require_SBOLConverter = __commonJS({
    "node_modules/sboljs/dist/SBOLConverter.js"(exports) {
      "use strict";
      init_shim();
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var toSBOL2_1 = require_toSBOL2();
      var toSBOL3_1 = require_toSBOL3();
      var toSBOL2_2 = require_toSBOL22();
      var toSBOL1_1 = require_toSBOL1();
      var SBOLConverter4 = class {
        static convert1to2(g) {
          return __awaiter(this, void 0, void 0, function* () {
            yield (0, toSBOL2_1.default)(g);
          });
        }
        static convert2to3(g) {
          return __awaiter(this, void 0, void 0, function* () {
            yield (0, toSBOL3_1.default)(g);
          });
        }
        static convert3to2(g) {
          return __awaiter(this, void 0, void 0, function* () {
            yield (0, toSBOL2_2.default)(g);
          });
        }
        static convert2to1(g) {
          return __awaiter(this, void 0, void 0, function* () {
            yield (0, toSBOL1_1.default)(g);
          });
        }
      };
      exports.default = SBOLConverter4;
    }
  });

  // node_modules/sboljs/dist/index.js
  var require_dist5 = __commonJS({
    "node_modules/sboljs/dist/index.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Graph = exports.rdf = exports.S3ExperimentalData = exports.S3Experiment = exports.S3Model = exports.S3MapsTo = exports.S3Collection = exports.S3Participation = exports.S3Interaction = exports.S3SequenceFeature = exports.S3Constraint = exports.S3Range = exports.S3OrientedLocation = exports.S3Feature = exports.S3Location = exports.S3Sequence = exports.S3Component = exports.S3SubComponent = exports.S3Identified = exports.sbol3 = exports.SBOL3GraphView = exports.S2Attachment = exports.S2MapsTo = exports.S2Interaction = exports.S2Collection = exports.S2GenericLocation = exports.S2Cut = exports.S2Range = exports.S2Location = exports.S2OrientedLocation = exports.S2Sequence = exports.S2ExperimentalData = exports.S2Experiment = exports.S2Implementation = exports.S2FunctionalComponent = exports.S2SequenceAnnotation = exports.S2ModuleDefinition = exports.S2ComponentDefinition = exports.S2ModuleInstance = exports.S2ComponentInstance = exports.S2Identified = exports.sbol2 = exports.SBOL2GraphView = exports.S1SequenceAnnotation = exports.S1DnaSequence = exports.S1DnaComponent = exports.S1Collection = exports.S1Facade = exports.sbol1 = exports.SBOL1GraphView = void 0;
      exports.genbankToSBOL2 = exports.fastaToSBOL2 = exports.SBOLConverter = exports.Facade = exports.serialize = exports.SearchResult = exports.SearchQuery = exports.Repository = exports.triple = exports.node = void 0;
      var SBOL1GraphView_1 = require_SBOL1GraphView();
      exports.SBOL1GraphView = SBOL1GraphView_1.default;
      var SBOL2GraphView_1 = require_SBOL2GraphView();
      exports.SBOL2GraphView = SBOL2GraphView_1.default;
      var SBOL3GraphView_1 = require_SBOL3GraphView();
      exports.SBOL3GraphView = SBOL3GraphView_1.default;
      var SBOL1GraphView_2 = require_SBOL1GraphView();
      Object.defineProperty(exports, "sbol1", { enumerable: true, get: function() {
        return SBOL1GraphView_2.sbol1;
      } });
      var SBOL2GraphView_2 = require_SBOL2GraphView();
      Object.defineProperty(exports, "sbol2", { enumerable: true, get: function() {
        return SBOL2GraphView_2.sbol2;
      } });
      var SBOL3GraphView_2 = require_SBOL3GraphView();
      Object.defineProperty(exports, "sbol3", { enumerable: true, get: function() {
        return SBOL3GraphView_2.sbol3;
      } });
      var S1Facade_1 = require_S1Facade();
      exports.S1Facade = S1Facade_1.default;
      var S1Collection_1 = require_S1Collection();
      exports.S1Collection = S1Collection_1.default;
      var S1DnaComponent_1 = require_S1DnaComponent();
      exports.S1DnaComponent = S1DnaComponent_1.default;
      var S1DnaSequence_1 = require_S1DnaSequence();
      exports.S1DnaSequence = S1DnaSequence_1.default;
      var S1SequenceAnnotation_1 = require_S1SequenceAnnotation();
      exports.S1SequenceAnnotation = S1SequenceAnnotation_1.default;
      var S2Identified_1 = require_S2Identified();
      exports.S2Identified = S2Identified_1.default;
      var S2ComponentInstance_1 = require_S2ComponentInstance();
      exports.S2ComponentInstance = S2ComponentInstance_1.default;
      var S2ModuleInstance_1 = require_S2ModuleInstance();
      exports.S2ModuleInstance = S2ModuleInstance_1.default;
      var S2ComponentDefinition_1 = require_S2ComponentDefinition();
      exports.S2ComponentDefinition = S2ComponentDefinition_1.default;
      var S2ModuleDefinition_1 = require_S2ModuleDefinition();
      exports.S2ModuleDefinition = S2ModuleDefinition_1.default;
      var S2SequenceAnnotation_1 = require_S2SequenceAnnotation();
      exports.S2SequenceAnnotation = S2SequenceAnnotation_1.default;
      var S2FunctionalComponent_1 = require_S2FunctionalComponent();
      exports.S2FunctionalComponent = S2FunctionalComponent_1.default;
      var S2Implementation_1 = require_S2Implementation();
      exports.S2Implementation = S2Implementation_1.default;
      var S2Experiment_1 = require_S2Experiment();
      exports.S2Experiment = S2Experiment_1.default;
      var S2ExperimentalData_1 = require_S2ExperimentalData();
      exports.S2ExperimentalData = S2ExperimentalData_1.default;
      var S2Sequence_1 = require_S2Sequence();
      exports.S2Sequence = S2Sequence_1.default;
      var S2Location_1 = require_S2Location();
      exports.S2Location = S2Location_1.default;
      var S2OrientedLocation_1 = require_S2OrientedLocation();
      exports.S2OrientedLocation = S2OrientedLocation_1.default;
      var S2Range_1 = require_S2Range();
      exports.S2Range = S2Range_1.default;
      var S2Cut_1 = require_S2Cut();
      exports.S2Cut = S2Cut_1.default;
      var S2GenericLocation_1 = require_S2GenericLocation();
      exports.S2GenericLocation = S2GenericLocation_1.default;
      var S2Collection_1 = require_S2Collection();
      exports.S2Collection = S2Collection_1.default;
      var S2Interaction_1 = require_S2Interaction();
      exports.S2Interaction = S2Interaction_1.default;
      var S2MapsTo_1 = require_S2MapsTo();
      exports.S2MapsTo = S2MapsTo_1.default;
      var S2Attachment_1 = require_S2Attachment();
      exports.S2Attachment = S2Attachment_1.default;
      var S3Identified_1 = require_S3Identified();
      exports.S3Identified = S3Identified_1.default;
      var S3SubComponent_1 = require_S3SubComponent();
      exports.S3SubComponent = S3SubComponent_1.default;
      var S3Component_1 = require_S3Component();
      exports.S3Component = S3Component_1.default;
      var S3Sequence_1 = require_S3Sequence();
      exports.S3Sequence = S3Sequence_1.default;
      var S3Constraint_1 = require_S3Constraint();
      exports.S3Constraint = S3Constraint_1.default;
      var S3Location_1 = require_S3Location();
      exports.S3Location = S3Location_1.default;
      var S3OrientedLocation_1 = require_S3OrientedLocation();
      exports.S3OrientedLocation = S3OrientedLocation_1.default;
      var S3Range_1 = require_S3Range();
      exports.S3Range = S3Range_1.default;
      var S3SequenceFeature_1 = require_S3SequenceFeature();
      exports.S3SequenceFeature = S3SequenceFeature_1.default;
      var S3Interaction_1 = require_S3Interaction();
      exports.S3Interaction = S3Interaction_1.default;
      var S3Participation_1 = require_S3Participation();
      exports.S3Participation = S3Participation_1.default;
      var S3Collection_1 = require_S3Collection();
      exports.S3Collection = S3Collection_1.default;
      var S3Feature_1 = require_S3Feature();
      exports.S3Feature = S3Feature_1.default;
      var S3ComponentReference_1 = require_S3ComponentReference();
      exports.S3MapsTo = S3ComponentReference_1.default;
      var S3Model_1 = require_S3Model();
      exports.S3Model = S3Model_1.default;
      var S3Experiment_1 = require_S3Experiment();
      exports.S3Experiment = S3Experiment_1.default;
      var S3ExperimentalData_1 = require_S3ExperimentalData();
      exports.S3ExperimentalData = S3ExperimentalData_1.default;
      var SBOL2Repository_1 = require_SBOL2Repository();
      exports.Repository = SBOL2Repository_1.default;
      var SBOL2Repository_2 = require_SBOL2Repository();
      Object.defineProperty(exports, "SearchQuery", { enumerable: true, get: function() {
        return SBOL2Repository_2.SearchQuery;
      } });
      Object.defineProperty(exports, "SearchResult", { enumerable: true, get: function() {
        return SBOL2Repository_2.SearchResult;
      } });
      var rdfoo_1 = require_dist();
      Object.defineProperty(exports, "Graph", { enumerable: true, get: function() {
        return rdfoo_1.Graph;
      } });
      Object.defineProperty(exports, "node", { enumerable: true, get: function() {
        return rdfoo_1.node;
      } });
      Object.defineProperty(exports, "triple", { enumerable: true, get: function() {
        return rdfoo_1.triple;
      } });
      Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
        return rdfoo_1.serialize;
      } });
      Object.defineProperty(exports, "Facade", { enumerable: true, get: function() {
        return rdfoo_1.Facade;
      } });
      Object.defineProperty(exports, "rdf", { enumerable: true, get: function() {
        return rdfoo_1.rdf;
      } });
      var SBOLConverter_1 = require_SBOLConverter();
      exports.SBOLConverter = SBOLConverter_1.default;
      var fastaToSBOL2_1 = require_fastaToSBOL2();
      exports.fastaToSBOL2 = fastaToSBOL2_1.default;
      var genbankToSBOL2_1 = require_genbankToSBOL2();
      exports.genbankToSBOL2 = genbankToSBOL2_1.default;
    }
  });

  // node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "node_modules/color-name/index.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // node_modules/color-convert/conversions.js
  var require_conversions = __commonJS({
    "node_modules/color-convert/conversions.js"(exports, module) {
      init_shim();
      var cssKeywords = require_color_name();
      var reverseKeywords = {};
      for (const key of Object.keys(cssKeywords)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
      var convert2 = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] }
      };
      module.exports = convert2;
      for (const model of Object.keys(convert2)) {
        if (!("channels" in convert2[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert2[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert2[model].labels.length !== convert2[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        const { channels, labels } = convert2[model];
        delete convert2[model].channels;
        delete convert2[model].labels;
        Object.defineProperty(convert2[model], "channels", { value: channels });
        Object.defineProperty(convert2[model], "labels", { value: labels });
      }
      convert2.rgb.hsl = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const min = Math.min(r, g, b);
        const max = Math.max(r, g, b);
        const delta = max - min;
        let h;
        let s;
        if (max === min) {
          h = 0;
        } else if (r === max) {
          h = (g - b) / delta;
        } else if (g === max) {
          h = 2 + (b - r) / delta;
        } else if (b === max) {
          h = 4 + (r - g) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0) {
          h += 360;
        }
        const l = (min + max) / 2;
        if (max === min) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max + min);
        } else {
          s = delta / (2 - max - min);
        }
        return [h, s * 100, l * 100];
      };
      convert2.rgb.hsv = function(rgb) {
        let rdif;
        let gdif;
        let bdif;
        let h;
        let s;
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const v = Math.max(r, g, b);
        const diff = v - Math.min(r, g, b);
        const diffc = function(c) {
          return (v - c) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
          h = 0;
          s = 0;
        } else {
          s = diff / v;
          rdif = diffc(r);
          gdif = diffc(g);
          bdif = diffc(b);
          if (r === v) {
            h = bdif - gdif;
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif;
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
          }
          if (h < 0) {
            h += 1;
          } else if (h > 1) {
            h -= 1;
          }
        }
        return [
          h * 360,
          s * 100,
          v * 100
        ];
      };
      convert2.rgb.hwb = function(rgb) {
        const r = rgb[0];
        const g = rgb[1];
        let b = rgb[2];
        const h = convert2.rgb.hsl(rgb)[0];
        const w = 1 / 255 * Math.min(r, Math.min(g, b));
        b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
        return [h, w * 100, b * 100];
      };
      convert2.rgb.cmyk = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const k = Math.min(1 - r, 1 - g, 1 - b);
        const c = (1 - r - k) / (1 - k) || 0;
        const m = (1 - g - k) / (1 - k) || 0;
        const y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
      };
      function comparativeDistance(x, y) {
        return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
      }
      convert2.rgb.keyword = function(rgb) {
        const reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        let currentClosestDistance = Infinity;
        let currentClosestKeyword;
        for (const keyword of Object.keys(cssKeywords)) {
          const value = cssKeywords[keyword];
          const distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
        return currentClosestKeyword;
      };
      convert2.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      };
      convert2.rgb.xyz = function(rgb) {
        let r = rgb[0] / 255;
        let g = rgb[1] / 255;
        let b = rgb[2] / 255;
        r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
        g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
        b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
        const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      };
      convert2.rgb.lab = function(rgb) {
        const xyz = convert2.rgb.xyz(rgb);
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
      };
      convert2.hsl.rgb = function(hsl) {
        const h = hsl[0] / 360;
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        let t2;
        let t3;
        let val;
        if (s === 0) {
          val = l * 255;
          return [val, val, val];
        }
        if (l < 0.5) {
          t2 = l * (1 + s);
        } else {
          t2 = l + s - l * s;
        }
        const t1 = 2 * l - t2;
        const rgb = [0, 0, 0];
        for (let i = 0; i < 3; i++) {
          t3 = h + 1 / 3 * -(i - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i] = val * 255;
        }
        return rgb;
      };
      convert2.hsl.hsv = function(hsl) {
        const h = hsl[0];
        let s = hsl[1] / 100;
        let l = hsl[2] / 100;
        let smin = s;
        const lmin = Math.max(l, 0.01);
        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        const v = (l + s) / 2;
        const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
        return [h, sv * 100, v * 100];
      };
      convert2.hsv.rgb = function(hsv) {
        const h = hsv[0] / 60;
        const s = hsv[1] / 100;
        let v = hsv[2] / 100;
        const hi = Math.floor(h) % 6;
        const f = h - Math.floor(h);
        const p = 255 * v * (1 - s);
        const q = 255 * v * (1 - s * f);
        const t = 255 * v * (1 - s * (1 - f));
        v *= 255;
        switch (hi) {
          case 0:
            return [v, t, p];
          case 1:
            return [q, v, p];
          case 2:
            return [p, v, t];
          case 3:
            return [p, q, v];
          case 4:
            return [t, p, v];
          case 5:
            return [v, p, q];
        }
      };
      convert2.hsv.hsl = function(hsv) {
        const h = hsv[0];
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const vmin = Math.max(v, 0.01);
        let sl;
        let l;
        l = (2 - s) * v;
        const lmin = (2 - s) * vmin;
        sl = s * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
      };
      convert2.hwb.rgb = function(hwb) {
        const h = hwb[0] / 360;
        let wh = hwb[1] / 100;
        let bl = hwb[2] / 100;
        const ratio = wh + bl;
        let f;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        const i = Math.floor(6 * h);
        const v = 1 - bl;
        f = 6 * h - i;
        if ((i & 1) !== 0) {
          f = 1 - f;
        }
        const n = wh + f * (v - wh);
        let r;
        let g;
        let b;
        switch (i) {
          default:
          case 6:
          case 0:
            r = v;
            g = n;
            b = wh;
            break;
          case 1:
            r = n;
            g = v;
            b = wh;
            break;
          case 2:
            r = wh;
            g = v;
            b = n;
            break;
          case 3:
            r = wh;
            g = n;
            b = v;
            break;
          case 4:
            r = n;
            g = wh;
            b = v;
            break;
          case 5:
            r = v;
            g = wh;
            b = n;
            break;
        }
        return [r * 255, g * 255, b * 255];
      };
      convert2.cmyk.rgb = function(cmyk) {
        const c = cmyk[0] / 100;
        const m = cmyk[1] / 100;
        const y = cmyk[2] / 100;
        const k = cmyk[3] / 100;
        const r = 1 - Math.min(1, c * (1 - k) + k);
        const g = 1 - Math.min(1, m * (1 - k) + k);
        const b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g * 255, b * 255];
      };
      convert2.xyz.rgb = function(xyz) {
        const x = xyz[0] / 100;
        const y = xyz[1] / 100;
        const z = xyz[2] / 100;
        let r;
        let g;
        let b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
        g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
        b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
      };
      convert2.xyz.lab = function(xyz) {
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
      };
      convert2.lab.xyz = function(lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let x;
        let y;
        let z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        const y2 = y ** 3;
        const x2 = x ** 3;
        const z2 = z ** 3;
        y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
      };
      convert2.lab.lch = function(lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let h;
        const hr = Math.atan2(b, a);
        h = hr * 360 / 2 / Math.PI;
        if (h < 0) {
          h += 360;
        }
        const c = Math.sqrt(a * a + b * b);
        return [l, c, h];
      };
      convert2.lch.lab = function(lch) {
        const l = lch[0];
        const c = lch[1];
        const h = lch[2];
        const hr = h / 360 * 2 * Math.PI;
        const a = c * Math.cos(hr);
        const b = c * Math.sin(hr);
        return [l, a, b];
      };
      convert2.rgb.ansi16 = function(args, saturation = null) {
        const [r, g, b] = args;
        let value = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert2.hsv.ansi16 = function(args) {
        return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
      };
      convert2.rgb.ansi256 = function(args) {
        const r = args[0];
        const g = args[1];
        const b = args[2];
        if (r === g && g === b) {
          if (r < 8) {
            return 16;
          }
          if (r > 248) {
            return 231;
          }
          return Math.round((r - 8) / 247 * 24) + 232;
        }
        const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
        return ansi;
      };
      convert2.ansi16.rgb = function(args) {
        let color = args % 10;
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5;
          }
          color = color / 10.5 * 255;
          return [color, color, color];
        }
        const mult = (~~(args > 50) + 1) * 0.5;
        const r = (color & 1) * mult * 255;
        const g = (color >> 1 & 1) * mult * 255;
        const b = (color >> 2 & 1) * mult * 255;
        return [r, g, b];
      };
      convert2.ansi256.rgb = function(args) {
        if (args >= 232) {
          const c = (args - 232) * 10 + 8;
          return [c, c, c];
        }
        args -= 16;
        let rem;
        const r = Math.floor(args / 36) / 5 * 255;
        const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
        const b = rem % 6 / 5 * 255;
        return [r, g, b];
      };
      convert2.rgb.hex = function(args) {
        const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        const string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert2.hex.rgb = function(args) {
        const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) {
          return [0, 0, 0];
        }
        let colorString = match[0];
        if (match[0].length === 3) {
          colorString = colorString.split("").map((char) => {
            return char + char;
          }).join("");
        }
        const integer = parseInt(colorString, 16);
        const r = integer >> 16 & 255;
        const g = integer >> 8 & 255;
        const b = integer & 255;
        return [r, g, b];
      };
      convert2.rgb.hcg = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const max = Math.max(Math.max(r, g), b);
        const min = Math.min(Math.min(r, g), b);
        const chroma = max - min;
        let grayscale;
        let hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max === r) {
          hue = (g - b) / chroma % 6;
        } else if (max === g) {
          hue = 2 + (b - r) / chroma;
        } else {
          hue = 4 + (r - g) / chroma;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert2.hsl.hcg = function(hsl) {
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
        let f = 0;
        if (c < 1) {
          f = (l - 0.5 * c) / (1 - c);
        }
        return [hsl[0], c * 100, f * 100];
      };
      convert2.hsv.hcg = function(hsv) {
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const c = s * v;
        let f = 0;
        if (c < 1) {
          f = (v - c) / (1 - c);
        }
        return [hsv[0], c * 100, f * 100];
      };
      convert2.hcg.rgb = function(hcg) {
        const h = hcg[0] / 360;
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        if (c === 0) {
          return [g * 255, g * 255, g * 255];
        }
        const pure = [0, 0, 0];
        const hi = h % 1 * 6;
        const v = hi % 1;
        const w = 1 - v;
        let mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
        }
        mg = (1 - c) * g;
        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255
        ];
      };
      convert2.hcg.hsv = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const v = c + g * (1 - c);
        let f = 0;
        if (v > 0) {
          f = c / v;
        }
        return [hcg[0], f * 100, v * 100];
      };
      convert2.hcg.hsl = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const l = g * (1 - c) + 0.5 * c;
        let s = 0;
        if (l > 0 && l < 0.5) {
          s = c / (2 * l);
        } else if (l >= 0.5 && l < 1) {
          s = c / (2 * (1 - l));
        }
        return [hcg[0], s * 100, l * 100];
      };
      convert2.hcg.hwb = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const v = c + g * (1 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
      };
      convert2.hwb.hcg = function(hwb) {
        const w = hwb[1] / 100;
        const b = hwb[2] / 100;
        const v = 1 - b;
        const c = v - w;
        let g = 0;
        if (c < 1) {
          g = (v - c) / (1 - c);
        }
        return [hwb[0], c * 100, g * 100];
      };
      convert2.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert2.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert2.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert2.gray.hsl = function(args) {
        return [0, 0, args[0]];
      };
      convert2.gray.hsv = convert2.gray.hsl;
      convert2.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert2.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert2.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert2.gray.hex = function(gray) {
        const val = Math.round(gray[0] / 100 * 255) & 255;
        const integer = (val << 16) + (val << 8) + val;
        const string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert2.rgb.gray = function(rgb) {
        const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    }
  });

  // node_modules/color-convert/route.js
  var require_route = __commonJS({
    "node_modules/color-convert/route.js"(exports, module) {
      init_shim();
      var conversions = require_conversions();
      function buildGraph() {
        const graph2 = {};
        const models = Object.keys(conversions);
        for (let len = models.length, i = 0; i < len; i++) {
          graph2[models[i]] = {
            distance: -1,
            parent: null
          };
        }
        return graph2;
      }
      function deriveBFS(fromModel) {
        const graph2 = buildGraph();
        const queue = [fromModel];
        graph2[fromModel].distance = 0;
        while (queue.length) {
          const current = queue.pop();
          const adjacents = Object.keys(conversions[current]);
          for (let len = adjacents.length, i = 0; i < len; i++) {
            const adjacent = adjacents[i];
            const node19 = graph2[adjacent];
            if (node19.distance === -1) {
              node19.distance = graph2[current].distance + 1;
              node19.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph2;
      }
      function link(from, to) {
        return function(args) {
          return to(from(args));
        };
      }
      function wrapConversion(toModel, graph2) {
        const path = [graph2[toModel].parent, toModel];
        let fn = conversions[graph2[toModel].parent][toModel];
        let cur = graph2[toModel].parent;
        while (graph2[cur].parent) {
          path.unshift(graph2[cur].parent);
          fn = link(conversions[graph2[cur].parent][cur], fn);
          cur = graph2[cur].parent;
        }
        fn.conversion = path;
        return fn;
      }
      module.exports = function(fromModel) {
        const graph2 = deriveBFS(fromModel);
        const conversion = {};
        const models = Object.keys(graph2);
        for (let len = models.length, i = 0; i < len; i++) {
          const toModel = models[i];
          const node19 = graph2[toModel];
          if (node19.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph2);
        }
        return conversion;
      };
    }
  });

  // node_modules/color-convert/index.js
  var require_color_convert = __commonJS({
    "node_modules/color-convert/index.js"(exports, module) {
      init_shim();
      var conversions = require_conversions();
      var route = require_route();
      var convert2 = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          return fn(args);
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          const result = fn(args);
          if (typeof result === "object") {
            for (let len = result.length, i = 0; i < len; i++) {
              result[i] = Math.round(result[i]);
            }
          }
          return result;
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      models.forEach((fromModel) => {
        convert2[fromModel] = {};
        Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels });
        Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
        const routes = route(fromModel);
        const routeModels = Object.keys(routes);
        routeModels.forEach((toModel) => {
          const fn = routes[toModel];
          convert2[fromModel][toModel] = wrapRounded(fn);
          convert2[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module.exports = convert2;
    }
  });

  // node_modules/ansi-styles/index.js
  var require_ansi_styles = __commonJS({
    "node_modules/ansi-styles/index.js"(exports, module) {
      "use strict";
      init_shim();
      var wrapAnsi16 = (fn, offset) => (...args) => {
        const code = fn(...args);
        return `\x1B[${code + offset}m`;
      };
      var wrapAnsi256 = (fn, offset) => (...args) => {
        const code = fn(...args);
        return `\x1B[${38 + offset};5;${code}m`;
      };
      var wrapAnsi16m = (fn, offset) => (...args) => {
        const rgb = fn(...args);
        return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
      };
      var ansi2ansi = (n) => n;
      var rgb2rgb = (r, g, b) => [r, g, b];
      var setLazyProperty = (object, property, get) => {
        Object.defineProperty(object, property, {
          get: () => {
            const value = get();
            Object.defineProperty(object, property, {
              value,
              enumerable: true,
              configurable: true
            });
            return value;
          },
          enumerable: true,
          configurable: true
        });
      };
      var colorConvert;
      var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
        if (colorConvert === void 0) {
          colorConvert = require_color_convert();
        }
        const offset = isBackground ? 10 : 0;
        const styles = {};
        for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
          const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
          if (sourceSpace === targetSpace) {
            styles[name] = wrap(identity, offset);
          } else if (typeof suite === "object") {
            styles[name] = wrap(suite[targetSpace], offset);
          }
        }
        return styles;
      };
      function assembleStyles() {
        const codes = /* @__PURE__ */ new Map();
        const styles = {
          modifier: {
            reset: [0, 0],
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            blackBright: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles.color.gray = styles.color.blackBright;
        styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
        styles.color.grey = styles.color.blackBright;
        styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
        for (const [groupName, group17] of Object.entries(styles)) {
          for (const [styleName, style] of Object.entries(group17)) {
            styles[styleName] = {
              open: `\x1B[${style[0]}m`,
              close: `\x1B[${style[1]}m`
            };
            group17[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
          }
          Object.defineProperty(styles, groupName, {
            value: group17,
            enumerable: false
          });
        }
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
        styles.color.close = "\x1B[39m";
        styles.bgColor.close = "\x1B[49m";
        setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
        setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
        setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
        setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
        setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
        setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
        return styles;
      }
      Object.defineProperty(module, "exports", {
        enumerable: true,
        get: assembleStyles
      });
    }
  });

  // node_modules/supports-color/browser.js
  var require_browser3 = __commonJS({
    "node_modules/supports-color/browser.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = {
        stdout: false,
        stderr: false
      };
    }
  });

  // node_modules/chalk/source/util.js
  var require_util3 = __commonJS({
    "node_modules/chalk/source/util.js"(exports, module) {
      "use strict";
      init_shim();
      var stringReplaceAll = (string, substring, replacer) => {
        let index = string.indexOf(substring);
        if (index === -1) {
          return string;
        }
        const substringLength = substring.length;
        let endIndex = 0;
        let returnValue = "";
        do {
          returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
          endIndex = index + substringLength;
          index = string.indexOf(substring, endIndex);
        } while (index !== -1);
        returnValue += string.substr(endIndex);
        return returnValue;
      };
      var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
        let endIndex = 0;
        let returnValue = "";
        do {
          const gotCR = string[index - 1] === "\r";
          returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
          endIndex = index + 1;
          index = string.indexOf("\n", endIndex);
        } while (index !== -1);
        returnValue += string.substr(endIndex);
        return returnValue;
      };
      module.exports = {
        stringReplaceAll,
        stringEncaseCRLFWithFirstIndex
      };
    }
  });

  // node_modules/chalk/source/templates.js
  var require_templates = __commonJS({
    "node_modules/chalk/source/templates.js"(exports, module) {
      "use strict";
      init_shim();
      var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
      var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
      var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
      var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
      var ESCAPES = /* @__PURE__ */ new Map([
        ["n", "\n"],
        ["r", "\r"],
        ["t", "	"],
        ["b", "\b"],
        ["f", "\f"],
        ["v", "\v"],
        ["0", "\0"],
        ["\\", "\\"],
        ["e", "\x1B"],
        ["a", "\x07"]
      ]);
      function unescape(c) {
        const u = c[0] === "u";
        const bracket = c[1] === "{";
        if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
          return String.fromCharCode(parseInt(c.slice(1), 16));
        }
        if (u && bracket) {
          return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
        }
        return ESCAPES.get(c) || c;
      }
      function parseArguments(name, arguments_) {
        const results = [];
        const chunks = arguments_.trim().split(/\s*,\s*/g);
        let matches;
        for (const chunk of chunks) {
          const number = Number(chunk);
          if (!Number.isNaN(number)) {
            results.push(number);
          } else if (matches = chunk.match(STRING_REGEX)) {
            results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
          } else {
            throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
          }
        }
        return results;
      }
      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0;
        const results = [];
        let matches;
        while ((matches = STYLE_REGEX.exec(style)) !== null) {
          const name = matches[1];
          if (matches[2]) {
            const args = parseArguments(name, matches[2]);
            results.push([name].concat(args));
          } else {
            results.push([name]);
          }
        }
        return results;
      }
      function buildStyle(chalk5, styles) {
        const enabled = {};
        for (const layer of styles) {
          for (const style of layer.styles) {
            enabled[style[0]] = layer.inverse ? null : style.slice(1);
          }
        }
        let current = chalk5;
        for (const [styleName, styles2] of Object.entries(enabled)) {
          if (!Array.isArray(styles2)) {
            continue;
          }
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
        }
        return current;
      }
      module.exports = (chalk5, temporary) => {
        const styles = [];
        const chunks = [];
        let chunk = [];
        temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
          if (escapeCharacter) {
            chunk.push(unescape(escapeCharacter));
          } else if (style) {
            const string = chunk.join("");
            chunk = [];
            chunks.push(styles.length === 0 ? string : buildStyle(chalk5, styles)(string));
            styles.push({ inverse, styles: parseStyle(style) });
          } else if (close) {
            if (styles.length === 0) {
              throw new Error("Found extraneous } in Chalk template literal");
            }
            chunks.push(buildStyle(chalk5, styles)(chunk.join("")));
            chunk = [];
            styles.pop();
          } else {
            chunk.push(character);
          }
        });
        chunks.push(chunk.join(""));
        if (styles.length > 0) {
          const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(errMessage);
        }
        return chunks.join("");
      };
    }
  });

  // node_modules/chalk/source/index.js
  var require_source = __commonJS({
    "node_modules/chalk/source/index.js"(exports, module) {
      "use strict";
      init_shim();
      var ansiStyles = require_ansi_styles();
      var { stdout: stdoutColor, stderr: stderrColor } = require_browser3();
      var {
        stringReplaceAll,
        stringEncaseCRLFWithFirstIndex
      } = require_util3();
      var { isArray } = Array;
      var levelMapping = [
        "ansi",
        "ansi",
        "ansi256",
        "ansi16m"
      ];
      var styles = /* @__PURE__ */ Object.create(null);
      var applyOptions = (object, options = {}) => {
        if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
          throw new Error("The `level` option should be an integer from 0 to 3");
        }
        const colorLevel = stdoutColor ? stdoutColor.level : 0;
        object.level = options.level === void 0 ? colorLevel : options.level;
      };
      var ChalkClass = class {
        constructor(options) {
          return chalkFactory(options);
        }
      };
      var chalkFactory = (options) => {
        const chalk6 = {};
        applyOptions(chalk6, options);
        chalk6.template = (...arguments_) => chalkTag(chalk6.template, ...arguments_);
        Object.setPrototypeOf(chalk6, Chalk.prototype);
        Object.setPrototypeOf(chalk6.template, chalk6);
        chalk6.template.constructor = () => {
          throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
        };
        chalk6.template.Instance = ChalkClass;
        return chalk6.template;
      };
      function Chalk(options) {
        return chalkFactory(options);
      }
      for (const [styleName, style] of Object.entries(ansiStyles)) {
        styles[styleName] = {
          get() {
            const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
            Object.defineProperty(this, styleName, { value: builder });
            return builder;
          }
        };
      }
      styles.visible = {
        get() {
          const builder = createBuilder(this, this._styler, true);
          Object.defineProperty(this, "visible", { value: builder });
          return builder;
        }
      };
      var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
      for (const model of usedModels) {
        styles[model] = {
          get() {
            const { level } = this;
            return function(...arguments_) {
              const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
              return createBuilder(this, styler, this._isEmpty);
            };
          }
        };
      }
      for (const model of usedModels) {
        const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles[bgModel] = {
          get() {
            const { level } = this;
            return function(...arguments_) {
              const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
              return createBuilder(this, styler, this._isEmpty);
            };
          }
        };
      }
      var proto = Object.defineProperties(() => {
      }, {
        ...styles,
        level: {
          enumerable: true,
          get() {
            return this._generator.level;
          },
          set(level) {
            this._generator.level = level;
          }
        }
      });
      var createStyler = (open, close, parent) => {
        let openAll;
        let closeAll;
        if (parent === void 0) {
          openAll = open;
          closeAll = close;
        } else {
          openAll = parent.openAll + open;
          closeAll = close + parent.closeAll;
        }
        return {
          open,
          close,
          openAll,
          closeAll,
          parent
        };
      };
      var createBuilder = (self2, _styler, _isEmpty) => {
        const builder = (...arguments_) => {
          if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
            return applyStyle(builder, chalkTag(builder, ...arguments_));
          }
          return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
        };
        Object.setPrototypeOf(builder, proto);
        builder._generator = self2;
        builder._styler = _styler;
        builder._isEmpty = _isEmpty;
        return builder;
      };
      var applyStyle = (self2, string) => {
        if (self2.level <= 0 || !string) {
          return self2._isEmpty ? "" : string;
        }
        let styler = self2._styler;
        if (styler === void 0) {
          return string;
        }
        const { openAll, closeAll } = styler;
        if (string.indexOf("\x1B") !== -1) {
          while (styler !== void 0) {
            string = stringReplaceAll(string, styler.close, styler.open);
            styler = styler.parent;
          }
        }
        const lfIndex = string.indexOf("\n");
        if (lfIndex !== -1) {
          string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
        }
        return openAll + string + closeAll;
      };
      var template;
      var chalkTag = (chalk6, ...strings) => {
        const [firstString] = strings;
        if (!isArray(firstString) || !isArray(firstString.raw)) {
          return strings.join(" ");
        }
        const arguments_ = strings.slice(1);
        const parts = [firstString.raw[0]];
        for (let i = 1; i < firstString.length; i++) {
          parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
        }
        if (template === void 0) {
          template = require_templates();
        }
        return template(chalk6, parts.join(""));
      };
      Object.defineProperties(Chalk.prototype, styles);
      var chalk5 = Chalk();
      chalk5.supportsColor = stdoutColor;
      chalk5.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
      chalk5.stderr.supportsColor = stderrColor;
      module.exports = chalk5;
    }
  });

  // node_modules/json-colorizer/src/lib/lexer.js
  var require_lexer = __commonJS({
    "node_modules/json-colorizer/src/lib/lexer.js"(exports) {
      init_shim();
      var tokenTypes = [
        { regex: /^\s+/, tokenType: "WHITESPACE" },
        { regex: /^[{}]/, tokenType: "BRACE" },
        { regex: /^[[\]]/, tokenType: "BRACKET" },
        { regex: /^:/, tokenType: "COLON" },
        { regex: /^,/, tokenType: "COMMA" },
        { regex: /^-?\d+(?:\.\d+)?(?:e[+-]?\d+)?/i, tokenType: "NUMBER_LITERAL" },
        { regex: /^"(?:\\.|[^"\\])*"(?=\s*:)/, tokenType: "STRING_KEY" },
        { regex: /^"(?:\\.|[^"\\])*"/, tokenType: "STRING_LITERAL" },
        { regex: /^true|^false/, tokenType: "BOOLEAN_LITERAL" },
        { regex: /^null/, tokenType: "NULL_LITERAL" }
      ];
      exports.getTokens = function getTokens(json, options = {}) {
        let input;
        if (options.pretty) {
          const inputObj = typeof json === "string" ? JSON.parse(json) : json;
          input = JSON.stringify(inputObj, null, 2);
        } else {
          input = typeof json === "string" ? json : JSON.stringify(json);
        }
        let tokens = [];
        let foundToken;
        do {
          foundToken = false;
          for (let i = 0; i < tokenTypes.length; i++) {
            const match = tokenTypes[i].regex.exec(input);
            if (match) {
              tokens.push({ type: tokenTypes[i].tokenType, value: match[0] });
              input = input.substring(match[0].length);
              foundToken = true;
              break;
            }
          }
        } while (_allTokensAnalyzed(input, foundToken));
        return tokens;
      };
      function _allTokensAnalyzed(input, foundToken) {
        const safeInput = input || {};
        const inputLength = safeInput.length;
        return inputLength > 0 && foundToken;
      }
    }
  });

  // node_modules/escape-string-regexp/index.js
  var require_escape_string_regexp = __commonJS({
    "node_modules/escape-string-regexp/index.js"(exports, module) {
      "use strict";
      init_shim();
      var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
      module.exports = function(str) {
        if (typeof str !== "string") {
          throw new TypeError("Expected a string");
        }
        return str.replace(matchOperatorsRe, "\\$&");
      };
    }
  });

  // node_modules/json-colorizer/node_modules/color-name/index.js
  var require_color_name2 = __commonJS({
    "node_modules/json-colorizer/node_modules/color-name/index.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // node_modules/json-colorizer/node_modules/color-convert/conversions.js
  var require_conversions2 = __commonJS({
    "node_modules/json-colorizer/node_modules/color-convert/conversions.js"(exports, module) {
      init_shim();
      var cssKeywords = require_color_name2();
      var reverseKeywords = {};
      for (key in cssKeywords) {
        if (cssKeywords.hasOwnProperty(key)) {
          reverseKeywords[cssKeywords[key]] = key;
        }
      }
      var key;
      var convert2 = module.exports = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] }
      };
      for (model in convert2) {
        if (convert2.hasOwnProperty(model)) {
          if (!("channels" in convert2[model])) {
            throw new Error("missing channels property: " + model);
          }
          if (!("labels" in convert2[model])) {
            throw new Error("missing channel labels property: " + model);
          }
          if (convert2[model].labels.length !== convert2[model].channels) {
            throw new Error("channel and label counts mismatch: " + model);
          }
          channels = convert2[model].channels;
          labels = convert2[model].labels;
          delete convert2[model].channels;
          delete convert2[model].labels;
          Object.defineProperty(convert2[model], "channels", { value: channels });
          Object.defineProperty(convert2[model], "labels", { value: labels });
        }
      }
      var channels;
      var labels;
      var model;
      convert2.rgb.hsl = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var min = Math.min(r, g, b);
        var max = Math.max(r, g, b);
        var delta = max - min;
        var h;
        var s;
        var l;
        if (max === min) {
          h = 0;
        } else if (r === max) {
          h = (g - b) / delta;
        } else if (g === max) {
          h = 2 + (b - r) / delta;
        } else if (b === max) {
          h = 4 + (r - g) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0) {
          h += 360;
        }
        l = (min + max) / 2;
        if (max === min) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max + min);
        } else {
          s = delta / (2 - max - min);
        }
        return [h, s * 100, l * 100];
      };
      convert2.rgb.hsv = function(rgb) {
        var rdif;
        var gdif;
        var bdif;
        var h;
        var s;
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var v = Math.max(r, g, b);
        var diff = v - Math.min(r, g, b);
        var diffc = function(c) {
          return (v - c) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
          h = s = 0;
        } else {
          s = diff / v;
          rdif = diffc(r);
          gdif = diffc(g);
          bdif = diffc(b);
          if (r === v) {
            h = bdif - gdif;
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif;
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
          }
          if (h < 0) {
            h += 1;
          } else if (h > 1) {
            h -= 1;
          }
        }
        return [
          h * 360,
          s * 100,
          v * 100
        ];
      };
      convert2.rgb.hwb = function(rgb) {
        var r = rgb[0];
        var g = rgb[1];
        var b = rgb[2];
        var h = convert2.rgb.hsl(rgb)[0];
        var w = 1 / 255 * Math.min(r, Math.min(g, b));
        b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
        return [h, w * 100, b * 100];
      };
      convert2.rgb.cmyk = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var c;
        var m;
        var y;
        var k;
        k = Math.min(1 - r, 1 - g, 1 - b);
        c = (1 - r - k) / (1 - k) || 0;
        m = (1 - g - k) / (1 - k) || 0;
        y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
      };
      function comparativeDistance(x, y) {
        return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
      }
      convert2.rgb.keyword = function(rgb) {
        var reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        var currentClosestDistance = Infinity;
        var currentClosestKeyword;
        for (var keyword in cssKeywords) {
          if (cssKeywords.hasOwnProperty(keyword)) {
            var value = cssKeywords[keyword];
            var distance = comparativeDistance(rgb, value);
            if (distance < currentClosestDistance) {
              currentClosestDistance = distance;
              currentClosestKeyword = keyword;
            }
          }
        }
        return currentClosestKeyword;
      };
      convert2.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      };
      convert2.rgb.xyz = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      };
      convert2.rgb.lab = function(rgb) {
        var xyz = convert2.rgb.xyz(rgb);
        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];
        var l;
        var a;
        var b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      };
      convert2.hsl.rgb = function(hsl) {
        var h = hsl[0] / 360;
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var t1;
        var t2;
        var t3;
        var rgb;
        var val;
        if (s === 0) {
          val = l * 255;
          return [val, val, val];
        }
        if (l < 0.5) {
          t2 = l * (1 + s);
        } else {
          t2 = l + s - l * s;
        }
        t1 = 2 * l - t2;
        rgb = [0, 0, 0];
        for (var i = 0; i < 3; i++) {
          t3 = h + 1 / 3 * -(i - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i] = val * 255;
        }
        return rgb;
      };
      convert2.hsl.hsv = function(hsl) {
        var h = hsl[0];
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var smin = s;
        var lmin = Math.max(l, 0.01);
        var sv;
        var v;
        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        v = (l + s) / 2;
        sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
        return [h, sv * 100, v * 100];
      };
      convert2.hsv.rgb = function(hsv) {
        var h = hsv[0] / 60;
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var hi = Math.floor(h) % 6;
        var f = h - Math.floor(h);
        var p = 255 * v * (1 - s);
        var q = 255 * v * (1 - s * f);
        var t = 255 * v * (1 - s * (1 - f));
        v *= 255;
        switch (hi) {
          case 0:
            return [v, t, p];
          case 1:
            return [q, v, p];
          case 2:
            return [p, v, t];
          case 3:
            return [p, q, v];
          case 4:
            return [t, p, v];
          case 5:
            return [v, p, q];
        }
      };
      convert2.hsv.hsl = function(hsv) {
        var h = hsv[0];
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var vmin = Math.max(v, 0.01);
        var lmin;
        var sl;
        var l;
        l = (2 - s) * v;
        lmin = (2 - s) * vmin;
        sl = s * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
      };
      convert2.hwb.rgb = function(hwb) {
        var h = hwb[0] / 360;
        var wh = hwb[1] / 100;
        var bl = hwb[2] / 100;
        var ratio = wh + bl;
        var i;
        var v;
        var f;
        var n;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        i = Math.floor(6 * h);
        v = 1 - bl;
        f = 6 * h - i;
        if ((i & 1) !== 0) {
          f = 1 - f;
        }
        n = wh + f * (v - wh);
        var r;
        var g;
        var b;
        switch (i) {
          default:
          case 6:
          case 0:
            r = v;
            g = n;
            b = wh;
            break;
          case 1:
            r = n;
            g = v;
            b = wh;
            break;
          case 2:
            r = wh;
            g = v;
            b = n;
            break;
          case 3:
            r = wh;
            g = n;
            b = v;
            break;
          case 4:
            r = n;
            g = wh;
            b = v;
            break;
          case 5:
            r = v;
            g = wh;
            b = n;
            break;
        }
        return [r * 255, g * 255, b * 255];
      };
      convert2.cmyk.rgb = function(cmyk) {
        var c = cmyk[0] / 100;
        var m = cmyk[1] / 100;
        var y = cmyk[2] / 100;
        var k = cmyk[3] / 100;
        var r;
        var g;
        var b;
        r = 1 - Math.min(1, c * (1 - k) + k);
        g = 1 - Math.min(1, m * (1 - k) + k);
        b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g * 255, b * 255];
      };
      convert2.xyz.rgb = function(xyz) {
        var x = xyz[0] / 100;
        var y = xyz[1] / 100;
        var z = xyz[2] / 100;
        var r;
        var g;
        var b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
        g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
        b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
      };
      convert2.xyz.lab = function(xyz) {
        var x = xyz[0];
        var y = xyz[1];
        var z = xyz[2];
        var l;
        var a;
        var b;
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
        l = 116 * y - 16;
        a = 500 * (x - y);
        b = 200 * (y - z);
        return [l, a, b];
      };
      convert2.lab.xyz = function(lab) {
        var l = lab[0];
        var a = lab[1];
        var b = lab[2];
        var x;
        var y;
        var z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        var y2 = Math.pow(y, 3);
        var x2 = Math.pow(x, 3);
        var z2 = Math.pow(z, 3);
        y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
      };
      convert2.lab.lch = function(lab) {
        var l = lab[0];
        var a = lab[1];
        var b = lab[2];
        var hr;
        var h;
        var c;
        hr = Math.atan2(b, a);
        h = hr * 360 / 2 / Math.PI;
        if (h < 0) {
          h += 360;
        }
        c = Math.sqrt(a * a + b * b);
        return [l, c, h];
      };
      convert2.lch.lab = function(lch) {
        var l = lch[0];
        var c = lch[1];
        var h = lch[2];
        var a;
        var b;
        var hr;
        hr = h / 360 * 2 * Math.PI;
        a = c * Math.cos(hr);
        b = c * Math.sin(hr);
        return [l, a, b];
      };
      convert2.rgb.ansi16 = function(args) {
        var r = args[0];
        var g = args[1];
        var b = args[2];
        var value = 1 in arguments ? arguments[1] : convert2.rgb.hsv(args)[2];
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert2.hsv.ansi16 = function(args) {
        return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
      };
      convert2.rgb.ansi256 = function(args) {
        var r = args[0];
        var g = args[1];
        var b = args[2];
        if (r === g && g === b) {
          if (r < 8) {
            return 16;
          }
          if (r > 248) {
            return 231;
          }
          return Math.round((r - 8) / 247 * 24) + 232;
        }
        var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
        return ansi;
      };
      convert2.ansi16.rgb = function(args) {
        var color = args % 10;
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5;
          }
          color = color / 10.5 * 255;
          return [color, color, color];
        }
        var mult = (~~(args > 50) + 1) * 0.5;
        var r = (color & 1) * mult * 255;
        var g = (color >> 1 & 1) * mult * 255;
        var b = (color >> 2 & 1) * mult * 255;
        return [r, g, b];
      };
      convert2.ansi256.rgb = function(args) {
        if (args >= 232) {
          var c = (args - 232) * 10 + 8;
          return [c, c, c];
        }
        args -= 16;
        var rem;
        var r = Math.floor(args / 36) / 5 * 255;
        var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
        var b = rem % 6 / 5 * 255;
        return [r, g, b];
      };
      convert2.rgb.hex = function(args) {
        var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        var string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert2.hex.rgb = function(args) {
        var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) {
          return [0, 0, 0];
        }
        var colorString = match[0];
        if (match[0].length === 3) {
          colorString = colorString.split("").map(function(char) {
            return char + char;
          }).join("");
        }
        var integer = parseInt(colorString, 16);
        var r = integer >> 16 & 255;
        var g = integer >> 8 & 255;
        var b = integer & 255;
        return [r, g, b];
      };
      convert2.rgb.hcg = function(rgb) {
        var r = rgb[0] / 255;
        var g = rgb[1] / 255;
        var b = rgb[2] / 255;
        var max = Math.max(Math.max(r, g), b);
        var min = Math.min(Math.min(r, g), b);
        var chroma = max - min;
        var grayscale;
        var hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max === r) {
          hue = (g - b) / chroma % 6;
        } else if (max === g) {
          hue = 2 + (b - r) / chroma;
        } else {
          hue = 4 + (r - g) / chroma + 4;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert2.hsl.hcg = function(hsl) {
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var c = 1;
        var f = 0;
        if (l < 0.5) {
          c = 2 * s * l;
        } else {
          c = 2 * s * (1 - l);
        }
        if (c < 1) {
          f = (l - 0.5 * c) / (1 - c);
        }
        return [hsl[0], c * 100, f * 100];
      };
      convert2.hsv.hcg = function(hsv) {
        var s = hsv[1] / 100;
        var v = hsv[2] / 100;
        var c = s * v;
        var f = 0;
        if (c < 1) {
          f = (v - c) / (1 - c);
        }
        return [hsv[0], c * 100, f * 100];
      };
      convert2.hcg.rgb = function(hcg) {
        var h = hcg[0] / 360;
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        if (c === 0) {
          return [g * 255, g * 255, g * 255];
        }
        var pure = [0, 0, 0];
        var hi = h % 1 * 6;
        var v = hi % 1;
        var w = 1 - v;
        var mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
        }
        mg = (1 - c) * g;
        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255
        ];
      };
      convert2.hcg.hsv = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var v = c + g * (1 - c);
        var f = 0;
        if (v > 0) {
          f = c / v;
        }
        return [hcg[0], f * 100, v * 100];
      };
      convert2.hcg.hsl = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var l = g * (1 - c) + 0.5 * c;
        var s = 0;
        if (l > 0 && l < 0.5) {
          s = c / (2 * l);
        } else if (l >= 0.5 && l < 1) {
          s = c / (2 * (1 - l));
        }
        return [hcg[0], s * 100, l * 100];
      };
      convert2.hcg.hwb = function(hcg) {
        var c = hcg[1] / 100;
        var g = hcg[2] / 100;
        var v = c + g * (1 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
      };
      convert2.hwb.hcg = function(hwb) {
        var w = hwb[1] / 100;
        var b = hwb[2] / 100;
        var v = 1 - b;
        var c = v - w;
        var g = 0;
        if (c < 1) {
          g = (v - c) / (1 - c);
        }
        return [hwb[0], c * 100, g * 100];
      };
      convert2.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert2.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert2.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert2.gray.hsl = convert2.gray.hsv = function(args) {
        return [0, 0, args[0]];
      };
      convert2.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert2.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert2.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert2.gray.hex = function(gray) {
        var val = Math.round(gray[0] / 100 * 255) & 255;
        var integer = (val << 16) + (val << 8) + val;
        var string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert2.rgb.gray = function(rgb) {
        var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    }
  });

  // node_modules/json-colorizer/node_modules/color-convert/route.js
  var require_route2 = __commonJS({
    "node_modules/json-colorizer/node_modules/color-convert/route.js"(exports, module) {
      init_shim();
      var conversions = require_conversions2();
      function buildGraph() {
        var graph2 = {};
        var models = Object.keys(conversions);
        for (var len = models.length, i = 0; i < len; i++) {
          graph2[models[i]] = {
            distance: -1,
            parent: null
          };
        }
        return graph2;
      }
      function deriveBFS(fromModel) {
        var graph2 = buildGraph();
        var queue = [fromModel];
        graph2[fromModel].distance = 0;
        while (queue.length) {
          var current = queue.pop();
          var adjacents = Object.keys(conversions[current]);
          for (var len = adjacents.length, i = 0; i < len; i++) {
            var adjacent = adjacents[i];
            var node19 = graph2[adjacent];
            if (node19.distance === -1) {
              node19.distance = graph2[current].distance + 1;
              node19.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph2;
      }
      function link(from, to) {
        return function(args) {
          return to(from(args));
        };
      }
      function wrapConversion(toModel, graph2) {
        var path = [graph2[toModel].parent, toModel];
        var fn = conversions[graph2[toModel].parent][toModel];
        var cur = graph2[toModel].parent;
        while (graph2[cur].parent) {
          path.unshift(graph2[cur].parent);
          fn = link(conversions[graph2[cur].parent][cur], fn);
          cur = graph2[cur].parent;
        }
        fn.conversion = path;
        return fn;
      }
      module.exports = function(fromModel) {
        var graph2 = deriveBFS(fromModel);
        var conversion = {};
        var models = Object.keys(graph2);
        for (var len = models.length, i = 0; i < len; i++) {
          var toModel = models[i];
          var node19 = graph2[toModel];
          if (node19.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph2);
        }
        return conversion;
      };
    }
  });

  // node_modules/json-colorizer/node_modules/color-convert/index.js
  var require_color_convert2 = __commonJS({
    "node_modules/json-colorizer/node_modules/color-convert/index.js"(exports, module) {
      init_shim();
      var conversions = require_conversions2();
      var route = require_route2();
      var convert2 = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        var wrappedFn = function(args) {
          if (args === void 0 || args === null) {
            return args;
          }
          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments);
          }
          return fn(args);
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(fn) {
        var wrappedFn = function(args) {
          if (args === void 0 || args === null) {
            return args;
          }
          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments);
          }
          var result = fn(args);
          if (typeof result === "object") {
            for (var len = result.length, i = 0; i < len; i++) {
              result[i] = Math.round(result[i]);
            }
          }
          return result;
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      models.forEach(function(fromModel) {
        convert2[fromModel] = {};
        Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels });
        Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
        var routes = route(fromModel);
        var routeModels = Object.keys(routes);
        routeModels.forEach(function(toModel) {
          var fn = routes[toModel];
          convert2[fromModel][toModel] = wrapRounded(fn);
          convert2[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module.exports = convert2;
    }
  });

  // node_modules/json-colorizer/node_modules/ansi-styles/index.js
  var require_ansi_styles2 = __commonJS({
    "node_modules/json-colorizer/node_modules/ansi-styles/index.js"(exports, module) {
      "use strict";
      init_shim();
      var colorConvert = require_color_convert2();
      var wrapAnsi16 = (fn, offset) => function() {
        const code = fn.apply(colorConvert, arguments);
        return `\x1B[${code + offset}m`;
      };
      var wrapAnsi256 = (fn, offset) => function() {
        const code = fn.apply(colorConvert, arguments);
        return `\x1B[${38 + offset};5;${code}m`;
      };
      var wrapAnsi16m = (fn, offset) => function() {
        const rgb = fn.apply(colorConvert, arguments);
        return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
      };
      function assembleStyles() {
        const codes = /* @__PURE__ */ new Map();
        const styles = {
          modifier: {
            reset: [0, 0],
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            gray: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles.color.grey = styles.color.gray;
        for (const groupName of Object.keys(styles)) {
          const group17 = styles[groupName];
          for (const styleName of Object.keys(group17)) {
            const style = group17[styleName];
            styles[styleName] = {
              open: `\x1B[${style[0]}m`,
              close: `\x1B[${style[1]}m`
            };
            group17[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
          }
          Object.defineProperty(styles, groupName, {
            value: group17,
            enumerable: false
          });
          Object.defineProperty(styles, "codes", {
            value: codes,
            enumerable: false
          });
        }
        const ansi2ansi = (n) => n;
        const rgb2rgb = (r, g, b) => [r, g, b];
        styles.color.close = "\x1B[39m";
        styles.bgColor.close = "\x1B[49m";
        styles.color.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 0)
        };
        styles.color.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 0)
        };
        styles.color.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 0)
        };
        styles.bgColor.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 10)
        };
        styles.bgColor.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 10)
        };
        styles.bgColor.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 10)
        };
        for (let key of Object.keys(colorConvert)) {
          if (typeof colorConvert[key] !== "object") {
            continue;
          }
          const suite = colorConvert[key];
          if (key === "ansi16") {
            key = "ansi";
          }
          if ("ansi16" in suite) {
            styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
            styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
          }
          if ("ansi256" in suite) {
            styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
            styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
          }
          if ("rgb" in suite) {
            styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
            styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
          }
        }
        return styles;
      }
      Object.defineProperty(module, "exports", {
        enumerable: true,
        get: assembleStyles
      });
    }
  });

  // node_modules/json-colorizer/node_modules/supports-color/browser.js
  var require_browser4 = __commonJS({
    "node_modules/json-colorizer/node_modules/supports-color/browser.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = {
        stdout: false,
        stderr: false
      };
    }
  });

  // node_modules/json-colorizer/node_modules/chalk/templates.js
  var require_templates2 = __commonJS({
    "node_modules/json-colorizer/node_modules/chalk/templates.js"(exports, module) {
      "use strict";
      init_shim();
      var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
      var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
      var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
      var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
      var ESCAPES = /* @__PURE__ */ new Map([
        ["n", "\n"],
        ["r", "\r"],
        ["t", "	"],
        ["b", "\b"],
        ["f", "\f"],
        ["v", "\v"],
        ["0", "\0"],
        ["\\", "\\"],
        ["e", "\x1B"],
        ["a", "\x07"]
      ]);
      function unescape(c) {
        if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
          return String.fromCharCode(parseInt(c.slice(1), 16));
        }
        return ESCAPES.get(c) || c;
      }
      function parseArguments(name, args) {
        const results = [];
        const chunks = args.trim().split(/\s*,\s*/g);
        let matches;
        for (const chunk of chunks) {
          if (!isNaN(chunk)) {
            results.push(Number(chunk));
          } else if (matches = chunk.match(STRING_REGEX)) {
            results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
          } else {
            throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
          }
        }
        return results;
      }
      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0;
        const results = [];
        let matches;
        while ((matches = STYLE_REGEX.exec(style)) !== null) {
          const name = matches[1];
          if (matches[2]) {
            const args = parseArguments(name, matches[2]);
            results.push([name].concat(args));
          } else {
            results.push([name]);
          }
        }
        return results;
      }
      function buildStyle(chalk5, styles) {
        const enabled = {};
        for (const layer of styles) {
          for (const style of layer.styles) {
            enabled[style[0]] = layer.inverse ? null : style.slice(1);
          }
        }
        let current = chalk5;
        for (const styleName of Object.keys(enabled)) {
          if (Array.isArray(enabled[styleName])) {
            if (!(styleName in current)) {
              throw new Error(`Unknown Chalk style: ${styleName}`);
            }
            if (enabled[styleName].length > 0) {
              current = current[styleName].apply(current, enabled[styleName]);
            } else {
              current = current[styleName];
            }
          }
        }
        return current;
      }
      module.exports = (chalk5, tmp) => {
        const styles = [];
        const chunks = [];
        let chunk = [];
        tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
          if (escapeChar) {
            chunk.push(unescape(escapeChar));
          } else if (style) {
            const str = chunk.join("");
            chunk = [];
            chunks.push(styles.length === 0 ? str : buildStyle(chalk5, styles)(str));
            styles.push({ inverse, styles: parseStyle(style) });
          } else if (close) {
            if (styles.length === 0) {
              throw new Error("Found extraneous } in Chalk template literal");
            }
            chunks.push(buildStyle(chalk5, styles)(chunk.join("")));
            chunk = [];
            styles.pop();
          } else {
            chunk.push(chr);
          }
        });
        chunks.push(chunk.join(""));
        if (styles.length > 0) {
          const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(errMsg);
        }
        return chunks.join("");
      };
    }
  });

  // node_modules/json-colorizer/node_modules/chalk/index.js
  var require_chalk = __commonJS({
    "node_modules/json-colorizer/node_modules/chalk/index.js"(exports, module) {
      "use strict";
      init_shim();
      var escapeStringRegexp = require_escape_string_regexp();
      var ansiStyles = require_ansi_styles2();
      var stdoutColor = require_browser4().stdout;
      var template = require_templates2();
      var isSimpleWindowsTerm = import_process.default.platform === "win32" && !(import_process.default.env.TERM || "").toLowerCase().startsWith("xterm");
      var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
      var skipModels = /* @__PURE__ */ new Set(["gray"]);
      var styles = /* @__PURE__ */ Object.create(null);
      function applyOptions(obj, options) {
        options = options || {};
        const scLevel = stdoutColor ? stdoutColor.level : 0;
        obj.level = options.level === void 0 ? scLevel : options.level;
        obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
      }
      function Chalk(options) {
        if (!this || !(this instanceof Chalk) || this.template) {
          const chalk5 = {};
          applyOptions(chalk5, options);
          chalk5.template = function() {
            const args = [].slice.call(arguments);
            return chalkTag.apply(null, [chalk5.template].concat(args));
          };
          Object.setPrototypeOf(chalk5, Chalk.prototype);
          Object.setPrototypeOf(chalk5.template, chalk5);
          chalk5.template.constructor = Chalk;
          return chalk5.template;
        }
        applyOptions(this, options);
      }
      if (isSimpleWindowsTerm) {
        ansiStyles.blue.open = "\x1B[94m";
      }
      for (const key of Object.keys(ansiStyles)) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        styles[key] = {
          get() {
            const codes = ansiStyles[key];
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
          }
        };
      }
      styles.visible = {
        get() {
          return build.call(this, this._styles || [], true, "visible");
        }
      };
      ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
      for (const model of Object.keys(ansiStyles.color.ansi)) {
        if (skipModels.has(model)) {
          continue;
        }
        styles[model] = {
          get() {
            const level = this.level;
            return function() {
              const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
              const codes = {
                open,
                close: ansiStyles.color.close,
                closeRe: ansiStyles.color.closeRe
              };
              return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
            };
          }
        };
      }
      ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
      for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
        if (skipModels.has(model)) {
          continue;
        }
        const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles[bgModel] = {
          get() {
            const level = this.level;
            return function() {
              const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
              const codes = {
                open,
                close: ansiStyles.bgColor.close,
                closeRe: ansiStyles.bgColor.closeRe
              };
              return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
            };
          }
        };
      }
      var proto = Object.defineProperties(() => {
      }, styles);
      function build(_styles, _empty, key) {
        const builder = function() {
          return applyStyle.apply(builder, arguments);
        };
        builder._styles = _styles;
        builder._empty = _empty;
        const self2 = this;
        Object.defineProperty(builder, "level", {
          enumerable: true,
          get() {
            return self2.level;
          },
          set(level) {
            self2.level = level;
          }
        });
        Object.defineProperty(builder, "enabled", {
          enumerable: true,
          get() {
            return self2.enabled;
          },
          set(enabled) {
            self2.enabled = enabled;
          }
        });
        builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
        builder.__proto__ = proto;
        return builder;
      }
      function applyStyle() {
        const args = arguments;
        const argsLen = args.length;
        let str = String(arguments[0]);
        if (argsLen === 0) {
          return "";
        }
        if (argsLen > 1) {
          for (let a = 1; a < argsLen; a++) {
            str += " " + args[a];
          }
        }
        if (!this.enabled || this.level <= 0 || !str) {
          return this._empty ? "" : str;
        }
        const originalDim = ansiStyles.dim.open;
        if (isSimpleWindowsTerm && this.hasGrey) {
          ansiStyles.dim.open = "";
        }
        for (const code of this._styles.slice().reverse()) {
          str = code.open + str.replace(code.closeRe, code.open) + code.close;
          str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
        }
        ansiStyles.dim.open = originalDim;
        return str;
      }
      function chalkTag(chalk5, strings) {
        if (!Array.isArray(strings)) {
          return [].slice.call(arguments, 1).join(" ");
        }
        const args = [].slice.call(arguments, 2);
        const parts = [strings.raw[0]];
        for (let i = 1; i < strings.length; i++) {
          parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
          parts.push(String(strings.raw[i]));
        }
        return template(chalk5, parts.join(""));
      }
      Object.defineProperties(Chalk.prototype, styles);
      module.exports = Chalk();
      module.exports.supportsColor = stdoutColor;
      module.exports.default = module.exports;
    }
  });

  // node_modules/lodash.get/index.js
  var require_lodash = __commonJS({
    "node_modules/lodash.get/index.js"(exports, module) {
      init_shim();
      var FUNC_ERROR_TEXT = "Expected a function";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var INFINITY = 1 / 0;
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var symbolTag = "[object Symbol]";
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      var reLeadingDot = /^\./;
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var freeGlobal = typeof _global == "object" && _global && _global.Object === Object && _global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e) {
          }
        }
        return result;
      }
      var arrayProto = Array.prototype;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var objectToString = objectProto.toString;
      var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Symbol2 = root.Symbol;
      var splice = arrayProto.splice;
      var Map2 = getNative(root, "Map");
      var nativeCreate = getNative(Object, "create");
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }
      function hashDelete(key) {
        return this.has(key) && delete this.__data__[key];
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        return getMapData(this, key)["delete"](key);
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        getMapData(this, key).set(key, value);
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseGet(object, path) {
        path = isKey(path, object) ? [path] : castPath(path);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function castPath(value) {
        return isArray(value) ? value : stringToPath(value);
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var stringToPath = memoize(function(string) {
        string = toString(string);
        var result = [];
        if (reLeadingDot.test(string)) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, string2) {
          result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result);
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        var tag = isObject(value) ? objectToString.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      module.exports = get;
    }
  });

  // node_modules/json-colorizer/src/lib/colorizer.js
  var require_colorizer = __commonJS({
    "node_modules/json-colorizer/src/lib/colorizer.js"(exports) {
      init_shim();
      var chalk5 = require_chalk();
      var get = require_lodash();
      var defaultColors = {
        BRACE: "gray",
        BRACKET: "gray",
        COLON: "gray",
        COMMA: "gray",
        STRING_KEY: "magenta",
        STRING_LITERAL: "yellow",
        NUMBER_LITERAL: "green",
        BOOLEAN_LITERAL: "cyan",
        NULL_LITERAL: "white"
      };
      exports.colorize = function colorize(tokens, options = {}) {
        const colors = options.colors || {};
        return tokens.reduce((acc, token) => {
          const colorKey = colors[token.type] || defaultColors[token.type];
          const colorFn = colorKey && colorKey[0] === "#" ? chalk5.hex(colorKey) : get(chalk5, colorKey);
          return acc + (colorFn ? colorFn(token.value) : token.value);
        }, "");
      };
    }
  });

  // node_modules/json-colorizer/src/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/json-colorizer/src/lib/index.js"(exports, module) {
      init_shim();
      var lexer = require_lexer();
      var colorizer = require_colorizer();
      module.exports = function colorizeJson(json, options) {
        return colorizer.colorize(lexer.getTokens(json, options), options);
      };
    }
  });

  // node_modules/assert/build/internal/errors.js
  var require_errors2 = __commonJS({
    "node_modules/assert/build/internal/errors.js"(exports, module) {
      "use strict";
      init_shim();
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var codes = {};
      var assert27;
      var util;
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inherits(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            var _this;
            _classCallCheck(this, NodeError2);
            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError2).call(this, getMessage(arg1, arg2, arg3)));
            _this.code = code;
            return _this;
          }
          return NodeError2;
        }(Base);
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        if (assert27 === void 0)
          assert27 = require_assert();
        assert27(typeof name === "string", "'name' must be a string");
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(_typeof(actual));
        return msg;
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
        var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
        if (util === void 0)
          util = require_util2();
        var inspected = util.inspect(value);
        if (inspected.length > 128) {
          inspected = "".concat(inspected.slice(0, 128), "...");
        }
        return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
      }, TypeError, RangeError);
      createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
        var type;
        if (value && value.constructor && value.constructor.name) {
          type = "instance of ".concat(value.constructor.name);
        } else {
          type = "type ".concat(_typeof(value));
        }
        return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
      }, TypeError);
      createErrorType("ERR_MISSING_ARGS", function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (assert27 === void 0)
          assert27 = require_assert();
        assert27(args.length > 0, "At least one arg needs to be specified");
        var msg = "The ";
        var len = args.length;
        args = args.map(function(a) {
          return '"'.concat(a, '"');
        });
        switch (len) {
          case 1:
            msg += "".concat(args[0], " argument");
            break;
          case 2:
            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
            break;
          default:
            msg += args.slice(0, len - 1).join(", ");
            msg += ", and ".concat(args[len - 1], " arguments");
            break;
        }
        return "".concat(msg, " must be specified");
      }, TypeError);
      module.exports.codes = codes;
    }
  });

  // node_modules/assert/build/internal/assert/assertion_error.js
  var require_assertion_error = __commonJS({
    "node_modules/assert/build/internal/assert/assertion_error.js"(exports, module) {
      "use strict";
      init_shim();
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          var ownKeys = Object.keys(source);
          if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
          }
          ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      function isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a = [null];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      var _require = require_util2();
      var inspect = _require.inspect;
      var _require2 = require_errors2();
      var ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function repeat(str, count) {
        count = Math.floor(count);
        if (str.length == 0 || count == 0)
          return "";
        var maxCount = str.length * count;
        count = Math.floor(Math.log(count) / Math.log(2));
        while (count) {
          str += str;
          count--;
        }
        str += str.substring(0, maxCount - str.length);
        return str;
      }
      var blue = "";
      var green = "";
      var red = "";
      var white = "";
      var kReadableOperator = {
        deepStrictEqual: "Expected values to be strictly deep-equal:",
        strictEqual: "Expected values to be strictly equal:",
        strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
        deepEqual: "Expected values to be loosely deep-equal:",
        equal: "Expected values to be loosely equal:",
        notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
        notStrictEqual: 'Expected "actual" to be strictly unequal to:',
        notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
        notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
        notEqual: 'Expected "actual" to be loosely unequal to:',
        notIdentical: "Values identical but not reference-equal:"
      };
      var kMaxShortLength = 10;
      function copyError(source) {
        var keys = Object.keys(source);
        var target = Object.create(Object.getPrototypeOf(source));
        keys.forEach(function(key) {
          target[key] = source[key];
        });
        Object.defineProperty(target, "message", {
          value: source.message
        });
        return target;
      }
      function inspectValue(val) {
        return inspect(val, {
          compact: false,
          customInspect: false,
          depth: 1e3,
          maxArrayLength: Infinity,
          showHidden: false,
          breakLength: Infinity,
          showProxy: false,
          sorted: true,
          getters: true
        });
      }
      function createErrDiff(actual, expected, operator) {
        var other = "";
        var res = "";
        var lastPos = 0;
        var end = "";
        var skipped = false;
        var actualInspected = inspectValue(actual);
        var actualLines = actualInspected.split("\n");
        var expectedLines = inspectValue(expected).split("\n");
        var i = 0;
        var indicator = "";
        if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
          operator = "strictEqualObject";
        }
        if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
          var inputLength = actualLines[0].length + expectedLines[0].length;
          if (inputLength <= kMaxShortLength) {
            if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
              return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
            }
          } else if (operator !== "strictEqualObject") {
            var maxLength = import_process.default.stderr && import_process.default.stderr.isTTY ? import_process.default.stderr.columns : 80;
            if (inputLength < maxLength) {
              while (actualLines[0][i] === expectedLines[0][i]) {
                i++;
              }
              if (i > 2) {
                indicator = "\n  ".concat(repeat(" ", i), "^");
                i = 0;
              }
            }
          }
        }
        var a = actualLines[actualLines.length - 1];
        var b = expectedLines[expectedLines.length - 1];
        while (a === b) {
          if (i++ < 2) {
            end = "\n  ".concat(a).concat(end);
          } else {
            other = a;
          }
          actualLines.pop();
          expectedLines.pop();
          if (actualLines.length === 0 || expectedLines.length === 0)
            break;
          a = actualLines[actualLines.length - 1];
          b = expectedLines[expectedLines.length - 1];
        }
        var maxLines = Math.max(actualLines.length, expectedLines.length);
        if (maxLines === 0) {
          var _actualLines = actualInspected.split("\n");
          if (_actualLines.length > 30) {
            _actualLines[26] = "".concat(blue, "...").concat(white);
            while (_actualLines.length > 27) {
              _actualLines.pop();
            }
          }
          return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
        }
        if (i > 3) {
          end = "\n".concat(blue, "...").concat(white).concat(end);
          skipped = true;
        }
        if (other !== "") {
          end = "\n  ".concat(other).concat(end);
          other = "";
        }
        var printedLines = 0;
        var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
        var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
        for (i = 0; i < maxLines; i++) {
          var cur = i - lastPos;
          if (actualLines.length < i + 1) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(expectedLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(expectedLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
            printedLines++;
          } else if (expectedLines.length < i + 1) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(actualLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(actualLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
            printedLines++;
          } else {
            var expectedLine = expectedLines[i];
            var actualLine = actualLines[i];
            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
            if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
              divergingLines = false;
              actualLine += ",";
            }
            if (divergingLines) {
              if (cur > 1 && i > 2) {
                if (cur > 4) {
                  res += "\n".concat(blue, "...").concat(white);
                  skipped = true;
                } else if (cur > 3) {
                  res += "\n  ".concat(actualLines[i - 2]);
                  printedLines++;
                }
                res += "\n  ".concat(actualLines[i - 1]);
                printedLines++;
              }
              lastPos = i;
              res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
              other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
              printedLines += 2;
            } else {
              res += other;
              other = "";
              if (cur === 1 || i === 0) {
                res += "\n  ".concat(actualLine);
                printedLines++;
              }
            }
          }
          if (printedLines > 20 && i < maxLines - 2) {
            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
          }
        }
        return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
      }
      var AssertionError = /* @__PURE__ */ function(_Error) {
        _inherits(AssertionError2, _Error);
        function AssertionError2(options) {
          var _this;
          _classCallCheck(this, AssertionError2);
          if (_typeof(options) !== "object" || options === null) {
            throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
          }
          var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
          var actual = options.actual, expected = options.expected;
          var limit = Error.stackTraceLimit;
          Error.stackTraceLimit = 0;
          if (message != null) {
            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, String(message)));
          } else {
            if (import_process.default.stderr && import_process.default.stderr.isTTY) {
              if (import_process.default.stderr && import_process.default.stderr.getColorDepth && import_process.default.stderr.getColorDepth() !== 1) {
                blue = "\x1B[34m";
                green = "\x1B[32m";
                white = "\x1B[39m";
                red = "\x1B[31m";
              } else {
                blue = "";
                green = "";
                white = "";
                red = "";
              }
            }
            if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
              actual = copyError(actual);
              expected = copyError(expected);
            }
            if (operator === "deepStrictEqual" || operator === "strictEqual") {
              _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, createErrDiff(actual, expected, operator)));
            } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
              var base = kReadableOperator[operator];
              var res = inspectValue(actual).split("\n");
              if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
                base = kReadableOperator.notStrictEqualObject;
              }
              if (res.length > 30) {
                res[26] = "".concat(blue, "...").concat(white);
                while (res.length > 27) {
                  res.pop();
                }
              }
              if (res.length === 1) {
                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(base, " ").concat(res[0])));
              } else {
                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n")));
              }
            } else {
              var _res = inspectValue(actual);
              var other = "";
              var knownOperators = kReadableOperator[operator];
              if (operator === "notDeepEqual" || operator === "notEqual") {
                _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                if (_res.length > 1024) {
                  _res = "".concat(_res.slice(0, 1021), "...");
                }
              } else {
                other = "".concat(inspectValue(expected));
                if (_res.length > 512) {
                  _res = "".concat(_res.slice(0, 509), "...");
                }
                if (other.length > 512) {
                  other = "".concat(other.slice(0, 509), "...");
                }
                if (operator === "deepEqual" || operator === "equal") {
                  _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                } else {
                  other = " ".concat(operator, " ").concat(other);
                }
              }
              _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(_res).concat(other)));
            }
          }
          Error.stackTraceLimit = limit;
          _this.generatedMessage = !message;
          Object.defineProperty(_assertThisInitialized(_this), "name", {
            value: "AssertionError [ERR_ASSERTION]",
            enumerable: false,
            writable: true,
            configurable: true
          });
          _this.code = "ERR_ASSERTION";
          _this.actual = actual;
          _this.expected = expected;
          _this.operator = operator;
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
          }
          _this.stack;
          _this.name = "AssertionError";
          return _possibleConstructorReturn(_this);
        }
        _createClass(AssertionError2, [{
          key: "toString",
          value: function toString() {
            return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
          }
        }, {
          key: inspect.custom,
          value: function value(recurseTimes, ctx) {
            return inspect(this, _objectSpread({}, ctx, {
              customInspect: false,
              depth: 0
            }));
          }
        }]);
        return AssertionError2;
      }(_wrapNativeSuper(Error));
      module.exports = AssertionError;
    }
  });

  // node_modules/es6-object-assign/index.js
  var require_es6_object_assign = __commonJS({
    "node_modules/es6-object-assign/index.js"(exports, module) {
      "use strict";
      init_shim();
      function assign(target, firstSource) {
        if (target === void 0 || target === null) {
          throw new TypeError("Cannot convert first argument to object");
        }
        var to = Object(target);
        for (var i = 1; i < arguments.length; i++) {
          var nextSource = arguments[i];
          if (nextSource === void 0 || nextSource === null) {
            continue;
          }
          var keysArray = Object.keys(Object(nextSource));
          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== void 0 && desc.enumerable) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
        return to;
      }
      function polyfill() {
        if (!Object.assign) {
          Object.defineProperty(Object, "assign", {
            enumerable: false,
            configurable: true,
            writable: true,
            value: assign
          });
        }
      }
      module.exports = {
        assign,
        polyfill
      };
    }
  });

  // node_modules/object-keys/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/object-keys/isArguments.js"(exports, module) {
      "use strict";
      init_shim();
      var toStr = Object.prototype.toString;
      module.exports = function isArguments(value) {
        var str = toStr.call(value);
        var isArgs = str === "[object Arguments]";
        if (!isArgs) {
          isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
        }
        return isArgs;
      };
    }
  });

  // node_modules/object-keys/implementation.js
  var require_implementation2 = __commonJS({
    "node_modules/object-keys/implementation.js"(exports, module) {
      "use strict";
      init_shim();
      var keysShim;
      if (!Object.keys) {
        has = Object.prototype.hasOwnProperty;
        toStr = Object.prototype.toString;
        isArgs = require_isArguments();
        isEnumerable = Object.prototype.propertyIsEnumerable;
        hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
        hasProtoEnumBug = isEnumerable.call(function() {
        }, "prototype");
        dontEnums = [
          "toString",
          "toLocaleString",
          "valueOf",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "constructor"
        ];
        equalsConstructorPrototype = function(o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        excludedKeys = {
          $applicationCache: true,
          $console: true,
          $external: true,
          $frame: true,
          $frameElement: true,
          $frames: true,
          $innerHeight: true,
          $innerWidth: true,
          $onmozfullscreenchange: true,
          $onmozfullscreenerror: true,
          $outerHeight: true,
          $outerWidth: true,
          $pageXOffset: true,
          $pageYOffset: true,
          $parent: true,
          $scrollLeft: true,
          $scrollTop: true,
          $scrollX: true,
          $scrollY: true,
          $self: true,
          $webkitIndexedDB: true,
          $webkitStorageInfo: true,
          $window: true
        };
        hasAutomationEqualityBug = function() {
          if (typeof window === "undefined") {
            return false;
          }
          for (var k in window) {
            try {
              if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                try {
                  equalsConstructorPrototype(window[k]);
                } catch (e) {
                  return true;
                }
              }
            } catch (e) {
              return true;
            }
          }
          return false;
        }();
        equalsConstructorPrototypeIfNotBuggy = function(o) {
          if (typeof window === "undefined" || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        keysShim = function keys(object) {
          var isObject = object !== null && typeof object === "object";
          var isFunction = toStr.call(object) === "[object Function]";
          var isArguments = isArgs(object);
          var isString2 = isObject && toStr.call(object) === "[object String]";
          var theKeys = [];
          if (!isObject && !isFunction && !isArguments) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var skipProto = hasProtoEnumBug && isFunction;
          if (isString2 && object.length > 0 && !has.call(object, 0)) {
            for (var i = 0; i < object.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments && object.length > 0) {
            for (var j = 0; j < object.length; ++j) {
              theKeys.push(String(j));
            }
          } else {
            for (var name in object) {
              if (!(skipProto && name === "prototype") && has.call(object, name)) {
                theKeys.push(String(name));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for (var k = 0; k < dontEnums.length; ++k) {
              if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
                theKeys.push(dontEnums[k]);
              }
            }
          }
          return theKeys;
        };
      }
      var has;
      var toStr;
      var isArgs;
      var isEnumerable;
      var hasDontEnumBug;
      var hasProtoEnumBug;
      var dontEnums;
      var equalsConstructorPrototype;
      var excludedKeys;
      var hasAutomationEqualityBug;
      var equalsConstructorPrototypeIfNotBuggy;
      module.exports = keysShim;
    }
  });

  // node_modules/object-keys/index.js
  var require_object_keys = __commonJS({
    "node_modules/object-keys/index.js"(exports, module) {
      "use strict";
      init_shim();
      var slice = Array.prototype.slice;
      var isArgs = require_isArguments();
      var origKeys = Object.keys;
      var keysShim = origKeys ? function keys(o) {
        return origKeys(o);
      } : require_implementation2();
      var originalKeys = Object.keys;
      keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
          var keysWorksWithArguments = function() {
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
          }(1, 2);
          if (!keysWorksWithArguments) {
            Object.keys = function keys(object) {
              if (isArgs(object)) {
                return originalKeys(slice.call(object));
              }
              return originalKeys(object);
            };
          }
        } else {
          Object.keys = keysShim;
        }
        return Object.keys || keysShim;
      };
      module.exports = keysShim;
    }
  });

  // node_modules/has-property-descriptors/index.js
  var require_has_property_descriptors = __commonJS({
    "node_modules/has-property-descriptors/index.js"(exports, module) {
      "use strict";
      init_shim();
      var GetIntrinsic = require_get_intrinsic();
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        if ($defineProperty) {
          try {
            $defineProperty({}, "a", { value: 1 });
            return true;
          } catch (e) {
            return false;
          }
        }
        return false;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!hasPropertyDescriptors()) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e) {
          return true;
        }
      };
      module.exports = hasPropertyDescriptors;
    }
  });

  // node_modules/define-properties/index.js
  var require_define_properties = __commonJS({
    "node_modules/define-properties/index.js"(exports, module) {
      "use strict";
      init_shim();
      var keys = require_object_keys();
      var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
      var toStr = Object.prototype.toString;
      var concat = Array.prototype.concat;
      var origDefineProperty = Object.defineProperty;
      var isFunction = function(fn) {
        return typeof fn === "function" && toStr.call(fn) === "[object Function]";
      };
      var hasPropertyDescriptors = require_has_property_descriptors()();
      var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
      var defineProperty = function(object, name, value, predicate) {
        if (name in object && (!isFunction(predicate) || !predicate())) {
          return;
        }
        if (supportsDescriptors) {
          origDefineProperty(object, name, {
            configurable: true,
            enumerable: false,
            value,
            writable: true
          });
        } else {
          object[name] = value;
        }
      };
      var defineProperties = function(object, map) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys(map);
        if (hasSymbols) {
          props = concat.call(props, Object.getOwnPropertySymbols(map));
        }
        for (var i = 0; i < props.length; i += 1) {
          defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
        }
      };
      defineProperties.supportsDescriptors = !!supportsDescriptors;
      module.exports = defineProperties;
    }
  });

  // node_modules/object-is/implementation.js
  var require_implementation3 = __commonJS({
    "node_modules/object-is/implementation.js"(exports, module) {
      "use strict";
      init_shim();
      var numberIsNaN = function(value) {
        return value !== value;
      };
      module.exports = function is(a, b) {
        if (a === 0 && b === 0) {
          return 1 / a === 1 / b;
        }
        if (a === b) {
          return true;
        }
        if (numberIsNaN(a) && numberIsNaN(b)) {
          return true;
        }
        return false;
      };
    }
  });

  // node_modules/object-is/polyfill.js
  var require_polyfill = __commonJS({
    "node_modules/object-is/polyfill.js"(exports, module) {
      "use strict";
      init_shim();
      var implementation = require_implementation3();
      module.exports = function getPolyfill() {
        return typeof Object.is === "function" ? Object.is : implementation;
      };
    }
  });

  // node_modules/object-is/shim.js
  var require_shim = __commonJS({
    "node_modules/object-is/shim.js"(exports, module) {
      "use strict";
      init_shim();
      var getPolyfill = require_polyfill();
      var define = require_define_properties();
      module.exports = function shimObjectIs() {
        var polyfill = getPolyfill();
        define(Object, { is: polyfill }, {
          is: function testObjectIs() {
            return Object.is !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // node_modules/object-is/index.js
  var require_object_is = __commonJS({
    "node_modules/object-is/index.js"(exports, module) {
      "use strict";
      init_shim();
      var define = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation3();
      var getPolyfill = require_polyfill();
      var shim = require_shim();
      var polyfill = callBind(getPolyfill(), Object);
      define(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = polyfill;
    }
  });

  // node_modules/is-nan/implementation.js
  var require_implementation4 = __commonJS({
    "node_modules/is-nan/implementation.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = function isNaN2(value) {
        return value !== value;
      };
    }
  });

  // node_modules/is-nan/polyfill.js
  var require_polyfill2 = __commonJS({
    "node_modules/is-nan/polyfill.js"(exports, module) {
      "use strict";
      init_shim();
      var implementation = require_implementation4();
      module.exports = function getPolyfill() {
        if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
          return Number.isNaN;
        }
        return implementation;
      };
    }
  });

  // node_modules/is-nan/shim.js
  var require_shim2 = __commonJS({
    "node_modules/is-nan/shim.js"(exports, module) {
      "use strict";
      init_shim();
      var define = require_define_properties();
      var getPolyfill = require_polyfill2();
      module.exports = function shimNumberIsNaN() {
        var polyfill = getPolyfill();
        define(Number, { isNaN: polyfill }, {
          isNaN: function testIsNaN() {
            return Number.isNaN !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // node_modules/is-nan/index.js
  var require_is_nan = __commonJS({
    "node_modules/is-nan/index.js"(exports, module) {
      "use strict";
      init_shim();
      var callBind = require_call_bind();
      var define = require_define_properties();
      var implementation = require_implementation4();
      var getPolyfill = require_polyfill2();
      var shim = require_shim2();
      var polyfill = callBind(getPolyfill(), Number);
      define(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = polyfill;
    }
  });

  // node_modules/assert/build/internal/util/comparisons.js
  var require_comparisons = __commonJS({
    "node_modules/assert/build/internal/util/comparisons.js"(exports, module) {
      "use strict";
      init_shim();
      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      function _iterableToArrayLimit(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      var regexFlagsSupported = /a/g.flags !== void 0;
      var arrayFromSet = function arrayFromSet2(set) {
        var array = [];
        set.forEach(function(value) {
          return array.push(value);
        });
        return array;
      };
      var arrayFromMap = function arrayFromMap2(map) {
        var array = [];
        map.forEach(function(value, key) {
          return array.push([key, value]);
        });
        return array;
      };
      var objectIs = Object.is ? Object.is : require_object_is();
      var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
        return [];
      };
      var numberIsNaN = Number.isNaN ? Number.isNaN : require_is_nan();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
      var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
      var objectToString = uncurryThis(Object.prototype.toString);
      var _require$types = require_util2().types;
      var isAnyArrayBuffer = _require$types.isAnyArrayBuffer;
      var isArrayBufferView = _require$types.isArrayBufferView;
      var isDate = _require$types.isDate;
      var isMap = _require$types.isMap;
      var isRegExp = _require$types.isRegExp;
      var isSet = _require$types.isSet;
      var isNativeError = _require$types.isNativeError;
      var isBoxedPrimitive = _require$types.isBoxedPrimitive;
      var isNumberObject = _require$types.isNumberObject;
      var isStringObject = _require$types.isStringObject;
      var isBooleanObject = _require$types.isBooleanObject;
      var isBigIntObject = _require$types.isBigIntObject;
      var isSymbolObject = _require$types.isSymbolObject;
      var isFloat32Array = _require$types.isFloat32Array;
      var isFloat64Array = _require$types.isFloat64Array;
      function isNonIndex(key) {
        if (key.length === 0 || key.length > 10)
          return true;
        for (var i = 0; i < key.length; i++) {
          var code = key.charCodeAt(i);
          if (code < 48 || code > 57)
            return true;
        }
        return key.length === 10 && key >= Math.pow(2, 32);
      }
      function getOwnNonIndexProperties(value) {
        return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
      }
      function compare(a, b) {
        if (a === b) {
          return 0;
        }
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) {
          return -1;
        }
        if (y < x) {
          return 1;
        }
        return 0;
      }
      var ONLY_ENUMERABLE = void 0;
      var kStrict = true;
      var kLoose = false;
      var kNoIterator = 0;
      var kIsArray = 1;
      var kIsSet = 2;
      var kIsMap = 3;
      function areSimilarRegExps(a, b) {
        return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
      }
      function areSimilarFloatArrays(a, b) {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        for (var offset = 0; offset < a.byteLength; offset++) {
          if (a[offset] !== b[offset]) {
            return false;
          }
        }
        return true;
      }
      function areSimilarTypedArrays(a, b) {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
      }
      function areEqualArrayBuffers(buf1, buf2) {
        return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
      }
      function isEqualBoxedPrimitive(val1, val2) {
        if (isNumberObject(val1)) {
          return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
        }
        if (isStringObject(val1)) {
          return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
        }
        if (isBooleanObject(val1)) {
          return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
        }
        if (isBigIntObject(val1)) {
          return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
        }
        return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
      }
      function innerDeepEqual(val1, val2, strict, memos) {
        if (val1 === val2) {
          if (val1 !== 0)
            return true;
          return strict ? objectIs(val1, val2) : true;
        }
        if (strict) {
          if (_typeof(val1) !== "object") {
            return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
          }
          if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
            return false;
          }
          if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
          }
        } else {
          if (val1 === null || _typeof(val1) !== "object") {
            if (val2 === null || _typeof(val2) !== "object") {
              return val1 == val2;
            }
            return false;
          }
          if (val2 === null || _typeof(val2) !== "object") {
            return false;
          }
        }
        var val1Tag = objectToString(val1);
        var val2Tag = objectToString(val2);
        if (val1Tag !== val2Tag) {
          return false;
        }
        if (Array.isArray(val1)) {
          if (val1.length !== val2.length) {
            return false;
          }
          var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
          var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
          if (keys1.length !== keys2.length) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
        }
        if (val1Tag === "[object Object]") {
          if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
            return false;
          }
        }
        if (isDate(val1)) {
          if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
            return false;
          }
        } else if (isRegExp(val1)) {
          if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
            return false;
          }
        } else if (isNativeError(val1) || val1 instanceof Error) {
          if (val1.message !== val2.message || val1.name !== val2.name) {
            return false;
          }
        } else if (isArrayBufferView(val1)) {
          if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
              return false;
            }
          } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
          }
          var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
          var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
          if (_keys.length !== _keys2.length) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
        } else if (isSet(val1)) {
          if (!isSet(val2) || val1.size !== val2.size) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsSet);
        } else if (isMap(val1)) {
          if (!isMap(val2) || val1.size !== val2.size) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsMap);
        } else if (isAnyArrayBuffer(val1)) {
          if (!areEqualArrayBuffers(val1, val2)) {
            return false;
          }
        } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kNoIterator);
      }
      function getEnumerables(val, keys) {
        return keys.filter(function(k) {
          return propertyIsEnumerable(val, k);
        });
      }
      function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
        if (arguments.length === 5) {
          aKeys = Object.keys(val1);
          var bKeys = Object.keys(val2);
          if (aKeys.length !== bKeys.length) {
            return false;
          }
        }
        var i = 0;
        for (; i < aKeys.length; i++) {
          if (!hasOwnProperty(val2, aKeys[i])) {
            return false;
          }
        }
        if (strict && arguments.length === 5) {
          var symbolKeysA = objectGetOwnPropertySymbols(val1);
          if (symbolKeysA.length !== 0) {
            var count = 0;
            for (i = 0; i < symbolKeysA.length; i++) {
              var key = symbolKeysA[i];
              if (propertyIsEnumerable(val1, key)) {
                if (!propertyIsEnumerable(val2, key)) {
                  return false;
                }
                aKeys.push(key);
                count++;
              } else if (propertyIsEnumerable(val2, key)) {
                return false;
              }
            }
            var symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
              return false;
            }
          } else {
            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
              return false;
            }
          }
        }
        if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
          return true;
        }
        if (memos === void 0) {
          memos = {
            val1: /* @__PURE__ */ new Map(),
            val2: /* @__PURE__ */ new Map(),
            position: 0
          };
        } else {
          var val2MemoA = memos.val1.get(val1);
          if (val2MemoA !== void 0) {
            var val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== void 0) {
              return val2MemoA === val2MemoB;
            }
          }
          memos.position++;
        }
        memos.val1.set(val1, memos.position);
        memos.val2.set(val2, memos.position);
        var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
        memos.val1.delete(val1);
        memos.val2.delete(val2);
        return areEq;
      }
      function setHasEqualElement(set, val1, strict, memo) {
        var setValues = arrayFromSet(set);
        for (var i = 0; i < setValues.length; i++) {
          var val2 = setValues[i];
          if (innerDeepEqual(val1, val2, strict, memo)) {
            set.delete(val2);
            return true;
          }
        }
        return false;
      }
      function findLooseMatchingPrimitives(prim) {
        switch (_typeof(prim)) {
          case "undefined":
            return null;
          case "object":
            return void 0;
          case "symbol":
            return false;
          case "string":
            prim = +prim;
          case "number":
            if (numberIsNaN(prim)) {
              return false;
            }
        }
        return true;
      }
      function setMightHaveLoosePrim(a, b, prim) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null)
          return altValue;
        return b.has(altValue) && !a.has(altValue);
      }
      function mapMightHaveLoosePrim(a, b, prim, item, memo) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) {
          return altValue;
        }
        var curB = b.get(altValue);
        if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
          return false;
        }
        return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
      }
      function setEquiv(a, b, strict, memo) {
        var set = null;
        var aValues = arrayFromSet(a);
        for (var i = 0; i < aValues.length; i++) {
          var val = aValues[i];
          if (_typeof(val) === "object" && val !== null) {
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(val);
          } else if (!b.has(val)) {
            if (strict)
              return false;
            if (!setMightHaveLoosePrim(a, b, val)) {
              return false;
            }
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(val);
          }
        }
        if (set !== null) {
          var bValues = arrayFromSet(b);
          for (var _i = 0; _i < bValues.length; _i++) {
            var _val = bValues[_i];
            if (_typeof(_val) === "object" && _val !== null) {
              if (!setHasEqualElement(set, _val, strict, memo))
                return false;
            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
              return false;
            }
          }
          return set.size === 0;
        }
        return true;
      }
      function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
        var setValues = arrayFromSet(set);
        for (var i = 0; i < setValues.length; i++) {
          var key2 = setValues[i];
          if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
            set.delete(key2);
            return true;
          }
        }
        return false;
      }
      function mapEquiv(a, b, strict, memo) {
        var set = null;
        var aEntries = arrayFromMap(a);
        for (var i = 0; i < aEntries.length; i++) {
          var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
          if (_typeof(key) === "object" && key !== null) {
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(key);
          } else {
            var item2 = b.get(key);
            if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
              if (strict)
                return false;
              if (!mapMightHaveLoosePrim(a, b, key, item1, memo))
                return false;
              if (set === null) {
                set = /* @__PURE__ */ new Set();
              }
              set.add(key);
            }
          }
        }
        if (set !== null) {
          var bEntries = arrayFromMap(b);
          for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
            if (_typeof(key) === "object" && key !== null) {
              if (!mapHasEqualEntry(set, a, key, item, strict, memo))
                return false;
            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
              return false;
            }
          }
          return set.size === 0;
        }
        return true;
      }
      function objEquiv(a, b, strict, keys, memos, iterationType) {
        var i = 0;
        if (iterationType === kIsSet) {
          if (!setEquiv(a, b, strict, memos)) {
            return false;
          }
        } else if (iterationType === kIsMap) {
          if (!mapEquiv(a, b, strict, memos)) {
            return false;
          }
        } else if (iterationType === kIsArray) {
          for (; i < a.length; i++) {
            if (hasOwnProperty(a, i)) {
              if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                return false;
              }
            } else if (hasOwnProperty(b, i)) {
              return false;
            } else {
              var keysA = Object.keys(a);
              for (; i < keysA.length; i++) {
                var key = keysA[i];
                if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                  return false;
                }
              }
              if (keysA.length !== Object.keys(b).length) {
                return false;
              }
              return true;
            }
          }
        }
        for (i = 0; i < keys.length; i++) {
          var _key = keys[i];
          if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
            return false;
          }
        }
        return true;
      }
      function isDeepEqual(val1, val2) {
        return innerDeepEqual(val1, val2, kLoose);
      }
      function isDeepStrictEqual(val1, val2) {
        return innerDeepEqual(val1, val2, kStrict);
      }
      module.exports = {
        isDeepEqual,
        isDeepStrictEqual
      };
    }
  });

  // node_modules/assert/build/assert.js
  var require_assert = __commonJS({
    "node_modules/assert/build/assert.js"(exports, module) {
      "use strict";
      init_shim();
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var _require = require_errors2();
      var _require$codes = _require.codes;
      var ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE;
      var ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var AssertionError = require_assertion_error();
      var _require2 = require_util2();
      var inspect = _require2.inspect;
      var _require$types = require_util2().types;
      var isPromise = _require$types.isPromise;
      var isRegExp = _require$types.isRegExp;
      var objectAssign = Object.assign ? Object.assign : require_es6_object_assign().assign;
      var objectIs = Object.is ? Object.is : require_object_is();
      var isDeepEqual;
      var isDeepStrictEqual;
      function lazyLoadComparison() {
        var comparison = require_comparisons();
        isDeepEqual = comparison.isDeepEqual;
        isDeepStrictEqual = comparison.isDeepStrictEqual;
      }
      var warned = false;
      var assert27 = module.exports = ok;
      var NO_EXCEPTION_SENTINEL = {};
      function innerFail(obj) {
        if (obj.message instanceof Error)
          throw obj.message;
        throw new AssertionError(obj);
      }
      function fail(actual, expected, message, operator, stackStartFn) {
        var argsLen = arguments.length;
        var internalMessage;
        if (argsLen === 0) {
          internalMessage = "Failed";
        } else if (argsLen === 1) {
          message = actual;
          actual = void 0;
        } else {
          if (warned === false) {
            warned = true;
            var warn = import_process.default.emitWarning ? import_process.default.emitWarning : console.warn.bind(console);
            warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
          }
          if (argsLen === 2)
            operator = "!=";
        }
        if (message instanceof Error)
          throw message;
        var errArgs = {
          actual,
          expected,
          operator: operator === void 0 ? "fail" : operator,
          stackStartFn: stackStartFn || fail
        };
        if (message !== void 0) {
          errArgs.message = message;
        }
        var err = new AssertionError(errArgs);
        if (internalMessage) {
          err.message = internalMessage;
          err.generatedMessage = true;
        }
        throw err;
      }
      assert27.fail = fail;
      assert27.AssertionError = AssertionError;
      function innerOk(fn, argLen, value, message) {
        if (!value) {
          var generatedMessage = false;
          if (argLen === 0) {
            generatedMessage = true;
            message = "No value argument passed to `assert.ok()`";
          } else if (message instanceof Error) {
            throw message;
          }
          var err = new AssertionError({
            actual: value,
            expected: true,
            message,
            operator: "==",
            stackStartFn: fn
          });
          err.generatedMessage = generatedMessage;
          throw err;
        }
      }
      function ok() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        innerOk.apply(void 0, [ok, args.length].concat(args));
      }
      assert27.ok = ok;
      assert27.equal = function equal(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (actual != expected) {
          innerFail({
            actual,
            expected,
            message,
            operator: "==",
            stackStartFn: equal
          });
        }
      };
      assert27.notEqual = function notEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (actual == expected) {
          innerFail({
            actual,
            expected,
            message,
            operator: "!=",
            stackStartFn: notEqual
          });
        }
      };
      assert27.deepEqual = function deepEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0)
          lazyLoadComparison();
        if (!isDeepEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "deepEqual",
            stackStartFn: deepEqual
          });
        }
      };
      assert27.notDeepEqual = function notDeepEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0)
          lazyLoadComparison();
        if (isDeepEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "notDeepEqual",
            stackStartFn: notDeepEqual
          });
        }
      };
      assert27.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0)
          lazyLoadComparison();
        if (!isDeepStrictEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "deepStrictEqual",
            stackStartFn: deepStrictEqual
          });
        }
      };
      assert27.notDeepStrictEqual = notDeepStrictEqual;
      function notDeepStrictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0)
          lazyLoadComparison();
        if (isDeepStrictEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "notDeepStrictEqual",
            stackStartFn: notDeepStrictEqual
          });
        }
      }
      assert27.strictEqual = function strictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (!objectIs(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "strictEqual",
            stackStartFn: strictEqual
          });
        }
      };
      assert27.notStrictEqual = function notStrictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (objectIs(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "notStrictEqual",
            stackStartFn: notStrictEqual
          });
        }
      };
      var Comparison = function Comparison2(obj, keys, actual) {
        var _this = this;
        _classCallCheck(this, Comparison2);
        keys.forEach(function(key) {
          if (key in obj) {
            if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && obj[key].test(actual[key])) {
              _this[key] = actual[key];
            } else {
              _this[key] = obj[key];
            }
          }
        });
      };
      function compareExceptionKey(actual, expected, key, message, keys, fn) {
        if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
          if (!message) {
            var a = new Comparison(actual, keys);
            var b = new Comparison(expected, keys, actual);
            var err = new AssertionError({
              actual: a,
              expected: b,
              operator: "deepStrictEqual",
              stackStartFn: fn
            });
            err.actual = actual;
            err.expected = expected;
            err.operator = fn.name;
            throw err;
          }
          innerFail({
            actual,
            expected,
            message,
            operator: fn.name,
            stackStartFn: fn
          });
        }
      }
      function expectedException(actual, expected, msg, fn) {
        if (typeof expected !== "function") {
          if (isRegExp(expected))
            return expected.test(actual);
          if (arguments.length === 2) {
            throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
          }
          if (_typeof(actual) !== "object" || actual === null) {
            var err = new AssertionError({
              actual,
              expected,
              message: msg,
              operator: "deepStrictEqual",
              stackStartFn: fn
            });
            err.operator = fn.name;
            throw err;
          }
          var keys = Object.keys(expected);
          if (expected instanceof Error) {
            keys.push("name", "message");
          } else if (keys.length === 0) {
            throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
          }
          if (isDeepEqual === void 0)
            lazyLoadComparison();
          keys.forEach(function(key) {
            if (typeof actual[key] === "string" && isRegExp(expected[key]) && expected[key].test(actual[key])) {
              return;
            }
            compareExceptionKey(actual, expected, key, msg, keys, fn);
          });
          return true;
        }
        if (expected.prototype !== void 0 && actual instanceof expected) {
          return true;
        }
        if (Error.isPrototypeOf(expected)) {
          return false;
        }
        return expected.call({}, actual) === true;
      }
      function getActual(fn) {
        if (typeof fn !== "function") {
          throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
        }
        try {
          fn();
        } catch (e) {
          return e;
        }
        return NO_EXCEPTION_SENTINEL;
      }
      function checkIsPromise(obj) {
        return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
      }
      function waitForActual(promiseFn) {
        return Promise.resolve().then(function() {
          var resultPromise;
          if (typeof promiseFn === "function") {
            resultPromise = promiseFn();
            if (!checkIsPromise(resultPromise)) {
              throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
            }
          } else if (checkIsPromise(promiseFn)) {
            resultPromise = promiseFn;
          } else {
            throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
          }
          return Promise.resolve().then(function() {
            return resultPromise;
          }).then(function() {
            return NO_EXCEPTION_SENTINEL;
          }).catch(function(e) {
            return e;
          });
        });
      }
      function expectsError(stackStartFn, actual, error, message) {
        if (typeof error === "string") {
          if (arguments.length === 4) {
            throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
          }
          if (_typeof(actual) === "object" && actual !== null) {
            if (actual.message === error) {
              throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
            }
          } else if (actual === error) {
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
          }
          message = error;
          error = void 0;
        } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
          throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
        }
        if (actual === NO_EXCEPTION_SENTINEL) {
          var details = "";
          if (error && error.name) {
            details += " (".concat(error.name, ")");
          }
          details += message ? ": ".concat(message) : ".";
          var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
          innerFail({
            actual: void 0,
            expected: error,
            operator: stackStartFn.name,
            message: "Missing expected ".concat(fnType).concat(details),
            stackStartFn
          });
        }
        if (error && !expectedException(actual, error, message, stackStartFn)) {
          throw actual;
        }
      }
      function expectsNoError(stackStartFn, actual, error, message) {
        if (actual === NO_EXCEPTION_SENTINEL)
          return;
        if (typeof error === "string") {
          message = error;
          error = void 0;
        }
        if (!error || expectedException(actual, error)) {
          var details = message ? ": ".concat(message) : ".";
          var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
          innerFail({
            actual,
            expected: error,
            operator: stackStartFn.name,
            message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
            stackStartFn
          });
        }
        throw actual;
      }
      assert27.throws = function throws(promiseFn) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
      };
      assert27.rejects = function rejects(promiseFn) {
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        return waitForActual(promiseFn).then(function(result) {
          return expectsError.apply(void 0, [rejects, result].concat(args));
        });
      };
      assert27.doesNotThrow = function doesNotThrow(fn) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
      };
      assert27.doesNotReject = function doesNotReject(fn) {
        for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          args[_key5 - 1] = arguments[_key5];
        }
        return waitForActual(fn).then(function(result) {
          return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
        });
      };
      assert27.ifError = function ifError(err) {
        if (err !== null && err !== void 0) {
          var message = "ifError got unwanted exception: ";
          if (_typeof(err) === "object" && typeof err.message === "string") {
            if (err.message.length === 0 && err.constructor) {
              message += err.constructor.name;
            } else {
              message += err.message;
            }
          } else {
            message += inspect(err);
          }
          var newErr = new AssertionError({
            actual: err,
            expected: null,
            operator: "ifError",
            message,
            stackStartFn: ifError
          });
          var origStack = err.stack;
          if (typeof origStack === "string") {
            var tmp2 = origStack.split("\n");
            tmp2.shift();
            var tmp1 = newErr.stack.split("\n");
            for (var i = 0; i < tmp2.length; i++) {
              var pos = tmp1.indexOf(tmp2[i]);
              if (pos !== -1) {
                tmp1 = tmp1.slice(0, pos);
                break;
              }
            }
            newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
          }
          throw newErr;
        }
      };
      function strict() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        innerOk.apply(void 0, [strict, args.length].concat(args));
      }
      assert27.strict = objectAssign(strict, assert27, {
        equal: assert27.strictEqual,
        deepEqual: assert27.deepStrictEqual,
        notEqual: assert27.notStrictEqual,
        notDeepEqual: assert27.notDeepStrictEqual
      });
      assert27.strict.strict = assert27.strict;
    }
  });

  // node_modules/node-fetch/browser.js
  var require_browser5 = __commonJS({
    "node_modules/node-fetch/browser.js"(exports, module) {
      "use strict";
      init_shim();
      var getGlobal = function() {
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw new Error("unable to locate global object");
      };
      var global = getGlobal();
      module.exports = exports = global.fetch;
      if (global.fetch) {
        exports.default = global.fetch.bind(global);
      }
      exports.Headers = global.Headers;
      exports.Request = global.Request;
      exports.Response = global.Response;
    }
  });

  // fs:fs
  var require_fs = __commonJS({
    "fs:fs"(exports, module) {
      init_shim();
      fs = window.require("fs");
      module.exports = fs;
    }
  });

  // node_modules/bioterms/dist/Prefixes.js
  var require_Prefixes3 = __commonJS({
    "node_modules/bioterms/dist/Prefixes.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var Prefixes5;
      (function(Prefixes6) {
        Prefixes6.sbol1 = "http://sbols.org/v1#";
        Prefixes6.sbol2 = "http://sbols.org/v2#";
        Prefixes6.sbolx = "http://sboldata.org/sbolx#";
        Prefixes6.sbol3 = "http://sbols.org/v3#";
        Prefixes6.rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
        Prefixes6.visual = "http://wiki.synbiohub.org/wiki/Terms/visual#";
        Prefixes6.sequenceOntologyPurl = "http://purl.org/obo/owl/SO#";
        Prefixes6.sequenceOntologyIdentifiersOrg = "http://identifiers.org/so/";
        Prefixes6.go = "http://identifiers.org/go/";
        Prefixes6.dcterms = "http://purl.org/dc/terms/";
        Prefixes6.rdfs = "http://www.w3.org/2000/01/rdf-schema#";
        Prefixes6.svg = "http://www.w3.org/2000/svg#";
        Prefixes6.sbo = "http://identifiers.org/biomodels.sbo/";
        Prefixes6.sybio = "http://www.sybio.ncl.ac.uk#";
        Prefixes6.prov = "http://www.w3.org/ns/prov#";
        Prefixes6.enrichment = "http://wiki.synbiohub.org/wiki/Terms/enrichment#";
        Prefixes6.measure = "http://www.ontology-of-units-of-measure.org/resource/om-2/";
      })(Prefixes5 = exports.Prefixes || (exports.Prefixes = {}));
      function prefixify(uri) {
        uri = "" + uri;
        for (var i = 0; i < keys.length; ++i) {
          const prefix = keys[i];
          const uriPrefix = Prefixes5[prefix];
          if (uri.indexOf(uriPrefix) === 0) {
            return prefix + ":" + uri.slice(uriPrefix.length);
          }
        }
        return uri;
      }
      exports.prefixify = prefixify;
      var keys = Object.keys(Prefixes5);
    }
  });

  // node_modules/bioterms/dist/Types.js
  var require_Types3 = __commonJS({
    "node_modules/bioterms/dist/Types.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var Prefixes_1 = require_Prefixes3();
      var Types9;
      (function(Types10) {
        let SBOL1;
        (function(SBOL12) {
          SBOL12.DnaComponent = Prefixes_1.Prefixes.sbol1 + "DnaComponent";
          SBOL12.DnaSequence = Prefixes_1.Prefixes.sbol1 + "DnaSequence";
          SBOL12.Collection = Prefixes_1.Prefixes.sbol1 + "Collection";
          SBOL12.SequenceAnnotation = Prefixes_1.Prefixes.sbol1 + "SequenceAnnotation";
        })(SBOL1 = Types10.SBOL1 || (Types10.SBOL1 = {}));
        let SBOL2;
        (function(SBOL22) {
          SBOL22.ModuleDefinition = Prefixes_1.Prefixes.sbol2 + "ModuleDefinition";
          SBOL22.ComponentDefinition = Prefixes_1.Prefixes.sbol2 + "ComponentDefinition";
          SBOL22.Module = Prefixes_1.Prefixes.sbol2 + "Module";
          SBOL22.Component = Prefixes_1.Prefixes.sbol2 + "Component";
          SBOL22.Range = Prefixes_1.Prefixes.sbol2 + "Range";
          SBOL22.Cut = Prefixes_1.Prefixes.sbol2 + "Cut";
          SBOL22.GenericLocation = Prefixes_1.Prefixes.sbol2 + "GenericLocation";
          SBOL22.SequenceAnnotation = Prefixes_1.Prefixes.sbol2 + "SequenceAnnotation";
          SBOL22.SequenceConstraint = Prefixes_1.Prefixes.sbol2 + "SequenceConstraint";
          SBOL22.Interaction = Prefixes_1.Prefixes.sbol2 + "Interaction";
          SBOL22.Participation = Prefixes_1.Prefixes.sbol2 + "Participation";
          SBOL22.Collection = Prefixes_1.Prefixes.sbol2 + "Collection";
          SBOL22.FunctionalComponent = Prefixes_1.Prefixes.sbol2 + "FunctionalComponent";
          SBOL22.Sequence = Prefixes_1.Prefixes.sbol2 + "Sequence";
          SBOL22.MapsTo = Prefixes_1.Prefixes.sbol2 + "MapsTo";
          SBOL22.Attachment = Prefixes_1.Prefixes.sbol2 + "Attachment";
          SBOL22.Model = Prefixes_1.Prefixes.sbol2 + "Model";
          SBOL22.Implementation = Prefixes_1.Prefixes.sbol2 + "Implementation";
          SBOL22.Experiment = Prefixes_1.Prefixes.sbol2 + "Experiment";
          SBOL22.ExperimentalData = Prefixes_1.Prefixes.sbol2 + "ExperimentalData";
        })(SBOL2 = Types10.SBOL2 || (Types10.SBOL2 = {}));
        let SBOLX;
        (function(SBOLX2) {
          SBOLX2.Component = Prefixes_1.Prefixes.sbolx + "Component";
          SBOLX2.SubComponent = Prefixes_1.Prefixes.sbolx + "SubComponent";
          SBOLX2.Range = Prefixes_1.Prefixes.sbolx + "Range";
          SBOLX2.Cut = Prefixes_1.Prefixes.sbolx + "Cut";
          SBOLX2.SequenceConstraint = Prefixes_1.Prefixes.sbolx + "SequenceConstraint";
          SBOLX2.Interaction = Prefixes_1.Prefixes.sbolx + "Interaction";
          SBOLX2.Participation = Prefixes_1.Prefixes.sbolx + "Participation";
          SBOLX2.Collection = Prefixes_1.Prefixes.sbolx + "Collection";
          SBOLX2.Sequence = Prefixes_1.Prefixes.sbolx + "Sequence";
          SBOLX2.OrientedLocation = Prefixes_1.Prefixes.sbolx + "OrientedLocation";
          SBOLX2.SequenceAnnotation = Prefixes_1.Prefixes.sbolx + "SequenceAnnotation";
          SBOLX2.Attachment = Prefixes_1.Prefixes.sbolx + "Attachment";
          SBOLX2.Model = Prefixes_1.Prefixes.sbolx + "Model";
          SBOLX2.Implementation = Prefixes_1.Prefixes.sbolx + "Implementation";
          SBOLX2.MapsTo = Prefixes_1.Prefixes.sbolx + "MapsTo";
          SBOLX2.Experiment = Prefixes_1.Prefixes.sbolx + "Experiment";
          SBOLX2.ExperimentalData = Prefixes_1.Prefixes.sbolx + "ExperimentalData";
        })(SBOLX = Types10.SBOLX || (Types10.SBOLX = {}));
        let SBOL3;
        (function(SBOL32) {
          SBOL32.Component = Prefixes_1.Prefixes.sbol3 + "Component";
          SBOL32.SubComponent = Prefixes_1.Prefixes.sbol3 + "SubComponent";
          SBOL32.Range = Prefixes_1.Prefixes.sbol3 + "Range";
          SBOL32.Cut = Prefixes_1.Prefixes.sbol3 + "Cut";
          SBOL32.EntireSequence = Prefixes_1.Prefixes.sbol3 + "EntireSequence";
          SBOL32.Constraint = Prefixes_1.Prefixes.sbol3 + "Constraint";
          SBOL32.Interaction = Prefixes_1.Prefixes.sbol3 + "Interaction";
          SBOL32.Participation = Prefixes_1.Prefixes.sbol3 + "Participation";
          SBOL32.Collection = Prefixes_1.Prefixes.sbol3 + "Collection";
          SBOL32.Sequence = Prefixes_1.Prefixes.sbol3 + "Sequence";
          SBOL32.OrientedLocation = Prefixes_1.Prefixes.sbol3 + "OrientedLocation";
          SBOL32.SequenceFeature = Prefixes_1.Prefixes.sbol3 + "SequenceFeature";
          SBOL32.Attachment = Prefixes_1.Prefixes.sbol3 + "Attachment";
          SBOL32.Model = Prefixes_1.Prefixes.sbol3 + "Model";
          SBOL32.Implementation = Prefixes_1.Prefixes.sbol3 + "Implementation";
          SBOL32.MapsTo = Prefixes_1.Prefixes.sbol3 + "MapsTo";
          SBOL32.Experiment = Prefixes_1.Prefixes.sbol3 + "Experiment";
          SBOL32.ExperimentalData = Prefixes_1.Prefixes.sbol3 + "ExperimentalData";
          SBOL32.Namespace = Prefixes_1.Prefixes.sbol3 + "Namespace";
        })(SBOL3 = Types10.SBOL3 || (Types10.SBOL3 = {}));
        let Visual;
        (function(Visual2) {
          Visual2.ModuleDepiction = Prefixes_1.Prefixes.visual + "ModuleDepiction";
          Visual2.ComponentDepiction = Prefixes_1.Prefixes.visual + "ComponentDepiction";
          Visual2.Glyph = Prefixes_1.Prefixes.visual + "Glyph";
          Visual2.Label = Prefixes_1.Prefixes.visual + "Label";
        })(Visual = Types10.Visual || (Types10.Visual = {}));
        let SyBiOnt;
        (function(SyBiOnt2) {
          SyBiOnt2.Protein = Prefixes_1.Prefixes.sybio + "Protein";
          SyBiOnt2.InduciblePromoter = Prefixes_1.Prefixes.sybio + "InduciblePromoter";
          SyBiOnt2.Reaction = Prefixes_1.Prefixes.sybio + "Reaction";
          SyBiOnt2.ReactionParticipant = Prefixes_1.Prefixes.sybio + "ReactionParticipant";
          SyBiOnt2.Compound = Prefixes_1.Prefixes.sybio + "Compound";
        })(SyBiOnt = Types10.SyBiOnt || (Types10.SyBiOnt = {}));
        let Prov;
        (function(Prov2) {
          Prov2.Agent = Prefixes_1.Prefixes.prov + "Agent";
          Prov2.Association = Prefixes_1.Prefixes.prov + "Association";
          Prov2.Activity = Prefixes_1.Prefixes.prov + "Activity";
          Prov2.Usage = Prefixes_1.Prefixes.prov + "Usage";
          Prov2.Plan = Prefixes_1.Prefixes.prov + "Plan";
        })(Prov = Types10.Prov || (Types10.Prov = {}));
        let Enrichment;
        (function(Enrichment2) {
          Enrichment2.GeneProduct = Prefixes_1.Prefixes.enrichment + "GeneProduct";
        })(Enrichment = Types10.Enrichment || (Types10.Enrichment = {}));
        let Measure;
        (function(Measure_1) {
          Measure_1.Measure = Prefixes_1.Prefixes.measure + "Measure";
        })(Measure = Types10.Measure || (Types10.Measure = {}));
      })(Types9 = exports.Types || (exports.Types = {}));
    }
  });

  // node_modules/bioterms/dist/Predicates.js
  var require_Predicates3 = __commonJS({
    "node_modules/bioterms/dist/Predicates.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var Prefixes_1 = require_Prefixes3();
      var Predicates14;
      (function(Predicates15) {
        Predicates15.a = Prefixes_1.Prefixes.rdf + "type";
        let SBOL1;
        (function(SBOL12) {
          SBOL12.nucleotides = Prefixes_1.Prefixes.sbol1 + "nucleotides";
          SBOL12.subComponent = Prefixes_1.Prefixes.sbol1 + "subComponent";
          SBOL12.dnaSequence = Prefixes_1.Prefixes.sbol1 + "dnaSequence";
          SBOL12.bioStart = Prefixes_1.Prefixes.sbol1 + "bioStart";
          SBOL12.bioEnd = Prefixes_1.Prefixes.sbol1 + "bioEnd";
          SBOL12.displayId = Prefixes_1.Prefixes.sbol1 + "displayId";
          SBOL12.name = Prefixes_1.Prefixes.sbol1 + "name";
          SBOL12.description = Prefixes_1.Prefixes.sbol1 + "description";
          SBOL12.annotation = Prefixes_1.Prefixes.sbol1 + "annotation";
          SBOL12.strand = Prefixes_1.Prefixes.sbol1 + "strand";
          SBOL12.component = Prefixes_1.Prefixes.sbol1 + "component";
          SBOL12.precedes = Prefixes_1.Prefixes.sbol1 + "precedes";
        })(SBOL1 = Predicates15.SBOL1 || (Predicates15.SBOL1 = {}));
        let SBOL2;
        (function(SBOL22) {
          SBOL22.component = Prefixes_1.Prefixes.sbol2 + "component";
          SBOL22.module = Prefixes_1.Prefixes.sbol2 + "module";
          SBOL22.definition = Prefixes_1.Prefixes.sbol2 + "definition";
          SBOL22.functionalComponent = Prefixes_1.Prefixes.sbol2 + "functionalComponent";
          SBOL22.role = Prefixes_1.Prefixes.sbol2 + "role";
          SBOL22.location = Prefixes_1.Prefixes.sbol2 + "location";
          SBOL22.start = Prefixes_1.Prefixes.sbol2 + "start";
          SBOL22.end = Prefixes_1.Prefixes.sbol2 + "end";
          SBOL22.at = Prefixes_1.Prefixes.sbol2 + "at";
          SBOL22.sequenceAnnotation = Prefixes_1.Prefixes.sbol2 + "sequenceAnnotation";
          SBOL22.sequenceConstraint = Prefixes_1.Prefixes.sbol2 + "sequenceConstraint";
          SBOL22.orientation = Prefixes_1.Prefixes.sbol2 + "orientation";
          SBOL22.displayId = Prefixes_1.Prefixes.sbol2 + "displayId";
          SBOL22.version = Prefixes_1.Prefixes.sbol2 + "version";
          SBOL22.access = Prefixes_1.Prefixes.sbol2 + "access";
          SBOL22.mapsTo = Prefixes_1.Prefixes.sbol2 + "mapsTo";
          SBOL22.local = Prefixes_1.Prefixes.sbol2 + "local";
          SBOL22.remote = Prefixes_1.Prefixes.sbol2 + "remote";
          SBOL22.refinement = Prefixes_1.Prefixes.sbol2 + "refinement";
          SBOL22.interaction = Prefixes_1.Prefixes.sbol2 + "interaction";
          SBOL22.participation = Prefixes_1.Prefixes.sbol2 + "participation";
          SBOL22.participant = Prefixes_1.Prefixes.sbol2 + "participant";
          SBOL22.type = Prefixes_1.Prefixes.sbol2 + "type";
          SBOL22.sequence = Prefixes_1.Prefixes.sbol2 + "sequence";
          SBOL22.encoding = Prefixes_1.Prefixes.sbol2 + "encoding";
          SBOL22.elements = Prefixes_1.Prefixes.sbol2 + "elements";
          SBOL22.persistentIdentity = Prefixes_1.Prefixes.sbol2 + "persistentIdentity";
          SBOL22.restriction = Prefixes_1.Prefixes.sbol2 + "restriction";
          SBOL22.subject = Prefixes_1.Prefixes.sbol2 + "subject";
          SBOL22.object = Prefixes_1.Prefixes.sbol2 + "object";
          SBOL22.member = Prefixes_1.Prefixes.sbol2 + "member";
          SBOL22.model = Prefixes_1.Prefixes.sbol2 + "model";
          SBOL22.framework = Prefixes_1.Prefixes.sbol2 + "framework";
          SBOL22.language = Prefixes_1.Prefixes.sbol2 + "language";
          SBOL22.source = Prefixes_1.Prefixes.sbol2 + "source";
          SBOL22.attachment = Prefixes_1.Prefixes.sbol2 + "attachment";
          SBOL22.format = Prefixes_1.Prefixes.sbol2 + "format";
          SBOL22.size = Prefixes_1.Prefixes.sbol2 + "size";
          SBOL22.hash = Prefixes_1.Prefixes.sbol2 + "hash";
          SBOL22.built = Prefixes_1.Prefixes.sbol2 + "built";
          SBOL22.experimentalData = Prefixes_1.Prefixes.sbol2 + "experimentalData";
          SBOL22.sourceLocation = Prefixes_1.Prefixes.sbol2 + "sourceLocation";
          SBOL22.measure = Prefixes_1.Prefixes.sbol2 + "measure";
        })(SBOL2 = Predicates15.SBOL2 || (Predicates15.SBOL2 = {}));
        let SBOLX;
        (function(SBOLX2) {
          SBOLX2.subComponent = Prefixes_1.Prefixes.sbolx + "subComponent";
          SBOLX2.instanceOf = Prefixes_1.Prefixes.sbolx + "instanceOf";
          SBOLX2.role = Prefixes_1.Prefixes.sbolx + "role";
          SBOLX2.location = Prefixes_1.Prefixes.sbolx + "location";
          SBOLX2.start = Prefixes_1.Prefixes.sbolx + "start";
          SBOLX2.end = Prefixes_1.Prefixes.sbolx + "end";
          SBOLX2.at = Prefixes_1.Prefixes.sbolx + "at";
          SBOLX2.sequenceAnnotation = Prefixes_1.Prefixes.sbolx + "sequenceAnnotation";
          SBOLX2.sequenceConstraint = Prefixes_1.Prefixes.sbolx + "sequenceConstraint";
          SBOLX2.orientation = Prefixes_1.Prefixes.sbolx + "orientation";
          SBOLX2.id = Prefixes_1.Prefixes.sbolx + "id";
          SBOLX2.version = Prefixes_1.Prefixes.sbolx + "version";
          SBOLX2.access = Prefixes_1.Prefixes.sbolx + "access";
          SBOLX2.mapsTo = Prefixes_1.Prefixes.sbolx + "mapsTo";
          SBOLX2.local = Prefixes_1.Prefixes.sbolx + "local";
          SBOLX2.remote = Prefixes_1.Prefixes.sbolx + "remote";
          SBOLX2.refinement = Prefixes_1.Prefixes.sbolx + "refinement";
          SBOLX2.interaction = Prefixes_1.Prefixes.sbolx + "interaction";
          SBOLX2.participation = Prefixes_1.Prefixes.sbolx + "participation";
          SBOLX2.participant = Prefixes_1.Prefixes.sbolx + "participant";
          SBOLX2.type = Prefixes_1.Prefixes.sbolx + "type";
          SBOLX2.sequence = Prefixes_1.Prefixes.sbolx + "sequence";
          SBOLX2.encoding = Prefixes_1.Prefixes.sbolx + "encoding";
          SBOLX2.elements = Prefixes_1.Prefixes.sbolx + "elements";
          SBOLX2.persistentIdentity = Prefixes_1.Prefixes.sbolx + "persistentIdentity";
          SBOLX2.restriction = Prefixes_1.Prefixes.sbolx + "restriction";
          SBOLX2.subject = Prefixes_1.Prefixes.sbolx + "subject";
          SBOLX2.object = Prefixes_1.Prefixes.sbolx + "object";
          SBOLX2.member = Prefixes_1.Prefixes.sbolx + "member";
          SBOLX2.model = Prefixes_1.Prefixes.sbolx + "model";
          SBOLX2.framework = Prefixes_1.Prefixes.sbolx + "framework";
          SBOLX2.language = Prefixes_1.Prefixes.sbolx + "language";
          SBOLX2.source = Prefixes_1.Prefixes.sbolx + "source";
          SBOLX2.attachment = Prefixes_1.Prefixes.sbolx + "attachment";
          SBOLX2.format = Prefixes_1.Prefixes.sbolx + "format";
          SBOLX2.size = Prefixes_1.Prefixes.sbolx + "size";
          SBOLX2.hash = Prefixes_1.Prefixes.sbolx + "hash";
          SBOLX2.built = Prefixes_1.Prefixes.sbolx + "built";
          SBOLX2.experimentalData = Prefixes_1.Prefixes.sbolx + "experimentalData";
          SBOLX2.sourceLocation = Prefixes_1.Prefixes.sbolx + "sourceLocation";
          SBOLX2.measure = Prefixes_1.Prefixes.sbolx + "measure";
        })(SBOLX = Predicates15.SBOLX || (Predicates15.SBOLX = {}));
        let SBOL3;
        (function(SBOL32) {
          SBOL32.instanceOf = Prefixes_1.Prefixes.sbol3 + "instanceOf";
          SBOL32.role = Prefixes_1.Prefixes.sbol3 + "role";
          SBOL32.hasLocation = Prefixes_1.Prefixes.sbol3 + "hasLocation";
          SBOL32.start = Prefixes_1.Prefixes.sbol3 + "start";
          SBOL32.end = Prefixes_1.Prefixes.sbol3 + "end";
          SBOL32.at = Prefixes_1.Prefixes.sbol3 + "at";
          SBOL32.hasFeature = Prefixes_1.Prefixes.sbol3 + "hasFeature";
          SBOL32.hasConstraint = Prefixes_1.Prefixes.sbol3 + "hasConstraint";
          SBOL32.orientation = Prefixes_1.Prefixes.sbol3 + "orientation";
          SBOL32.displayId = Prefixes_1.Prefixes.sbol3 + "displayId";
          SBOL32.name = Prefixes_1.Prefixes.sbol3 + "name";
          SBOL32.description = Prefixes_1.Prefixes.sbol3 + "description";
          SBOL32.access = Prefixes_1.Prefixes.sbol3 + "access";
          SBOL32.mapsTo = Prefixes_1.Prefixes.sbol3 + "mapsTo";
          SBOL32.local = Prefixes_1.Prefixes.sbol3 + "local";
          SBOL32.remote = Prefixes_1.Prefixes.sbol3 + "remote";
          SBOL32.refinement = Prefixes_1.Prefixes.sbol3 + "refinement";
          SBOL32.hasInteraction = Prefixes_1.Prefixes.sbol3 + "hasInteraction";
          SBOL32.hasInterface = Prefixes_1.Prefixes.sbol3 + "hasInterface";
          SBOL32.hasParticipation = Prefixes_1.Prefixes.sbol3 + "hasParticipation";
          SBOL32.participant = Prefixes_1.Prefixes.sbol3 + "participant";
          SBOL32.type = Prefixes_1.Prefixes.sbol3 + "type";
          SBOL32.hasSequence = Prefixes_1.Prefixes.sbol3 + "hasSequence";
          SBOL32.encoding = Prefixes_1.Prefixes.sbol3 + "encoding";
          SBOL32.elements = Prefixes_1.Prefixes.sbol3 + "elements";
          SBOL32.persistentIdentity = Prefixes_1.Prefixes.sbol3 + "persistentIdentity";
          SBOL32.restriction = Prefixes_1.Prefixes.sbol3 + "restriction";
          SBOL32.subject = Prefixes_1.Prefixes.sbol3 + "subject";
          SBOL32.object = Prefixes_1.Prefixes.sbol3 + "object";
          SBOL32.member = Prefixes_1.Prefixes.sbol3 + "member";
          SBOL32.hasModel = Prefixes_1.Prefixes.sbol3 + "hasModel";
          SBOL32.framework = Prefixes_1.Prefixes.sbol3 + "framework";
          SBOL32.language = Prefixes_1.Prefixes.sbol3 + "language";
          SBOL32.source = Prefixes_1.Prefixes.sbol3 + "source";
          SBOL32.hasAttachment = Prefixes_1.Prefixes.sbol3 + "hasAttachment";
          SBOL32.format = Prefixes_1.Prefixes.sbol3 + "format";
          SBOL32.size = Prefixes_1.Prefixes.sbol3 + "size";
          SBOL32.hash = Prefixes_1.Prefixes.sbol3 + "hash";
          SBOL32.built = Prefixes_1.Prefixes.sbol3 + "built";
          SBOL32.experimentalData = Prefixes_1.Prefixes.sbol3 + "experimentalData";
          SBOL32.sourceLocation = Prefixes_1.Prefixes.sbol3 + "sourceLocation";
          SBOL32.hasMeasure = Prefixes_1.Prefixes.sbol3 + "hasMeasure";
          SBOL32.hasNamespace = Prefixes_1.Prefixes.sbol3 + "hasNamespace";
        })(SBOL3 = Predicates15.SBOL3 || (Predicates15.SBOL3 = {}));
        let Dcterms;
        (function(Dcterms2) {
          Dcterms2.title = Prefixes_1.Prefixes.dcterms + "title";
          Dcterms2.description = Prefixes_1.Prefixes.dcterms + "description";
        })(Dcterms = Predicates15.Dcterms || (Predicates15.Dcterms = {}));
        let SVG;
        (function(SVG2) {
          SVG2.fontFamily = Prefixes_1.Prefixes.svg + "font-family";
          SVG2.fontSize = Prefixes_1.Prefixes.svg + "font-size";
          SVG2.fontStyle = Prefixes_1.Prefixes.svg + "font-style";
        })(SVG = Predicates15.SVG || (Predicates15.SVG = {}));
        let SyBiOnt;
        (function(SyBiOnt2) {
          SyBiOnt2.encodedBy = Prefixes_1.Prefixes.sybio + "encodedBy";
          SyBiOnt2.EC = Prefixes_1.Prefixes.sybio + "EC";
          SyBiOnt2.isBalanced = Prefixes_1.Prefixes.sybio + "isBalanced";
          SyBiOnt2.isReactionClass = Prefixes_1.Prefixes.sybio + "isReactionClass";
          SyBiOnt2.inPolymerization = Prefixes_1.Prefixes.sybio + "inPolymerization";
          SyBiOnt2.inTransport = Prefixes_1.Prefixes.sybio + "inTransport";
          SyBiOnt2.reactionDirection = Prefixes_1.Prefixes.sybio + "reactionDirection";
          SyBiOnt2.hasReactionParticipant = Prefixes_1.Prefixes.sybio + "hasReactionParticipant";
          SyBiOnt2.referencesCompound = Prefixes_1.Prefixes.sybio + "referencesCompound";
          SyBiOnt2.reactionSide = Prefixes_1.Prefixes.sybio + "reactionSide";
          SyBiOnt2.reactionSummary = Prefixes_1.Prefixes.sybio + "reactionSummary";
          SyBiOnt2.stoicRatio = Prefixes_1.Prefixes.sybio + "stoichiometricRatio";
          SyBiOnt2.compoundCharge = Prefixes_1.Prefixes.sybio + "compoundCharge";
          SyBiOnt2.compoundFormula = Prefixes_1.Prefixes.sybio + "compoundFormula";
          SyBiOnt2.compoundMass = Prefixes_1.Prefixes.sybio + "compoundMass";
          SyBiOnt2.compoundSmilesFormula = Prefixes_1.Prefixes.sybio + "compoundSmilesFormula";
          SyBiOnt2.interactsWith = Prefixes_1.Prefixes.sybio + "interactsWith";
          SyBiOnt2.taxId = Prefixes_1.Prefixes.sybio + "taxId";
        })(SyBiOnt = Predicates15.SyBiOnt || (Predicates15.SyBiOnt = {}));
        let Prov;
        (function(Prov2) {
          Prov2.wasDerivedFrom = Prefixes_1.Prefixes.prov + "wasDerivedFrom";
          Prov2.wasGeneratedBy = Prefixes_1.Prefixes.prov + "wasGeneratedBy";
          Prov2.qualifiedAssociation = Prefixes_1.Prefixes.prov + "qualifiedAssociation";
          Prov2.qualifiedUsage = Prefixes_1.Prefixes.prov + "qualifiedUsage";
          Prov2.startedAtTime = Prefixes_1.Prefixes.prov + "startedAtTime";
          Prov2.endedAtTime = Prefixes_1.Prefixes.prov + "endedAtTime";
          Prov2.wasInformedBy = Prefixes_1.Prefixes.prov + "wasInformedBy";
          Prov2.agent = Prefixes_1.Prefixes.prov + "agent";
          Prov2.entity = Prefixes_1.Prefixes.prov + "entity";
          Prov2.hadRole = Prefixes_1.Prefixes.prov + "hadRole";
          Prov2.hadPlan = Prefixes_1.Prefixes.prov + "hadPlan";
        })(Prov = Predicates15.Prov || (Predicates15.Prov = {}));
        let Enrichment;
        (function(Enrichment2) {
          Enrichment2.hint = Prefixes_1.Prefixes.enrichment + "hint";
          Enrichment2.orfStart = Prefixes_1.Prefixes.enrichment + "orfStart";
          Enrichment2.orfEnd = Prefixes_1.Prefixes.enrichment + "orfEnd";
        })(Enrichment = Predicates15.Enrichment || (Predicates15.Enrichment = {}));
        let Measure;
        (function(Measure2) {
          Measure2.hasNumericalValue = Prefixes_1.Prefixes.measure + "hasNumericalValue";
          Measure2.hasUnit = Prefixes_1.Prefixes.measure + "hasUnit";
        })(Measure = Predicates15.Measure || (Predicates15.Measure = {}));
      })(Predicates14 = exports.Predicates || (exports.Predicates = {}));
    }
  });

  // node_modules/bioterms/dist/Specifiers.js
  var require_Specifiers3 = __commonJS({
    "node_modules/bioterms/dist/Specifiers.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var Prefixes_1 = require_Prefixes3();
      var Specifiers2;
      (function(Specifiers3) {
        let SBOL2;
        (function(SBOL22) {
          let Orientation;
          (function(Orientation2) {
            Orientation2.Inline = Prefixes_1.Prefixes.sbol2 + "inline";
            Orientation2.ReverseComplement = Prefixes_1.Prefixes.sbol2 + "reverseComplement";
          })(Orientation = SBOL22.Orientation || (SBOL22.Orientation = {}));
          let Direction;
          (function(Direction2) {
            Direction2.Input = Prefixes_1.Prefixes.sbol2 + "in";
            Direction2.Output = Prefixes_1.Prefixes.sbol2 + "out";
            Direction2.InputAndOutput = Prefixes_1.Prefixes.sbol2 + "inout";
            Direction2.None = Prefixes_1.Prefixes.sbol2 + "none";
          })(Direction = SBOL22.Direction || (SBOL22.Direction = {}));
          let Access;
          (function(Access2) {
            Access2.PublicAccess = Prefixes_1.Prefixes.sbol2 + "public";
            Access2.PrivateAccess = Prefixes_1.Prefixes.sbol2 + "private";
          })(Access = SBOL22.Access || (SBOL22.Access = {}));
          let Type;
          (function(Type2) {
            Type2.DNA = "http://www.biopax.org/release/biopax-level3.owl#DnaRegion";
            Type2.RNA = "http://www.biopax.org/release/biopax-level3.owl#RnaRegion";
            Type2.Protein = "http://www.biopax.org/release/biopax-level3.owl#Protein";
            Type2.SmallMolecule = "http://www.biopax.org/release/biopax-level3.owl#SmallMolecule";
            Type2.Complex = "http://www.biopax.org/release/biopax-level3.owl#Complex";
            Type2.Effector = "http://identifiers.org/chebi/CHEBI:35224";
            Type2.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000988";
          })(Type = SBOL22.Type || (SBOL22.Type = {}));
          let SequenceEncoding;
          (function(SequenceEncoding2) {
            SequenceEncoding2.NucleicAcid = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.RNA = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.AminoAcid = "http://www.chem.qmul.ac.uk/iupac/AminoAcid/";
          })(SequenceEncoding = SBOL22.SequenceEncoding || (SBOL22.SequenceEncoding = {}));
          let SequenceConstraint;
          (function(SequenceConstraint2) {
            SequenceConstraint2.Precedes = Prefixes_1.Prefixes.sbol2 + "precedes";
            SequenceConstraint2.OppositeOrientationAs = Prefixes_1.Prefixes.sbol2 + "oppositeOrientationAs";
          })(SequenceConstraint = SBOL22.SequenceConstraint || (SBOL22.SequenceConstraint = {}));
          let ProvRole;
          (function(ProvRole2) {
            ProvRole2.Design = Prefixes_1.Prefixes.sbol2 + "design";
            ProvRole2.Build = Prefixes_1.Prefixes.sbol2 + "build";
            ProvRole2.Test = Prefixes_1.Prefixes.sbol2 + "test";
            ProvRole2.Learn = Prefixes_1.Prefixes.sbol2 + "learn";
          })(ProvRole = SBOL22.ProvRole || (SBOL22.ProvRole = {}));
          let MapsToRefinement;
          (function(MapsToRefinement2) {
            MapsToRefinement2.UseLocal = Prefixes_1.Prefixes.sbol2 + "useLocal";
            MapsToRefinement2.UseRemote = Prefixes_1.Prefixes.sbol2 + "useRemote";
          })(MapsToRefinement = SBOL22.MapsToRefinement || (SBOL22.MapsToRefinement = {}));
        })(SBOL2 = Specifiers3.SBOL2 || (Specifiers3.SBOL2 = {}));
        let SBOLX;
        (function(SBOLX2) {
          let Orientation;
          (function(Orientation2) {
            Orientation2.Inline = Prefixes_1.Prefixes.sbolx + "inline";
            Orientation2.ReverseComplement = Prefixes_1.Prefixes.sbolx + "reverseComplement";
          })(Orientation = SBOLX2.Orientation || (SBOLX2.Orientation = {}));
          let Direction;
          (function(Direction2) {
            Direction2.Input = Prefixes_1.Prefixes.sbolx + "in";
            Direction2.Output = Prefixes_1.Prefixes.sbolx + "out";
            Direction2.InputAndOutput = Prefixes_1.Prefixes.sbolx + "inout";
            Direction2.None = Prefixes_1.Prefixes.sbolx + "none";
          })(Direction = SBOLX2.Direction || (SBOLX2.Direction = {}));
          let Access;
          (function(Access2) {
            Access2.PublicAccess = Prefixes_1.Prefixes.sbolx + "public";
            Access2.PrivateAccess = Prefixes_1.Prefixes.sbolx + "private";
          })(Access = SBOLX2.Access || (SBOLX2.Access = {}));
          let Type;
          (function(Type2) {
            Type2.DNA = "http://www.biopax.org/release/biopax-level3.owl#DnaRegion";
            Type2.RNA = "http://www.biopax.org/release/biopax-level3.owl#RnaRegion";
            Type2.Protein = "http://www.biopax.org/release/biopax-level3.owl#Protein";
            Type2.SmallMolecule = "http://www.biopax.org/release/biopax-level3.owl#SmallMolecule";
            Type2.Complex = "http://www.biopax.org/release/biopax-level3.owl#Complex";
            Type2.Effector = "http://identifiers.org/chebi/CHEBI:35224";
            Type2.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000988";
          })(Type = SBOLX2.Type || (SBOLX2.Type = {}));
          let SequenceEncoding;
          (function(SequenceEncoding2) {
            SequenceEncoding2.NucleicAcid = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.RNA = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.AminoAcid = "http://www.chem.qmul.ac.uk/iupac/AminoAcid/";
          })(SequenceEncoding = SBOLX2.SequenceEncoding || (SBOLX2.SequenceEncoding = {}));
          let SequenceConstraint;
          (function(SequenceConstraint2) {
            SequenceConstraint2.Precedes = Prefixes_1.Prefixes.sbolx + "precedes";
            SequenceConstraint2.OppositeOrientationAs = Prefixes_1.Prefixes.sbolx + "oppositeOrientationAs";
          })(SequenceConstraint = SBOLX2.SequenceConstraint || (SBOLX2.SequenceConstraint = {}));
          let ProvRole;
          (function(ProvRole2) {
            ProvRole2.Design = Prefixes_1.Prefixes.sbolx + "design";
            ProvRole2.Build = Prefixes_1.Prefixes.sbolx + "build";
            ProvRole2.Test = Prefixes_1.Prefixes.sbolx + "test";
            ProvRole2.Learn = Prefixes_1.Prefixes.sbolx + "learn";
          })(ProvRole = SBOLX2.ProvRole || (SBOLX2.ProvRole = {}));
          let MapsToRefinement;
          (function(MapsToRefinement2) {
            MapsToRefinement2.UseLocal = Prefixes_1.Prefixes.sbolx + "useLocal";
            MapsToRefinement2.UseRemote = Prefixes_1.Prefixes.sbolx + "useRemote";
          })(MapsToRefinement = SBOLX2.MapsToRefinement || (SBOLX2.MapsToRefinement = {}));
        })(SBOLX = Specifiers3.SBOLX || (Specifiers3.SBOLX = {}));
        let SBOL3;
        (function(SBOL32) {
          let Orientation;
          (function(Orientation2) {
            Orientation2.Inline = Prefixes_1.Prefixes.sbol3 + "inline";
            Orientation2.ReverseComplement = Prefixes_1.Prefixes.sbol3 + "reverseComplement";
          })(Orientation = SBOL32.Orientation || (SBOL32.Orientation = {}));
          let Direction;
          (function(Direction2) {
            Direction2.Input = Prefixes_1.Prefixes.sbol3 + "in";
            Direction2.Output = Prefixes_1.Prefixes.sbol3 + "out";
            Direction2.InputAndOutput = Prefixes_1.Prefixes.sbol3 + "inout";
            Direction2.None = Prefixes_1.Prefixes.sbol3 + "none";
          })(Direction = SBOL32.Direction || (SBOL32.Direction = {}));
          let Access;
          (function(Access2) {
            Access2.PublicAccess = Prefixes_1.Prefixes.sbol3 + "public";
            Access2.PrivateAccess = Prefixes_1.Prefixes.sbol3 + "private";
          })(Access = SBOL32.Access || (SBOL32.Access = {}));
          let Type;
          (function(Type2) {
            Type2.DNA = "http://www.biopax.org/release/biopax-level3.owl#DnaRegion";
            Type2.RNA = "http://www.biopax.org/release/biopax-level3.owl#RnaRegion";
            Type2.Protein = "http://www.biopax.org/release/biopax-level3.owl#Protein";
            Type2.SmallMolecule = "http://www.biopax.org/release/biopax-level3.owl#SmallMolecule";
            Type2.Complex = "http://www.biopax.org/release/biopax-level3.owl#Complex";
            Type2.Effector = "http://identifiers.org/chebi/CHEBI:35224";
            Type2.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000988";
          })(Type = SBOL32.Type || (SBOL32.Type = {}));
          let SequenceEncoding;
          (function(SequenceEncoding2) {
            SequenceEncoding2.NucleicAcid = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.RNA = "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html";
            SequenceEncoding2.AminoAcid = "http://www.chem.qmul.ac.uk/iupac/AminoAcid/";
          })(SequenceEncoding = SBOL32.SequenceEncoding || (SBOL32.SequenceEncoding = {}));
          let Constraint;
          (function(Constraint2) {
            Constraint2.Precedes = Prefixes_1.Prefixes.sbol3 + "precedes";
            Constraint2.OppositeOrientationAs = Prefixes_1.Prefixes.sbol3 + "oppositeOrientationAs";
          })(Constraint = SBOL32.Constraint || (SBOL32.Constraint = {}));
          let ProvRole;
          (function(ProvRole2) {
            ProvRole2.Design = Prefixes_1.Prefixes.sbol3 + "design";
            ProvRole2.Build = Prefixes_1.Prefixes.sbol3 + "build";
            ProvRole2.Test = Prefixes_1.Prefixes.sbol3 + "test";
            ProvRole2.Learn = Prefixes_1.Prefixes.sbol3 + "learn";
          })(ProvRole = SBOL32.ProvRole || (SBOL32.ProvRole = {}));
          let MapsToRefinement;
          (function(MapsToRefinement2) {
            MapsToRefinement2.UseLocal = Prefixes_1.Prefixes.sbol3 + "useLocal";
            MapsToRefinement2.UseRemote = Prefixes_1.Prefixes.sbol3 + "useRemote";
          })(MapsToRefinement = SBOL32.MapsToRefinement || (SBOL32.MapsToRefinement = {}));
        })(SBOL3 = Specifiers3.SBOL3 || (Specifiers3.SBOL3 = {}));
        let Visual;
        (function(Visual2) {
          Visual2.Blackbox = Prefixes_1.Prefixes.visual + "blackbox";
          Visual2.Whitebox = Prefixes_1.Prefixes.visual + "whitebox";
          Visual2.Float = Prefixes_1.Prefixes.visual + "float";
          Visual2.Backbone = Prefixes_1.Prefixes.visual + "backbone";
          Visual2.Forward = Prefixes_1.Prefixes.visual + "forward";
          Visual2.Reverse = Prefixes_1.Prefixes.visual + "reverse";
          Visual2.Expandable = Prefixes_1.Prefixes.visual + "expandable";
          Visual2.NotExpandable = Prefixes_1.Prefixes.visual + "notExpandable";
          Visual2.AnchorTop = Prefixes_1.Prefixes.visual + "anchorTop";
          Visual2.AnchorMid = Prefixes_1.Prefixes.visual + "anchorMid";
          Visual2.AnchorBottom = Prefixes_1.Prefixes.visual + "anchorBottom";
        })(Visual = Specifiers3.Visual || (Specifiers3.Visual = {}));
        let SO;
        (function(SO2) {
          SO2.CDS = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000316";
          SO2.Promoter = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000167";
          SO2.RBS = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000139";
          SO2.RestrictionSite = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001687";
          SO2.Terminator = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000141";
          SO2.OriginOfReplication = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000296";
          SO2.OriginOfTransfer = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000724";
          SO2.PlasmidBackbone = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000755";
          SO2.EngineeredRegion = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000804";
        })(SO = Specifiers3.SO || (Specifiers3.SO = {}));
        let SBO;
        (function(SBO2) {
          SBO2.Inhibition = Prefixes_1.Prefixes.sbo + "SBO:0000169";
          SBO2.Inhibitor = Prefixes_1.Prefixes.sbo + "SBO:0000020";
          SBO2.Inhibited = Prefixes_1.Prefixes.sbo + "SBO:0000642";
          SBO2.Stimulation = Prefixes_1.Prefixes.sbo + "SBO:0000170";
          SBO2.Stimulator = Prefixes_1.Prefixes.sbo + "SBO:0000459";
          SBO2.Stimulated = Prefixes_1.Prefixes.sbo + "SBO:0000643";
          SBO2.GeneticProduction = Prefixes_1.Prefixes.sbo + "SBO:0000589";
          SBO2.Product = Prefixes_1.Prefixes.sbo + "SBO:0000011";
          SBO2.Modifier = Prefixes_1.Prefixes.sbo + "SBO:0000019";
          SBO2.Promoter = Prefixes_1.Prefixes.sbo + "SBO:0000598";
          SBO2.Control = Prefixes_1.Prefixes.sbo + "SBO:0000168";
        })(SBO = Specifiers3.SBO || (Specifiers3.SBO = {}));
        let GO;
        (function(GO2) {
          GO2.ProteinDepolymerization = Prefixes_1.Prefixes.go + "GO:0051261";
          GO2.CovalentChromatinModification = Prefixes_1.Prefixes.go + "GO:0016569";
          GO2.ProteinProcessing = Prefixes_1.Prefixes.go + "GO:0016485";
          GO2.ProteinBinding = Prefixes_1.Prefixes.go + "GO:0005515";
          GO2.CatalyticActivity = Prefixes_1.Prefixes.go + "GO:0003824";
        })(GO = Specifiers3.GO || (Specifiers3.GO = {}));
        let SyBiOnt;
        (function(SyBiOnt2) {
          SyBiOnt2.Bidirectional = Prefixes_1.Prefixes.sybio + "Bidirectional";
          SyBiOnt2.LeftToRight = Prefixes_1.Prefixes.sybio + "LeftToRight";
          SyBiOnt2.RightToLeft = Prefixes_1.Prefixes.sybio + "RightToLeft";
          SyBiOnt2.UndefinedDirection = Prefixes_1.Prefixes.sybio + "UndefinedDirection";
          SyBiOnt2.LeftSide = Prefixes_1.Prefixes.sybio + "LeftSide";
          SyBiOnt2.RightSide = Prefixes_1.Prefixes.sybio + "RightSide";
        })(SyBiOnt = Specifiers3.SyBiOnt || (Specifiers3.SyBiOnt = {}));
      })(Specifiers2 = exports.Specifiers || (exports.Specifiers = {}));
    }
  });

  // node_modules/bioterms/dist/sequenceOntology.js
  var require_sequenceOntology3 = __commonJS({
    "node_modules/bioterms/dist/sequenceOntology.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      function uriToName(uri) {
        let temp = uri.split("/");
        let id = temp.pop();
        let entry = sequenceOntology.so[id];
        if (!entry)
          return void 0;
        let name = entry["name"];
        return name;
      }
      exports.uriToName = uriToName;
      var sequenceOntology;
      (function(sequenceOntology2) {
        sequenceOntology2.so = {
          "SO:0000000": {
            "name": "Sequence_Ontology"
          },
          "SO:0000001": {
            "name": "region",
            "def": "A sequence_feature with an extent greater than zero. A nucleotide region is composed of bases and a polypeptide region is composed of amino acids. [SO:ke]"
          },
          "SO:0000002": {
            "name": "sequence_secondary_structure",
            "def": "A folded sequence. [SO:ke]"
          },
          "SO:0000003": {
            "name": "G_quartet",
            "def": "G-quartets are unusual nucleic acid structures consisting of a planar arrangement where each guanine is hydrogen bonded by hoogsteen pairing to another guanine in the quartet. [http://www.ncbi.nlm.nih.gov/pubmed/7919797?dopt=Abstract]"
          },
          "SO:0000004": {
            "name": "interior_coding_exon"
          },
          "SO:0000005": {
            "name": "satellite_DNA",
            "def": "The many tandem repeats (identical or related) of a short basic repeating unit; many have a base composition or other property different from the genome average that allows them to be separated from the bulk (main band) genomic DNA. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000006": {
            "name": "PCR_product",
            "def": "A region amplified by a PCR reaction. [SO:ke]"
          },
          "SO:0000007": {
            "name": "read_pair",
            "def": "One of a pair of sequencing reads in which the two members of the pair are related by originating at either end of a clone insert. [SO:ls]"
          },
          "SO:0000008": {
            "name": "gene_sensu_your_favorite_organism"
          },
          "SO:0000009": {
            "name": "gene_class"
          },
          "SO:0000010": {
            "name": "protein_coding"
          },
          "SO:0000011": {
            "name": "non_protein_coding"
          },
          "SO:0000012": {
            "name": "scRNA_primary_transcript",
            "def": "The primary transcript of any one of several small cytoplasmic RNA molecules present in the cytoplasm and sometimes nucleus of a Eukaryote. [http://www.ebi.ac.uk/embl/WebFeat/align/scRNA_s.html]"
          },
          "SO:0000013": {
            "name": "scRNA",
            "def": "A small non coding RNA sequence, present in the cytoplasm. [SO:ke]"
          },
          "SO:0000014": {
            "name": "INR_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters required for the correct positioning of the polymerase for the start of transcription. Overlaps the TSS. The mammalian consensus sequence is YYAN(T|A)YY; the Drosophila consensus sequence is TCA(G|T)t(T|C). In each the A is at position +1 with respect to the TSS. Functionally similar to the TATA box element. [PMID:12651739, PMID:16858867]"
          },
          "SO:0000015": {
            "name": "DPE_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters; Positioned from +28 to +32 with respect to the TSS (+1). Experimental results suggest that the DPE acts in conjunction with the INR_motif to provide a binding site for TFIID in the absence of a TATA box to mediate transcription of TATA-less promoters. Consensus sequence (A|G)G(A|T)(C|T)(G|A|C). [PMID:12651739:12537576, PMID:16858867]"
          },
          "SO:0000016": {
            "name": "BREu_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, located immediately upstream of some TATA box elements at -37 to -32 with respect to the TSS (+1). Consensus sequence is (G|C)(G|C)(G|A)CGCC. Binds TFIIB. [PMID:12651739, PMID:16858867]"
          },
          "SO:0000017": {
            "name": "PSE_motif",
            "def": "A sequence element characteristic of the promoters of snRNA genes transcribed by RNA polymerase II or by RNA polymerase III. Located between -45 and -60 relative to the TSS. The human PSE_motif consensus sequence is TCACCNTNA(C|G)TNAAAAG(T|G). [PMID:12651739]"
          },
          "SO:0000018": {
            "name": "linkage_group",
            "def": "A group of loci that can be grouped in a linear order representing the different degrees of linkage among the genes concerned. [ISBN:038752046]"
          },
          "SO:0000020": {
            "name": "RNA_internal_loop",
            "def": "A region of double stranded RNA where the bases do not conform to WC base pairing. The loop is closed on both sides by canonical base pairing. If the interruption to base pairing occurs on one strand only, it is known as a bulge. [SO:ke]"
          },
          "SO:0000021": {
            "name": "asymmetric_RNA_internal_loop",
            "def": "An internal RNA loop where one of the strands includes more bases than the corresponding region on the other strand. [SO:ke]"
          },
          "SO:0000022": {
            "name": "A_minor_RNA_motif",
            "def": "A region forming a motif, composed of adenines, where the minor groove edges are inserted into the minor groove of another helix. [SO:ke]"
          },
          "SO:0000023": {
            "name": "K_turn_RNA_motif",
            "def": "The kink turn (K-turn) is an RNA structural motif that creates a sharp (~120 degree) bend between two continuous helices. [SO:ke]"
          },
          "SO:0000024": {
            "name": "sarcin_like_RNA_motif",
            "def": "A loop in ribosomal RNA containing the sites of attack for ricin and sarcin. [http://www.ncbi.nlm.nih.gov/pubmed/7897662]"
          },
          "SO:0000025": {
            "name": "symmetric_RNA_internal_loop",
            "def": "An internal RNA loop where the extent of the loop on both stands is the same size. [SO:ke]"
          },
          "SO:0000026": {
            "name": "RNA_junction_loop"
          },
          "SO:0000027": {
            "name": "RNA_hook_turn"
          },
          "SO:0000028": {
            "name": "base_pair"
          },
          "SO:0000029": {
            "name": "WC_base_pair",
            "def": "The canonical base pair, where two bases interact via WC edges, with glycosidic bonds oriented cis relative to the axis of orientation. [PMID:12177293]"
          },
          "SO:0000030": {
            "name": "sugar_edge_base_pair",
            "def": "A type of non-canonical base-pairing. [PMID:12177293]"
          },
          "SO:0000031": {
            "name": "aptamer",
            "def": "DNA or RNA molecules that have been selected from random pools based on their ability to bind other molecules. [http://aptamer.icmb.utexas.edu]"
          },
          "SO:0000032": {
            "name": "DNA_aptamer",
            "def": "DNA molecules that have been selected from random pools based on their ability to bind other molecules. [http:aptamer.icmb.utexas.edu]"
          },
          "SO:0000033": {
            "name": "RNA_aptamer",
            "def": "RNA molecules that have been selected from random pools based on their ability to bind other molecules. [http://aptamer.icmb.utexas.edu]"
          },
          "SO:0000034": {
            "name": "morpholino_oligo",
            "def": "Morpholino oligos are synthesized from four different Morpholino subunits, each of which contains one of the four genetic bases (A, C, G, T) linked to a 6-membered morpholine ring. Eighteen to 25 subunits of these four subunit types are joined in a specific order by non-ionic phosphorodiamidate intersubunit linkages to give a Morpholino. [http://www.gene-tools.com/]"
          },
          "SO:0000035": {
            "name": "riboswitch",
            "def": "A riboswitch is a part of an mRNA that can act as a direct sensor of small molecules to control their own expression. A riboswitch is a cis element in the 5' end of an mRNA, that acts as a direct sensor of metabolites. [PMID:2820954]"
          },
          "SO:0000036": {
            "name": "matrix_attachment_site",
            "def": "A DNA region that is required for the binding of chromatin to the nuclear matrix. [SO:ma]"
          },
          "SO:0000037": {
            "name": "locus_control_region",
            "def": "A DNA region that includes DNAse hypersensitive sites located 5' to a gene that confers the high-level, position-independent, and copy number-dependent expression to that gene. [SO:ma]"
          },
          "SO:0000038": {
            "name": "match_set",
            "def": "A collection of match parts. [SO:ke]"
          },
          "SO:0000039": {
            "name": "match_part",
            "def": "A part of a match, for example an hsp from blast is a match_part. [SO:ke]"
          },
          "SO:0000040": {
            "name": "genomic_clone",
            "def": "A clone of a DNA region of a genome. [SO:ma]"
          },
          "SO:0000041": {
            "name": "sequence_operation",
            "def": "An operation that can be applied to a sequence, that results in a change. [SO:ke]"
          },
          "SO:0000042": {
            "name": "pseudogene_attribute",
            "def": "An attribute of a pseudogene (SO:0000336). [SO:ma]"
          },
          "SO:0000043": {
            "name": "processed_pseudogene",
            "def": "A pseudogene where by an mRNA was retrotransposed. The mRNA sequence is transcribed back into the genome, lacking introns and promoters, but often including a polyA tail. [SO:xp]"
          },
          "SO:0000044": {
            "name": "pseudogene_by_unequal_crossing_over",
            "def": "A pseudogene caused by unequal crossing over at recombination. [SO:ke]"
          },
          "SO:0000045": {
            "name": "delete",
            "def": "To remove a subsection of sequence. [SO:ke]"
          },
          "SO:0000046": {
            "name": "insert",
            "def": "To insert a subsection of sequence. [SO:ke]"
          },
          "SO:0000047": {
            "name": "invert",
            "def": "To invert a subsection of sequence. [SO:ke]"
          },
          "SO:0000048": {
            "name": "substitute",
            "def": "To substitute a subsection of sequence for another. [SO:ke]"
          },
          "SO:0000049": {
            "name": "translocate",
            "def": "To translocate a subsection of sequence. [SO:ke]"
          },
          "SO:0000050": {
            "name": "gene_part",
            "def": "A part of a gene, that has no other route in the ontology back to region. This concept is necessary for logical inference as these parts must have the properties of region. It also allows us to associate all the parts of genes with a gene. [SO:ke]"
          },
          "SO:0000051": {
            "name": "probe",
            "def": "A DNA sequence used experimentally to detect the presence or absence of a complementary nucleic acid. [SO:ma]"
          },
          "SO:0000052": {
            "name": "assortment_derived_deficiency"
          },
          "SO:0000053": {
            "name": "sequence_variant_affecting_regulatory_region",
            "def": "A sequence_variant_effect which changes the regulatory region of a gene. [SO:ke]"
          },
          "SO:0000054": {
            "name": "aneuploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number. [SO:ke]"
          },
          "SO:0000055": {
            "name": "hyperploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number as extra chromosomes are present. [SO:ke]"
          },
          "SO:0000056": {
            "name": "hypoploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number as some chromosomes are missing. [SO:ke]"
          },
          "SO:0000057": {
            "name": "operator",
            "def": "A regulatory element of an operon to which activators or repressors bind thereby effecting translation of genes in that operon. [SO:ma]"
          },
          "SO:0000058": {
            "name": "assortment_derived_aneuploid"
          },
          "SO:0000059": {
            "name": "nuclease_binding_site",
            "def": "A binding site that, of a nucleotide molecule, that interacts selectively and non-covalently with polypeptide residues of a nuclease. [SO:cb]"
          },
          "SO:0000060": {
            "name": "compound_chromosome_arm"
          },
          "SO:0000061": {
            "name": "restriction_enzyme_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues of a restriction enzyme. [SO:cb]"
          },
          "SO:0000062": {
            "name": "deficient_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby a translocation in which one of the four broken ends loses a segment before re-joining. [FB:reference_manual]"
          },
          "SO:0000063": {
            "name": "deficient_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a translocation in which one of the four broken ends loses a segment before re-joining. [SO:ke]"
          },
          "SO:0000064": {
            "name": "gene_by_transcript_attribute"
          },
          "SO:0000065": {
            "name": "free_chromosome_arm",
            "def": "A chromosome structure variation whereby an arm exists as an individual chromosome element. [SO:ke]"
          },
          "SO:0000066": {
            "name": "gene_by_polyadenylation_attribute"
          },
          "SO:0000067": {
            "name": "gene_to_gene_feature"
          },
          "SO:0000068": {
            "name": "overlapping",
            "def": "An attribute describing a gene that has a sequence that overlaps the sequence of another gene. [SO:ke]"
          },
          "SO:0000069": {
            "name": "inside_intron",
            "def": "An attribute to describe a gene when it is located within the intron of another gene. [SO:ke]"
          },
          "SO:0000070": {
            "name": "inside_intron_antiparallel",
            "def": "An attribute to describe a gene when it is located within the intron of another gene and on the opposite strand. [SO:ke]"
          },
          "SO:0000071": {
            "name": "inside_intron_parallel",
            "def": "An attribute to describe a gene when it is located within the intron of another gene and on the same strand. [SO:ke]"
          },
          "SO:0000072": {
            "name": "end_overlapping_gene"
          },
          "SO:0000073": {
            "name": "five_prime_three_prime_overlap",
            "def": "An attribute to describe a gene when the five prime region overlaps with another gene's 3' region. [SO:ke]"
          },
          "SO:0000074": {
            "name": "five_prime_five_prime_overlap",
            "def": "An attribute to describe a gene when the five prime region overlaps with another gene's five prime region. [SO:ke]"
          },
          "SO:0000075": {
            "name": "three_prime_three_prime_overlap",
            "def": "An attribute to describe a gene when the 3' region overlaps with another gene's 3' region. [SO:ke]"
          },
          "SO:0000076": {
            "name": "three_prime_five_prime_overlap",
            "def": "An attribute to describe a gene when the 3' region overlaps with another gene's 5' region. [SO:ke]"
          },
          "SO:0000077": {
            "name": "antisense",
            "def": "A region sequence that is complementary to a sequence of messenger RNA. [SO:ke]"
          },
          "SO:0000078": {
            "name": "polycistronic_transcript",
            "def": "A transcript that is polycistronic. [SO:xp]"
          },
          "SO:0000079": {
            "name": "dicistronic_transcript",
            "def": "A transcript that is dicistronic. [SO:ke]"
          },
          "SO:0000080": {
            "name": "operon_member"
          },
          "SO:0000081": {
            "name": "gene_array_member"
          },
          "SO:0000082": {
            "name": "processed_transcript_attribute"
          },
          "SO:0000083": {
            "name": "macronuclear_sequence"
          },
          "SO:0000084": {
            "name": "micronuclear_sequence"
          },
          "SO:0000085": {
            "name": "gene_by_genome_location"
          },
          "SO:0000086": {
            "name": "gene_by_organelle_of_genome"
          },
          "SO:0000087": {
            "name": "nuclear_gene",
            "def": "A gene from nuclear sequence. [SO:xp]"
          },
          "SO:0000088": {
            "name": "mt_gene",
            "def": "A gene located in mitochondrial sequence. [SO:xp]"
          },
          "SO:0000089": {
            "name": "kinetoplast_gene",
            "def": "A gene located in kinetoplast sequence. [SO:xp]"
          },
          "SO:0000090": {
            "name": "plastid_gene",
            "def": "A gene from plastid sequence. [SO:xp]"
          },
          "SO:0000091": {
            "name": "apicoplast_gene",
            "def": "A gene from apicoplast sequence. [SO:xp]"
          },
          "SO:0000092": {
            "name": "ct_gene",
            "def": "A gene from chloroplast sequence. [SO:xp]"
          },
          "SO:0000093": {
            "name": "chromoplast_gene",
            "def": "A gene from chromoplast_sequence. [SO:xp]"
          },
          "SO:0000094": {
            "name": "cyanelle_gene",
            "def": "A gene from cyanelle sequence. [SO:xp]"
          },
          "SO:0000095": {
            "name": "leucoplast_gene",
            "def": "A plastid gene from leucoplast sequence. [SO:xp]"
          },
          "SO:0000096": {
            "name": "proplastid_gene",
            "def": "A gene from proplastid sequence. [SO:ke]"
          },
          "SO:0000097": {
            "name": "nucleomorph_gene",
            "def": "A gene from nucleomorph sequence. [SO:xp]"
          },
          "SO:0000098": {
            "name": "plasmid_gene",
            "def": "A gene from plasmid sequence. [SO:xp]"
          },
          "SO:0000099": {
            "name": "proviral_gene",
            "def": "A gene from proviral sequence. [SO:xp]"
          },
          "SO:0000100": {
            "name": "endogenous_retroviral_gene",
            "def": "A proviral gene with origin endogenous retrovirus. [SO:xp]"
          },
          "SO:0000101": {
            "name": "transposable_element",
            "def": "A transposon or insertion sequence. An element that can insert in a variety of DNA sequences. [http://www.sci.sdsu.edu/~smaloy/Glossary/T.html]"
          },
          "SO:0000102": {
            "name": "expressed_sequence_match",
            "def": "A match to an EST or cDNA sequence. [SO:ke]"
          },
          "SO:0000103": {
            "name": "clone_insert_end",
            "def": "The end of the clone insert. [SO:ke]"
          },
          "SO:0000104": {
            "name": "polypeptide",
            "def": "A sequence of amino acids linked by peptide bonds which may lack appreciable tertiary structure and may not be liable to irreversible denaturation. [SO:ma]"
          },
          "SO:0000105": {
            "name": "chromosome_arm",
            "def": "A region of the chromosome between the centromere and the telomere. Human chromosomes have two arms, the p arm (short) and the q arm (long) which are separated from each other by the centromere. [http://www.medterms.com/script/main/art.asp?articlekey=5152]"
          },
          "SO:0000106": {
            "name": "non_capped_primary_transcript"
          },
          "SO:0000107": {
            "name": "sequencing_primer"
          },
          "SO:0000108": {
            "name": "mRNA_with_frameshift",
            "def": "An mRNA with a frameshift. [SO:xp]"
          },
          "SO:0000109": {
            "name": "sequence_variant_obs",
            "def": "A sequence_variant is a non exact copy of a sequence_feature or genome exhibiting one or more sequence_alteration. [SO:ke]"
          },
          "SO:0000110": {
            "name": "sequence_feature",
            "def": "Any extent of continuous biological sequence. [LAMHDI:mb, SO:ke]"
          },
          "SO:0000111": {
            "name": "transposable_element_gene",
            "def": "A gene encoded within a transposable element. For example gag, int, env and pol are the transposable element genes of the TY element in yeast. [SO:ke]"
          },
          "SO:0000112": {
            "name": "primer",
            "def": "An oligo to which new deoxyribonucleotides can be added by DNA polymerase. [SO:ke]"
          },
          "SO:0000113": {
            "name": "proviral_region",
            "def": "A viral sequence which has integrated into a host genome. [SO:ke]"
          },
          "SO:0000114": {
            "name": "methylated_cytosine",
            "def": "A methylated deoxy-cytosine. [SO:ke]"
          },
          "SO:0000115": {
            "name": "transcript_feature"
          },
          "SO:0000116": {
            "name": "edited",
            "def": "An attribute describing a sequence that is modified by editing. [SO:ke]"
          },
          "SO:0000117": {
            "name": "transcript_with_readthrough_stop_codon"
          },
          "SO:0000118": {
            "name": "transcript_with_translational_frameshift",
            "def": "A transcript with a translational frameshift. [SO:xp]"
          },
          "SO:0000119": {
            "name": "regulated",
            "def": "An attribute to describe a sequence that is regulated. [SO:ke]"
          },
          "SO:0000120": {
            "name": "protein_coding_primary_transcript",
            "def": "A primary transcript that, at least in part, encodes one or more proteins. [SO:ke]"
          },
          "SO:0000121": {
            "name": "forward_primer",
            "def": "A single stranded oligo used for polymerase chain reaction. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
          },
          "SO:0000122": {
            "name": "RNA_sequence_secondary_structure",
            "def": "A folded RNA sequence. [SO:ke]"
          },
          "SO:0000123": {
            "name": "transcriptionally_regulated",
            "def": "An attribute describing a gene that is regulated at transcription. [SO:ma]"
          },
          "SO:0000124": {
            "name": "transcriptionally_constitutive",
            "def": "Expressed in relatively constant amounts without regard to cellular environmental conditions such as the concentration of a particular substrate. [SO:ke]"
          },
          "SO:0000125": {
            "name": "transcriptionally_induced",
            "def": "An inducer molecule is required for transcription to occur. [SO:ke]"
          },
          "SO:0000126": {
            "name": "transcriptionally_repressed",
            "def": "A repressor molecule is required for transcription to stop. [SO:ke]"
          },
          "SO:0000127": {
            "name": "silenced_gene",
            "def": "A gene that is silenced. [SO:xp]"
          },
          "SO:0000128": {
            "name": "gene_silenced_by_DNA_modification",
            "def": "A gene that is silenced by DNA modification. [SO:xp]"
          },
          "SO:0000129": {
            "name": "gene_silenced_by_DNA_methylation",
            "def": "A gene that is silenced by DNA methylation. [SO:xp]"
          },
          "SO:0000130": {
            "name": "post_translationally_regulated",
            "def": "An attribute describing a gene that is regulated after it has been translated. [SO:ke]"
          },
          "SO:0000131": {
            "name": "translationally_regulated",
            "def": "An attribute describing a gene that is regulated as it is translated. [SO:ke]"
          },
          "SO:0000132": {
            "name": "reverse_primer",
            "def": "A single stranded oligo used for polymerase chain reaction. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
          },
          "SO:0000133": {
            "name": "epigenetically_modified",
            "def": "This attribute describes a gene where heritable changes other than those in the DNA sequence occur. These changes include: modification to the DNA (such as DNA methylation, the covalent modification of cytosine), and post-translational modification of histones. [SO:ke]"
          },
          "SO:0000134": {
            "name": "genomically_imprinted",
            "def": "Imprinted genes are epigenetically modified genes that are expressed monoallelically according to their parent of origin. [SO:ke]"
          },
          "SO:0000135": {
            "name": "maternally_imprinted",
            "def": "The maternal copy of the gene is modified, rendering it transcriptionally silent. [SO:ke]"
          },
          "SO:0000136": {
            "name": "paternally_imprinted",
            "def": "The paternal copy of the gene is modified, rendering it transcriptionally silent. [SO:ke]"
          },
          "SO:0000137": {
            "name": "allelically_excluded",
            "def": "Allelic exclusion is a process occurring in diploid organisms, where a gene is inactivated and not expressed in that cell. [SO:ke]"
          },
          "SO:0000138": {
            "name": "gene_rearranged_at_DNA_level",
            "def": "An epigenetically modified gene, rearranged at the DNA level. [SO:xp]"
          },
          "SO:0000139": {
            "name": "ribosome_entry_site",
            "def": "Region in mRNA where ribosome assembles. [SO:ke]"
          },
          "SO:0000140": {
            "name": "attenuator",
            "def": "A sequence segment located within the five prime end of an mRNA that causes premature termination of translation. [SO:as]"
          },
          "SO:0000141": {
            "name": "terminator",
            "def": "The sequence of DNA located either at the end of the transcript that causes RNA polymerase to terminate transcription. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000142": {
            "name": "DNA_sequence_secondary_structure",
            "def": "A folded DNA sequence. [SO:ke]"
          },
          "SO:0000143": {
            "name": "assembly_component",
            "def": "A region of known length which may be used to manufacture a longer region. [SO:ke]"
          },
          "SO:0000144": {
            "name": "primary_transcript_attribute"
          },
          "SO:0000145": {
            "name": "recoded_codon",
            "def": "A codon that has been redefined at translation. The redefinition may be as a result of translational bypass, translational frameshifting or stop codon readthrough. [SO:xp]"
          },
          "SO:0000146": {
            "name": "capped",
            "def": "An attribute describing when a sequence, usually an mRNA is capped by the addition of a modified guanine nucleotide at the 5' end. [SO:ke]"
          },
          "SO:0000147": {
            "name": "exon",
            "def": "A region of the transcript sequence within a gene which is not removed from the primary RNA transcript by RNA splicing. [SO:ke]"
          },
          "SO:0000148": {
            "name": "supercontig",
            "def": "One or more contigs that have been ordered and oriented using end-read information. Contains gaps that are filled with N's. [SO:ls]"
          },
          "SO:0000149": {
            "name": "contig",
            "def": "A contiguous sequence derived from sequence assembly. Has no gaps, but may contain N's from unavailable bases. [SO:ls]"
          },
          "SO:0000150": {
            "name": "read",
            "def": "A sequence obtained from a single sequencing experiment. Typically a read is produced when a base calling program interprets information from a chromatogram trace file produced from a sequencing machine. [SO:rd]"
          },
          "SO:0000151": {
            "name": "clone",
            "def": "A piece of DNA that has been inserted in a vector so that it can be propagated in a host bacterium or some other organism. [SO:ke]"
          },
          "SO:0000152": {
            "name": "YAC",
            "def": "Yeast Artificial Chromosome, a vector constructed from the telomeric, centromeric, and replication origin sequences needed for replication in yeast cells. [SO:ma]"
          },
          "SO:0000153": {
            "name": "BAC",
            "def": "Bacterial Artificial Chromosome, a cloning vector that can be propagated as mini-chromosomes in a bacterial host. [SO:ma]"
          },
          "SO:0000154": {
            "name": "PAC",
            "def": "The P1-derived artificial chromosome are DNA constructs that are derived from the DNA of P1 bacteriophage. They can carry large amounts (about 100-300 kilobases) of other sequences for a variety of bioengineering purposes. It is one type of vector used to clone DNA fragments (100- to 300-kb insert size; average, 150 kb) in Escherichia coli cells. [http://en.wikipedia.org/wiki/P1-derived_artificial_chromosome]"
          },
          "SO:0000155": {
            "name": "plasmid",
            "def": "A self replicating, using the hosts cellular machinery, often circular nucleic acid molecule that is distinct from a chromosome in the organism. [SO:ma]"
          },
          "SO:0000156": {
            "name": "cosmid",
            "def": "A cloning vector that is a hybrid of lambda phages and a plasmid that can be propagated as a plasmid or packaged as a phage,since they retain the lambda cos sites. [SO:ma]"
          },
          "SO:0000157": {
            "name": "phagemid",
            "def": "A plasmid which carries within its sequence a bacteriophage replication origin. When the host bacterium is infected with \\helper\\ phage, a phagemid is replicated along with the phage DNA and packaged into phage capsids. [SO:ma]"
          },
          "SO:0000158": {
            "name": "fosmid",
            "def": "A cloning vector that utilizes the E. coli F factor. [SO:ma]"
          },
          "SO:0000159": {
            "name": "deletion",
            "def": "The point at which one or more contiguous nucleotides were excised. [SO:ke]"
          },
          "SO:0000160": {
            "name": "lambda_clone",
            "def": "A linear clone derived from lambda bacteriophage. The genes involved in the lysogenic pathway are removed from the from the viral DNA. Up to 25 kb of foreign DNA can then be inserted into the lambda genome. [ISBN:0-1767-2380-8]"
          },
          "SO:0000161": {
            "name": "methylated_adenine",
            "def": "A modified  base in which adenine has been methylated. [SO:ke]"
          },
          "SO:0000162": {
            "name": "splice_site",
            "def": "Consensus region of primary transcript bordering junction of splicing. A region that overlaps exactly 2 base and adjacent_to splice_junction. [SO:cjm, SO:ke]"
          },
          "SO:0000163": {
            "name": "five_prime_cis_splice_site",
            "def": "Intronic 2 bp region bordering the exon, at the 5' edge of the intron. A splice_site that is downstream_adjacent_to exon and starts intron. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html, SO:cjm, SO:ke]"
          },
          "SO:0000164": {
            "name": "three_prime_cis_splice_site",
            "def": "Intronic 2 bp region bordering the exon, at the 3' edge of the intron. A splice_site that is upstream_adjacent_to exon and finishes intron. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html, SO:cjm, SO:ke]"
          },
          "SO:0000165": {
            "name": "enhancer",
            "def": "A cis-acting sequence that increases the utilization of (some) eukaryotic promoters, and can function in either orientation and in any location (upstream or downstream) relative to the promoter. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000166": {
            "name": "enhancer_bound_by_factor",
            "def": "An enhancer bound by a factor. [SO:xp]"
          },
          "SO:0000167": {
            "name": "promoter",
            "def": "A regulatory_region composed of the TSS(s) and binding sites for TF_complexes of the basal transcription machinery. [SO:regcreative]"
          },
          "SO:0000168": {
            "name": "restriction_enzyme_cut_site",
            "def": "A specific nucleotide sequence of DNA at or near which a particular restriction enzyme cuts the DNA. [SO:ma]"
          },
          "SO:0000169": {
            "name": "RNApol_I_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase I binds, to begin transcription. [SO:ke]"
          },
          "SO:0000170": {
            "name": "RNApol_II_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase II binds, to begin transcription. [SO:ke]"
          },
          "SO:0000171": {
            "name": "RNApol_III_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase III binds, to begin transcription. [SO:ke]"
          },
          "SO:0000172": {
            "name": "CAAT_signal",
            "def": "Part of a conserved sequence located about 75-bp upstream of the start point of eukaryotic transcription units which may be involved in RNA polymerase binding; consensus=GG(C|T)CAATCT. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000173": {
            "name": "GC_rich_promoter_region",
            "def": "A conserved GC-rich region located upstream of the start point of eukaryotic transcription units which may occur in multiple copies or in either orientation; consensus=GGGCGG. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000174": {
            "name": "TATA_box",
            "def": "A conserved AT-rich septamer found about 25-bp before the start point of many eukaryotic RNA polymerase II transcript units; may be involved in positioning the enzyme for correct initiation; consensus=TATA(A|T)A(A|T). [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, PMID:16858867]"
          },
          "SO:0000175": {
            "name": "minus_10_signal",
            "def": "A conserved region about 10-bp upstream of the start point of bacterial transcription units which may be involved in binding RNA polymerase; consensus=TAtAaT. This region is associated with sigma factor 70. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000176": {
            "name": "minus_35_signal",
            "def": "A conserved hexamer about 35-bp upstream of the start point of bacterial transcription units; consensus=TTGACa or TGTTGACA. This region is associated with sigma factor 70. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000177": {
            "name": "cross_genome_match",
            "def": "A nucleotide match against a sequence from another organism. [SO:ma]"
          },
          "SO:0000178": {
            "name": "operon",
            "def": "A group of contiguous genes transcribed as a single (polycistronic) mRNA from a single regulatory region. [SO:ma]"
          },
          "SO:0000179": {
            "name": "clone_insert_start",
            "def": "The start of the clone insert. [SO:ke]"
          },
          "SO:0000180": {
            "name": "retrotransposon",
            "def": "A transposable element that is incorporated into a chromosome by a mechanism that requires reverse transcriptase. [http://www.dddmag.com/Glossary.aspx#r]"
          },
          "SO:0000181": {
            "name": "translated_nucleotide_match",
            "def": "A match against a translated sequence. [SO:ke]"
          },
          "SO:0000182": {
            "name": "DNA_transposon",
            "def": "A transposon where the mechanism of transposition is via a DNA intermediate. [SO:ke]"
          },
          "SO:0000183": {
            "name": "non_transcribed_region",
            "def": "A region of the gene which is not transcribed. [SO:ke]"
          },
          "SO:0000184": {
            "name": "U2_intron",
            "def": "A major type of spliceosomal intron spliced by the U2 spliceosome, that includes U1, U2, U4/U6 and U5 snRNAs. [PMID:9428511]"
          },
          "SO:0000185": {
            "name": "primary_transcript",
            "def": "A transcript that in its initial state requires modification to be functional. [SO:ma]"
          },
          "SO:0000186": {
            "name": "LTR_retrotransposon",
            "def": "A retrotransposon flanked by long terminal repeat sequences. [SO:ke]"
          },
          "SO:0000187": {
            "name": "repeat_family",
            "def": "A group of characterized repeat sequences. [SO:ke]"
          },
          "SO:0000188": {
            "name": "intron",
            "def": "A region of a primary transcript that is transcribed, but removed from within the transcript by splicing together the sequences (exons) on either side of it. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000189": {
            "name": "non_LTR_retrotransposon",
            "def": "A retrotransposon without long terminal repeat sequences. [SO:ke]"
          },
          "SO:0000190": {
            "name": "five_prime_intron"
          },
          "SO:0000191": {
            "name": "interior_intron"
          },
          "SO:0000192": {
            "name": "three_prime_intron"
          },
          "SO:0000193": {
            "name": "RFLP_fragment",
            "def": "A DNA fragment used as a reagent to detect the polymorphic genomic loci by hybridizing against the genomic DNA digested with a given restriction enzyme. [GOC:pj]"
          },
          "SO:0000194": {
            "name": "LINE_element",
            "def": "A dispersed repeat family with many copies, each from 1 to 6 kb long. New elements are generated by retroposition of a transcribed copy. Typically the LINE contains 2 ORF's one of which is reverse transcriptase, and 3'and 5' direct repeats. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html]"
          },
          "SO:0000195": {
            "name": "coding_exon",
            "def": "An exon whereby at least one base is part of a codon (here, 'codon' is inclusive of the stop_codon). [SO:ke]"
          },
          "SO:0000196": {
            "name": "five_prime_coding_exon_coding_region",
            "def": "The sequence of the five_prime_coding_exon that codes for protein. [SO:cjm]"
          },
          "SO:0000197": {
            "name": "three_prime_coding_exon_coding_region",
            "def": "The sequence of the three_prime_coding_exon that codes for protein. [SO:cjm]"
          },
          "SO:0000198": {
            "name": "noncoding_exon",
            "def": "An exon that does not contain any codons. [SO:ke]"
          },
          "SO:0000199": {
            "name": "translocation",
            "def": "A region of nucleotide sequence that has translocated to a new position. The observed adjacency of two previously separated regions. [NCBI:th, SO:ke]"
          },
          "SO:0000200": {
            "name": "five_prime_coding_exon",
            "def": "The 5' most coding exon. [SO:ke]"
          },
          "SO:0000201": {
            "name": "interior_exon",
            "def": "An exon that is bounded by 5' and 3' splice sites. [PMID:10373547]"
          },
          "SO:0000202": {
            "name": "three_prime_coding_exon",
            "def": "The coding exon that is most 3-prime on a given transcript. [SO:ma]"
          },
          "SO:0000203": {
            "name": "UTR",
            "def": "Messenger RNA sequences that are untranslated and lie five prime or three prime to sequences which are translated. [SO:ke]"
          },
          "SO:0000204": {
            "name": "five_prime_UTR",
            "def": "A region at the 5' end of a mature transcript (preceding the initiation codon) that is not translated into a protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000205": {
            "name": "three_prime_UTR",
            "def": "A region at the 3' end of a mature transcript (following the stop codon) that is not translated into a protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000206": {
            "name": "SINE_element",
            "def": "A repetitive element, a few hundred base pairs long, that is dispersed throughout the genome. A common human SINE is the Alu element. [SO:ke]"
          },
          "SO:0000207": {
            "name": "simple_sequence_length_variation"
          },
          "SO:0000208": {
            "name": "terminal_inverted_repeat_element",
            "def": "A DNA transposable element defined as having termini with perfect, or nearly perfect short inverted repeats, generally 10 - 40 nucleotides long. [http://www.genetics.org/cgi/reprint/156/4/1983.pdf]"
          },
          "SO:0000209": {
            "name": "rRNA_primary_transcript",
            "def": "A primary transcript encoding a ribosomal RNA. [SO:ke]"
          },
          "SO:0000210": {
            "name": "tRNA_primary_transcript",
            "def": "A primary transcript encoding a transfer RNA (SO:0000253). [SO:ke]"
          },
          "SO:0000211": {
            "name": "alanine_tRNA_primary_transcript",
            "def": "A primary transcript encoding alanyl tRNA. [SO:ke]"
          },
          "SO:0000212": {
            "name": "arginine_tRNA_primary_transcript",
            "def": "A primary transcript encoding arginyl tRNA (SO:0000255). [SO:ke]"
          },
          "SO:0000213": {
            "name": "asparagine_tRNA_primary_transcript",
            "def": "A primary transcript encoding asparaginyl tRNA (SO:0000256). [SO:ke]"
          },
          "SO:0000214": {
            "name": "aspartic_acid_tRNA_primary_transcript",
            "def": "A primary transcript encoding aspartyl tRNA (SO:0000257). [SO:ke]"
          },
          "SO:0000215": {
            "name": "cysteine_tRNA_primary_transcript",
            "def": "A primary transcript encoding cysteinyl tRNA (SO:0000258). [SO:ke]"
          },
          "SO:0000216": {
            "name": "glutamic_acid_tRNA_primary_transcript",
            "def": "A primary transcript encoding glutaminyl tRNA (SO:0000260). [SO:ke]"
          },
          "SO:0000217": {
            "name": "glutamine_tRNA_primary_transcript",
            "def": "A primary transcript encoding glutamyl tRNA (SO:0000260). [SO:ke]"
          },
          "SO:0000218": {
            "name": "glycine_tRNA_primary_transcript",
            "def": "A primary transcript encoding glycyl tRNA (SO:0000263). [SO:ke]"
          },
          "SO:0000219": {
            "name": "histidine_tRNA_primary_transcript",
            "def": "A primary transcript encoding histidyl tRNA (SO:0000262). [SO:ke]"
          },
          "SO:0000220": {
            "name": "isoleucine_tRNA_primary_transcript",
            "def": "A primary transcript encoding isoleucyl tRNA (SO:0000263). [SO:ke]"
          },
          "SO:0000221": {
            "name": "leucine_tRNA_primary_transcript",
            "def": "A primary transcript encoding leucyl tRNA (SO:0000264). [SO:ke]"
          },
          "SO:0000222": {
            "name": "lysine_tRNA_primary_transcript",
            "def": "A primary transcript encoding lysyl tRNA (SO:0000265). [SO:ke]"
          },
          "SO:0000223": {
            "name": "methionine_tRNA_primary_transcript",
            "def": "A primary transcript encoding methionyl tRNA (SO:0000266). [SO:ke]"
          },
          "SO:0000224": {
            "name": "phenylalanine_tRNA_primary_transcript",
            "def": "A primary transcript encoding phenylalanyl tRNA (SO:0000267). [SO:ke]"
          },
          "SO:0000225": {
            "name": "proline_tRNA_primary_transcript",
            "def": "A primary transcript encoding prolyl tRNA (SO:0000268). [SO:ke]"
          },
          "SO:0000226": {
            "name": "serine_tRNA_primary_transcript",
            "def": "A primary transcript encoding seryl tRNA (SO:000269). [SO:ke]"
          },
          "SO:0000227": {
            "name": "threonine_tRNA_primary_transcript",
            "def": "A primary transcript encoding threonyl tRNA (SO:000270). [SO:ke]"
          },
          "SO:0000228": {
            "name": "tryptophan_tRNA_primary_transcript",
            "def": "A primary transcript encoding tryptophanyl tRNA (SO:000271). [SO:ke]"
          },
          "SO:0000229": {
            "name": "tyrosine_tRNA_primary_transcript",
            "def": "A primary transcript encoding tyrosyl tRNA (SO:000272). [SO:ke]"
          },
          "SO:0000230": {
            "name": "valine_tRNA_primary_transcript",
            "def": "A primary transcript encoding valyl tRNA (SO:000273). [SO:ke]"
          },
          "SO:0000231": {
            "name": "snRNA_primary_transcript",
            "def": "A primary transcript encoding a small nuclear RNA (SO:0000274). [SO:ke]"
          },
          "SO:0000232": {
            "name": "snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar mRNA (SO:0000275). [SO:ke]"
          },
          "SO:0000233": {
            "name": "mature_transcript",
            "def": "A transcript which has undergone the necessary modifications, if any, for its function. In eukaryotes this includes, for example, processing of introns, cleavage, base modification, and modifications to the 5' and/or the 3' ends, other than addition of bases. In bacteria functional mRNAs are usually not modified. [SO:ke]"
          },
          "SO:0000234": {
            "name": "mRNA",
            "def": "Messenger RNA is the intermediate molecule between DNA and protein. It includes UTR and coding sequences. It does not contain introns. [SO:ma]"
          },
          "SO:0000235": {
            "name": "TF_binding_site",
            "def": "A region of a nucleotide molecule that binds a Transcription Factor or Transcription Factor complex [GO:0005667]. [SO:ke]"
          },
          "SO:0000236": {
            "name": "ORF",
            "def": "The in-frame interval between the stop codons of a reading frame which when read as sequential triplets, has the potential of encoding a sequential string of amino acids. TER(NNN)nTER. [SGD:rb, SO:ma]"
          },
          "SO:0000237": {
            "name": "transcript_attribute"
          },
          "SO:0000238": {
            "name": "foldback_element",
            "def": "A transposable element with extensive secondary structure, characterized by large modular imperfect long inverted repeats. [http://www.genetics.org/cgi/reprint/156/4/1983.pdf]"
          },
          "SO:0000239": {
            "name": "flanking_region",
            "def": "The sequences extending on either side of a specific region. [SO:ke]"
          },
          "SO:0000240": {
            "name": "chromosome_variation"
          },
          "SO:0000241": {
            "name": "internal_UTR",
            "def": "A UTR bordered by the terminal and initial codons of two CDSs in a polycistronic transcript. Every UTR is either 5', 3' or internal. [SO:cjm]"
          },
          "SO:0000242": {
            "name": "untranslated_region_polycistronic_mRNA",
            "def": "The untranslated sequence separating the 'cistrons' of multicistronic mRNA. [SO:ke]"
          },
          "SO:0000243": {
            "name": "internal_ribosome_entry_site",
            "def": "Sequence element that recruits a ribosomal subunit to internal mRNA for translation initiation. [SO:ke]"
          },
          "SO:0000244": {
            "name": "four_cutter_restriction_site"
          },
          "SO:0000245": {
            "name": "mRNA_by_polyadenylation_status"
          },
          "SO:0000246": {
            "name": "polyadenylated",
            "def": "A attribute describing the addition of a poly A tail to the 3' end of a mRNA molecule. [SO:ke]"
          },
          "SO:0000247": {
            "name": "mRNA_not_polyadenylated"
          },
          "SO:0000248": {
            "name": "sequence_length_variation"
          },
          "SO:0000249": {
            "name": "six_cutter_restriction_site"
          },
          "SO:0000250": {
            "name": "modified_RNA_base_feature",
            "def": "A post_transcriptionally modified base. [SO:ke]"
          },
          "SO:0000251": {
            "name": "eight_cutter_restriction_site"
          },
          "SO:0000252": {
            "name": "rRNA",
            "def": "RNA that comprises part of a ribosome, and that can provide both structural scaffolding and catalytic activity. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, ISBN:0198506732]"
          },
          "SO:0000253": {
            "name": "tRNA",
            "def": "Transfer RNA (tRNA) molecules are approximately 80 nucleotides in length. Their secondary structure includes four short double-helical elements and three loops (D, anti-codon, and T loops). Further hydrogen bonds mediate the characteristic L-shaped molecular structure. Transfer RNAs have two regions of fundamental functional importance: the anti-codon, which is responsible for specific mRNA codon recognition, and the 3' end, to which the tRNA's corresponding amino acid is attached (by aminoacyl-tRNA synthetases). Transfer RNAs cope with the degeneracy of the genetic code in two manners: having more than one tRNA (with a specific anti-codon) for a particular amino acid; and 'wobble' base-pairing, i.e. permitting non-standard base-pairing at the 3rd anti-codon position. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00005, ISBN:0198506732]"
          },
          "SO:0000254": {
            "name": "alanyl_tRNA",
            "def": "A tRNA sequence that has an alanine anticodon, and a 3' alanine binding region. [SO:ke]"
          },
          "SO:0000255": {
            "name": "rRNA_small_subunit_primary_transcript",
            "def": "A primary transcript encoding a small ribosomal subunit RNA. [SO:ke]"
          },
          "SO:0000256": {
            "name": "asparaginyl_tRNA",
            "def": "A tRNA sequence that has an asparagine anticodon, and a 3' asparagine binding region. [SO:ke]"
          },
          "SO:0000257": {
            "name": "aspartyl_tRNA",
            "def": "A tRNA sequence that has an aspartic acid anticodon, and a 3' aspartic acid binding region. [SO:ke]"
          },
          "SO:0000258": {
            "name": "cysteinyl_tRNA",
            "def": "A tRNA sequence that has a cysteine anticodon, and a 3' cysteine binding region. [SO:ke]"
          },
          "SO:0000259": {
            "name": "glutaminyl_tRNA",
            "def": "A tRNA sequence that has a glutamine anticodon, and a 3' glutamine binding region. [SO:ke]"
          },
          "SO:0000260": {
            "name": "glutamyl_tRNA",
            "def": "A tRNA sequence that has a glutamic acid anticodon, and a 3' glutamic acid binding region. [SO:ke]"
          },
          "SO:0000261": {
            "name": "glycyl_tRNA",
            "def": "A tRNA sequence that has a glycine anticodon, and a 3' glycine binding region. [SO:ke]"
          },
          "SO:0000262": {
            "name": "histidyl_tRNA",
            "def": "A tRNA sequence that has a histidine anticodon, and a 3' histidine binding region. [SO:ke]"
          },
          "SO:0000263": {
            "name": "isoleucyl_tRNA",
            "def": "A tRNA sequence that has an isoleucine anticodon, and a 3' isoleucine binding region. [SO:ke]"
          },
          "SO:0000264": {
            "name": "leucyl_tRNA",
            "def": "A tRNA sequence that has a leucine anticodon, and a 3' leucine binding region. [SO:ke]"
          },
          "SO:0000265": {
            "name": "lysyl_tRNA",
            "def": "A tRNA sequence that has a lysine anticodon, and a 3' lysine binding region. [SO:ke]"
          },
          "SO:0000266": {
            "name": "methionyl_tRNA",
            "def": "A tRNA sequence that has a methionine anticodon, and a 3' methionine binding region. [SO:ke]"
          },
          "SO:0000267": {
            "name": "phenylalanyl_tRNA",
            "def": "A tRNA sequence that has a phenylalanine anticodon, and a 3' phenylalanine binding region. [SO:ke]"
          },
          "SO:0000268": {
            "name": "prolyl_tRNA",
            "def": "A tRNA sequence that has a proline anticodon, and a 3' proline binding region. [SO:ke]"
          },
          "SO:0000269": {
            "name": "seryl_tRNA",
            "def": "A tRNA sequence that has a serine anticodon, and a 3' serine binding region. [SO:ke]"
          },
          "SO:0000270": {
            "name": "threonyl_tRNA",
            "def": "A tRNA sequence that has a threonine anticodon, and a 3' threonine binding region. [SO:ke]"
          },
          "SO:0000271": {
            "name": "tryptophanyl_tRNA",
            "def": "A tRNA sequence that has a tryptophan anticodon, and a 3' tryptophan binding region. [SO:ke]"
          },
          "SO:0000272": {
            "name": "tyrosyl_tRNA",
            "def": "A tRNA sequence that has a tyrosine anticodon, and a 3' tyrosine binding region. [SO:ke]"
          },
          "SO:0000273": {
            "name": "valyl_tRNA",
            "def": "A tRNA sequence that has a valine anticodon, and a 3' valine binding region. [SO:ke]"
          },
          "SO:0000274": {
            "name": "snRNA",
            "def": "A small nuclear RNA molecule involved in pre-mRNA splicing and processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, PMID:11733745, WB:ems]"
          },
          "SO:0000275": {
            "name": "snoRNA",
            "def": "A snoRNA (small nucleolar RNA) is any one of a class of small RNAs that are associated with the eukaryotic nucleus as components of small nucleolar ribonucleoproteins. They participate in the processing or modifications of many RNAs, mostly ribosomal RNAs (rRNAs) though snoRNAs are also known to target other classes of RNA, including spliceosomal RNAs, tRNAs, and mRNAs via a stretch of sequence that is complementary to a sequence in the targeted RNA. [GOC:kgc]"
          },
          "SO:0000276": {
            "name": "miRNA",
            "def": "Small, ~22-nt, RNA molecule that is the endogenous transcript of a miRNA gene (or the product of other non coding RNA genes. Micro RNAs are produced from precursor molecules (SO:0000647) that can form local hairpin structures, which ordinarily are processed (usually via the Dicer pathway) such that a single miRNA molecule accumulates from one arm of a hairpin precursor molecule. Micro RNAs may trigger the cleavage of their target molecules or act as translational repressors. [PMID:11081512, PMID:12592000]"
          },
          "SO:0000277": {
            "name": "bound_by_factor",
            "def": "An attribute describing a sequence that is bound by another molecule. [SO:ke]"
          },
          "SO:0000278": {
            "name": "transcript_bound_by_nucleic_acid",
            "def": "A transcript that is bound by a nucleic acid. [SO:xp]"
          },
          "SO:0000279": {
            "name": "transcript_bound_by_protein",
            "def": "A transcript that is bound by a protein. [SO:xp]"
          },
          "SO:0000280": {
            "name": "engineered_gene",
            "def": "A gene that is engineered. [SO:xp]"
          },
          "SO:0000281": {
            "name": "engineered_foreign_gene",
            "def": "A gene that is engineered and foreign. [SO:xp]"
          },
          "SO:0000282": {
            "name": "mRNA_with_minus_1_frameshift",
            "def": "An mRNA with a minus 1 frameshift. [SO:xp]"
          },
          "SO:0000283": {
            "name": "engineered_foreign_transposable_element_gene",
            "def": "A transposable_element that is engineered and foreign. [SO:xp]"
          },
          "SO:0000284": {
            "name": "type_I_enzyme_restriction_site",
            "def": "The recognition site is bipartite and interrupted. [http://www.promega.com]"
          },
          "SO:0000285": {
            "name": "foreign_gene",
            "def": "A gene that is foreign. [SO:xp]"
          },
          "SO:0000286": {
            "name": "long_terminal_repeat",
            "def": "A sequence directly repeated at both ends of a defined sequence, of the sort typically found in retroviruses. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000287": {
            "name": "fusion_gene",
            "def": "A gene that is a fusion. [SO:xp]"
          },
          "SO:0000288": {
            "name": "engineered_fusion_gene",
            "def": "A fusion gene that is engineered. [SO:xp]"
          },
          "SO:0000289": {
            "name": "microsatellite",
            "def": "A repeat_region containing repeat_units of 2 to 10 bp repeated in tandem. [http://www.informatics.jax.org/silver/glossary.shtml, NCBI:th]"
          },
          "SO:0000290": {
            "name": "dinucleotide_repeat_microsatellite_feature"
          },
          "SO:0000291": {
            "name": "trinucleotide_repeat_microsatellite_feature"
          },
          "SO:0000292": {
            "name": "repetitive_element"
          },
          "SO:0000293": {
            "name": "engineered_foreign_repetitive_element",
            "def": "A repetitive element that is engineered and foreign. [SO:xp]"
          },
          "SO:0000294": {
            "name": "inverted_repeat",
            "def": "The sequence is complementarily repeated on the opposite strand. It is a palindrome, and it may, or may not be hyphenated. Examples: GCTGATCAGC, or GCTGA-----TCAGC. [SO:ke]"
          },
          "SO:0000295": {
            "name": "U12_intron",
            "def": "A type of spliceosomal intron spliced by the U12 spliceosome, that includes U11, U12, U4atac/U6atac and U5 snRNAs. [PMID:9428511]"
          },
          "SO:0000296": {
            "name": "origin_of_replication",
            "def": "The origin of replication; starting site for duplication of a nucleic acid molecule to give two identical copies. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000297": {
            "name": "D_loop",
            "def": "Displacement loop; a region within mitochondrial DNA in which a short stretch of RNA is paired with one strand of DNA, displacing the original partner DNA strand in this region; also used to describe the displacement of a region of one strand of duplex DNA by a single stranded invader in the reaction catalyzed by RecA protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000298": {
            "name": "recombination_feature"
          },
          "SO:0000299": {
            "name": "specific_recombination_site"
          },
          "SO:0000300": {
            "name": "recombination_feature_of_rearranged_gene"
          },
          "SO:0000301": {
            "name": "vertebrate_immune_system_gene_recombination_feature"
          },
          "SO:0000302": {
            "name": "J_gene_recombination_feature",
            "def": "Recombination signal including J-heptamer, J-spacer and J-nonamer in 5' of J-region of a J-gene or J-sequence. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000303": {
            "name": "clip",
            "def": "Part of the primary transcript that is clipped off during processing. [SO:ke]"
          },
          "SO:0000304": {
            "name": "type_II_enzyme_restriction_site",
            "def": "The recognition site is either palindromic, partially palindromic or an interrupted palindrome. Cleavage occurs within the recognition site. [http://www.promega.com]"
          },
          "SO:0000305": {
            "name": "modified_DNA_base",
            "def": "A modified nucleotide, i.e. a nucleotide other than A, T, C. G. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000306": {
            "name": "methylated_DNA_base_feature",
            "def": "A nucleotide modified by methylation. [SO:ke]"
          },
          "SO:0000307": {
            "name": "CpG_island",
            "def": "Regions of a few hundred to a few thousand bases in vertebrate genomes that are relatively GC and CpG rich; they are typically unmethylated and often found near the 5' ends of genes. [SO:rd]"
          },
          "SO:0000308": {
            "name": "sequence_feature_locating_method"
          },
          "SO:0000309": {
            "name": "computed_feature"
          },
          "SO:0000310": {
            "name": "predicted_ab_initio_computation"
          },
          "SO:0000311": {
            "name": "computed_feature_by_similarity",
            "def": ". [SO:ma]"
          },
          "SO:0000312": {
            "name": "experimentally_determined",
            "def": "Attribute to describe a feature that has been experimentally verified. [SO:ke]"
          },
          "SO:0000313": {
            "name": "stem_loop",
            "def": "A double-helical region of nucleic acid formed by base-pairing between adjacent (inverted) complementary sequences. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000314": {
            "name": "direct_repeat",
            "def": "A repeat where the same sequence is repeated in the same direction. Example: GCTGA-followed by-GCTGA. [SO:ke]"
          },
          "SO:0000315": {
            "name": "TSS",
            "def": "The first base where RNA polymerase begins to synthesize the RNA transcript. [SO:ke]"
          },
          "SO:0000316": {
            "name": "CDS",
            "def": "A contiguous sequence which begins with, and includes, a start codon and ends with, and includes, a stop codon. [SO:ma]"
          },
          "SO:0000317": {
            "name": "cDNA_clone",
            "def": "Complementary DNA; A piece of DNA copied from an mRNA and spliced into a vector for propagation in a suitable host. [http://seqcore.brcf.med.umich.edu/doc/educ/dnapr/mbglossary/mbgloss.html]"
          },
          "SO:0000318": {
            "name": "start_codon",
            "def": "First codon to be translated by a ribosome. [SO:ke]"
          },
          "SO:0000319": {
            "name": "stop_codon",
            "def": "In mRNA, a set of three nucleotides that indicates the end of information for protein synthesis. [SO:ke]"
          },
          "SO:0000320": {
            "name": "intronic_splice_enhancer",
            "def": "Sequences within the intron that modulate splice site selection for some introns. [SO:ke]"
          },
          "SO:0000321": {
            "name": "mRNA_with_plus_1_frameshift",
            "def": "An mRNA with a plus 1 frameshift. [SO:ke]"
          },
          "SO:0000322": {
            "name": "nuclease_hypersensitive_site"
          },
          "SO:0000323": {
            "name": "coding_start",
            "def": "The first base to be translated into protein. [SO:ke]"
          },
          "SO:0000324": {
            "name": "tag",
            "def": "A nucleotide sequence that may be used to identify a larger sequence. [SO:ke]"
          },
          "SO:0000325": {
            "name": "rRNA_large_subunit_primary_transcript",
            "def": "A primary transcript encoding a large ribosomal subunit RNA. [SO:ke]"
          },
          "SO:0000326": {
            "name": "SAGE_tag",
            "def": "A short diagnostic sequence tag, serial analysis of gene expression (SAGE), that allows the quantitative and simultaneous analysis of a large number of transcripts. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=7570003&dopt=Abstract]"
          },
          "SO:0000327": {
            "name": "coding_end",
            "def": "The last base to be translated into protein. It does not include the stop codon. [SO:ke]"
          },
          "SO:0000328": {
            "name": "microarray_oligo"
          },
          "SO:0000329": {
            "name": "mRNA_with_plus_2_frameshift",
            "def": "An mRNA with a plus 2 frameshift. [SO:xp]"
          },
          "SO:0000330": {
            "name": "conserved_region",
            "def": "Region of sequence similarity by descent from a common ancestor. [SO:ke]"
          },
          "SO:0000331": {
            "name": "STS",
            "def": "Short (typically a few hundred base pairs) DNA sequence that has a single occurrence in a genome and whose location and base sequence are known. [http://www.biospace.com]"
          },
          "SO:0000332": {
            "name": "coding_conserved_region",
            "def": "Coding region of sequence similarity by descent from a common ancestor. [SO:ke]"
          },
          "SO:0000333": {
            "name": "exon_junction",
            "def": "The boundary between two exons in a processed transcript. [SO:ke]"
          },
          "SO:0000334": {
            "name": "nc_conserved_region",
            "def": "Non-coding region of sequence similarity by descent from a common ancestor. [SO:ke]"
          },
          "SO:0000335": {
            "name": "mRNA_with_minus_2_frameshift",
            "def": "A mRNA with a minus 2 frameshift. [SO:ke]"
          },
          "SO:0000336": {
            "name": "pseudogene",
            "def": "A sequence that closely resembles a known functional gene, at another locus within a genome, that is non-functional as a consequence of (usually several) mutations that prevent either its transcription or translation (or both). In general, pseudogenes result from either reverse transcription of a transcript of their \\normal\\ paralog (SO:0000043) (in which case the pseudogene typically lacks introns and includes a poly(A) tail) or from recombination (SO:0000044) (in which case the pseudogene is typically a tandem duplication of its \\normal\\ paralog). [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html]"
          },
          "SO:0000337": {
            "name": "RNAi_reagent",
            "def": "A double stranded RNA duplex, at least 20bp long, used experimentally to inhibit gene function by RNA interference. [SO:rd]"
          },
          "SO:0000338": {
            "name": "MITE",
            "def": "A highly repetitive and short (100-500 base pair) transposable element with terminal inverted repeats (TIR) and target site duplication (TSD). MITEs do not encode proteins. [http://www.pnas.org/cgi/content/full/97/18/10083]"
          },
          "SO:0000339": {
            "name": "recombination_hotspot",
            "def": "A region in a genome which promotes recombination. [SO:rd]"
          },
          "SO:0000340": {
            "name": "chromosome",
            "def": "Structural unit composed of a nucleic acid molecule which controls its own replication through the interaction of specific proteins at one or more origins of replication. [SO:ma]"
          },
          "SO:0000341": {
            "name": "chromosome_band",
            "def": "A cytologically distinguishable feature of a chromosome, often made visible by staining, and usually alternating light and dark. [SO:ma]"
          },
          "SO:0000342": {
            "name": "site_specific_recombination_target_region"
          },
          "SO:0000343": {
            "name": "match",
            "def": "A region of sequence, aligned to another sequence with some statistical significance, using an algorithm such as BLAST or SIM4. [SO:ke]"
          },
          "SO:0000344": {
            "name": "splice_enhancer",
            "def": "Region of a transcript that regulates splicing. [SO:ke]"
          },
          "SO:0000345": {
            "name": "EST",
            "def": "A tag produced from a single sequencing read from a cDNA clone or PCR product; typically a few hundred base pairs long. [SO:ke]"
          },
          "SO:0000346": {
            "name": "loxP_site"
          },
          "SO:0000347": {
            "name": "nucleotide_match",
            "def": "A match against a nucleotide sequence. [SO:ke]"
          },
          "SO:0000348": {
            "name": "nucleic_acid",
            "def": "An attribute describing a sequence consisting of nucleobases bound to repeating units. The forms found in nature are deoxyribonucleic acid (DNA), where the repeating units are 2-deoxy-D-ribose rings connected to a phosphate backbone, and ribonucleic acid (RNA), where the repeating units are D-ribose rings connected to a phosphate backbone. [CHEBI:33696, RSC:cb]"
          },
          "SO:0000349": {
            "name": "protein_match",
            "def": "A match against a protein sequence. [SO:ke]"
          },
          "SO:0000350": {
            "name": "FRT_site",
            "def": "An inversion site found on the Saccharomyces cerevisiae 2 micron plasmid. [SO:ma]"
          },
          "SO:0000351": {
            "name": "synthetic_sequence",
            "def": "An attribute to decide a sequence of nucleotides, nucleotide analogs, or amino acids that has been designed by an experimenter and which may, or may not, correspond with any natural sequence. [SO:ma]"
          },
          "SO:0000352": {
            "name": "DNA",
            "def": "An attribute describing a sequence consisting of nucleobases bound to a repeating unit made of a 2-deoxy-D-ribose ring connected to a phosphate backbone. [RSC:cb]"
          },
          "SO:0000353": {
            "name": "sequence_assembly",
            "def": "A sequence of nucleotides that has been algorithmically derived from an alignment of two or more different sequences. [SO:ma]"
          },
          "SO:0000354": {
            "name": "group_1_intron_homing_endonuclease_target_region",
            "def": "A region of intronic nucleotide sequence targeted by a nuclease enzyme. [SO:ke]"
          },
          "SO:0000355": {
            "name": "haplotype_block",
            "def": "A region of the genome which is co-inherited as the result of the lack of historic recombination within it. [SO:ma]"
          },
          "SO:0000356": {
            "name": "RNA",
            "def": "An attribute describing a sequence consisting of nucleobases bound to a repeating unit made of a D-ribose ring connected to a phosphate backbone. [RSC:cb]"
          },
          "SO:0000357": {
            "name": "flanked",
            "def": "An attribute describing a region that is bounded either side by a particular kind of region. [SO:ke]"
          },
          "SO:0000359": {
            "name": "floxed",
            "def": "An attribute describing sequence that is flanked by Lox-P sites. [SO:ke]"
          },
          "SO:0000360": {
            "name": "codon",
            "def": "A set of (usually) three nucleotide bases in a DNA or RNA sequence, which together code for a unique amino acid or the termination of translation and are contained within the CDS. [http://www.everythingbio.com/glos/definition.php?word=codon, SO:ke]"
          },
          "SO:0000361": {
            "name": "FRT_flanked",
            "def": "An attribute to describe sequence that is flanked by the FLP recombinase recognition site, FRT. [SO:ke]"
          },
          "SO:0000362": {
            "name": "invalidated_by_chimeric_cDNA",
            "def": "A cDNA clone constructed from more than one mRNA. Usually an experimental artifact. [SO:ma]"
          },
          "SO:0000363": {
            "name": "floxed_gene",
            "def": "A transgene that is floxed. [SO:xp]"
          },
          "SO:0000364": {
            "name": "transposable_element_flanking_region",
            "def": "The region of sequence surrounding a transposable element. [SO:ke]"
          },
          "SO:0000365": {
            "name": "integron",
            "def": "A region encoding an integrase which acts at a site adjacent to it (attI_site) to insert DNA which must include but is not limited to an attC_site. [SO:as]"
          },
          "SO:0000366": {
            "name": "insertion_site",
            "def": "The junction where an insertion occurred. [SO:ke]"
          },
          "SO:0000367": {
            "name": "attI_site",
            "def": "A region within an integron, adjacent to an integrase, at which site specific recombination involving an attC_site takes place. [SO:as]"
          },
          "SO:0000368": {
            "name": "transposable_element_insertion_site",
            "def": "The junction in a genome where a transposable_element has inserted. [SO:ke]"
          },
          "SO:0000369": {
            "name": "integrase_coding_region"
          },
          "SO:0000370": {
            "name": "small_regulatory_ncRNA",
            "def": "A non-coding RNA, usually with a specific secondary structure, that acts to regulate gene expression. [SO:ma]"
          },
          "SO:0000371": {
            "name": "conjugative_transposon",
            "def": "A transposon that encodes function required for conjugation. [http://www.sci.sdsu.edu/~smaloy/Glossary/C.html]"
          },
          "SO:0000372": {
            "name": "enzymatic_RNA",
            "def": "An RNA sequence that has catalytic activity with or without an associated ribonucleoprotein. [RSC:cb]"
          },
          "SO:0000373": {
            "name": "recombinationally_inverted_gene",
            "def": "A recombinationally rearranged gene by inversion. [SO:xp]"
          },
          "SO:0000374": {
            "name": "ribozyme",
            "def": "An RNA with catalytic activity. [SO:ma]"
          },
          "SO:0000375": {
            "name": "rRNA_5_8S",
            "def": "5_8S ribosomal RNA (5. 8S rRNA) is a component of the large subunit of the eukaryotic ribosome. It is transcribed by RNA polymerase I as part of the 45S precursor that also contains 18S and 28S rRNA. Functionally, it is thought that 5.8S rRNA may be involved in ribosome translocation. It is also known to form covalent linkage to the p53 tumour suppressor protein. 5_8S rRNA is also found in archaea. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00002]"
          },
          "SO:0000376": {
            "name": "RNA_6S",
            "def": "A small (184-nt in E. coli) RNA that forms a hairpin type structure. 6S RNA associates with RNA polymerase in a highly specific manner. 6S RNA represses expression from a sigma70-dependent promoter during stationary phase. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00013]"
          },
          "SO:0000377": {
            "name": "CsrB_RsmB_RNA",
            "def": "An enterobacterial RNA that binds the CsrA protein. The CsrB RNAs contain a conserved motif CAGGXXG that is found in up to 18 copies and has been suggested to bind CsrA. The Csr regulatory system has a strong negative regulatory effect on glycogen biosynthesis, glyconeogenesis and glycogen catabolism and a positive regulatory effect on glycolysis. In other bacteria such as Erwinia caratovara the RsmA protein has been shown to regulate the production of virulence determinants, such extracellular enzymes. RsmA binds to RsmB regulatory RNA which is also a member of this family. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00018]"
          },
          "SO:0000378": {
            "name": "DsrA_RNA",
            "def": "DsrA RNA regulates both transcription, by overcoming transcriptional silencing by the nucleoid-associated H-NS protein, and translation, by promoting efficient translation of the stress sigma factor, RpoS. These two activities of DsrA can be separated by mutation: the first of three stem-loops of the 85 nucleotide RNA is necessary for RpoS translation but not for anti-H-NS action, while the second stem-loop is essential for antisilencing and less critical for RpoS translation. The third stem-loop, which behaves as a transcription terminator, can be substituted by the trp transcription terminator without loss of either DsrA function. The sequence of the first stem-loop of DsrA is complementary with the upstream leader portion of RpoS messenger RNA, suggesting that pairing of DsrA with the RpoS message might be important for translational regulation. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00014]"
          },
          "SO:0000379": {
            "name": "GcvB_RNA",
            "def": "A small untranslated RNA involved in expression of the dipeptide and oligopeptide transport systems in Escherichia coli. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00022]"
          },
          "SO:0000380": {
            "name": "hammerhead_ribozyme",
            "def": "A small catalytic RNA motif that catalyzes self-cleavage reaction. Its name comes from its secondary structure which resembles a carpenter's hammer. The hammerhead ribozyme is involved in the replication of some viroid and some satellite RNAs. [PMID:2436805]"
          },
          "SO:0000381": {
            "name": "group_IIA_intron"
          },
          "SO:0000382": {
            "name": "group_IIB_intron"
          },
          "SO:0000383": {
            "name": "MicF_RNA",
            "def": "A non-translated 93 nt antisense RNA that binds its target ompF mRNA and regulates ompF expression by inhibiting translation and inducing degradation of the message. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00033]"
          },
          "SO:0000384": {
            "name": "OxyS_RNA",
            "def": "A small untranslated RNA which is induced in response to oxidative stress in Escherichia coli. Acts as a global regulator to activate or repress the expression of as many as 40 genes, including the fhlA-encoded transcriptional activator and the rpoS-encoded sigma(s) subunit of RNA polymerase. OxyS is bound by the Hfq protein, that increases the OxyS RNA interaction with its target messages. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00035]"
          },
          "SO:0000385": {
            "name": "RNase_MRP_RNA",
            "def": "The RNA molecule essential for the catalytic activity of RNase MRP, an enzymatically active ribonucleoprotein with two distinct roles in eukaryotes. In mitochondria it plays a direct role in the initiation of mitochondrial DNA replication. In the nucleus it is involved in precursor rRNA processing, where it cleaves the internal transcribed spacer 1 between 18S and 5.8S rRNAs. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00030]"
          },
          "SO:0000386": {
            "name": "RNase_P_RNA",
            "def": "The RNA component of Ribonuclease P (RNase P), a ubiquitous endoribonuclease, found in archaea, bacteria and eukarya as well as chloroplasts and mitochondria. Its best characterized activity is the generation of mature 5 prime ends of tRNAs by cleaving the 5 prime leader elements of precursor-tRNAs. Cellular RNase Ps are ribonucleoproteins. RNA from bacterial RNase Ps retains its catalytic activity in the absence of the protein subunit, i.e. it is a ribozyme. Isolated eukaryotic and archaeal RNase P RNA has not been shown to retain its catalytic function, but is still essential for the catalytic activity of the holoenzyme. Although the archaeal and eukaryotic holoenzymes have a much greater protein content than the bacterial ones, the RNA cores from all the three lineages are homologous. Helices corresponding to P1, P2, P3, P4, and P10/11 are common to all cellular RNase P RNAs. Yet, there is considerable sequence variation, particularly among the eukaryotic RNAs. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00010]"
          },
          "SO:0000387": {
            "name": "RprA_RNA",
            "def": "Translational regulation of the stationary phase sigma factor RpoS is mediated by the formation of a double-stranded RNA stem-loop structure in the upstream region of the rpoS messenger RNA, occluding the translation initiation site. Clones carrying rprA (RpoS regulator RNA) increased the translation of RpoS. The rprA gene encodes a 106 nucleotide regulatory RNA. As with DsrA Rfam:RF00014, RprA is predicted to form three stem-loops. Thus, at least two small RNAs, DsrA and RprA, participate in the positive regulation of RpoS translation. Unlike DsrA, RprA does not have an extensive region of complementarity to the RpoS leader, leaving its mechanism of action unclear. RprA is non-essential. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00034]"
          },
          "SO:0000388": {
            "name": "RRE_RNA",
            "def": "The Rev response element (RRE) is encoded within the HIV-env gene. Rev is an essential regulatory protein of HIV that binds an internal loop of the RRE leading, encouraging further Rev-RRE binding. This RNP complex is critical for mRNA export and hence for expression of the HIV structural proteins. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00036]"
          },
          "SO:0000389": {
            "name": "spot_42_RNA",
            "def": "A 109-nucleotide RNA of E. coli that seems to have a regulatory role on the galactose operon. Changes in Spot 42 levels are implicated in affecting DNA polymerase I levels. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00021]"
          },
          "SO:0000390": {
            "name": "telomerase_RNA",
            "def": "The RNA component of telomerase, a reverse transcriptase that synthesizes telomeric DNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00025]"
          },
          "SO:0000391": {
            "name": "U1_snRNA",
            "def": "U1 is a small nuclear RNA (snRNA) component of the spliceosome (involved in pre-mRNA splicing). Its 5' end forms complementary base pairs with the 5' splice junction, thus defining the 5' donor site of an intron. There are significant differences in sequence and secondary structure between metazoan and yeast U1 snRNAs, the latter being much longer (568 nucleotides as compared to 164 nucleotides in human). Nevertheless, secondary structure predictions suggest that all U1 snRNAs share a 'common core' consisting of helices I, II, the proximal region of III, and IV. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00003]"
          },
          "SO:0000392": {
            "name": "U2_snRNA",
            "def": "U2 is a small nuclear RNA (snRNA) component of the spliceosome (involved in pre-mRNA splicing). Complementary binding between U2 snRNA (in an area lying towards the 5' end but 3' to hairpin I) and the branchpoint sequence (BPS) of the intron results in the bulging out of an unpaired adenine, on the BPS, which initiates a nucleophilic attack at the intronic 5' splice site, thus starting the first of two transesterification reactions that mediate splicing. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00004]"
          },
          "SO:0000393": {
            "name": "U4_snRNA",
            "def": "U4 small nuclear RNA (U4 snRNA) is a component of the major U2-dependent spliceosome. It forms a duplex with U6, and with each splicing round, it is displaced from U6 (and the spliceosome) in an ATP-dependent manner, allowing U6 to refold and create the active site for splicing catalysis. A recycling process involving protein Prp24 re-anneals U4 and U6. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00015]"
          },
          "SO:0000394": {
            "name": "U4atac_snRNA",
            "def": "An snRNA required for the splicing of the minor U12-dependent class of eukaryotic nuclear introns. It forms a base paired complex with U6atac_snRNA (SO:0000397). [PMID:=12409455]"
          },
          "SO:0000395": {
            "name": "U5_snRNA",
            "def": "U5 RNA is a component of both types of known spliceosome. The precise function of this molecule is unknown, though it is known that the 5' loop is required for splice site selection and p220 binding, and that both the 3' stem-loop and the Sm site are important for Sm protein binding and cap methylation. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00020]"
          },
          "SO:0000396": {
            "name": "U6_snRNA",
            "def": "U6 snRNA is a component of the spliceosome which is involved in splicing pre-mRNA. The putative secondary structure consensus base pairing is confined to a short 5' stem loop, but U6 snRNA is thought to form extensive base-pair interactions with U4 snRNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00015]"
          },
          "SO:0000397": {
            "name": "U6atac_snRNA",
            "def": "U6atac_snRNA is an snRNA required for the splicing of the minor U12-dependent class of eukaryotic nuclear introns. It forms a base paired complex with U4atac_snRNA (SO:0000394). [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=retrieve&db=pubmed&list_uids=12409455&dopt=Abstract]"
          },
          "SO:0000398": {
            "name": "U11_snRNA",
            "def": "U11 snRNA plays a role in splicing of the minor U12-dependent class of eukaryotic nuclear introns, similar to U1 snRNA in the major class spliceosome it base pairs to the conserved 5' splice site sequence. [PMID:9622129]"
          },
          "SO:0000399": {
            "name": "U12_snRNA",
            "def": "The U12 small nuclear (snRNA), together with U4atac/U6atac, U5, and U11 snRNAs and associated proteins, forms a spliceosome that cleaves a divergent class of low-abundance pre-mRNA introns. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00007]"
          },
          "SO:0000400": {
            "name": "sequence_attribute",
            "def": "An attribute describes a quality of sequence. [SO:ke]"
          },
          "SO:0000401": {
            "name": "gene_attribute"
          },
          "SO:0000402": {
            "name": "enhancer_attribute"
          },
          "SO:0000403": {
            "name": "U14_snoRNA",
            "def": "U14 small nucleolar RNA (U14 snoRNA) is required for early cleavages of eukaryotic precursor rRNAs. In yeasts, this molecule possess a stem-loop region (known as the Y-domain) which is essential for function. A similar structure, but with a different consensus sequence, is found in plants, but is absent in vertebrates. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00016, PMID:2551119]"
          },
          "SO:0000404": {
            "name": "vault_RNA",
            "def": "A family of RNAs are found as part of the enigmatic vault ribonucleoprotein complex. The complex consists of a major vault protein (MVP), two minor vault proteins (VPARP and TEP1), and several small untranslated RNA molecules. It has been suggested that the vault complex is involved in drug resistance. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00006]"
          },
          "SO:0000405": {
            "name": "Y_RNA",
            "def": "Y RNAs are components of the Ro ribonucleoprotein particle (Ro RNP), in association with Ro60 and La proteins. The Y RNAs and Ro60 and La proteins are well conserved, but the function of the Ro RNP is not known. In humans the RNA component can be one of four small RNAs: hY1, hY3, hY4 and hY5. These small RNAs are predicted to fold into a conserved secondary structure containing three stem structures. The largest of the four, hY1, contains an additional hairpin. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00019]"
          },
          "SO:0000406": {
            "name": "twintron",
            "def": "An intron within an intron. Twintrons are group II or III introns, into which another group II or III intron has been transposed. [PMID:1899376, PMID:7823908]"
          },
          "SO:0000407": {
            "name": "rRNA_18S",
            "def": "A large polynucleotide in eukaryotes, which functions as the small subunit of the ribosome. [SO:ke]"
          },
          "SO:0000408": {
            "name": "site",
            "def": "The interbase position where something (eg an aberration) occurred. [SO:ke]"
          },
          "SO:0000409": {
            "name": "binding_site",
            "def": "A biological_region of sequence that, in the molecule, interacts selectively and non-covalently with other molecules. A region on the surface of a molecule that may interact with another molecule. When applied to polypeptides: Amino acids involved in binding or interactions. It can also apply to an amino acid bond which is represented by the positions of the two flanking amino acids. [EBIBS:GAR, SO:ke]"
          },
          "SO:0000410": {
            "name": "protein_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with polypeptide molecules. [SO:ke]"
          },
          "SO:0000411": {
            "name": "rescue_region",
            "def": "A region that rescues. [SO:xp]"
          },
          "SO:0000412": {
            "name": "restriction_fragment",
            "def": "A region of polynucleotide sequence produced by digestion with a restriction endonuclease. [SO:ke]"
          },
          "SO:0000413": {
            "name": "sequence_difference",
            "def": "A region where the sequence differs from that of a specified sequence. [SO:ke]"
          },
          "SO:0000414": {
            "name": "invalidated_by_genomic_contamination",
            "def": "An attribute to describe a feature that is invalidated due to genomic contamination. [SO:ke]"
          },
          "SO:0000415": {
            "name": "invalidated_by_genomic_polyA_primed_cDNA",
            "def": "An attribute to describe a feature that is invalidated due to polyA priming. [SO:ke]"
          },
          "SO:0000416": {
            "name": "invalidated_by_partial_processing",
            "def": "An attribute to describe a feature that is invalidated due to partial processing. [SO:ke]"
          },
          "SO:0000417": {
            "name": "polypeptide_domain",
            "def": "A structurally or functionally defined protein region. In proteins with multiple domains, the combination of the domains determines the function of the protein. A region which has been shown to recur throughout evolution. [EBIBS:GAR]"
          },
          "SO:0000418": {
            "name": "signal_peptide",
            "def": "The signal_peptide is a short region of the peptide located at the N-terminus that directs the protein to be secreted or part of membrane components. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000419": {
            "name": "mature_protein_region",
            "def": "The polypeptide sequence that remains when the cleaved peptide regions have been cleaved from the immature peptide. [EBIBS:GAR, http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, SO:cb]"
          },
          "SO:0000420": {
            "name": "five_prime_terminal_inverted_repeat"
          },
          "SO:0000421": {
            "name": "three_prime_terminal_inverted_repeat"
          },
          "SO:0000422": {
            "name": "U5_LTR_region"
          },
          "SO:0000423": {
            "name": "R_LTR_region"
          },
          "SO:0000424": {
            "name": "U3_LTR_region"
          },
          "SO:0000425": {
            "name": "five_prime_LTR"
          },
          "SO:0000426": {
            "name": "three_prime_LTR"
          },
          "SO:0000427": {
            "name": "R_five_prime_LTR_region"
          },
          "SO:0000428": {
            "name": "U5_five_prime_LTR_region"
          },
          "SO:0000429": {
            "name": "U3_five_prime_LTR_region"
          },
          "SO:0000430": {
            "name": "R_three_prime_LTR_region"
          },
          "SO:0000431": {
            "name": "U3_three_prime_LTR_region"
          },
          "SO:0000432": {
            "name": "U5_three_prime_LTR_region"
          },
          "SO:0000433": {
            "name": "non_LTR_retrotransposon_polymeric_tract",
            "def": "A polymeric tract, such as poly(dA), within a non_LTR_retrotransposon. [SO:ke]"
          },
          "SO:0000434": {
            "name": "target_site_duplication",
            "def": "A sequence of the target DNA that is duplicated when a transposable element or phage inserts; usually found at each end the insertion. [http://www.koko.gov.my/CocoaBioTech/Glossaryt.html]"
          },
          "SO:0000435": {
            "name": "RR_tract",
            "def": "A polypurine tract within an LTR_retrotransposon. [SO:ke]"
          },
          "SO:0000436": {
            "name": "ARS",
            "def": "A sequence that can autonomously replicate, as a plasmid, when transformed into a bacterial host. [SO:ma]"
          },
          "SO:0000437": {
            "name": "assortment_derived_duplication"
          },
          "SO:0000438": {
            "name": "gene_not_polyadenylated"
          },
          "SO:0000439": {
            "name": "inverted_ring_chromosome"
          },
          "SO:0000440": {
            "name": "vector_replicon",
            "def": "A replicon that has been modified to act as a vector for foreign sequence. [SO:ma]"
          },
          "SO:0000441": {
            "name": "ss_oligo",
            "def": "A single stranded oligonucleotide. [SO:ke]"
          },
          "SO:0000442": {
            "name": "ds_oligo",
            "def": "A double stranded oligonucleotide. [SO:ke]"
          },
          "SO:0000443": {
            "name": "polymer_attribute",
            "def": "An attribute to describe the kind of biological sequence. [SO:ke]"
          },
          "SO:0000444": {
            "name": "three_prime_noncoding_exon",
            "def": "Non-coding exon in the 3' UTR. [SO:ke]"
          },
          "SO:0000445": {
            "name": "five_prime_noncoding_exon",
            "def": "Non-coding exon in the 5' UTR. [SO:ke]"
          },
          "SO:0000446": {
            "name": "UTR_intron",
            "def": "Intron located in the untranslated region. [SO:ke]"
          },
          "SO:0000447": {
            "name": "five_prime_UTR_intron",
            "def": "An intron located in the 5' UTR. [SO:ke]"
          },
          "SO:0000448": {
            "name": "three_prime_UTR_intron",
            "def": "An intron located in the 3' UTR. [SO:ke]"
          },
          "SO:0000449": {
            "name": "random_sequence",
            "def": "A sequence of nucleotides or amino acids which, by design, has a \\random\\ order of components, given a predetermined input frequency of these components. [SO:ma]"
          },
          "SO:0000450": {
            "name": "interband",
            "def": "A light region between two darkly staining bands in a polytene chromosome. [SO:ma]"
          },
          "SO:0000451": {
            "name": "gene_with_polyadenylated_mRNA",
            "def": "A gene that encodes a polyadenylated mRNA. [SO:xp]"
          },
          "SO:0000452": {
            "name": "transgene_attribute"
          },
          "SO:0000453": {
            "name": "chromosomal_transposition",
            "def": "A chromosome structure variant whereby a region of a chromosome has been transferred to another position. Among interchromosomal rearrangements, the term transposition is reserved for that class in which the telomeres of the chromosomes involved are coupled (that is to say, form the two ends of a single DNA molecule) as in wild-type. [FB:reference_manual, SO:ke]"
          },
          "SO:0000454": {
            "name": "rasiRNA",
            "def": "A 17-28-nt, small interfering RNA derived from transcripts of repetitive elements. [http://www.developmentalcell.com/content/article/abstract?uid=PIIS1534580703002284]"
          },
          "SO:0000455": {
            "name": "gene_with_mRNA_with_frameshift",
            "def": "A gene that encodes an mRNA with a frameshift. [SO:xp]"
          },
          "SO:0000456": {
            "name": "recombinationally_rearranged_gene",
            "def": "A gene that is recombinationally rearranged. [SO:ke]"
          },
          "SO:0000457": {
            "name": "interchromosomal_duplication",
            "def": "A chromosome duplication involving an insertion from another chromosome. [SO:ke]"
          },
          "SO:0000458": {
            "name": "D_gene_segment",
            "def": "Germline genomic DNA including D-region with 5' UTR and 3' UTR, also designated as D-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000459": {
            "name": "gene_with_trans_spliced_transcript",
            "def": "A gene with a transcript that is trans-spliced. [SO:xp]"
          },
          "SO:0000460": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_segment"
          },
          "SO:0000461": {
            "name": "inversion_derived_bipartite_deficiency",
            "def": "A chromosomal deletion whereby a chromosome generated by recombination between two inversions; has a deficiency at each end of the inversion. [FB:km]"
          },
          "SO:0000462": {
            "name": "pseudogenic_region",
            "def": "A non-functional descendant of a functional entity. [SO:cjm]"
          },
          "SO:0000463": {
            "name": "encodes_alternately_spliced_transcripts",
            "def": "A gene that encodes more than one transcript. [SO:ke]"
          },
          "SO:0000464": {
            "name": "decayed_exon",
            "def": "A non-functional descendant of an exon. [SO:ke]"
          },
          "SO:0000465": {
            "name": "inversion_derived_deficiency_plus_duplication",
            "def": "A chromosome deletion whereby a chromosome is generated by recombination between two inversions; there is a deficiency at one end of the inversion and a duplication at the other end of the inversion. [FB:km]"
          },
          "SO:0000466": {
            "name": "V_gene_segment",
            "def": "Germline genomic DNA including L-part1, V-intron and V-exon, with the 5' UTR and 3' UTR. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000467": {
            "name": "post_translationally_regulated_by_protein_stability",
            "def": "An attribute describing a gene sequence where the resulting protein is regulated by the stability of the resulting protein. [SO:ke]"
          },
          "SO:0000468": {
            "name": "golden_path_fragment",
            "def": "One of the pieces of sequence that make up a golden path. [SO:rd]"
          },
          "SO:0000469": {
            "name": "post_translationally_regulated_by_protein_modification",
            "def": "An attribute describing a gene sequence where the resulting protein is modified to regulate it. [SO:ke]"
          },
          "SO:0000470": {
            "name": "J_gene_segment",
            "def": "Germline genomic DNA of an immunoglobulin/T-cell receptor gene including J-region with 5' UTR (SO:0000204) and 3' UTR (SO:0000205), also designated as J-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000471": {
            "name": "autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation. [SO:ke]"
          },
          "SO:0000472": {
            "name": "tiling_path",
            "def": "A set of regions which overlap with minimal polymorphism to form a linear sequence. [SO:cjm]"
          },
          "SO:0000473": {
            "name": "negatively_autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation where it decreases transcription. [SO:ke]"
          },
          "SO:0000474": {
            "name": "tiling_path_fragment",
            "def": "A piece of sequence that makes up a tiling_path (SO:0000472). [SO:ke]"
          },
          "SO:0000475": {
            "name": "positively_autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation, where it increases transcription. [SO:ke]"
          },
          "SO:0000476": {
            "name": "contig_read",
            "def": "A DNA sequencer read which is part of a contig. [SO:ke]"
          },
          "SO:0000477": {
            "name": "polycistronic_gene",
            "def": "A gene that is polycistronic. [SO:ke]"
          },
          "SO:0000478": {
            "name": "C_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene including C-region (and introns if present) with 5' UTR (SO:0000204) and 3' UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000479": {
            "name": "trans_spliced_transcript",
            "def": "A transcript that is trans-spliced. [SO:xp]"
          },
          "SO:0000480": {
            "name": "tiling_path_clone",
            "def": "A clone which is part of a tiling path. A tiling path is a set of sequencing substrates, typically clones, which have been selected in order to efficiently cover a region of the genome in preparation for sequencing and assembly. [SO:ke]"
          },
          "SO:0000481": {
            "name": "terminal_inverted_repeat",
            "def": "An inverted repeat (SO:0000294) occurring at the termini of a DNA transposon. [SO:ke]"
          },
          "SO:0000482": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_gene_cluster"
          },
          "SO:0000483": {
            "name": "nc_primary_transcript",
            "def": "A primary transcript that is never translated into a protein. [SO:ke]"
          },
          "SO:0000484": {
            "name": "three_prime_coding_exon_noncoding_region",
            "def": "The sequence of the 3' exon that is not coding. [SO:ke]"
          },
          "SO:0000485": {
            "name": "DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one DJ-gene, and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000486": {
            "name": "five_prime_coding_exon_noncoding_region",
            "def": "The sequence of the 5' exon preceding the start codon. [SO:ke]"
          },
          "SO:0000487": {
            "name": "VDJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000488": {
            "name": "VDJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000489": {
            "name": "VJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000490": {
            "name": "VJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000491": {
            "name": "VJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000492": {
            "name": "D_gene_recombination_feature"
          },
          "SO:0000493": {
            "name": "three_prime_D_heptamer",
            "def": "7 nucleotide recombination site like CACAGTG, part of a 3' D-recombination signal sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000494": {
            "name": "three_prime_D_nonamer",
            "def": "A 9 nucleotide recombination site (e.g. ACAAAAACC), part of a 3' D-recombination signal sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000495": {
            "name": "three_prime_D_spacer",
            "def": "A 12 or 23 nucleotide spacer between the 3'D-HEPTAMER and 3'D-NONAMER of a 3'D-RS. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000496": {
            "name": "five_prime_D_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACTGTG), part of a 5' D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000497": {
            "name": "five_prime_D_nonamer",
            "def": "9 nucleotide recombination site (e.g. GGTTTTTGT), part of a five_prime_D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000498": {
            "name": "five_prime_D_spacer",
            "def": "12 or 23 nucleotide spacer between the 5' D-heptamer (SO:0000496) and 5' D-nonamer (SO:0000497) of a 5' D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000499": {
            "name": "virtual_sequence",
            "def": "A continuous piece of sequence similar to the 'virtual contig' concept of the Ensembl database. [SO:ke]"
          },
          "SO:0000500": {
            "name": "Hoogsteen_base_pair",
            "def": "A type of non-canonical base-pairing. This is less energetically favourable than watson crick base pairing. Hoogsteen GC base pairs only have two hydrogen bonds. [PMID:12177293]"
          },
          "SO:0000501": {
            "name": "reverse_Hoogsteen_base_pair",
            "def": "A type of non-canonical base-pairing. [SO:ke]"
          },
          "SO:0000502": {
            "name": "transcribed_region",
            "def": "A region of sequence that is transcribed. This region may cover the transcript of a gene, it may emcompas the sequence covered by all of the transcripts of a alternately spliced gene, or it may cover the region transcribed by a polycistronic transcript. A gene may have 1 or more transcribed regions and a transcribed_region may belong to one or more genes. [SO:ke]"
          },
          "SO:0000503": {
            "name": "alternately_spliced_gene_encodeing_one_transcript"
          },
          "SO:0000504": {
            "name": "D_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000505": {
            "name": "D_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene and one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000506": {
            "name": "D_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000507": {
            "name": "pseudogenic_exon",
            "def": "A non functional descendant of an exon, part of a pseudogene. [SO:ke]"
          },
          "SO:0000508": {
            "name": "D_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene, and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000509": {
            "name": "D_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one D-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000510": {
            "name": "VD_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in partially rearranged genomic DNA including L-part1, V-intron and V-D-exon, with the 5' UTR (SO:0000204) and 3' UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000511": {
            "name": "J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000512": {
            "name": "inversion_derived_deficiency_plus_aneuploid",
            "def": "A chromosomal deletion whereby a chromosome generated by recombination between two inversions; has a deficiency at one end and presumed to have a deficiency or duplication at the other end of the inversion. [FB:km]"
          },
          "SO:0000513": {
            "name": "J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000514": {
            "name": "J_nonamer",
            "def": "9 nucleotide recombination site (e.g. GGTTTTTGT), part of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000515": {
            "name": "J_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACAGTG), part of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000516": {
            "name": "pseudogenic_transcript",
            "def": "A non functional descendant of a transcript, part of a pseudogene. [SO:ke]"
          },
          "SO:0000517": {
            "name": "J_spacer",
            "def": "12 or 23 nucleotide spacer between the J-nonamer and the J-heptamer of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000518": {
            "name": "V_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000519": {
            "name": "V_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000520": {
            "name": "V_VDJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000521": {
            "name": "V_VDJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one VDJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000522": {
            "name": "V_VDJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000523": {
            "name": "V_VJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000524": {
            "name": "V_VJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one VJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000525": {
            "name": "V_VJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000526": {
            "name": "V_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one V-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000527": {
            "name": "V_D_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000528": {
            "name": "V_D_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000529": {
            "name": "V_D_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000530": {
            "name": "V_D_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000531": {
            "name": "V_D_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one D-gene and one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000532": {
            "name": "V_D_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one D-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000533": {
            "name": "V_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACAGTG), part of V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000534": {
            "name": "V_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000535": {
            "name": "V_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000536": {
            "name": "V_nonamer",
            "def": "9 nucleotide recombination site (e.g. ACAAAAACC), part of V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000537": {
            "name": "V_spacer",
            "def": "12 or 23 nucleotide spacer between the V-heptamer and the V-nonamer of a V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000538": {
            "name": "V_gene_recombination_feature",
            "def": "Recombination signal including V-heptamer, V-spacer and V-nonamer in 3' of V-region of a V-gene or V-sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000539": {
            "name": "DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000540": {
            "name": "DJ_J_C_cluster",
            "def": "Genomic DNA in rearranged configuration including at least one D-J-GENE, one J-GENE and one C-GENE. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000541": {
            "name": "VDJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000542": {
            "name": "V_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000543": {
            "name": "alternately_spliced_gene_encoding_greater_than_one_transcript"
          },
          "SO:0000544": {
            "name": "helitron",
            "def": "A rolling circle transposon. Autonomous helitrons encode a 5'-to-3' DNA helicase and nuclease/ligase similar to those encoded by known rolling-circle replicons. [http://www.pnas.org/cgi/content/full/100/11/6569]"
          },
          "SO:0000545": {
            "name": "recoding_pseudoknot",
            "def": "The pseudoknots involved in recoding are unique in that, as they play their role as a structure, they are immediately unfolded and their now linear sequence serves as a template for decoding. [http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=33937]"
          },
          "SO:0000546": {
            "name": "designed_sequence"
          },
          "SO:0000547": {
            "name": "inversion_derived_bipartite_duplication",
            "def": "A chromosome generated by recombination between two inversions; there is a duplication at each end of the inversion. [FB:km]"
          },
          "SO:0000548": {
            "name": "gene_with_edited_transcript",
            "def": "A gene that encodes a transcript that is edited. [SO:xp]"
          },
          "SO:0000549": {
            "name": "inversion_derived_duplication_plus_aneuploid",
            "def": "A chromosome generated by recombination between two inversions; has a duplication at one end and presumed to have a deficiency or duplication at the other end of the inversion. [FB:km]"
          },
          "SO:0000550": {
            "name": "aneuploid_chromosome",
            "def": "A chromosome structural variation whereby either a chromosome exists in addition to the normal chromosome complement or is lacking. [SO:ke]"
          },
          "SO:0000551": {
            "name": "polyA_signal_sequence",
            "def": "The recognition sequence necessary for endonuclease cleavage of an RNA transcript that is followed by polyadenylation; consensus=AATAAA. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000552": {
            "name": "Shine_Dalgarno_sequence",
            "def": "A region in the 5' UTR that pairs with the 16S rRNA during formation of the preinitiation complex. [SO:jh]"
          },
          "SO:0000553": {
            "name": "polyA_site",
            "def": "The site on an RNA transcript to which will be added adenine residues by post-transcriptional polyadenylation. The boundary between the UTR and the polyA sequence. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000554": {
            "name": "assortment_derived_deficiency_plus_duplication"
          },
          "SO:0000555": {
            "name": "five_prime_clip",
            "def": "5' most region of a precursor transcript that is clipped off during processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000556": {
            "name": "five_prime_D_recombination_signal_sequence",
            "def": "Recombination signal of an immunoglobulin/T-cell receptor gene, including the 5' D-nonamer (SO:0000497), 5' D-spacer (SO:0000498), and 5' D-heptamer (SO:0000396) in 5' of the D-region of a D-gene, or in 5' of the D-region of DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000557": {
            "name": "three_prime_clip",
            "def": "3'-most region of a precursor transcript that is clipped off during processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000558": {
            "name": "C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene including more than one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000559": {
            "name": "D_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one D-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000560": {
            "name": "D_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one D-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000561": {
            "name": "heptamer_of_recombination_feature_of_vertebrate_immune_system_gene",
            "def": "Seven nucleotide recombination site (e.g. CACAGTG), part of V-gene, D-gene or J-gene recombination feature of an immunoglobulin or T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000562": {
            "name": "nonamer_of_recombination_feature_of_vertebrate_immune_system_gene"
          },
          "SO:0000563": {
            "name": "vertebrate_immune_system_gene_recombination_spacer"
          },
          "SO:0000564": {
            "name": "V_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000565": {
            "name": "V_VDJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000566": {
            "name": "V_VJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000567": {
            "name": "inversion_derived_aneuploid_chromosome",
            "def": "A chromosome may be generated by recombination between two inversions; presumed to have a deficiency or duplication at each end of the inversion. [FB:km]"
          },
          "SO:0000568": {
            "name": "bidirectional_promoter",
            "def": "An unregulated promoter that allows continuous expression. [SO:ke]"
          },
          "SO:0000569": {
            "name": "retrotransposed",
            "def": "An attribute of a feature that occurred as the product of a reverse transcriptase mediated event. [SO:ke]"
          },
          "SO:0000570": {
            "name": "three_prime_D_recombination_signal_sequence",
            "def": "Recombination signal of an immunoglobulin/T-cell receptor gene, including the 3' D-heptamer (SO:0000493), 3' D-spacer, and 3' D-nonamer (SO:0000494) in 3' of the D-region of a D-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000571": {
            "name": "miRNA_encoding"
          },
          "SO:0000572": {
            "name": "DJ_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in partially rearranged genomic DNA including D-J-region with 5' UTR and 3' UTR, also designated as D-J-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000573": {
            "name": "rRNA_encoding"
          },
          "SO:0000574": {
            "name": "VDJ_gene_segment",
            "def": "Rearranged genomic DNA of immunoglobulin/T-cell receptor gene including L-part1, V-intron and V-D-J-exon, with the 5'UTR (SO:0000204) and 3'UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000575": {
            "name": "scRNA_encoding"
          },
          "SO:0000576": {
            "name": "VJ_gene_segment",
            "def": "Rearranged genomic DNA of immunoglobulin/T-cell receptor gene including L-part1, V-intron and V-J-exon, with the 5'UTR (SO:0000204) and 3'UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
          },
          "SO:0000577": {
            "name": "centromere",
            "def": "A region of chromosome where the spindle fibers attach during mitosis and meiosis. [SO:ke]"
          },
          "SO:0000578": {
            "name": "snoRNA_encoding"
          },
          "SO:0000579": {
            "name": "edited_transcript_feature",
            "def": "A locatable feature on a transcript that is edited. [SO:ma]"
          },
          "SO:0000580": {
            "name": "methylation_guide_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a methylation guide small nucleolar RNA. [SO:ke]"
          },
          "SO:0000581": {
            "name": "cap",
            "def": "A structure consisting of a 7-methylguanosine in 5'-5' triphosphate linkage with the first nucleotide of an mRNA. It is added post-transcriptionally, and is not encoded in the DNA. [http://seqcore.brcf.med.umich.edu/doc/educ/dnapr/mbglossary/mbgloss.html]"
          },
          "SO:0000582": {
            "name": "rRNA_cleavage_snoRNA_primary_transcript",
            "def": "A primary transcript encoding an rRNA cleavage snoRNA. [SO:ke]"
          },
          "SO:0000583": {
            "name": "pre_edited_region",
            "def": "The region of a transcript that will be edited. [http://dna.kdna.ucla.edu/rna/index.aspx]"
          },
          "SO:0000584": {
            "name": "tmRNA",
            "def": "A tmRNA liberates a mRNA from a stalled ribosome. To accomplish this part of the tmRNA is used as a reading frame that ends in a translation stop signal. The broken mRNA is replaced in the ribosome by the tmRNA and translation of the tmRNA leads to addition of a proteolysis tag to the incomplete protein enabling recognition by a protease. Recently a number of permuted tmRNAs genes have been found encoded in two parts. TmRNAs have been identified in eubacteria and some chloroplasts but are absent from archeal and Eukaryote nuclear genomes. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00023]"
          },
          "SO:0000585": {
            "name": "C_D_box_snoRNA_encoding"
          },
          "SO:0000586": {
            "name": "tmRNA_primary_transcript",
            "def": "A primary transcript encoding a tmRNA (SO:0000584). [SO:ke]"
          },
          "SO:0000587": {
            "name": "group_I_intron",
            "def": "Group I catalytic introns are large self-splicing ribozymes. They catalyze their own excision from mRNA, tRNA and rRNA precursors in a wide range of organisms. The core secondary structure consists of 9 paired regions (P1-P9). These fold to essentially two domains, the P4-P6 domain (formed from the stacking of P5, P4, P6 and P6a helices) and the P3-P9 domain (formed from the P8, P3, P7 and P9 helices). Group I catalytic introns often have long ORFs inserted in loop regions. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00028]"
          },
          "SO:0000588": {
            "name": "autocatalytically_spliced_intron",
            "def": "A self spliced intron. [SO:ke]"
          },
          "SO:0000589": {
            "name": "SRP_RNA_primary_transcript",
            "def": "A primary transcript encoding a signal recognition particle RNA. [SO:ke]"
          },
          "SO:0000590": {
            "name": "SRP_RNA",
            "def": "The signal recognition particle (SRP) is a universally conserved ribonucleoprotein. It is involved in the co-translational targeting of proteins to membranes. The eukaryotic SRP consists of a 300-nucleotide 7S RNA and six proteins: SRPs 72, 68, 54, 19, 14, and 9. Archaeal SRP consists of a 7S RNA and homologues of the eukaryotic SRP19 and SRP54 proteins. In most eubacteria, the SRP consists of a 4.5S RNA and the Ffh protein (a homologue of the eukaryotic SRP54 protein). Eukaryotic and archaeal 7S RNAs have very similar secondary structures, with eight helical elements. These fold into the Alu and S domains, separated by a long linker region. Eubacterial SRP is generally a simpler structure, with the M domain of Ffh bound to a region of the 4.5S RNA that corresponds to helix 8 of the eukaryotic and archaeal SRP S domain. Some Gram-positive bacteria (e.g. Bacillus subtilis), however, have a larger SRP RNA that also has an Alu domain. The Alu domain is thought to mediate the peptide chain elongation retardation function of the SRP. The universally conserved helix which interacts with the SRP54/Ffh M domain mediates signal sequence recognition. In eukaryotes and archaea, the SRP19-helix 6 complex is thought to be involved in SRP assembly and stabilizes helix 8 for SRP54 binding. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00017]"
          },
          "SO:0000591": {
            "name": "pseudoknot",
            "def": "A tertiary structure in RNA where nucleotides in a loop form base pairs with a region of RNA downstream of the loop. [RSC:cb]"
          },
          "SO:0000592": {
            "name": "H_pseudoknot",
            "def": "A pseudoknot which contains two stems and at least two loops. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=10334330&dopt=Abstract]"
          },
          "SO:0000593": {
            "name": "C_D_box_snoRNA",
            "def": "Most box C/D snoRNAs also contain long (>10 nt) sequences complementary to rRNA. Boxes C and D, as well as boxes C' and D', are usually located in close proximity, and form a structure known as the box C/D motif. This motif is important for snoRNA stability, processing, nucleolar targeting and function. A small number of box C/D snoRNAs are involved in rRNA processing; most, however, are known or predicted to serve as guide RNAs in ribose methylation of rRNA. Targeting involves direct base pairing of the snoRNA at the rRNA site to be modified and selection of a rRNA nucleotide a fixed distance from box D or D'. [http://www.bio.umass.edu/biochem/rna-sequence/Yeast_snoRNA_Database/snoRNA_DataBase.html]"
          },
          "SO:0000594": {
            "name": "H_ACA_box_snoRNA",
            "def": "Members of the box H/ACA family contain an ACA triplet, exactly 3 nt upstream from the 3' end and an H-box in a hinge region that links two structurally similar functional domains of the molecule. Both boxes are important for snoRNA biosynthesis and function. A few box H/ACA snoRNAs are involved in rRNA processing; most others are known or predicted to participate in selection of uridine nucleosides in rRNA to be converted to pseudouridines. Site selection is mediated by direct base pairing of the snoRNA with rRNA through one or both targeting domains. [http://www.bio.umass.edu/biochem/rna-sequence/Yeast_snoRNA_Database/snoRNA_DataBase.html]"
          },
          "SO:0000595": {
            "name": "C_D_box_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar RNA of the box C/D family. [SO:ke]"
          },
          "SO:0000596": {
            "name": "H_ACA_box_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar RNA of the box H/ACA family. [SO:ke]"
          },
          "SO:0000597": {
            "name": "transcript_edited_by_U_insertion/deletion",
            "def": "The insertion and deletion of uridine (U) residues, usually within coding regions of mRNA transcripts of cryptogenes in the mitochondrial genome of kinetoplastid protozoa. [http://www.rna.ucla.edu/index.html]"
          },
          "SO:0000598": {
            "name": "edited_by_C_insertion_and_dinucleotide_insertion"
          },
          "SO:0000599": {
            "name": "edited_by_C_to_U_substitution"
          },
          "SO:0000600": {
            "name": "edited_by_A_to_I_substitution"
          },
          "SO:0000601": {
            "name": "edited_by_G_addition"
          },
          "SO:0000602": {
            "name": "guide_RNA",
            "def": "A short 3'-uridylated RNA that can form a duplex (except for its post-transcriptionally added oligo_U tail (SO:0000609)) with a stretch of mature edited mRNA. [http://www.rna.ucla.edu/index.html]"
          },
          "SO:0000603": {
            "name": "group_II_intron",
            "def": "Group II introns are found in rRNA, tRNA and mRNA of organelles in fungi, plants and protists, and also in mRNA in bacteria. They are large self-splicing ribozymes and have 6 structural domains (usually designated dI to dVI). A subset of group II introns also encode essential splicing proteins in intronic ORFs. The length of these introns can therefore be up to 3kb. Splicing occurs in almost identical fashion to nuclear pre-mRNA splicing with two transesterification steps. The 2' hydroxyl of a bulged adenosine in domain VI attacks the 5' splice site, followed by nucleophilic attack on the 3' splice site by the 3' OH of the upstream exon. Protein machinery is required for splicing in vivo, and long range intron to intron and intron-exon interactions are important for splice site positioning. Group II introns are further sub-classified into groups IIA and IIB which differ in splice site consensus, distance of bulged A from 3' splice site, some tertiary interactions, and intronic ORF phylogeny. [http://www.sanger.ac.uk/Software/Rfam/browse/index.shtml]"
          },
          "SO:0000604": {
            "name": "editing_block",
            "def": "Edited mRNA sequence mediated by a single guide RNA (SO:0000602). [http://dna.kdna.ucla.edu/rna/index.aspx]"
          },
          "SO:0000605": {
            "name": "intergenic_region",
            "def": "A region containing or overlapping no genes that is bounded on either side by a gene, or bounded by a gene and the end of the chromosome. [SO:cjm]"
          },
          "SO:0000606": {
            "name": "editing_domain",
            "def": "Edited mRNA sequence mediated by two or more overlapping guide RNAs (SO:0000602). [http://dna.kdna.ucla.edu/rna/index.aspx]"
          },
          "SO:0000607": {
            "name": "unedited_region",
            "def": "The region of an edited transcript that will not be edited. [http://dna.kdna.ucla.edu/rna/index.aspx]"
          },
          "SO:0000608": {
            "name": "H_ACA_box_snoRNA_encoding"
          },
          "SO:0000609": {
            "name": "oligo_U_tail",
            "def": "The string of non-encoded U's at the 3' end of a guide RNA (SO:0000602). [http://www.rna.ucla.edu/]"
          },
          "SO:0000610": {
            "name": "polyA_sequence",
            "def": "Sequence of about 100 nucleotides of A added to the 3' end of most eukaryotic mRNAs. [SO:ke]"
          },
          "SO:0000611": {
            "name": "branch_site",
            "def": "A pyrimidine rich sequence near the 3' end of an intron to which the 5'end becomes covalently bound during nuclear splicing. The resulting structure resembles a lariat. [SO:ke]"
          },
          "SO:0000612": {
            "name": "polypyrimidine_tract",
            "def": "The polypyrimidine tract is one of the cis-acting sequence elements directing intron removal in pre-mRNA splicing. [http://nar.oupjournals.org/cgi/content/full/25/4/888]"
          },
          "SO:0000613": {
            "name": "bacterial_RNApol_promoter",
            "def": "A DNA sequence to which bacterial RNA polymerase binds, to begin transcription. [SO:ke]"
          },
          "SO:0000614": {
            "name": "bacterial_terminator",
            "def": "A terminator signal for bacterial transcription. [SO:ke]"
          },
          "SO:0000615": {
            "name": "terminator_of_type_2_RNApol_III_promoter",
            "def": "A terminator signal for RNA polymerase III transcription. [SO:ke]"
          },
          "SO:0000616": {
            "name": "transcription_end_site",
            "def": "The base where transcription ends. [SO:ke]"
          },
          "SO:0000617": {
            "name": "RNApol_III_promoter_type_1"
          },
          "SO:0000618": {
            "name": "RNApol_III_promoter_type_2"
          },
          "SO:0000619": {
            "name": "A_box",
            "def": "A variably distant linear promoter region recognized by TFIIIC, with consensus sequence TGGCnnAGTGG. [SO:ke]"
          },
          "SO:0000620": {
            "name": "B_box",
            "def": "A variably distant linear promoter region recognized by TFIIIC, with consensus sequence AGGTTCCAnnCC. [SO:ke]"
          },
          "SO:0000621": {
            "name": "RNApol_III_promoter_type_3"
          },
          "SO:0000622": {
            "name": "C_box",
            "def": "An RNA polymerase III type 1 promoter with consensus sequence CAnnCCn. [SO:ke]"
          },
          "SO:0000623": {
            "name": "snRNA_encoding"
          },
          "SO:0000624": {
            "name": "telomere",
            "def": "A specific structure at the end of a linear chromosome, required for the integrity and maintenance of the end. [SO:ma]"
          },
          "SO:0000625": {
            "name": "silencer",
            "def": "A regulatory region which upon binding of transcription factors, suppress the transcription of the gene or genes they control. [SO:ke]"
          },
          "SO:0000626": {
            "name": "chromosomal_regulatory_element"
          },
          "SO:0000627": {
            "name": "insulator",
            "def": "A transcriptional cis regulatory region that when located between a CM and a gene's promoter prevents the CRM from modulating that genes expression. [SO:regcreative]"
          },
          "SO:0000628": {
            "name": "chromosomal_structural_element"
          },
          "SO:0000629": {
            "name": "five_prime_open_reading_frame"
          },
          "SO:0000630": {
            "name": "upstream_AUG_codon",
            "def": "A start codon upstream of the ORF. [SO:ke]"
          },
          "SO:0000631": {
            "name": "polycistronic_primary_transcript",
            "def": "A primary transcript encoding for more than one gene product. [SO:ke]"
          },
          "SO:0000632": {
            "name": "monocistronic_primary_transcript",
            "def": "A primary transcript encoding for one gene product. [SO:ke]"
          },
          "SO:0000633": {
            "name": "monocistronic_mRNA",
            "def": "An mRNA with either a single protein product, or for which the regions encoding all its protein products overlap. [SO:rd]"
          },
          "SO:0000634": {
            "name": "polycistronic_mRNA",
            "def": "An mRNA that encodes multiple proteins from at least two non-overlapping regions. [SO:rd]"
          },
          "SO:0000635": {
            "name": "mini_exon_donor_RNA",
            "def": "A primary transcript that donates the spliced leader to other mRNA. [SO:ke]"
          },
          "SO:0000636": {
            "name": "spliced_leader_RNA"
          },
          "SO:0000637": {
            "name": "engineered_plasmid",
            "def": "A plasmid that is engineered. [SO:xp]"
          },
          "SO:0000638": {
            "name": "transcribed_spacer_region",
            "def": "Part of an rRNA transcription unit that is transcribed but discarded during maturation, not giving rise to any part of rRNA. [http://oregonstate.edu/instruction/bb492/general/glossary.html]"
          },
          "SO:0000639": {
            "name": "internal_transcribed_spacer_region",
            "def": "Non-coding regions of DNA sequence that separate genes coding for the 28S, 5.8S, and 18S ribosomal RNAs. [SO:ke]"
          },
          "SO:0000640": {
            "name": "external_transcribed_spacer_region",
            "def": "Non-coding regions of DNA that precede the sequence that codes for the ribosomal RNA. [SO:ke]"
          },
          "SO:0000641": {
            "name": "tetranucleotide_repeat_microsatellite_feature"
          },
          "SO:0000642": {
            "name": "SRP_RNA_encoding"
          },
          "SO:0000643": {
            "name": "minisatellite",
            "def": "A repeat region containing tandemly repeated sequences having a unit length of 10 to 40 bp. [http://www.informatics.jax.org/silver/glossary.shtml]"
          },
          "SO:0000644": {
            "name": "antisense_RNA",
            "def": "Antisense RNA is RNA that is transcribed from the coding, rather than the template, strand of DNA. It is therefore complementary to mRNA. [SO:ke]"
          },
          "SO:0000645": {
            "name": "antisense_primary_transcript",
            "def": "The reverse complement of the primary transcript. [SO:ke]"
          },
          "SO:0000646": {
            "name": "siRNA",
            "def": "A small RNA molecule that is the product of a longer exogenous or endogenous dsRNA, which is either a bimolecular duplex or very long hairpin, processed (via the Dicer pathway) such that numerous siRNAs accumulate from both strands of the dsRNA. SRNAs trigger the cleavage of their target molecules. [PMID:12592000]"
          },
          "SO:0000647": {
            "name": "miRNA_primary_transcript",
            "def": "A primary transcript encoding a micro RNA. [SO:ke]"
          },
          "SO:0000650": {
            "name": "small_subunit_rRNA",
            "def": "Ribosomal RNA transcript that structures the small subunit of the ribosome. [SO:ke]"
          },
          "SO:0000651": {
            "name": "large_subunit_rRNA",
            "def": "Ribosomal RNA transcript that structures the large subunit of the ribosome. [SO:ke]"
          },
          "SO:0000652": {
            "name": "rRNA_5S",
            "def": "5S ribosomal RNA (5S rRNA) is a component of the large ribosomal subunit in both prokaryotes and eukaryotes. In eukaryotes, it is synthesised by RNA polymerase III (the other eukaryotic rRNAs are cleaved from a 45S precursor synthesised by RNA polymerase I). In Xenopus oocytes, it has been shown that fingers 4-7 of the nine-zinc finger transcription factor TFIIIA can bind to the central region of 5S RNA. Thus, in addition to positively regulating 5S rRNA transcription, TFIIIA also stabilizes 5S rRNA until it is required for transcription. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00001]"
          },
          "SO:0000653": {
            "name": "rRNA_28S",
            "def": "A component of the large ribosomal subunit. [SO:ke]"
          },
          "SO:0000654": {
            "name": "maxicircle_gene",
            "def": "A mitochondrial gene located in a maxicircle. [SO:xp]"
          },
          "SO:0000655": {
            "name": "ncRNA",
            "def": "An RNA transcript that does not encode for a protein rather the RNA molecule is the gene product. [SO:ke]"
          },
          "SO:0000656": {
            "name": "stRNA_encoding"
          },
          "SO:0000657": {
            "name": "repeat_region",
            "def": "A region of sequence containing one or more repeat units. [SO:ke]"
          },
          "SO:0000658": {
            "name": "dispersed_repeat",
            "def": "A repeat that is located at dispersed sites in the genome. [SO:ke]"
          },
          "SO:0000659": {
            "name": "tmRNA_encoding"
          },
          "SO:0000660": {
            "name": "DNA_invertase_target_sequence"
          },
          "SO:0000661": {
            "name": "intron_attribute"
          },
          "SO:0000662": {
            "name": "spliceosomal_intron",
            "def": "An intron which is spliced by the spliceosome. [SO:ke]"
          },
          "SO:0000663": {
            "name": "tRNA_encoding"
          },
          "SO:0000664": {
            "name": "introgressed_chromosome_region"
          },
          "SO:0000665": {
            "name": "monocistronic_transcript",
            "def": "A transcript that is monocistronic. [SO:xp]"
          },
          "SO:0000666": {
            "name": "mobile_intron",
            "def": "An intron (mitochondrial, chloroplast, nuclear or prokaryotic) that encodes a double strand sequence specific endonuclease allowing for mobility. [SO:ke]"
          },
          "SO:0000667": {
            "name": "insertion",
            "def": "The sequence of one or more nucleotides added between two adjacent nucleotides in the sequence. [SO:ke]"
          },
          "SO:0000668": {
            "name": "EST_match",
            "def": "A match against an EST sequence. [SO:ke]"
          },
          "SO:0000669": {
            "name": "sequence_rearrangement_feature"
          },
          "SO:0000670": {
            "name": "chromosome_breakage_sequence",
            "def": "A sequence within the micronuclear DNA of ciliates at which chromosome breakage and telomere addition occurs during nuclear differentiation. [SO:ma]"
          },
          "SO:0000671": {
            "name": "internal_eliminated_sequence",
            "def": "A sequence eliminated from the genome of ciliates during nuclear differentiation. [SO:ma]"
          },
          "SO:0000672": {
            "name": "macronucleus_destined_segment",
            "def": "A sequence that is conserved, although rearranged relative to the micronucleus, in the macronucleus of a ciliate genome. [SO:ma]"
          },
          "SO:0000673": {
            "name": "transcript",
            "def": "An RNA synthesized on a DNA or RNA template by an RNA polymerase. [SO:ma]"
          },
          "SO:0000674": {
            "name": "non_canonical_splice_site",
            "def": "A splice site where the donor and acceptor sites differ from the canonical form. [SO:ke]"
          },
          "SO:0000675": {
            "name": "canonical_splice_site",
            "def": "The major class of splice site with dinucleotides GT and AG for donor and acceptor sites, respectively. [SO:ke]"
          },
          "SO:0000676": {
            "name": "canonical_three_prime_splice_site",
            "def": "The canonical 3' splice site has the sequence \\AG\\. [SO:ke]"
          },
          "SO:0000677": {
            "name": "canonical_five_prime_splice_site",
            "def": "The canonical 5' splice site has the sequence \\GT\\. [SO:ke]"
          },
          "SO:0000678": {
            "name": "non_canonical_three_prime_splice_site",
            "def": "A 3' splice site that does not have the sequence \\AG\\. [SO:ke]"
          },
          "SO:0000679": {
            "name": "non_canonical_five_prime_splice_site",
            "def": "A 5' splice site which does not have the sequence \\GT\\. [SO:ke]"
          },
          "SO:0000680": {
            "name": "non_canonical_start_codon",
            "def": "A start codon that is not the usual AUG sequence. [SO:ke]"
          },
          "SO:0000681": {
            "name": "aberrant_processed_transcript",
            "def": "A transcript that has been processed \\incorrectly\\, for example by the failure of splicing of one or more exons. [SO:ke]"
          },
          "SO:0000682": {
            "name": "splicing_feature"
          },
          "SO:0000683": {
            "name": "exonic_splice_enhancer",
            "def": "Exonic splicing enhancers (ESEs) facilitate exon definition by assisting in the recruitment of splicing factors to the adjacent intron. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=12403462&dopt=Abstract]"
          },
          "SO:0000684": {
            "name": "nuclease_sensitive_site",
            "def": "A region of nucleotide sequence targeted by a nuclease enzyme. [SO:ma]"
          },
          "SO:0000685": {
            "name": "DNAseI_hypersensitive_site"
          },
          "SO:0000686": {
            "name": "translocation_element",
            "def": "A chromosomal translocation whereby the chromosomes carrying non-homologous centromeres may be recovered independently. These chromosomes are described as translocation elements. This occurs for some translocations, particularly but not exclusively, reciprocal translocations. [SO:ma]"
          },
          "SO:0000687": {
            "name": "deletion_junction",
            "def": "The space between two bases in a sequence which marks the position where a deletion has occurred. [SO:ke]"
          },
          "SO:0000688": {
            "name": "golden_path",
            "def": "A set of subregions selected from sequence contigs which when concatenated form a nonredundant linear sequence. [SO:ls]"
          },
          "SO:0000689": {
            "name": "cDNA_match",
            "def": "A match against cDNA sequence. [SO:ke]"
          },
          "SO:0000690": {
            "name": "gene_with_polycistronic_transcript",
            "def": "A gene that encodes a polycistronic transcript. [SO:xp]"
          },
          "SO:0000691": {
            "name": "cleaved_initiator_methionine",
            "def": "The initiator methionine that has been cleaved from a mature polypeptide sequence. [EBIBS:GAR]"
          },
          "SO:0000692": {
            "name": "gene_with_dicistronic_transcript",
            "def": "A gene that encodes a dicistronic transcript. [SO:xp]"
          },
          "SO:0000693": {
            "name": "gene_with_recoded_mRNA",
            "def": "A gene that encodes an mRNA that is recoded. [SO:xp]"
          },
          "SO:0000694": {
            "name": "SNP",
            "def": "SNPs are single base pair positions in genomic DNA at which different sequence alternatives exist in normal individuals in some population(s), wherein the least frequent variant has an abundance of 1% or greater. [SO:cb]"
          },
          "SO:0000695": {
            "name": "reagent",
            "def": "A sequence used in experiment. [SO:ke]"
          },
          "SO:0000696": {
            "name": "oligo",
            "def": "A short oligonucleotide sequence, of length on the order of 10's of bases; either single or double stranded. [SO:ma]"
          },
          "SO:0000697": {
            "name": "gene_with_stop_codon_read_through",
            "def": "A gene that encodes a transcript with stop codon readthrough. [SO:xp]"
          },
          "SO:0000698": {
            "name": "gene_with_stop_codon_redefined_as_pyrrolysine",
            "def": "A gene encoding an mRNA that has the stop codon redefined as pyrrolysine. [SO:xp]"
          },
          "SO:0000699": {
            "name": "junction",
            "def": "A sequence_feature with an extent of zero. [SO:ke]"
          },
          "SO:0000700": {
            "name": "remark",
            "def": "A comment about the sequence. [SO:ke]"
          },
          "SO:0000701": {
            "name": "possible_base_call_error",
            "def": "A region of sequence where the validity of the base calling is questionable. [SO:ke]"
          },
          "SO:0000702": {
            "name": "possible_assembly_error",
            "def": "A region of sequence where there may have been an error in the assembly. [SO:ke]"
          },
          "SO:0000703": {
            "name": "experimental_result_region",
            "def": "A region of sequence implicated in an experimental result. [SO:ke]"
          },
          "SO:0000704": {
            "name": "gene",
            "def": "A region (or regions) that includes all of the sequence elements necessary to encode a functional transcript. A gene may include regulatory regions, transcribed regions and/or other functional sequence regions. [SO:immuno_workshop]"
          },
          "SO:0000705": {
            "name": "tandem_repeat",
            "def": "Two or more adjacent copies of a region (of length greater than 1). [SO:ke]"
          },
          "SO:0000706": {
            "name": "trans_splice_acceptor_site",
            "def": "The 3' splice site of the acceptor primary transcript. [SO:ke]"
          },
          "SO:0000707": {
            "name": "trans_splice_donor_site",
            "def": "The 5' five prime splice site region of the donor RNA. [SO:ke]"
          },
          "SO:0000708": {
            "name": "SL1_acceptor_site",
            "def": "A trans_splicing_acceptor_site which appends the 22nt SL1 RNA leader sequence to the 5' end of most mRNAs. [SO:nlw]"
          },
          "SO:0000709": {
            "name": "SL2_acceptor_site",
            "def": "A trans_splicing_acceptor_site which appends the 22nt SL2 RNA leader sequence to the 5' end of mRNAs. SL2 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0000710": {
            "name": "gene_with_stop_codon_redefined_as_selenocysteine",
            "def": "A gene encoding an mRNA that has the stop codon redefined as selenocysteine. [SO:xp]"
          },
          "SO:0000711": {
            "name": "gene_with_mRNA_recoded_by_translational_bypass",
            "def": "A gene with mRNA recoded by translational bypass. [SO:xp]"
          },
          "SO:0000712": {
            "name": "gene_with_transcript_with_translational_frameshift",
            "def": "A gene encoding a transcript that has a translational frameshift. [SO:xp]"
          },
          "SO:0000713": {
            "name": "DNA_motif",
            "def": "A motif that is active in the DNA form of the sequence. [SO:ke]"
          },
          "SO:0000714": {
            "name": "nucleotide_motif",
            "def": "A region of nucleotide sequence corresponding to a known motif. [SO:ke]"
          },
          "SO:0000715": {
            "name": "RNA_motif",
            "def": "A motif that is active in RNA sequence. [SO:ke]"
          },
          "SO:0000716": {
            "name": "dicistronic_mRNA",
            "def": "An mRNA that has the quality dicistronic. [SO:ke]"
          },
          "SO:0000717": {
            "name": "reading_frame",
            "def": "A nucleic acid sequence that when read as sequential triplets, has the potential of encoding a sequential string of amino acids. It need not contain the start or stop codon. [SGD:rb]"
          },
          "SO:0000718": {
            "name": "blocked_reading_frame",
            "def": "A reading_frame that is interrupted by one or more stop codons; usually identified through inter-genomic sequence comparisons. [SGD:rb]"
          },
          "SO:0000719": {
            "name": "ultracontig",
            "def": "An ordered and oriented set of scaffolds based on somewhat weaker sets of inferential evidence such as one set of mate pair reads together with supporting evidence from ESTs or location of markers from SNP or microsatellite maps, or cytogenetic localization of contained markers. [FB:WG]"
          },
          "SO:0000720": {
            "name": "foreign_transposable_element",
            "def": "A transposable element that is foreign. [SO:ke]"
          },
          "SO:0000721": {
            "name": "gene_with_dicistronic_primary_transcript",
            "def": "A gene that encodes a dicistronic primary transcript. [SO:xp]"
          },
          "SO:0000722": {
            "name": "gene_with_dicistronic_mRNA",
            "def": "A gene that encodes a polycistronic mRNA. [SO:xp]"
          },
          "SO:0000723": {
            "name": "iDNA",
            "def": "Genomic sequence removed from the genome, as a normal event, by a process of recombination. [SO:ma]"
          },
          "SO:0000724": {
            "name": "oriT",
            "def": "A region of a DNA molecule where transfer is initiated during the process of conjugation or mobilization. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000725": {
            "name": "transit_peptide",
            "def": "The transit_peptide is a short region at the N-terminus of the peptide that directs the protein to an organelle (chloroplast, mitochondrion, microbody or cyanelle). [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0000726": {
            "name": "repeat_unit",
            "def": "The simplest repeated component of a repeat region. A single repeat. [SO:ke]"
          },
          "SO:0000727": {
            "name": "CRM",
            "def": "A regulatory region where transcription factor binding sites clustered to regulate various aspects of transcription activities. (CRMs can be located a few kb to hundred kb upstream of the basal promoter, in the coding sequence, within introns, or in the downstream 3'UTR sequences, as well as on different chromosome). A single gene can be regulated by multiple CRMs to give precise control of its spatial and temporal expression. CRMs function as nodes in large, intertwined regulatory network. [PMID:19660565, SO:SG]"
          },
          "SO:0000728": {
            "name": "intein",
            "def": "A region of a peptide that is able to excise itself and rejoin the remaining portions with a peptide bond. [SO:ke]"
          },
          "SO:0000729": {
            "name": "intein_containing",
            "def": "An attribute of protein-coding genes where the initial protein product contains an intein. [SO:ke]"
          },
          "SO:0000730": {
            "name": "gap",
            "def": "A gap in the sequence of known length. The unknown bases are filled in with N's. [SO:ke]"
          },
          "SO:0000731": {
            "name": "fragmentary",
            "def": "An attribute to describe a feature that is incomplete. [SO:ke]"
          },
          "SO:0000732": {
            "name": "predicted",
            "def": "An attribute describing an unverified region. [SO:ke]"
          },
          "SO:0000733": {
            "name": "feature_attribute",
            "def": "An attribute describing a located_sequence_feature. [SO:ke]"
          },
          "SO:0000734": {
            "name": "exemplar_mRNA",
            "def": "An exemplar is a representative cDNA sequence for each gene. The exemplar approach is a method that usually involves some initial clustering into gene groups and the subsequent selection of a representative from each gene group. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
          },
          "SO:0000735": {
            "name": "sequence_location"
          },
          "SO:0000736": {
            "name": "organelle_sequence"
          },
          "SO:0000737": {
            "name": "mitochondrial_sequence"
          },
          "SO:0000738": {
            "name": "nuclear_sequence"
          },
          "SO:0000739": {
            "name": "nucleomorphic_sequence"
          },
          "SO:0000740": {
            "name": "plastid_sequence"
          },
          "SO:0000741": {
            "name": "kinetoplast",
            "def": "A kinetoplast is an interlocked network of thousands of minicircles and tens of maxicircles, located near the base of the flagellum of some protozoan species. [PMID:8395055]"
          },
          "SO:0000742": {
            "name": "maxicircle",
            "def": "A maxicircle is a replicon, part of a kinetoplast, that contains open reading frames and replicates via a rolling circle method. [PMID:8395055]"
          },
          "SO:0000743": {
            "name": "apicoplast_sequence"
          },
          "SO:0000744": {
            "name": "chromoplast_sequence"
          },
          "SO:0000745": {
            "name": "chloroplast_sequence"
          },
          "SO:0000746": {
            "name": "cyanelle_sequence"
          },
          "SO:0000747": {
            "name": "leucoplast_sequence"
          },
          "SO:0000748": {
            "name": "proplastid_sequence"
          },
          "SO:0000749": {
            "name": "plasmid_location"
          },
          "SO:0000750": {
            "name": "amplification_origin",
            "def": "An origin_of_replication that is used for the amplification of a chromosomal nucleic acid sequence. [SO:ma]"
          },
          "SO:0000751": {
            "name": "proviral_location"
          },
          "SO:0000752": {
            "name": "gene_group_regulatory_region"
          },
          "SO:0000753": {
            "name": "clone_insert",
            "def": "The region of sequence that has been inserted and is being propagated by the clone. [SO:ke]"
          },
          "SO:0000754": {
            "name": "lambda_vector",
            "def": "The lambda bacteriophage is the vector for the linear lambda clone. The genes involved in the lysogenic pathway are removed from the from the viral DNA. Up to 25 kb of foreign DNA can then be inserted into the lambda genome. [ISBN:0-1767-2380-8]"
          },
          "SO:0000755": {
            "name": "plasmid_vector"
          },
          "SO:0000756": {
            "name": "cDNA",
            "def": "DNA synthesized by reverse transcriptase using RNA as a template. [SO:ma]"
          },
          "SO:0000757": {
            "name": "single_stranded_cDNA"
          },
          "SO:0000758": {
            "name": "double_stranded_cDNA"
          },
          "SO:0000759": {
            "name": "plasmid_clone"
          },
          "SO:0000760": {
            "name": "YAC_clone"
          },
          "SO:0000761": {
            "name": "phagemid_clone"
          },
          "SO:0000762": {
            "name": "PAC_clone"
          },
          "SO:0000763": {
            "name": "fosmid_clone"
          },
          "SO:0000764": {
            "name": "BAC_clone"
          },
          "SO:0000765": {
            "name": "cosmid_clone"
          },
          "SO:0000766": {
            "name": "pyrrolysyl_tRNA",
            "def": "A tRNA sequence that has a pyrrolysine anticodon, and a 3' pyrrolysine binding region. [SO:ke]"
          },
          "SO:0000767": {
            "name": "clone_insert_start"
          },
          "SO:0000768": {
            "name": "episome",
            "def": "A plasmid that may integrate with a chromosome. [SO:ma]"
          },
          "SO:0000769": {
            "name": "tmRNA_coding_piece",
            "def": "The region of a two-piece tmRNA that bears the reading frame encoding the proteolysis tag. The tmRNA gene undergoes circular permutation in some groups of bacteria. Processing of the transcripts from such a gene leaves the mature tmRNA in two pieces, base-paired together. [doi:10.1093/nar/gkh795, Indiana:kw, issn:1362-4962]"
          },
          "SO:0000770": {
            "name": "tmRNA_acceptor_piece",
            "def": "The acceptor region of a two-piece tmRNA that when mature is charged at its 3' end with alanine. The tmRNA gene undergoes circular permutation in some groups of bacteria; processing of the transcripts from such a gene leaves the mature tmRNA in two pieces, base-paired together. [doi:10.1093/nar/gkh795, Indiana:kw]"
          },
          "SO:0000771": {
            "name": "QTL",
            "def": "A quantitative trait locus (QTL) is a polymorphic locus which contains alleles that differentially affect the expression of a continuously distributed phenotypic trait. Usually it is a marker described by statistical association to quantitative variation in the particular phenotypic trait that is thought to be controlled by the cumulative action of alleles at multiple loci. [http://rgd.mcw.edu/tu/qtls/]"
          },
          "SO:0000772": {
            "name": "genomic_island",
            "def": "A genomic island is an integrated mobile genetic element, characterized by size (over 10 Kb). It that has features that suggest a foreign origin. These can include nucleotide distribution (oligonucleotides signature, CG content etc.) that differs from the bulk of the chromosome and/or genes suggesting DNA mobility. [Phigo:at, SO:ke]"
          },
          "SO:0000773": {
            "name": "pathogenic_island",
            "def": "Mobile genetic elements that contribute to rapid changes in virulence potential. They are present on the genomes of pathogenic strains but absent from the genomes of non pathogenic members of the same or related species. [SO:ke]"
          },
          "SO:0000774": {
            "name": "metabolic_island",
            "def": "A transmissible element containing genes involved in metabolism, analogous to the pathogenicity islands of gram negative bacteria. [SO:ke]"
          },
          "SO:0000775": {
            "name": "adaptive_island",
            "def": "An adaptive island is a genomic island that provides an adaptive advantage to the host. [SO:ke]"
          },
          "SO:0000776": {
            "name": "symbiosis_island",
            "def": "A transmissible element containing genes involved in symbiosis, analogous to the pathogenicity islands of gram negative bacteria. [SO:ke]"
          },
          "SO:0000777": {
            "name": "pseudogenic_rRNA",
            "def": "A non functional descendant of an rRNA. [SO:ke]"
          },
          "SO:0000778": {
            "name": "pseudogenic_tRNA",
            "def": "A non functional descendent of a tRNA. [SO:ke]"
          },
          "SO:0000779": {
            "name": "engineered_episome",
            "def": "An episome that is engineered. [SO:xp]"
          },
          "SO:0000780": {
            "name": "transposable_element_attribute"
          },
          "SO:0000781": {
            "name": "transgenic",
            "def": "Attribute describing sequence that has been integrated with foreign sequence. [SO:ke]"
          },
          "SO:0000782": {
            "name": "natural",
            "def": "An attribute describing a feature that occurs in nature. [SO:ke]"
          },
          "SO:0000783": {
            "name": "engineered",
            "def": "An attribute to describe a region that was modified in vitro. [SO:ke]"
          },
          "SO:0000784": {
            "name": "foreign",
            "def": "An attribute to describe a region from another species. [SO:ke]"
          },
          "SO:0000785": {
            "name": "cloned_region"
          },
          "SO:0000786": {
            "name": "reagent_attribute"
          },
          "SO:0000787": {
            "name": "clone_attribute"
          },
          "SO:0000788": {
            "name": "cloned"
          },
          "SO:0000789": {
            "name": "validated",
            "def": "An attribute to describe a feature that has been proven. [SO:ke]"
          },
          "SO:0000790": {
            "name": "invalidated",
            "def": "An attribute describing a feature that is invalidated. [SO:ke]"
          },
          "SO:0000791": {
            "name": "cloned_genomic"
          },
          "SO:0000792": {
            "name": "cloned_cDNA"
          },
          "SO:0000793": {
            "name": "engineered_DNA"
          },
          "SO:0000794": {
            "name": "engineered_rescue_region",
            "def": "A rescue region that is engineered. [SO:xp]"
          },
          "SO:0000795": {
            "name": "rescue_mini_gene",
            "def": "A mini_gene that rescues. [SO:xp]"
          },
          "SO:0000796": {
            "name": "transgenic_transposable_element",
            "def": "TE that has been modified in vitro, including insertion of DNA derived from a source other than the originating TE. [FB:mc]"
          },
          "SO:0000797": {
            "name": "natural_transposable_element",
            "def": "TE that exists (or existed) in nature. [FB:mc]"
          },
          "SO:0000798": {
            "name": "engineered_transposable_element",
            "def": "TE that has been modified by manipulations in vitro. [FB:mc]"
          },
          "SO:0000799": {
            "name": "engineered_foreign_transposable_element",
            "def": "A transposable_element that is engineered and foreign. [FB:mc]"
          },
          "SO:0000800": {
            "name": "assortment_derived_duplication",
            "def": "A multi-chromosome duplication aberration generated by reassortment of other aberration components. [FB:gm]"
          },
          "SO:0000801": {
            "name": "assortment_derived_deficiency_plus_duplication",
            "def": "A multi-chromosome aberration generated by reassortment of other aberration components; presumed to have a deficiency and a duplication. [FB:gm]"
          },
          "SO:0000802": {
            "name": "assortment_derived_deficiency",
            "def": "A multi-chromosome deficiency aberration generated by reassortment of other aberration components. [FB:gm]"
          },
          "SO:0000803": {
            "name": "assortment_derived_aneuploid",
            "def": "A multi-chromosome aberration generated by reassortment of other aberration components; presumed to have a deficiency or a duplication. [FB:gm]"
          },
          "SO:0000804": {
            "name": "engineered_region",
            "def": "A region that is engineered. [SO:xp]"
          },
          "SO:0000805": {
            "name": "engineered_foreign_region",
            "def": "A region that is engineered and foreign. [SO:xp]"
          },
          "SO:0000806": {
            "name": "fusion"
          },
          "SO:0000807": {
            "name": "engineered_tag",
            "def": "A tag that is engineered. [SO:xp]"
          },
          "SO:0000808": {
            "name": "validated_cDNA_clone",
            "def": "A cDNA clone that has been validated. [SO:xp]"
          },
          "SO:0000809": {
            "name": "invalidated_cDNA_clone",
            "def": "A cDNA clone that is invalid. [SO:xp]"
          },
          "SO:0000810": {
            "name": "chimeric_cDNA_clone",
            "def": "A cDNA clone invalidated because it is chimeric. [SO:xp]"
          },
          "SO:0000811": {
            "name": "genomically_contaminated_cDNA_clone",
            "def": "A cDNA clone invalidated by genomic contamination. [SO:xp]"
          },
          "SO:0000812": {
            "name": "polyA_primed_cDNA_clone",
            "def": "A cDNA clone invalidated by polyA priming. [SO:xp]"
          },
          "SO:0000813": {
            "name": "partially_processed_cDNA_clone",
            "def": "A cDNA invalidated clone by partial processing. [SO:xp]"
          },
          "SO:0000814": {
            "name": "rescue",
            "def": "An attribute describing a region's ability, when introduced to a mutant organism, to re-establish (rescue) a phenotype. [SO:ke]"
          },
          "SO:0000815": {
            "name": "mini_gene",
            "def": "By definition, minigenes are short open-reading frames (ORF), usually encoding approximately 9 to 20 amino acids, which are expressed in vivo (as distinct from being synthesized as peptide or protein ex vivo and subsequently injected). The in vivo synthesis confers a distinct advantage: the expressed sequences can enter both antigen presentation pathways, MHC I (inducing CD8+ T- cells, which are usually cytotoxic T-lymphocytes (CTL)) and MHC II (inducing CD4+ T-cells, usually 'T-helpers' (Th)); and can encounter B-cells, inducing antibody responses. Three main vector approaches have been used to deliver minigenes: viral vectors, bacterial vectors and plasmid DNA. [PMID:15992143]"
          },
          "SO:0000816": {
            "name": "rescue_gene",
            "def": "A gene that rescues. [SO:xp]"
          },
          "SO:0000817": {
            "name": "wild_type",
            "def": "An attribute describing sequence with the genotype found in nature and/or standard laboratory stock. [SO:ke]"
          },
          "SO:0000818": {
            "name": "wild_type_rescue_gene",
            "def": "A gene that rescues. [SO:xp]"
          },
          "SO:0000819": {
            "name": "mitochondrial_chromosome",
            "def": "A chromosome originating in a mitochondria. [SO:xp]"
          },
          "SO:0000820": {
            "name": "chloroplast_chromosome",
            "def": "A chromosome originating in a chloroplast. [SO:xp]"
          },
          "SO:0000821": {
            "name": "chromoplast_chromosome",
            "def": "A chromosome originating in a chromoplast. [SO:xp]"
          },
          "SO:0000822": {
            "name": "cyanelle_chromosome",
            "def": "A chromosome originating in a cyanelle. [SO:xp]"
          },
          "SO:0000823": {
            "name": "leucoplast_chromosome",
            "def": "A chromosome with origin in a leucoplast. [SO:xp]"
          },
          "SO:0000824": {
            "name": "macronuclear_chromosome",
            "def": "A chromosome originating in a macronucleus. [SO:xp]"
          },
          "SO:0000825": {
            "name": "micronuclear_chromosome",
            "def": "A chromosome originating in a micronucleus. [SO:xp]"
          },
          "SO:0000828": {
            "name": "nuclear_chromosome",
            "def": "A chromosome originating in a nucleus. [SO:xp]"
          },
          "SO:0000829": {
            "name": "nucleomorphic_chromosome",
            "def": "A chromosome originating in a nucleomorph. [SO:xp]"
          },
          "SO:0000830": {
            "name": "chromosome_part",
            "def": "A region of a chromosome. [SO:ke]"
          },
          "SO:0000831": {
            "name": "gene_member_region",
            "def": "A region of a gene. [SO:ke]"
          },
          "SO:0000832": {
            "name": "promoter_region",
            "def": "A region of sequence which is part of a promoter. [SO:ke]"
          },
          "SO:0000833": {
            "name": "transcript_region",
            "def": "A region of a transcript. [SO:ke]"
          },
          "SO:0000834": {
            "name": "mature_transcript_region",
            "def": "A region of a mature transcript. [SO:ke]"
          },
          "SO:0000835": {
            "name": "primary_transcript_region",
            "def": "A part of a primary transcript. [SO:ke]"
          },
          "SO:0000836": {
            "name": "mRNA_region",
            "def": "A region of an mRNA. [SO:cb]"
          },
          "SO:0000837": {
            "name": "UTR_region",
            "def": "A region of UTR. [SO:ke]"
          },
          "SO:0000838": {
            "name": "rRNA_primary_transcript_region",
            "def": "A region of an rRNA primary transcript. [SO:ke]"
          },
          "SO:0000839": {
            "name": "polypeptide_region",
            "def": "Biological sequence region that can be assigned to a specific subsequence of a polypeptide. [SO:GAR, SO:ke]"
          },
          "SO:0000840": {
            "name": "repeat_component",
            "def": "A region of a repeated sequence. [SO:ke]"
          },
          "SO:0000841": {
            "name": "spliceosomal_intron_region",
            "def": "A region within an intron. [SO:ke]"
          },
          "SO:0000842": {
            "name": "gene_component_region"
          },
          "SO:0000843": {
            "name": "bacterial_RNApol_promoter_region",
            "def": "A region which is part of a bacterial RNA polymerase promoter. [SO:ke]"
          },
          "SO:0000844": {
            "name": "RNApol_II_promoter_region",
            "def": "A region of sequence which is a promoter for RNA polymerase II. [SO:ke]"
          },
          "SO:0000845": {
            "name": "RNApol_III_promoter_type_1_region",
            "def": "A region of sequence which is a promoter for RNA polymerase III type 1. [SO:ke]"
          },
          "SO:0000846": {
            "name": "RNApol_III_promoter_type_2_region",
            "def": "A region of sequence which is a promoter for RNA polymerase III type 2. [SO:ke]"
          },
          "SO:0000847": {
            "name": "tmRNA_region",
            "def": "A region of a tmRNA. [SO:cb]"
          },
          "SO:0000848": {
            "name": "LTR_component"
          },
          "SO:0000849": {
            "name": "three_prime_LTR_component"
          },
          "SO:0000850": {
            "name": "five_prime_LTR_component"
          },
          "SO:0000851": {
            "name": "CDS_region",
            "def": "A region of a CDS. [SO:cb]"
          },
          "SO:0000852": {
            "name": "exon_region",
            "def": "A region of an exon. [RSC:cb]"
          },
          "SO:0000853": {
            "name": "homologous_region",
            "def": "A region that is homologous to another region. [SO:ke]"
          },
          "SO:0000854": {
            "name": "paralogous_region",
            "def": "A homologous_region that is paralogous to another region. [SO:ke]"
          },
          "SO:0000855": {
            "name": "orthologous_region",
            "def": "A homologous_region that is orthologous to another region. [SO:ke]"
          },
          "SO:0000856": {
            "name": "conserved"
          },
          "SO:0000857": {
            "name": "homologous",
            "def": "Similarity due to common ancestry. [SO:ke]"
          },
          "SO:0000858": {
            "name": "orthologous",
            "def": "An attribute describing a kind of homology where divergence occurred after a speciation event. [SO:ke]"
          },
          "SO:0000859": {
            "name": "paralogous",
            "def": "An attribute describing a kind of homology where divergence occurred after a duplication event. [SO:ke]"
          },
          "SO:0000860": {
            "name": "syntenic",
            "def": "Attribute describing sequence regions occurring in same order on chromosome of different species. [SO:ke]"
          },
          "SO:0000861": {
            "name": "capped_primary_transcript",
            "def": "A primary transcript that is capped. [SO:xp]"
          },
          "SO:0000862": {
            "name": "capped_mRNA",
            "def": "An mRNA that is capped. [SO:xp]"
          },
          "SO:0000863": {
            "name": "mRNA_attribute",
            "def": "An attribute describing an mRNA feature. [SO:ke]"
          },
          "SO:0000864": {
            "name": "exemplar",
            "def": "An attribute describing a sequence is representative of a class of similar sequences. [SO:ke]"
          },
          "SO:0000865": {
            "name": "frameshift",
            "def": "An attribute describing a sequence that contains a mutation involving the deletion or insertion of one or more bases, where this number is not divisible by 3. [SO:ke]"
          },
          "SO:0000866": {
            "name": "minus_1_frameshift",
            "def": "A frameshift caused by deleting one base. [SO:ke]"
          },
          "SO:0000867": {
            "name": "minus_2_frameshift",
            "def": "A frameshift caused by deleting two bases. [SO:ke]"
          },
          "SO:0000868": {
            "name": "plus_1_frameshift",
            "def": "A frameshift caused by inserting one base. [SO:ke]"
          },
          "SO:0000869": {
            "name": "plus_2_framshift",
            "def": "A frameshift caused by inserting two bases. [SO:ke]"
          },
          "SO:0000870": {
            "name": "trans_spliced",
            "def": "An attribute describing transcript sequence that is created by splicing exons from diferent genes. [SO:ke]"
          },
          "SO:0000871": {
            "name": "polyadenylated_mRNA",
            "def": "An mRNA that is polyadenylated. [SO:xp]"
          },
          "SO:0000872": {
            "name": "trans_spliced_mRNA",
            "def": "An mRNA that is trans-spliced. [SO:xp]"
          },
          "SO:0000873": {
            "name": "edited_transcript",
            "def": "A transcript that is edited. [SO:ke]"
          },
          "SO:0000874": {
            "name": "edited_transcript_by_A_to_I_substitution",
            "def": "A transcript that has been edited by A to I substitution. [SO:ke]"
          },
          "SO:0000875": {
            "name": "bound_by_protein",
            "def": "An attribute describing a sequence that is bound by a protein. [SO:ke]"
          },
          "SO:0000876": {
            "name": "bound_by_nucleic_acid",
            "def": "An attribute describing a sequence that is bound by a nucleic acid. [SO:ke]"
          },
          "SO:0000877": {
            "name": "alternatively_spliced",
            "def": "An attribute describing a situation where a gene may encode for more than 1 transcript. [SO:ke]"
          },
          "SO:0000878": {
            "name": "monocistronic",
            "def": "An attribute describing a sequence that contains the code for one gene product. [SO:ke]"
          },
          "SO:0000879": {
            "name": "dicistronic",
            "def": "An attribute describing a sequence that contains the code for two gene products. [SO:ke]"
          },
          "SO:0000880": {
            "name": "polycistronic",
            "def": "An attribute describing a sequence that contains the code for more than one gene product. [SO:ke]"
          },
          "SO:0000881": {
            "name": "recoded",
            "def": "An attribute describing an mRNA sequence that has been reprogrammed at translation, causing localized alterations. [SO:ke]"
          },
          "SO:0000882": {
            "name": "codon_redefined",
            "def": "An attribute describing the alteration of codon meaning. [SO:ke]"
          },
          "SO:0000883": {
            "name": "stop_codon_read_through",
            "def": "A stop codon redefined to be a new amino acid. [SO:ke]"
          },
          "SO:0000884": {
            "name": "stop_codon_redefined_as_pyrrolysine",
            "def": "A stop codon redefined to be the new amino acid, pyrrolysine. [SO:ke]"
          },
          "SO:0000885": {
            "name": "stop_codon_redefined_as_selenocysteine",
            "def": "A stop codon redefined to be the new amino acid, selenocysteine. [SO:ke]"
          },
          "SO:0000886": {
            "name": "recoded_by_translational_bypass",
            "def": "Recoded mRNA where a block of nucleotides is not translated. [SO:ke]"
          },
          "SO:0000887": {
            "name": "translationally_frameshifted",
            "def": "Recoding by frameshifting a particular site. [SO:ke]"
          },
          "SO:0000888": {
            "name": "maternally_imprinted_gene",
            "def": "A gene that is maternally_imprinted. [SO:xp]"
          },
          "SO:0000889": {
            "name": "paternally_imprinted_gene",
            "def": "A gene that is paternally imprinted. [SO:xp]"
          },
          "SO:0000890": {
            "name": "post_translationally_regulated_gene",
            "def": "A gene that is post translationally regulated. [SO:xp]"
          },
          "SO:0000891": {
            "name": "negatively_autoregulated_gene",
            "def": "A gene that is negatively autoreguated. [SO:xp]"
          },
          "SO:0000892": {
            "name": "positively_autoregulated_gene",
            "def": "A gene that is positively autoregulated. [SO:xp]"
          },
          "SO:0000893": {
            "name": "silenced",
            "def": "An attribute describing an epigenetic process where a gene is inactivated at transcriptional or translational level. [SO:ke]"
          },
          "SO:0000894": {
            "name": "silenced_by_DNA_modification",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by DNA modifications, resulting in repression of transcription. [SO:ke]"
          },
          "SO:0000895": {
            "name": "silenced_by_DNA_methylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by DNA methylation, resulting in repression of transcription. [SO:ke]"
          },
          "SO:0000896": {
            "name": "translationally_regulated_gene",
            "def": "A gene that is translationally regulated. [SO:xp]"
          },
          "SO:0000897": {
            "name": "allelically_excluded_gene",
            "def": "A gene that is allelically_excluded. [SO:xp]"
          },
          "SO:0000898": {
            "name": "epigenetically_modified_gene",
            "def": "A gene that is epigenetically modified. [SO:ke]"
          },
          "SO:0000899": {
            "name": "nuclear_mitochondrial",
            "def": "An attribute describing a nuclear pseudogene of a mitochndrial gene. [SO:ke]"
          },
          "SO:0000900": {
            "name": "processed",
            "def": "An attribute describing a pseudogene where by an mRNA was retrotransposed. The mRNA sequence is transcribed back into the genome, lacking introns and promotors, but often including a polyA tail. [SO:ke]"
          },
          "SO:0000901": {
            "name": "unequally_crossed_over",
            "def": "An attribute describing a pseudogene that was created by tandem duplication and unequal crossing over during recombination. [SO:ke]"
          },
          "SO:0000902": {
            "name": "transgene",
            "def": "A transgene is a gene that has been transferred naturally or by any of a number of genetic engineering techniques from one organism to another. [SO:xp]"
          },
          "SO:0000903": {
            "name": "endogenous_retroviral_sequence"
          },
          "SO:0000904": {
            "name": "rearranged_at_DNA_level",
            "def": "An attribute to describe the sequence of a feature, where the DNA is rearranged. [SO:ke]"
          },
          "SO:0000905": {
            "name": "status",
            "def": "An attribute describing the status of a feature, based on the available evidence. [SO:ke]"
          },
          "SO:0000906": {
            "name": "independently_known",
            "def": "Attribute to describe a feature that is independently known - not predicted. [SO:ke]"
          },
          "SO:0000907": {
            "name": "supported_by_sequence_similarity",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity techniques. [SO:ke]"
          },
          "SO:0000908": {
            "name": "supported_by_domain_match",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity of a known domain. [SO:ke]"
          },
          "SO:0000909": {
            "name": "supported_by_EST_or_cDNA",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity to EST or cDNA data. [SO:ke]"
          },
          "SO:0000910": {
            "name": "orphan"
          },
          "SO:0000911": {
            "name": "predicted_by_ab_initio_computation",
            "def": "An attribute describing a feature that is predicted by a computer program that did not rely on sequence similarity. [SO:ke]"
          },
          "SO:0000912": {
            "name": "asx_turn",
            "def": "A motif of three consecutive residues and one H-bond in which: residue(i) is Aspartate or Asparagine (Asx), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2). [http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0000913": {
            "name": "cloned_cDNA_insert",
            "def": "A clone insert made from cDNA. [SO:xp]"
          },
          "SO:0000914": {
            "name": "cloned_genomic_insert",
            "def": "A clone insert made from genomic DNA. [SO:xp]"
          },
          "SO:0000915": {
            "name": "engineered_insert",
            "def": "A clone insert that is engineered. [SO:xp]"
          },
          "SO:0000916": {
            "name": "edit_operation"
          },
          "SO:0000917": {
            "name": "insert_U",
            "def": "An edit to insert a U. [SO:ke]"
          },
          "SO:0000918": {
            "name": "delete_U",
            "def": "An edit to delete a uridine. [SO:ke]"
          },
          "SO:0000919": {
            "name": "substitute_A_to_I",
            "def": "An edit to substitute an I for an A. [SO:ke]"
          },
          "SO:0000920": {
            "name": "insert_C",
            "def": "An edit to insert a cytidine. [SO:ke]"
          },
          "SO:0000921": {
            "name": "insert_dinucleotide",
            "def": "An edit to insert a dinucleotide. [SO:ke]"
          },
          "SO:0000922": {
            "name": "substitute_C_to_U",
            "def": "An edit to substitute an U for a C. [SO:ke]"
          },
          "SO:0000923": {
            "name": "insert_G",
            "def": "An edit to insert a G. [SO:ke]"
          },
          "SO:0000924": {
            "name": "insert_GC",
            "def": "An edit to insert a GC dinucleotide. [SO:ke]"
          },
          "SO:0000925": {
            "name": "insert_GU",
            "def": "An edit to insert a GU dinucleotide. [SO:ke]"
          },
          "SO:0000926": {
            "name": "insert_CU",
            "def": "An edit to insert a CU dinucleotide. [SO:ke]"
          },
          "SO:0000927": {
            "name": "insert_AU",
            "def": "An edit to insert a AU dinucleotide. [SO:ke]"
          },
          "SO:0000928": {
            "name": "insert_AA",
            "def": "An edit to insert a AA dinucleotide. [SO:ke]"
          },
          "SO:0000929": {
            "name": "edited_mRNA",
            "def": "An mRNA that is edited. [SO:xp]"
          },
          "SO:0000930": {
            "name": "guide_RNA_region",
            "def": "A region of guide RNA. [SO:ma]"
          },
          "SO:0000931": {
            "name": "anchor_region",
            "def": "A region of a guide_RNA that base-pairs to a target mRNA. [SO:jk]"
          },
          "SO:0000932": {
            "name": "pre_edited_mRNA"
          },
          "SO:0000933": {
            "name": "intermediate",
            "def": "An attribute to describe a feature between stages of processing. [SO:ke]"
          },
          "SO:0000934": {
            "name": "miRNA_target_site",
            "def": "A miRNA target site is a binding site where the molecule is a micro RNA. [FB:cds]"
          },
          "SO:0000935": {
            "name": "edited_CDS",
            "def": "A CDS that is edited. [SO:xp]"
          },
          "SO:0000936": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_rearranged_segment"
          },
          "SO:0000937": {
            "name": "vertebrate_immune_system_feature"
          },
          "SO:0000938": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_rearranged_gene_cluster"
          },
          "SO:0000939": {
            "name": "vertebrate_immune_system_gene_recombination_signal_feature"
          },
          "SO:0000940": {
            "name": "recombinationally_rearranged"
          },
          "SO:0000941": {
            "name": "recombinationally_rearranged_vertebrate_immune_system_gene",
            "def": "A recombinationally rearranged gene of the vertebrate immune system. [SO:xp]"
          },
          "SO:0000942": {
            "name": "attP_site",
            "def": "An integration/excision site of a phage chromosome at which a recombinase acts to insert the phage DNA at a cognate integration/excision site on a bacterial chromosome. [SO:as]"
          },
          "SO:0000943": {
            "name": "attB_site",
            "def": "An integration/excision site of a bacterial chromosome at which a recombinase acts to insert foreign DNA containing a cognate integration/excision site. [SO:as]"
          },
          "SO:0000944": {
            "name": "attL_site",
            "def": "A region that results from recombination between attP_site and attB_site, composed of the 5' portion of attB_site and the 3' portion of attP_site. [SO:as]"
          },
          "SO:0000945": {
            "name": "attR_site",
            "def": "A region that results from recombination between attP_site and attB_site, composed of the 5' portion of attP_site and the 3' portion of attB_site. [SO:as]"
          },
          "SO:0000946": {
            "name": "integration_excision_site",
            "def": "A region specifically recognised by a recombinase, which inserts or removes another region marked by a distinct cognate integration/excision site. [SO:as]"
          },
          "SO:0000947": {
            "name": "resolution_site",
            "def": "A region specifically recognized by a recombinase, which separates a physically contiguous circle of DNA into two physically separate circles. [SO:as]"
          },
          "SO:0000948": {
            "name": "inversion_site",
            "def": "A region specifically recognised by a recombinase, which inverts the region flanked by a pair of sites. [SO:ma]"
          },
          "SO:0000949": {
            "name": "dif_site",
            "def": "A site at which replicated bacterial circular chromosomes are decatenated by site specific resolvase. [SO:as]"
          },
          "SO:0000950": {
            "name": "attC_site",
            "def": "An attC site is a sequence required for the integration of a DNA of an integron. [SO:as]"
          },
          "SO:0000951": {
            "name": "eukaryotic_terminator"
          },
          "SO:0000952": {
            "name": "oriV",
            "def": "An origin of vegetative replication in plasmids and phages. [SO:as]"
          },
          "SO:0000953": {
            "name": "oriC",
            "def": "An origin of bacterial chromosome replication. [SO:as]"
          },
          "SO:0000954": {
            "name": "DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, DNA molecule. [SO:ma]"
          },
          "SO:0000955": {
            "name": "double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded DNA molecule. [SO:ma]"
          },
          "SO:0000956": {
            "name": "single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded DNA molecule. [SO:ma]"
          },
          "SO:0000957": {
            "name": "linear_double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, linear DNA molecule. [SO:ma]"
          },
          "SO:0000958": {
            "name": "circular_double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, circular DNA molecule. [SO:ma]"
          },
          "SO:0000959": {
            "name": "linear_single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, linear DNA molecule. [SO:ma]"
          },
          "SO:0000960": {
            "name": "circular_single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, circular DNA molecule. [SO:ma]"
          },
          "SO:0000961": {
            "name": "RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, RNA molecule. [SO:ma]"
          },
          "SO:0000962": {
            "name": "single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded RNA molecule. [SO:ma]"
          },
          "SO:0000963": {
            "name": "linear_single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, linear RNA molecule. [SO:ma]"
          },
          "SO:0000964": {
            "name": "linear_double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, linear RNA molecule. [SO:ma]"
          },
          "SO:0000965": {
            "name": "double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded RNA molecule. [SO:ma]"
          },
          "SO:0000966": {
            "name": "circular_single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, circular DNA molecule. [SO:ma]"
          },
          "SO:0000967": {
            "name": "circular_double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, circular RNA molecule. [SO:ma]"
          },
          "SO:0000968": {
            "name": "sequence_replication_mode"
          },
          "SO:0000969": {
            "name": "rolling_circle"
          },
          "SO:0000970": {
            "name": "theta_replication"
          },
          "SO:0000971": {
            "name": "DNA_replication_mode"
          },
          "SO:0000972": {
            "name": "RNA_replication_mode"
          },
          "SO:0000973": {
            "name": "insertion_sequence",
            "def": "A terminal_inverted_repeat_element that is bacterial and only encodes the functions required for its transposition between these inverted repeats. [SO:as]"
          },
          "SO:0000975": {
            "name": "minicircle_gene"
          },
          "SO:0000976": {
            "name": "cryptic",
            "def": "A feature_attribute describing a feature that is not manifest under normal conditions. [SO:ke]"
          },
          "SO:0000977": {
            "name": "anchor_binding_site"
          },
          "SO:0000978": {
            "name": "template_region",
            "def": "A region of a guide_RNA that specifies the insertions and deletions of bases in the editing of a target mRNA. [SO:jk]"
          },
          "SO:0000979": {
            "name": "gRNA_encoding",
            "def": "A non-protein_coding gene that encodes a guide_RNA. [SO:ma]"
          },
          "SO:0000980": {
            "name": "minicircle",
            "def": "A minicircle is a replicon, part of a kinetoplast, that encodes for guide RNAs. [PMID:8395055]"
          },
          "SO:0000981": {
            "name": "rho_dependent_bacterial_terminator"
          },
          "SO:0000982": {
            "name": "rho_independent_bacterial_terminator"
          },
          "SO:0000983": {
            "name": "strand_attribute"
          },
          "SO:0000984": {
            "name": "single"
          },
          "SO:0000985": {
            "name": "double"
          },
          "SO:0000986": {
            "name": "topology_attribute"
          },
          "SO:0000987": {
            "name": "linear",
            "def": "A quality of a nucleotide polymer that has a 3'-terminal residue and a 5'-terminal residue. [SO:cb]"
          },
          "SO:0000988": {
            "name": "circular",
            "def": "A quality of a nucleotide polymer that has no terminal nucleotide residues. [SO:cb]"
          },
          "SO:0000989": {
            "name": "class_II_RNA",
            "def": "Small non-coding RNA (59-60 nt long) containing 5' and 3' ends that are predicted to come together to form a stem structure. Identified in the social amoeba Dictyostelium discoideum and localized in the cytoplasm. [PMID:15333696]"
          },
          "SO:0000990": {
            "name": "class_I_RNA",
            "def": "Small non-coding RNA (55-65 nt long) containing highly conserved 5' and 3' ends (16 and 8 nt, respectively) that are predicted to come together to form a stem structure. Identified in the social amoeba Dictyostelium discoideum and localized in the cytoplasm. [PMID:15333696]"
          },
          "SO:0000991": {
            "name": "genomic_DNA"
          },
          "SO:0000992": {
            "name": "BAC_cloned_genomic_insert"
          },
          "SO:0000993": {
            "name": "consensus"
          },
          "SO:0000994": {
            "name": "consensus_region"
          },
          "SO:0000995": {
            "name": "consensus_mRNA"
          },
          "SO:0000996": {
            "name": "predicted_gene"
          },
          "SO:0000997": {
            "name": "gene_fragment"
          },
          "SO:0000998": {
            "name": "recursive_splice_site",
            "def": "A recursive splice site is a splice site which subdivides a large intron. Recursive splicing is a mechanism that splices large introns by sub dividing the intron at non exonic elements and alternate exons. [http://www.genetics.org/cgi/content/full/170/2/661]"
          },
          "SO:0000999": {
            "name": "BAC_end",
            "def": "A region of sequence from the end of a BAC clone that may provide a highly specific marker. [SO:ke]"
          },
          "SO:0001000": {
            "name": "rRNA_16S",
            "def": "A large polynucleotide in Bacteria and Archaea, which functions as the small subunit of the ribosome. [SO:ke]"
          },
          "SO:0001001": {
            "name": "rRNA_23S",
            "def": "A large polynucleotide in Bacteria and Archaea, which functions as the large subunit of the ribosome. [SO:ke]"
          },
          "SO:0001002": {
            "name": "rRNA_25S",
            "def": "A large polynucleotide which functions as part of the large subunit of the ribosome in some eukaryotes. [RSC:cb]"
          },
          "SO:0001003": {
            "name": "solo_LTR",
            "def": "A recombination product between the 2 LTR of the same element. [SO:ke]"
          },
          "SO:0001004": {
            "name": "low_complexity"
          },
          "SO:0001005": {
            "name": "low_complexity_region"
          },
          "SO:0001006": {
            "name": "prophage",
            "def": "A phage genome after it has established in the host genome in a latent/immune state either as a plasmid or as an integrated \\island\\. [GOC:jl]"
          },
          "SO:0001007": {
            "name": "cryptic_prophage",
            "def": "A remnant of an integrated prophage in the host genome or an \\island\\ in the host genome that includes phage like-genes. [GOC:jl]"
          },
          "SO:0001008": {
            "name": "tetraloop",
            "def": "A base-paired stem with loop of 4 non-hydrogen bonded nucleotides. [SO:ke]"
          },
          "SO:0001009": {
            "name": "DNA_constraint_sequence",
            "def": "A double-stranded DNA used to control macromolecular structure and function. [http:/www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=search&db=pubmed&term=SILVERMAN+SK[au\\]&dispmax=50]"
          },
          "SO:0001010": {
            "name": "i_motif",
            "def": "A cytosine rich domain whereby strands associate both inter- and intramolecularly at moderately acidic pH. [PMID:9753739]"
          },
          "SO:0001011": {
            "name": "PNA_oligo",
            "def": "Peptide nucleic acid, is a chemical not known to occur naturally but is artificially synthesized and used in some biological research and medical treatments. The PNA backbone is composed of repeating N-(2-aminoethyl)-glycine units linked by peptide bonds. The purine and pyrimidine bases are linked to the backbone by methylene carbonyl bonds. [SO:ke]"
          },
          "SO:0001012": {
            "name": "DNAzyme",
            "def": "A DNA sequence with catalytic activity. [SO:cb]"
          },
          "SO:0001013": {
            "name": "MNP",
            "def": "A multiple nucleotide polymorphism with alleles of common length > 1, for example AAA/TTT. [http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs=rs2067431]"
          },
          "SO:0001014": {
            "name": "intron_domain"
          },
          "SO:0001015": {
            "name": "wobble_base_pair",
            "def": "A type of non-canonical base pairing, most commonly between G and U, which is important for the secondary structure of RNAs. It has similar thermodynamic stability to the Watson-Crick pairing. Wobble base pairs only have two hydrogen bonds. Other wobble base pair possibilities are I-A, I-U and I-C. [PMID:11256617]"
          },
          "SO:0001016": {
            "name": "internal_guide_sequence",
            "def": "A purine-rich sequence in the group I introns which determines the locations of the splice sites in group I intron splicing and has catalytic activity. [SO:cb]"
          },
          "SO:0001017": {
            "name": "silent_mutation",
            "def": "A sequence variant that does not affect protein function. Silent mutations may occur in genic ( CDS, UTR, intron etc) and intergenic regions. Silent mutations may have affects on processes such as splicing and regulation. [SO:ke]"
          },
          "SO:0001018": {
            "name": "epitope",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with antibodies, B cells or T cells. [http://en.wikipedia.org/wiki/Epitope, SO:cb]"
          },
          "SO:0001019": {
            "name": "copy_number_variation",
            "def": "A variation that increases or decreases the copy number of a given region. [SO:ke]"
          },
          "SO:0001020": {
            "name": "sequence_variant_affecting_copy_number"
          },
          "SO:0001021": {
            "name": "chromosome_breakpoint"
          },
          "SO:0001022": {
            "name": "inversion_breakpoint",
            "def": "The point within a chromosome where an inversion begins or ends. [SO:cb]"
          },
          "SO:0001023": {
            "name": "allele",
            "def": "An allele is one of a set of coexisting sequence variants of a gene. [SO:immuno_workshop]"
          },
          "SO:0001024": {
            "name": "haplotype",
            "def": "A haplotype is one of a set of coexisting sequence variants of a haplotype block. [SO:immuno_workshop]"
          },
          "SO:0001025": {
            "name": "polymorphic_sequence_variant",
            "def": "A sequence variant that is segregating in one or more natural populations of a species. [SO:immuno_workshop]"
          },
          "SO:0001026": {
            "name": "genome",
            "def": "A genome is the sum of genetic material within a cell or virion. [SO:immuno_workshop]"
          },
          "SO:0001027": {
            "name": "genotype",
            "def": "A genotype is a variant genome, complete or incomplete. [SO:immuno_workshop]"
          },
          "SO:0001028": {
            "name": "diplotype",
            "def": "A diplotype is a pair of haplotypes from a given individual. It is a genotype where the phase is known. [SO:immuno_workshop]"
          },
          "SO:0001029": {
            "name": "direction_attribute"
          },
          "SO:0001030": {
            "name": "forward",
            "def": "Forward is an attribute of the feature, where the feature is in the 5' to 3' direction. [SO:ke]"
          },
          "SO:0001031": {
            "name": "reverse",
            "def": "Reverse is an attribute of the feature, where the feature is in the 3' to 5' direction. Again could be applied to primer. [SO:ke]"
          },
          "SO:0001032": {
            "name": "mitochondrial_DNA"
          },
          "SO:0001033": {
            "name": "chloroplast_DNA"
          },
          "SO:0001034": {
            "name": "miRtron",
            "def": "A de-branched intron which mimics the structure of pre-miRNA and enters the miRNA processing pathway without Drosha mediated cleavage. [PMID:17589500, SO:ma]"
          },
          "SO:0001035": {
            "name": "piRNA",
            "def": "A small non coding RNA, part of a silencing system that prevents the spreading of selfish genetic elements. [SO:ke]"
          },
          "SO:0001036": {
            "name": "arginyl_tRNA",
            "def": "A tRNA sequence that has an arginine anticodon, and a 3' arginine binding region. [SO:ke]"
          },
          "SO:0001037": {
            "name": "mobile_genetic_element",
            "def": "A nucleotide region with either intra-genome or intracellular mobility, of varying length, which often carry the information necessary for transfer and recombination with the host genome. [PMID:14681355]"
          },
          "SO:0001038": {
            "name": "extrachromosomal_mobile_genetic_element",
            "def": "An MGE that is not integrated into the host chromosome. [SO:ke]"
          },
          "SO:0001039": {
            "name": "integrated_mobile_genetic_element",
            "def": "An MGE that is integrated into the host chromosome. [SO:ke]"
          },
          "SO:0001040": {
            "name": "integrated_plasmid",
            "def": "A plasmid sequence that is integrated within the host chromosome. [SO:ke]"
          },
          "SO:0001041": {
            "name": "viral_sequence",
            "def": "The region of nucleotide sequence of a virus, a submicroscopic particle that replicates by infecting a host cell. [SO:ke]"
          },
          "SO:0001042": {
            "name": "phage_sequence",
            "def": "The nucleotide sequence of a virus that infects bacteria. [SO:ke]"
          },
          "SO:0001043": {
            "name": "attCtn_site",
            "def": "An attachment site located on a conjugative transposon and used for site-specific integration of a conjugative transposon. [Phigo:at]"
          },
          "SO:0001044": {
            "name": "nuclear_mt_pseudogene",
            "def": "A nuclear pseudogene of either coding or non-coding mitochondria derived sequence. [SO:xp]"
          },
          "SO:0001045": {
            "name": "cointegrated_plasmid",
            "def": "A MGE region consisting of two fused plasmids resulting from a replicative transposition event. [phigo:at]"
          },
          "SO:0001046": {
            "name": "IRLinv_site",
            "def": "Component of the inversion site located at the left of a region susceptible to site-specific inversion. [Phigo:at]"
          },
          "SO:0001047": {
            "name": "IRRinv_site",
            "def": "Component of the inversion site located at the right of a region susceptible to site-specific inversion. [Phigo:at]"
          },
          "SO:0001048": {
            "name": "inversion_site_part",
            "def": "A region located within an inversion site. [SO:ke]"
          },
          "SO:0001049": {
            "name": "defective_conjugative_transposon",
            "def": "An island that contains genes for integration/excision and the gene and site for the initiation of intercellular transfer by conjugation. It can be complemented for transfer by a conjugative transposon. [Phigo:ariane]"
          },
          "SO:0001050": {
            "name": "repeat_fragment",
            "def": "A portion of a repeat, interrupted by the insertion of another element. [SO:ke]"
          },
          "SO:0001051": {
            "name": "nested_region"
          },
          "SO:0001052": {
            "name": "nested_repeat"
          },
          "SO:0001053": {
            "name": "nested_transposon"
          },
          "SO:0001054": {
            "name": "transposon_fragment",
            "def": "A portion of a transposon, interrupted by the insertion of another element. [SO:ke]"
          },
          "SO:0001055": {
            "name": "transcriptional_cis_regulatory_region",
            "def": "A regulatory_region that modulates the transcription of a gene or genes. [PMID:9679020, SO:regcreative]"
          },
          "SO:0001056": {
            "name": "splicing_regulatory_region",
            "def": "A regulatory_region that modulates splicing. [SO:ke]"
          },
          "SO:0001057": {
            "name": "enhanceosome"
          },
          "SO:0001058": {
            "name": "promoter_targeting_sequence",
            "def": "A transcriptional_cis_regulatory_region that restricts the activity of a CRM to a single promoter and which functions only when both itself and an insulator are located between the CRM and the promoter. [SO:regcreative]"
          },
          "SO:0001059": {
            "name": "sequence_alteration",
            "def": "A sequence_alteration is a sequence_feature whose extent is the deviation from another sequence. [SO:ke]"
          },
          "SO:0001060": {
            "name": "sequence_variant",
            "def": "A sequence_variant is a non exact copy of a sequence_feature or genome exhibiting one or more sequence_alteration. [SO:ke]"
          },
          "SO:0001061": {
            "name": "propeptide_cleavage_site",
            "def": "The propeptide_cleavage_site is the arginine/lysine boundary on a propeptide where cleavage occurs. [EBIBS:GAR]"
          },
          "SO:0001062": {
            "name": "propeptide",
            "def": "Part of a peptide chain which is cleaved off during the formation of the mature protein. [EBIBS:GAR]"
          },
          "SO:0001063": {
            "name": "immature_peptide_region",
            "def": "An immature_peptide_region is the extent of the peptide after it has been translated and before any processing occurs. [EBIBS:GAR]"
          },
          "SO:0001064": {
            "name": "active_peptide",
            "def": "Active peptides are proteins which are biologically active, released from a precursor molecule. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001066": {
            "name": "compositionally_biased_region_of_peptide",
            "def": "Polypeptide region that is rich in a particular amino acid or homopolymeric and greater than three residues in length. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001067": {
            "name": "polypeptide_motif",
            "def": "A sequence motif is a short (up to 20 amino acids) region of biological interest. Such motifs, although they are too short to constitute functional domains, share sequence similarities and are conserved in different proteins. They display a common function (protein-binding, subcellular location etc.). [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001068": {
            "name": "polypeptide_repeat",
            "def": "A polypeptide_repeat is a single copy of an internal sequence repetition. [EBIBS:GAR]"
          },
          "SO:0001070": {
            "name": "polypeptide_structural_region",
            "def": "Region of polypeptide with a given structural property. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001071": {
            "name": "membrane_structure",
            "def": "Arrangement of the polypeptide with respect to the lipid bilayer. [EBIBS:GAR]"
          },
          "SO:0001072": {
            "name": "extramembrane_polypeptide_region",
            "def": "Polypeptide region that is localized outside of a lipid bilayer. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001073": {
            "name": "cytoplasmic_polypeptide_region",
            "def": "Polypeptide region that is localized inside the cytoplasm. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001074": {
            "name": "non_cytoplasmic_polypeptide_region",
            "def": "Polypeptide region that is localized outside of a lipid bilayer and outside of the cytoplasm. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001075": {
            "name": "intramembrane_polypeptide_region",
            "def": "Polypeptide region present in the lipid bilayer. [EBIBS:GAR]"
          },
          "SO:0001076": {
            "name": "membrane_peptide_loop",
            "def": "Polypeptide region localized within the lipid bilayer where both ends traverse the same membrane. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001077": {
            "name": "transmembrane_polypeptide_region",
            "def": "Polypeptide region traversing the lipid bilayer. [EBIBS:GAR, UniProt:curator_manual]"
          },
          "SO:0001078": {
            "name": "polypeptide_secondary_structure",
            "def": "A region of peptide with secondary structure has hydrogen bonding along the peptide chain that causes a defined conformation of the chain. [EBIBS:GAR]"
          },
          "SO:0001079": {
            "name": "polypeptide_structural_motif",
            "def": "Motif is a three-dimensional structural element within the chain, which appears also in a variety of other molecules. Unlike a domain, a motif does not need to form a stable globular unit. [EBIBS:GAR]"
          },
          "SO:0001080": {
            "name": "coiled_coil",
            "def": "A coiled coil is a structural motif in proteins, in which alpha-helices are coiled together like the strands of a rope. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001081": {
            "name": "helix_turn_helix",
            "def": "A motif comprising two helices separated by a turn. [EBIBS:GAR]"
          },
          "SO:0001082": {
            "name": "polypeptide_sequencing_information",
            "def": "Incompatibility in the sequence due to some experimental problem. [EBIBS:GAR]"
          },
          "SO:0001083": {
            "name": "non_adjacent_residues",
            "def": "Indicates that two consecutive residues in a fragment sequence are not consecutive in the full-length protein and that there are a number of unsequenced residues between them. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001084": {
            "name": "non_terminal_residue",
            "def": "The residue at an extremity of the sequence is not the terminal residue. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001085": {
            "name": "sequence_conflict",
            "def": "Different sources report differing sequences. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001086": {
            "name": "sequence_uncertainty",
            "def": "Describes the positions in a sequence where the authors are unsure about the sequence assignment. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001087": {
            "name": "cross_link",
            "def": "Posttranslationally formed amino acid bonds. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001088": {
            "name": "disulfide_bond",
            "def": "The covalent bond between sulfur atoms that binds two peptide chains or different parts of one peptide chain and is a structural determinant in many protein molecules. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001089": {
            "name": "post_translationally_modified_region",
            "def": "A region where a transformation occurs in a protein after it has been synthesized. This which may regulate, stabilize, crosslink or introduce new chemical functionalities in the protein. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001090": {
            "name": "covalent_binding_site",
            "def": "Binding involving a covalent bond. [EBIBS:GAR]"
          },
          "SO:0001091": {
            "name": "non_covalent_binding_site",
            "def": "Binding site for any chemical group (co-enzyme, prosthetic group, etc.). [EBIBS:GAR]"
          },
          "SO:0001092": {
            "name": "polypeptide_metal_contact",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with metal ions. [EBIBS:GAR, SO:cb, UniProt:curation_manual]"
          },
          "SO:0001093": {
            "name": "protein_protein_contact",
            "def": "A binding site that, in the protein molecule, interacts selectively and non-covalently with polypeptide residues. [EBIBS:GAR, UniProt:Curation_manual]"
          },
          "SO:0001094": {
            "name": "polypeptide_calcium_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with calcium ions. [EBIBS:GAR]"
          },
          "SO:0001095": {
            "name": "polypeptide_cobalt_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with cobalt ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001096": {
            "name": "polypeptide_copper_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with copper ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001097": {
            "name": "polypeptide_iron_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with iron ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001098": {
            "name": "polypeptide_magnesium_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with magnesium ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001099": {
            "name": "polypeptide_manganese_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with manganese ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001100": {
            "name": "polypeptide_molybdenum_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with molybdenum ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001101": {
            "name": "polypeptide_nickel_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with nickel ions. [EBIBS:GAR]"
          },
          "SO:0001102": {
            "name": "polypeptide_tungsten_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with tungsten ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001103": {
            "name": "polypeptide_zinc_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with zinc ions. [EBIBS:GAR, SO:cb]"
          },
          "SO:0001104": {
            "name": "catalytic_residue",
            "def": "Amino acid involved in the activity of an enzyme. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001105": {
            "name": "polypeptide_ligand_contact",
            "def": "Residues which interact with a ligand. [EBIBS:GAR]"
          },
          "SO:0001106": {
            "name": "asx_motif",
            "def": "A motif of five consecutive residues and two H-bonds in which: Residue(i) is Aspartate or Asparagine (Asx), side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2) or (i+3), main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+3) or (i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001107": {
            "name": "beta_bulge",
            "def": "A motif of three residues within a beta-sheet in which the main chains of two consecutive residues are H-bonded to that of the third, and in which the dihedral angles are as follows: Residue(i): -140 degrees < phi(l) -20 degrees , -90 degrees < psi(l) < 40 degrees. Residue (i+1): -180 degrees < phi < -25 degrees or +120 degrees < phi < +180 degrees, +40 degrees < psi < +180 degrees or -180 degrees < psi < -120 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001108": {
            "name": "beta_bulge_loop",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds. Beta bulge loops often occur at the loop ends of beta-hairpins. [EBIBS:GAR, Http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001109": {
            "name": "beta_bulge_loop_five",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds in which: the main-chain NH of residue(i) is H-bonded to the main-chain CO of residue(i+4), the main-chain CO of residue i is H-bonded to the main-chain NH of residue(i+3), these loops have an RL nest at residues i+2 and i+3. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001110": {
            "name": "beta_bulge_loop_six",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds in which: the main-chain NH of residue(i) is H-bonded to the main-chain CO of residue(i+5), the main-chain CO of residue i is H-bonded to the main-chain NH of residue(i+4), these loops have an RL nest at residues i+3 and i+4. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001111": {
            "name": "beta_strand",
            "def": "A beta strand describes a single length of polypeptide chain that forms part of a beta sheet. A single continuous stretch of amino acids adopting an extended conformation of hydrogen bonds between the N-O and the C=O of another part of the peptide. This forms a secondary protein structure in which two or more extended polypeptide regions are hydrogen-bonded to one another in a planar array. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001112": {
            "name": "antiparallel_beta_strand",
            "def": "A peptide region which hydrogen bonded to another region of peptide running in the oposite direction (one running N-terminal to C-terminal and one running C-terminal to N-terminal). Hydrogen bonding occurs between every other C=O from one strand to every other N-H on the adjacent strand. In this case, if two atoms C-alpha (i) and C-alpha (j) are adjacent in two hydrogen-bonded beta strands, then they form two mutual backbone hydrogen bonds to each other's flanking peptide groups; this is known as a close pair of hydrogen bonds. The peptide backbone dihedral angles (phi, psi) are about (-140 degrees, 135 degrees) in antiparallel sheets. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001113": {
            "name": "parallel_beta_strand",
            "def": "A peptide region which hydrogen bonded to another region of peptide running in the oposite direction (both running N-terminal to C-terminal). This orientation is slightly less stable because it introduces nonplanarity in the inter-strand hydrogen bonding pattern. Hydrogen bonding occurs between every other C=O from one strand to every other N-H on the adjacent strand. In this case, if two atoms C-alpha (i)and C-alpha (j) are adjacent in two hydrogen-bonded beta strands, then they do not hydrogen bond to each other; rather, one residue forms hydrogen bonds to the residues that flank the other (but not vice versa). For example, residue i may form hydrogen bonds to residues j - 1 and j + 1; this is known as a wide pair of hydrogen bonds. By contrast, residue j may hydrogen-bond to different residues altogether, or to none at all. The dihedral angles (phi, psi) are about (-120 degrees, 115 degrees) in parallel sheets. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001114": {
            "name": "peptide_helix",
            "def": "A helix is a secondary_structure conformation where the peptide backbone forms a coil. [EBIBS:GAR]"
          },
          "SO:0001115": {
            "name": "left_handed_peptide_helix",
            "def": "A left handed helix is a region of peptide where the coiled conformation turns in an anticlockwise, left handed screw. [EBIBS:GAR]"
          },
          "SO:0001116": {
            "name": "right_handed_peptide_helix",
            "def": "A right handed helix is a region of peptide where the coiled conformation turns in a clockwise, right handed screw. [EBIBS:GAR]"
          },
          "SO:0001117": {
            "name": "alpha_helix",
            "def": "The helix has 3.6 residues per turn which corresponds to a translation of 1.5 angstroms (= 0.15 nm) along the helical axis. Every backbone N-H group donates a hydrogen bond to the backbone C=O group of the amino acid four residues earlier. [EBIBS:GAR]"
          },
          "SO:0001118": {
            "name": "pi_helix",
            "def": "The pi helix has 4.1 residues per turn and a translation of 1.15  (=0.115 nm) along the helical axis. The N-H group of an amino acid forms a hydrogen bond with the C=O group of the amino acid five residues earlier. [EBIBS:GAR]"
          },
          "SO:0001119": {
            "name": "three_ten_helix",
            "def": "The 3-10 helix has 3 residues per turn with a translation of 2.0 angstroms (=0.2 nm) along the helical axis. The N-H group of an amino acid forms a hydrogen bond with the C=O group of the amino acid three residues earlier. [EBIBS:GAR]"
          },
          "SO:0001120": {
            "name": "polypeptide_nest_motif",
            "def": "A motif of two consecutive residues with dihedral angles. Nest should not have Proline as any residue. Nests frequently occur as parts of other motifs such as Schellman loops. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001121": {
            "name": "polypeptide_nest_left_right_motif",
            "def": "A motif of two consecutive residues with dihedral angles: Residue(i): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001122": {
            "name": "polypeptide_nest_right_left_motif",
            "def": "A motif of two consecutive residues with dihedral angles: Residue(i): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001123": {
            "name": "schellmann_loop",
            "def": "A motif of six or seven consecutive residues that contains two H-bonds. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001124": {
            "name": "schellmann_loop_seven",
            "def": "Wild type: A motif of seven consecutive residues that contains two H-bonds in which: the main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+6), the main-chain CO of residue(i+1) is H-bonded to the main-chain NH of residue(i+5). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001125": {
            "name": "schellmann_loop_six",
            "def": "Common Type: A motif of six consecutive residues that contains two H-bonds in which: the main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+5) the main-chain CO of residue(i+1) is H-bonded to the main-chain NH of residue(i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001126": {
            "name": "serine_threonine_motif",
            "def": "A motif of five consecutive residues and two hydrogen bonds in which: residue(i) is Serine (S) or Threonine (T), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2) or (i+3) , the main-chain CO group of residue(i) is H-bonded to the main-chain NH of residue(i+3) or (i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001127": {
            "name": "serine_threonine_staple_motif",
            "def": "A motif of four or five consecutive residues and one H-bond in which: residue(i) is Serine (S) or Threonine (T), the side-chain OH of residue(i) is H-bonded to the main-chain CO of residue(i3) or (i4), Phi angles of residues(i1), (i2) and (i3) are negative. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001128": {
            "name": "polypeptide_turn_motif",
            "def": "A reversal in the direction of the backbone of a protein that is stabilized by hydrogen bond between backbone NH and CO groups, involving no more than 4 amino acid residues. [EBIBS:GAR, uniprot:feature_type]"
          },
          "SO:0001129": {
            "name": "asx_turn_left_handed_type_one",
            "def": "Left handed type I (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, -90 degrees < psi +120 degrees < +40 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001130": {
            "name": "asx_turn_left_handed_type_two",
            "def": "Left handed type II (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, +80 degrees < psi +120 degrees < +180 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001131": {
            "name": "asx_turn_right_handed_type_two",
            "def": "Right handed type II (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, +80 degrees < psi +120 degrees < +180 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001132": {
            "name": "asx_turn_right_handed_type_one",
            "def": "Right handed type I (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, -90 degrees < psi +120 degrees < +40 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001133": {
            "name": "beta_turn",
            "def": "A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles of the second and third residues, which are the basis for sub-categorization. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001134": {
            "name": "beta_turn_left_handed_type_one",
            "def": "Left handed type I:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles:- Residue(i+1): -140 degrees > phi > -20 degrees, -90 degrees > psi > +40 degrees. Residue(i+2): -140 degrees > phi > -20 degrees, -90 degrees > psi > +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001135": {
            "name": "beta_turn_left_handed_type_two",
            "def": "Left handed type II: A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees > phi > -20 degrees, +80 degrees > psi > +180 degrees. Residue(i+2): +20 degrees > phi > +140 degrees, -40 degrees > psi > +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001136": {
            "name": "beta_turn_right_handed_type_one",
            "def": "Right handed type I:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. Residue(i+2): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001137": {
            "name": "beta_turn_right_handed_type_two",
            "def": "Right handed type II:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees < phi < -20 degrees, +80 degrees < psi < +180 degrees. Residue(i+2): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001138": {
            "name": "gamma_turn",
            "def": "Gamma turns, defined for 3 residues i,( i+1),( i+2) if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001139": {
            "name": "gamma_turn_classic",
            "def": "Gamma turns, defined for 3 residues i, i+1, i+2 if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees: phi(i+1)=75.0 - psi(i+1)=-64.0. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001140": {
            "name": "gamma_turn_inverse",
            "def": "Gamma turns, defined for 3 residues i, i+1, i+2 if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees: phi(i+1)=-79.0 - psi(i+1)=69.0. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001141": {
            "name": "serine_threonine_turn",
            "def": "A motif of three consecutive residues and one H-bond in which: residue(i) is Serine (S) or Threonine (T), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001142": {
            "name": "st_turn_left_handed_type_one",
            "def": "The peptide twists in an anticlockwise, left handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, -90 degrees psi +120 degrees < +40 degrees, residue(i+1): -140 degrees < phi < -20 degrees, -90 < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001143": {
            "name": "st_turn_left_handed_type_two",
            "def": "The peptide twists in an anticlockwise, left handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, +80 degrees psi +120 degrees < +180 degrees, residue(i+1): +20 degrees < phi < +140 degrees, -40 < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001144": {
            "name": "st_turn_right_handed_type_one",
            "def": "The peptide twists in an clockwise, right handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, -90 degrees psi +120 degrees < +40 degrees, residue(i+1): -140 degrees < phi < -20 degrees, -90 < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001145": {
            "name": "st_turn_right_handed_type_two",
            "def": "The peptide twists in an clockwise, right handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, +80 degrees psi +120 degrees < +180 degrees, residue(i+1): +20 degrees < phi < +140 degrees, -40 < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0001146": {
            "name": "polypeptide_variation_site",
            "def": "A site of sequence variation (alteration). Alternative sequence due to naturally occurring events such as polymorphisms and alternative splicing or experimental methods such as site directed mutagenesis. [EBIBS:GAR, SO:ke]"
          },
          "SO:0001147": {
            "name": "natural_variant_site",
            "def": "Describes the natural sequence variants due to polymorphisms, disease-associated mutations, RNA editing and variations between strains, isolates or cultivars. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001148": {
            "name": "mutated_variant_site",
            "def": "Site which has been experimentally altered. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001149": {
            "name": "alternate_sequence_site",
            "def": "Description of sequence variants produced by alternative splicing, alternative promoter usage, alternative initiation and ribosomal frameshifting. [EBIBS:GAR, UniProt:curation_manual]"
          },
          "SO:0001150": {
            "name": "beta_turn_type_six",
            "def": "A motif of four consecutive peptide resides of type VIa or type VIb and where the i+2 residue is cis-proline. [SO:cb]"
          },
          "SO:0001151": {
            "name": "beta_turn_type_six_a",
            "def": "A motif of four consecutive peptide residues, of which the i+2 residue is proline, and that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -60 degrees, psi ~ 120 degrees. Residue(i+2): phi ~ -90 degrees, psi ~ 0 degrees. [PMID:2371257, SO:cb]"
          },
          "SO:0001152": {
            "name": "beta_turn_type_six_a_one"
          },
          "SO:0001153": {
            "name": "beta_turn_type_six_a_two"
          },
          "SO:0001154": {
            "name": "beta_turn_type_six_b",
            "def": "A motif of four consecutive peptide residues, of which the i+2 residue is proline, and that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -120 degrees, psi ~ 120 degrees. Residue(i+2): phi ~ -60 degrees, psi ~ 0 degrees. [PMID:2371257, SO:cb]"
          },
          "SO:0001155": {
            "name": "beta_turn_type_eight",
            "def": "A motif of four consecutive peptide residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -60 degrees, psi ~ -30 degrees. Residue(i+2): phi ~ -120 degrees, psi ~ 120 degrees. [PMID:2371257, SO:cb]"
          },
          "SO:0001156": {
            "name": "DRE_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -10 and -60 relative to the TSS. Consensus sequence is WATCGATW. [PMID:12537576]"
          },
          "SO:0001157": {
            "name": "DMv4_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, located immediately upstream of some TATA box elements with respect to the TSS (+1). Consensus sequence is YGGTCACACTR. Marked spatial preference within core promoter; tend to occur near the TSS, although not as tightly as INR (SO:0000014). [PMID:16827941:12537576]"
          },
          "SO:0001158": {
            "name": "E_box_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -60 and +1 relative to the TSS. Consensus sequence is AWCAGCTGWT. Tends to co-occur with DMv2 (SO:0001161). Tends to not occur with DPE motif (SO:0000015). [PMID:12537576:16827941]"
          },
          "SO:0001159": {
            "name": "DMv5_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -50 and -10 relative to the TSS. Consensus sequence is KTYRGTATWTTT. Tends to co-occur with DMv4 (SO:0001157) . Tends to not occur with DPE motif (SO:0000015) or MTE (SO:0001162). [PMID:12537576:16827941]"
          },
          "SO:0001160": {
            "name": "DMv3_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -30 and +15 relative to the TSS. Consensus sequence is KNNCAKCNCTRNY. Tends to co-occur with DMv2 (SO:0001161). Tends to not occur with DPE motif (SO:0000015) or MTE (0001162). [PMID:12537576:16827941]"
          },
          "SO:0001161": {
            "name": "DMv2_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -60 and -45 relative to the TSS. Consensus sequence is MKSYGGCARCGSYSS. Tends to co-occur with DMv3 (SO:0001160). Tends to not occur with DPE motif (SO:0000015) or MTE (SO:0001162). [PMID:12537576:16827941]"
          },
          "SO:0001162": {
            "name": "MTE",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between +20 and +30 relative to the TSS. Consensus sequence is CSARCSSAACGS. Tends to co-occur with INR motif (SO:0000014). Tends to not occur with DPE motif (SO:0000015) or DMv5 (SO:0001159). [PMID:12537576:15231738, PMID:16858867]"
          },
          "SO:0001163": {
            "name": "INR1_motif",
            "def": "A promoter motif with consensus sequence TCATTCG. [PMID:16827941]"
          },
          "SO:0001164": {
            "name": "DPE1_motif",
            "def": "A promoter motif with consensus sequence CGGACGT. [PMID:16827941]"
          },
          "SO:0001165": {
            "name": "DMv1_motif",
            "def": "A promoter motif with consensus sequence CARCCCT. [PMID:16827941]"
          },
          "SO:0001166": {
            "name": "GAGA_motif",
            "def": "A non directional promoter motif with consensus sequence GAGAGCG. [PMID:16827941]"
          },
          "SO:0001167": {
            "name": "NDM2_motif",
            "def": "A non directional promoter motif with consensus CGMYGYCR. [PMID:16827941]"
          },
          "SO:0001168": {
            "name": "NDM3_motif",
            "def": "A non directional promoter motif with consensus sequence GAAAGCT. [PMID:16827941]"
          },
          "SO:0001169": {
            "name": "ds_RNA_viral_sequence",
            "def": "A ds_RNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as double stranded RNA. [SO:ke]"
          },
          "SO:0001170": {
            "name": "polinton",
            "def": "A kind of DNA transposon that populates the genomes of protists, fungi, and animals, characterized by a unique set of proteins necessary for their transposition, including a protein-primed DNA polymerase B, retroviral integrase, cysteine protease, and ATPase. Polintons are characterized by 6-bp target site duplications, terminal-inverted repeats that are several hundred nucleotides long, and 5'-AG and TC-3' termini. Polintons exist as autonomous and nonautonomous elements. [PMID:16537396]"
          },
          "SO:0001171": {
            "name": "rRNA_21S",
            "def": "A component of the large ribosomal subunit in mitochondrial rRNA. [RSC:cb]"
          },
          "SO:0001172": {
            "name": "tRNA_region",
            "def": "A region of a tRNA. [RSC:cb]"
          },
          "SO:0001173": {
            "name": "anticodon_loop",
            "def": "A sequence of seven nucleotide bases in tRNA which contains the anticodon. It has the sequence 5'-pyrimidine-purine-anticodon-modified purine-any base-3. [ISBN:0716719207]"
          },
          "SO:0001174": {
            "name": "anticodon",
            "def": "A sequence of three nucleotide bases in tRNA which recognizes a codon in mRNA. [RSC:cb]"
          },
          "SO:0001175": {
            "name": "CCA_tail",
            "def": "Base sequence at the 3' end of a tRNA. The 3'-hydroxyl group on the terminal adenosine is the attachment point for the amino acid. [ISBN:0716719207]"
          },
          "SO:0001176": {
            "name": "DHU_loop",
            "def": "Non-base-paired sequence of nucleotide bases in tRNA. It contains several dihydrouracil residues. [ISBN:071671920]"
          },
          "SO:0001177": {
            "name": "T_loop",
            "def": "Non-base-paired sequence of three nucleotide bases in tRNA. It has sequence T-Psi-C. [ISBN:0716719207]"
          },
          "SO:0001178": {
            "name": "pyrrolysine_tRNA_primary_transcript",
            "def": "A primary transcript encoding pyrrolysyl tRNA (SO:0000766). [RSC:cb]"
          },
          "SO:0001179": {
            "name": "U3_snoRNA",
            "def": "U3 snoRNA is a member of the box C/D class of small nucleolar RNAs. The U3 snoRNA secondary structure is characterised by a small 5' domain (with boxes A and A'), and a larger 3' domain (with boxes B, C, C', and D), the two domains being linked by a single-stranded hinge. Boxes B and C form the B/C motif, which appears to be exclusive to U3 snoRNAs, and boxes C' and D form the C'/D motif. The latter is functionally similar to the C/D motifs found in other snoRNAs. The 5' domain and the hinge region act as a pre-rRNA-binding domain. The 3' domain has conserved protein-binding sites. Both the box B/C and box C'/D motifs are sufficient for nuclear retention of U3 snoRNA. The box C'/D motif is also necessary for nucleolar localization, stability and hypermethylation of U3 snoRNA. Both box B/C and C'/D motifs are involved in specific protein interactions and are necessary for the rRNA processing functions of U3 snoRNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00012]"
          },
          "SO:0001180": {
            "name": "AU_rich_element",
            "def": "A cis-acting element found in the 3' UTR of some mRNA which is rich in AUUUA pentamers. Messenger RNAs bearing multiple AU-rich elements are often unstable. [PMID:7892223]"
          },
          "SO:0001181": {
            "name": "Bruno_response_element",
            "def": "A cis-acting element found in the 3' UTR of some mRNA which is bound by the Drosophila Bruno protein and its homologs. [PMID:10893231]"
          },
          "SO:0001182": {
            "name": "iron_responsive_element",
            "def": "A regulatory sequence found in the 5' and 3' UTRs of many mRNAs which encode iron-binding proteins. It has a hairpin structure and is recognized by trans-acting proteins known as iron-regulatory proteins. [PMID:3198610, PMID:8710843]"
          },
          "SO:0001183": {
            "name": "morpholino_backbone",
            "def": "An attribute describing a sequence composed of nucleobases bound to a morpholino backbone. A morpholino backbone consists of morpholine (CHEBI:34856) rings connected by phosphorodiamidate linkages. [RSC:cb]"
          },
          "SO:0001184": {
            "name": "PNA",
            "def": "An attribute describing a sequence composed of peptide nucleic acid (CHEBI:48021), a chemical consisting of nucleobases bound to a backbone composed of repeating N-(2-aminoethyl)-glycine units linked by peptide bonds. The purine and pyrimidine bases are linked to the backbone by methylene carbonyl bonds. [RSC:cb]"
          },
          "SO:0001185": {
            "name": "enzymatic",
            "def": "An attribute describing the sequence of a transcript that has catalytic activity with or without an associated ribonucleoprotein. [RSC:cb]"
          },
          "SO:0001186": {
            "name": "ribozymic",
            "def": "An attribute describing the sequence of a transcript that has catalytic activity even without an associated ribonucleoprotein. [RSC:cb]"
          },
          "SO:0001187": {
            "name": "pseudouridylation_guide_snoRNA",
            "def": "A snoRNA that specifies the site of pseudouridylation in an RNA molecule by base pairing with a short sequence around the target residue. [GOC:mah, PMID:12457565]"
          },
          "SO:0001188": {
            "name": "LNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of 'locked' deoxyribose rings connected to a phosphate backbone. The deoxyribose unit's conformation is 'locked' by a 2'-C,4'-C-oxymethylene link. [CHEBI:48010]"
          },
          "SO:0001189": {
            "name": "LNA_oligo",
            "def": "An oligo composed of LNA residues. [RSC:cb]"
          },
          "SO:0001190": {
            "name": "TNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of threose rings connected to a phosphate backbone. [CHEBI:48019]"
          },
          "SO:0001191": {
            "name": "TNA_oligo",
            "def": "An oligo composed of TNA residues. [RSC:cb]"
          },
          "SO:0001192": {
            "name": "GNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of an acyclic three-carbon propylene glycol connected to a phosphate backbone. It has two enantiomeric forms, (R)-GNA and (S)-GNA. [CHEBI:48015]"
          },
          "SO:0001193": {
            "name": "GNA_oligo",
            "def": "An oligo composed of GNA residues. [RSC:cb]"
          },
          "SO:0001194": {
            "name": "R_GNA",
            "def": "An attribute describing a GNA sequence in the (R)-GNA enantiomer. [CHEBI:48016]"
          },
          "SO:0001195": {
            "name": "R_GNA_oligo",
            "def": "An oligo composed of (R)-GNA residues. [RSC:cb]"
          },
          "SO:0001196": {
            "name": "S_GNA",
            "def": "An attribute describing a GNA sequence in the (S)-GNA enantiomer. [CHEBI:48017]"
          },
          "SO:0001197": {
            "name": "S_GNA_oligo",
            "def": "An oligo composed of (S)-GNA residues. [RSC:cb]"
          },
          "SO:0001198": {
            "name": "ds_DNA_viral_sequence",
            "def": "A ds_DNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as double stranded DNA. [SO:ke]"
          },
          "SO:0001199": {
            "name": "ss_RNA_viral_sequence",
            "def": "A ss_RNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as single stranded RNA. [SO:ke]"
          },
          "SO:0001200": {
            "name": "negative_sense_ssRNA_viral_sequence",
            "def": "A negative_sense_RNA_viral_sequence is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus that is complementary to mRNA and must be converted to positive sense RNA by RNA polymerase before translation. [SO:ke]"
          },
          "SO:0001201": {
            "name": "positive_sense_ssRNA_viral_sequence",
            "def": "A positive_sense_RNA_viral_sequence is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus that can be immediately translated by the host. [SO:ke]"
          },
          "SO:0001202": {
            "name": "ambisense_ssRNA_viral_sequence",
            "def": "A ambisense_RNA_virus is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus with both messenger and anti messenger polarity. [SO:ke]"
          },
          "SO:0001203": {
            "name": "RNA_polymerase_promoter",
            "def": "A region (DNA) to which RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001204": {
            "name": "Phage_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which Bacteriophage RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001205": {
            "name": "SP6_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which the SP6 RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001206": {
            "name": "T3_RNA_Polymerase_Promoter",
            "def": "A DNA sequence to which the T3 RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001207": {
            "name": "T7_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which the T7 RNA polymerase binds, to begin transcription. [xenbase:jb]"
          },
          "SO:0001208": {
            "name": "five_prime_EST",
            "def": "An EST read from the 5' end of a transcript that usually codes for a protein. These regions tend to be conserved across species and do not change much within a gene family. [http://www.ncbi.nlm.nih.gov/About/primer/est.html]"
          },
          "SO:0001209": {
            "name": "three_prime_EST",
            "def": "An EST read from the 3' end of a transcript. They are more likely to fall within non-coding, or untranslated regions(UTRs). [http://www.ncbi.nlm.nih.gov/About/primer/est.html]"
          },
          "SO:0001210": {
            "name": "translational_frameshift",
            "def": "The region of mRNA (not divisible by 3 bases) that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
          },
          "SO:0001211": {
            "name": "plus_1_translational_frameshift",
            "def": "The region of mRNA 1 base long that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
          },
          "SO:0001212": {
            "name": "plus_2_translational_frameshift",
            "def": "The region of mRNA 2 bases long that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
          },
          "SO:0001213": {
            "name": "group_III_intron",
            "def": "Group III introns are introns found in the mRNA of the plastids of euglenoid protists. They are spliced by a two step transesterification with bulged adenosine as initiating nucleophile. [PMID:11377794]"
          },
          "SO:0001214": {
            "name": "noncoding_region_of_exon",
            "def": "The maximal intersection of exon and UTR. [SO:ke]"
          },
          "SO:0001215": {
            "name": "coding_region_of_exon",
            "def": "The region of an exon that encodes for protein sequence. [SO:ke]"
          },
          "SO:0001216": {
            "name": "endonuclease_spliced_intron",
            "def": "An intron that spliced via endonucleolytic cleavage and ligation rather than transesterification. [SO:ke]"
          },
          "SO:0001217": {
            "name": "protein_coding_gene"
          },
          "SO:0001218": {
            "name": "transgenic_insertion",
            "def": "An insertion that derives from another organism, via the use of recombinant DNA technology. [SO:bm]"
          },
          "SO:0001219": {
            "name": "retrogene"
          },
          "SO:0001220": {
            "name": "silenced_by_RNA_interference",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by RNA interference. [RSC:cb]"
          },
          "SO:0001221": {
            "name": "silenced_by_histone_modification",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone modification. [RSC:cb]"
          },
          "SO:0001222": {
            "name": "silenced_by_histone_methylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone methylation. [RSC:cb]"
          },
          "SO:0001223": {
            "name": "silenced_by_histone_deacetylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone deacetylation. [RSC:cb]"
          },
          "SO:0001224": {
            "name": "gene_silenced_by_RNA_interference",
            "def": "A gene that is silenced by RNA interference. [SO:xp]"
          },
          "SO:0001225": {
            "name": "gene_silenced_by_histone_modification",
            "def": "A gene that is silenced by histone modification. [SO:xp]"
          },
          "SO:0001226": {
            "name": "gene_silenced_by_histone_methylation",
            "def": "A gene that is silenced by histone methylation. [SO:xp]"
          },
          "SO:0001227": {
            "name": "gene_silenced_by_histone_deacetylation",
            "def": "A gene that is silenced by histone deacetylation. [SO:xp]"
          },
          "SO:0001228": {
            "name": "dihydrouridine",
            "def": "A modified RNA base in which the 5,6-dihydrouracil is bound to the ribose ring. [RSC:cb]"
          },
          "SO:0001229": {
            "name": "pseudouridine",
            "def": "A modified RNA base in which the 5- position of the uracil is bound to the ribose ring instead of the 4- position. [RSC:cb]"
          },
          "SO:0001230": {
            "name": "inosine",
            "def": "A modified RNA base in which hypoxanthine is bound to the ribose ring. [http://library.med.utah.edu/RNAmods/, RSC:cb]"
          },
          "SO:0001231": {
            "name": "seven_methylguanine",
            "def": "A modified RNA base in which guanine is methylated at the 7- position. [RSC:cb]"
          },
          "SO:0001232": {
            "name": "ribothymidine",
            "def": "A modified RNA base in which thymine is bound to the ribose ring. [RSC:cb]"
          },
          "SO:0001233": {
            "name": "methylinosine",
            "def": "A modified RNA base in which methylhypoxanthine is bound to the ribose ring. [RSC:cb]"
          },
          "SO:0001234": {
            "name": "mobile",
            "def": "An attribute describing a feature that has either intra-genome or intracellular mobility. [RSC:cb]"
          },
          "SO:0001235": {
            "name": "replicon",
            "def": "A region containing at least one unique origin of replication and a unique termination site. [ISBN:0716719207]"
          },
          "SO:0001236": {
            "name": "base",
            "def": "A base is a sequence feature that corresponds to a single unit of a nucleotide polymer. [SO:ke]"
          },
          "SO:0001237": {
            "name": "amino_acid",
            "def": "A sequence feature that corresponds to a single amino acid residue in a polypeptide. [RSC:cb]"
          },
          "SO:0001238": {
            "name": "major_TSS"
          },
          "SO:0001239": {
            "name": "minor_TSS"
          },
          "SO:0001240": {
            "name": "TSS_region",
            "def": "The region of a gene from the 5' most TSS to the 3' TSS. [BBOP:nw]"
          },
          "SO:0001241": {
            "name": "encodes_alternate_transcription_start_sites"
          },
          "SO:0001243": {
            "name": "miRNA_primary_transcript_region",
            "def": "A part of an miRNA primary_transcript. [SO:ke]"
          },
          "SO:0001244": {
            "name": "pre_miRNA",
            "def": "The 60-70 nucleotide region remain after Drosha processing of the primary transcript, that folds back upon itself to form a hairpin structure. [SO:ke]"
          },
          "SO:0001245": {
            "name": "miRNA_stem",
            "def": "The stem of the hairpin loop formed by folding of the pre-miRNA. [SO:ke]"
          },
          "SO:0001246": {
            "name": "miRNA_loop",
            "def": "The loop of the hairpin loop formed by folding of the pre-miRNA. [SO:ke]"
          },
          "SO:0001247": {
            "name": "synthetic_oligo",
            "def": "An oligo composed of synthetic nucleotides. [SO:ke]"
          },
          "SO:0001248": {
            "name": "assembly",
            "def": "A region of the genome of known length that is composed by ordering and aligning two or more different regions. [SO:ke]"
          },
          "SO:0001249": {
            "name": "fragment_assembly",
            "def": "A fragment assembly is a genome assembly that orders overlapping fragments of the genome based on landmark sequences. The base pair distance between the landmarks is known allowing additivity of lengths. [SO:ke]"
          },
          "SO:0001250": {
            "name": "fingerprint_map",
            "def": "A fingerprint_map is a physical map composed of restriction fragments. [SO:ke]"
          },
          "SO:0001251": {
            "name": "STS_map",
            "def": "An STS map is a physical map organized by the unique STS landmarks. [SO:ke]"
          },
          "SO:0001252": {
            "name": "RH_map",
            "def": "A radiation hybrid map is a physical map. [SO:ke]"
          },
          "SO:0001253": {
            "name": "sonicate_fragment",
            "def": "A DNA fragment generated by sonication. Sonication is a technique used to sheer DNA into smaller fragments. [SO:ke]"
          },
          "SO:0001254": {
            "name": "polyploid",
            "def": "A kind of chromosome variation where the chromosome complement is an exact multiple of the haploid number and is greater than the diploid number. [SO:ke]"
          },
          "SO:0001255": {
            "name": "autopolyploid",
            "def": "A polyploid where the multiple chromosome set was derived from the same organism. [SO:ke]"
          },
          "SO:0001256": {
            "name": "allopolyploid",
            "def": "A polyploid where the multiple chromosome set was derived from a different organism. [SO:ke]"
          },
          "SO:0001257": {
            "name": "homing_endonuclease_binding_site",
            "def": "The binding site (recognition site) of a homing endonuclease. The binding site is typically large. [SO:ke]"
          },
          "SO:0001258": {
            "name": "octamer_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters with sequence ATTGCAT that binds Pou-domain transcription factors. [GOC:dh, PMID:3095662]"
          },
          "SO:0001259": {
            "name": "apicoplast_chromosome",
            "def": "A chromosome originating in an apicoplast. [SO:xp]"
          },
          "SO:0001260": {
            "name": "sequence_collection",
            "def": "A collection of discontinuous sequences. [SO:ke]"
          },
          "SO:0001261": {
            "name": "overlapping_feature_set",
            "def": "A continuous region of sequence composed of the overlapping of multiple sequence_features, which ultimately provides evidence for another sequence_feature. [SO:ke]"
          },
          "SO:0001262": {
            "name": "overlapping_EST_set",
            "def": "A continous experimental result region extending the length of multiple overlapping EST's. [SO:ke]"
          },
          "SO:0001263": {
            "name": "ncRNA_gene"
          },
          "SO:0001264": {
            "name": "gRNA_gene"
          },
          "SO:0001265": {
            "name": "miRNA_gene"
          },
          "SO:0001266": {
            "name": "scRNA_gene"
          },
          "SO:0001267": {
            "name": "snoRNA_gene"
          },
          "SO:0001268": {
            "name": "snRNA_gene"
          },
          "SO:0001269": {
            "name": "SRP_RNA_gene"
          },
          "SO:0001271": {
            "name": "tmRNA_gene"
          },
          "SO:0001272": {
            "name": "tRNA_gene"
          },
          "SO:0001273": {
            "name": "modified_adenosine",
            "def": "A modified adenine is an adenine base feature that has been altered. [SO:ke]"
          },
          "SO:0001274": {
            "name": "modified_inosine",
            "def": "A modified inosine is an inosine base feature that has been altered. [SO:ke]"
          },
          "SO:0001275": {
            "name": "modified_cytidine",
            "def": "A modified cytidine is a cytidine base feature which has been altered. [SO:ke]"
          },
          "SO:0001276": {
            "name": "modified_guanosine"
          },
          "SO:0001277": {
            "name": "modified_uridine"
          },
          "SO:0001278": {
            "name": "one_methylinosine",
            "def": "1-methylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001279": {
            "name": "one_two_prime_O_dimethylinosine",
            "def": "1,2'-O-dimethylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001280": {
            "name": "two_prime_O_methylinosine",
            "def": "2'-O-methylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001281": {
            "name": "three_methylcytidine",
            "def": "3-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001282": {
            "name": "five_methylcytidine",
            "def": "5-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001283": {
            "name": "two_prime_O_methylcytidine",
            "def": "2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001284": {
            "name": "two_thiocytidine",
            "def": "2-thiocytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001285": {
            "name": "N4_acetylcytidine",
            "def": "N4-acetylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001286": {
            "name": "five_formylcytidine",
            "def": "5-formylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001287": {
            "name": "five_two_prime_O_dimethylcytidine",
            "def": "5,2'-O-dimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001288": {
            "name": "N4_acetyl_2_prime_O_methylcytidine",
            "def": "N4-acetyl-2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001289": {
            "name": "lysidine",
            "def": "Lysidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001290": {
            "name": "N4_methylcytidine",
            "def": "N4-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001291": {
            "name": "N4_2_prime_O_dimethylcytidine",
            "def": "N4,2'-O-dimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001292": {
            "name": "five_hydroxymethylcytidine",
            "def": "5-hydroxymethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001293": {
            "name": "five_formyl_two_prime_O_methylcytidine",
            "def": "5-formyl-2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001294": {
            "name": "N4_N4_2_prime_O_trimethylcytidine",
            "def": "N4_N4_2_prime_O_trimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001295": {
            "name": "one_methyladenosine",
            "def": "1_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001296": {
            "name": "two_methyladenosine",
            "def": "2_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001297": {
            "name": "N6_methyladenosine",
            "def": "N6_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001298": {
            "name": "two_prime_O_methyladenosine",
            "def": "2prime_O_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001299": {
            "name": "two_methylthio_N6_methyladenosine",
            "def": "2_methylthio_N6_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001300": {
            "name": "N6_isopentenyladenosine",
            "def": "N6_isopentenyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001301": {
            "name": "two_methylthio_N6_isopentenyladenosine",
            "def": "2_methylthio_N6_isopentenyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001302": {
            "name": "N6_cis_hydroxyisopentenyl_adenosine",
            "def": "N6_cis_hydroxyisopentenyl_adenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001303": {
            "name": "two_methylthio_N6_cis_hydroxyisopentenyl_adenosine",
            "def": "2_methylthio_N6_cis_hydroxyisopentenyl_adenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001304": {
            "name": "N6_glycinylcarbamoyladenosine",
            "def": "N6_glycinylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001305": {
            "name": "N6_threonylcarbamoyladenosine",
            "def": "N6_threonylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001306": {
            "name": "two_methylthio_N6_threonyl_carbamoyladenosine",
            "def": "2_methylthio_N6_threonyl_carbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001307": {
            "name": "N6_methyl_N6_threonylcarbamoyladenosine",
            "def": "N6_methyl_N6_threonylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001308": {
            "name": "N6_hydroxynorvalylcarbamoyladenosine",
            "def": "N6_hydroxynorvalylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001309": {
            "name": "two_methylthio_N6_hydroxynorvalyl_carbamoyladenosine",
            "def": "2_methylthio_N6_hydroxynorvalyl_carbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001310": {
            "name": "two_prime_O_ribosyladenosine_phosphate",
            "def": "2prime_O_ribosyladenosine_phosphate is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001311": {
            "name": "N6_N6_dimethyladenosine",
            "def": "N6_N6_dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001312": {
            "name": "N6_2_prime_O_dimethyladenosine",
            "def": "N6_2prime_O_dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001313": {
            "name": "N6_N6_2_prime_O_trimethyladenosine",
            "def": "N6_N6_2prime_O_trimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001314": {
            "name": "one_two_prime_O_dimethyladenosine",
            "def": "1,2'-O-dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001315": {
            "name": "N6_acetyladenosine",
            "def": "N6_acetyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001316": {
            "name": "seven_deazaguanosine",
            "def": "7-deazaguanosine is a modified guanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001317": {
            "name": "queuosine",
            "def": "Queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001318": {
            "name": "epoxyqueuosine",
            "def": "Epoxyqueuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001319": {
            "name": "galactosyl_queuosine",
            "def": "Galactosyl_queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001320": {
            "name": "mannosyl_queuosine",
            "def": "Mannosyl_queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001321": {
            "name": "seven_cyano_seven_deazaguanosine",
            "def": "7_cyano_7_deazaguanosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001322": {
            "name": "seven_aminomethyl_seven_deazaguanosine",
            "def": "7_aminomethyl_7_deazaguanosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001323": {
            "name": "archaeosine",
            "def": "Archaeosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001324": {
            "name": "one_methylguanosine",
            "def": "1_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001325": {
            "name": "N2_methylguanosine",
            "def": "N2_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001326": {
            "name": "seven_methylguanosine",
            "def": "7_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001327": {
            "name": "two_prime_O_methylguanosine",
            "def": "2prime_O_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001328": {
            "name": "N2_N2_dimethylguanosine",
            "def": "N2_N2_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001329": {
            "name": "N2_2_prime_O_dimethylguanosine",
            "def": "N2_2prime_O_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001330": {
            "name": "N2_N2_2_prime_O_trimethylguanosine",
            "def": "N2_N2_2prime_O_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001331": {
            "name": "two_prime_O_ribosylguanosine_phosphate",
            "def": "2prime_O_ribosylguanosine_phosphate is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001332": {
            "name": "wybutosine",
            "def": "Wybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001333": {
            "name": "peroxywybutosine",
            "def": "Peroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001334": {
            "name": "hydroxywybutosine",
            "def": "Hydroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001335": {
            "name": "undermodified_hydroxywybutosine",
            "def": "Undermodified_hydroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001336": {
            "name": "wyosine",
            "def": "Wyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001337": {
            "name": "methylwyosine",
            "def": "Methylwyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001338": {
            "name": "N2_7_dimethylguanosine",
            "def": "N2_7_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001339": {
            "name": "N2_N2_7_trimethylguanosine",
            "def": "N2_N2_7_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001340": {
            "name": "one_two_prime_O_dimethylguanosine",
            "def": "1_2prime_O_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001341": {
            "name": "four_demethylwyosine",
            "def": "4_demethylwyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001342": {
            "name": "isowyosine",
            "def": "Isowyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001343": {
            "name": "N2_7_2prirme_O_trimethylguanosine",
            "def": "N2_7_2prirme_O_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001344": {
            "name": "five_methyluridine",
            "def": "5_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001345": {
            "name": "two_prime_O_methyluridine",
            "def": "2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001346": {
            "name": "five_two_prime_O_dimethyluridine",
            "def": "5_2_prime_O_dimethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001347": {
            "name": "one_methylpseudouridine",
            "def": "1_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001348": {
            "name": "two_prime_O_methylpseudouridine",
            "def": "2prime_O_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001349": {
            "name": "two_thiouridine",
            "def": "2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001350": {
            "name": "four_thiouridine",
            "def": "4_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001351": {
            "name": "five_methyl_2_thiouridine",
            "def": "5_methyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001352": {
            "name": "two_thio_two_prime_O_methyluridine",
            "def": "2_thio_2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001353": {
            "name": "three_three_amino_three_carboxypropyl_uridine",
            "def": "3_3_amino_3_carboxypropyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001354": {
            "name": "five_hydroxyuridine",
            "def": "5_hydroxyuridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001355": {
            "name": "five_methoxyuridine",
            "def": "5_methoxyuridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001356": {
            "name": "uridine_five_oxyacetic_acid",
            "def": "Uridine_5_oxyacetic_acid is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001357": {
            "name": "uridine_five_oxyacetic_acid_methyl_ester",
            "def": "Uridine_5_oxyacetic_acid_methyl_ester is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001358": {
            "name": "five_carboxyhydroxymethyl_uridine",
            "def": "5_carboxyhydroxymethyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001359": {
            "name": "five_carboxyhydroxymethyl_uridine_methyl_ester",
            "def": "5_carboxyhydroxymethyl_uridine_methyl_ester is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001360": {
            "name": "five_methoxycarbonylmethyluridine",
            "def": "Five_methoxycarbonylmethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001361": {
            "name": "five_methoxycarbonylmethyl_two_prime_O_methyluridine",
            "def": "Five_methoxycarbonylmethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001362": {
            "name": "five_methoxycarbonylmethyl_two_thiouridine",
            "def": "5_methoxycarbonylmethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001363": {
            "name": "five_aminomethyl_two_thiouridine",
            "def": "5_aminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001364": {
            "name": "five_methylaminomethyluridine",
            "def": "5_methylaminomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001365": {
            "name": "five_methylaminomethyl_two_thiouridine",
            "def": "5_methylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001366": {
            "name": "five_methylaminomethyl_two_selenouridine",
            "def": "5_methylaminomethyl_2_selenouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001367": {
            "name": "five_carbamoylmethyluridine",
            "def": "5_carbamoylmethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001368": {
            "name": "five_carbamoylmethyl_two_prime_O_methyluridine",
            "def": "5_carbamoylmethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001369": {
            "name": "five_carboxymethylaminomethyluridine",
            "def": "5_carboxymethylaminomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001370": {
            "name": "five_carboxymethylaminomethyl_two_prime_O_methyluridine",
            "def": "5_carboxymethylaminomethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001371": {
            "name": "five_carboxymethylaminomethyl_two_thiouridine",
            "def": "5_carboxymethylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001372": {
            "name": "three_methyluridine",
            "def": "3_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001373": {
            "name": "one_methyl_three_three_amino_three_carboxypropyl_pseudouridine",
            "def": "1_methyl_3_3_amino_3_carboxypropyl_pseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001374": {
            "name": "five_carboxymethyluridine",
            "def": "5_carboxymethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001375": {
            "name": "three_two_prime_O_dimethyluridine",
            "def": "3_2prime_O_dimethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001376": {
            "name": "five_methyldihydrouridine",
            "def": "5_methyldihydrouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001377": {
            "name": "three_methylpseudouridine",
            "def": "3_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001378": {
            "name": "five_taurinomethyluridine",
            "def": "5_taurinomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001379": {
            "name": "five_taurinomethyl_two_thiouridine",
            "def": "5_taurinomethyl_2_thiouridineis a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001380": {
            "name": "five_isopentenylaminomethyl_uridine",
            "def": "5_isopentenylaminomethyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001381": {
            "name": "five_isopentenylaminomethyl_two_thiouridine",
            "def": "5_isopentenylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001382": {
            "name": "five_isopentenylaminomethyl_two_prime_O_methyluridine",
            "def": "5_isopentenylaminomethyl_2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
          },
          "SO:0001383": {
            "name": "histone_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues of a histone. [SO:ke]"
          },
          "SO:0001384": {
            "name": "CDS_fragment"
          },
          "SO:0001385": {
            "name": "modified_amino_acid_feature",
            "def": "A post translationally modified amino acid feature. [SO:ke]"
          },
          "SO:0001386": {
            "name": "modified_glycine",
            "def": "A post translationally modified glycine amino acid feature. [SO:ke]"
          },
          "SO:0001387": {
            "name": "modified_L_alanine",
            "def": "A post translationally modified alanine amino acid feature. [SO:ke]"
          },
          "SO:0001388": {
            "name": "modified_L_asparagine",
            "def": "A post translationally modified asparagine amino acid feature. [SO:ke]"
          },
          "SO:0001389": {
            "name": "modified_L_aspartic_acid",
            "def": "A post translationally modified aspartic acid amino acid feature. [SO:ke]"
          },
          "SO:0001390": {
            "name": "modified_L_cysteine",
            "def": "A post translationally modified cysteine amino acid feature. [SO:ke]"
          },
          "SO:0001391": {
            "name": "modified_L_glutamic_acid"
          },
          "SO:0001392": {
            "name": "modified_L_threonine",
            "def": "A post translationally modified threonine amino acid feature. [SO:ke]"
          },
          "SO:0001393": {
            "name": "modified_L_tryptophan",
            "def": "A post translationally modified tryptophan amino acid feature. [SO:ke]"
          },
          "SO:0001394": {
            "name": "modified_L_glutamine",
            "def": "A post translationally modified glutamine amino acid feature. [SO:ke]"
          },
          "SO:0001395": {
            "name": "modified_L_methionine",
            "def": "A post translationally modified methionine amino acid feature. [SO:ke]"
          },
          "SO:0001396": {
            "name": "modified_L_isoleucine",
            "def": "A post translationally modified isoleucine amino acid feature. [SO:ke]"
          },
          "SO:0001397": {
            "name": "modified_L_phenylalanine",
            "def": "A post translationally modified phenylalanine amino acid feature. [SO:ke]"
          },
          "SO:0001398": {
            "name": "modified_L_histidine",
            "def": "A post translationally modified histidine amino acid feature. [SO:ke]"
          },
          "SO:0001399": {
            "name": "modified_L_serine",
            "def": "A post translationally modified serine amino acid feature. [SO:ke]"
          },
          "SO:0001400": {
            "name": "modified_L_lysine",
            "def": "A post translationally modified lysine amino acid feature. [SO:ke]"
          },
          "SO:0001401": {
            "name": "modified_L_leucine",
            "def": "A post translationally modified leucine amino acid feature. [SO:ke]"
          },
          "SO:0001402": {
            "name": "modified_L_selenocysteine",
            "def": "A post translationally modified selenocysteine amino acid feature. [SO:ke]"
          },
          "SO:0001403": {
            "name": "modified_L_valine",
            "def": "A post translationally modified valine amino acid feature. [SO:ke]"
          },
          "SO:0001404": {
            "name": "modified_L_proline",
            "def": "A post translationally modified proline amino acid feature. [SO:ke]"
          },
          "SO:0001405": {
            "name": "modified_L_tyrosine",
            "def": "A post translationally modified tyrosine amino acid feature. [SO:ke]"
          },
          "SO:0001406": {
            "name": "modified_L_arginine",
            "def": "A post translationally modified arginine amino acid feature. [SO:ke]"
          },
          "SO:0001407": {
            "name": "peptidyl",
            "def": "An attribute describing the nature of a proteinaceous polymer, where by the amino acid units are joined by peptide bonds. [SO:ke]"
          },
          "SO:0001408": {
            "name": "cleaved_for_gpi_anchor_region",
            "def": "The C-terminal residues of a polypeptide which are exchanged for a GPI-anchor. [EBI:rh]"
          },
          "SO:0001409": {
            "name": "biomaterial_region",
            "def": "A region which is intended for use in an experiment. [SO:cb]"
          },
          "SO:0001410": {
            "name": "experimental_feature",
            "def": "A region which is the result of some arbitrary experimental procedure. The procedure may be carried out with biological material or inside a computer. [SO:cb]"
          },
          "SO:0001411": {
            "name": "biological_region",
            "def": "A region defined by its disposition to be involved in a biological process. [SO:cb]"
          },
          "SO:0001412": {
            "name": "topologically_defined_region",
            "def": "A region that is defined according to its relations with other regions within the same sequence. [SO:cb]"
          },
          "SO:0001413": {
            "name": "translocation_breakpoint",
            "def": "The point within a chromosome where a translocation begins or ends. [SO:cb]"
          },
          "SO:0001414": {
            "name": "insertion_breakpoint",
            "def": "The point within a chromosome where a insertion begins or ends. [SO:cb]"
          },
          "SO:0001415": {
            "name": "deletion_breakpoint",
            "def": "The point within a chromosome where a deletion begins or ends. [SO:cb]"
          },
          "SO:0001416": {
            "name": "five_prime_flanking_region",
            "def": "A flanking region located five prime of a specific region. [SO:chado]"
          },
          "SO:0001417": {
            "name": "three_prime_flanking_region",
            "def": "A flanking region located three prime of a specific region. [SO:chado]"
          },
          "SO:0001418": {
            "name": "transcribed_fragment",
            "def": "An experimental region, defined by a tiling array experiment to be transcribed at some level. [SO:ke]"
          },
          "SO:0001419": {
            "name": "cis_splice_site",
            "def": "Intronic 2 bp region bordering exon. A splice_site that adjacent_to exon and overlaps intron. [SO:cjm, SO:ke]"
          },
          "SO:0001420": {
            "name": "trans_splice_site",
            "def": "Primary transcript region bordering trans-splice junction. [SO:ke]"
          },
          "SO:0001421": {
            "name": "splice_junction",
            "def": "The boundary between an intron and an exon. [SO:ke]"
          },
          "SO:0001422": {
            "name": "conformational_switch",
            "def": "A region of a polypeptide, involved in the transition from one conformational state to another. [SO:ke]"
          },
          "SO:0001423": {
            "name": "dye_terminator_read",
            "def": "A read produced by the dye terminator method of sequencing. [SO:ke]"
          },
          "SO:0001424": {
            "name": "pyrosequenced_read",
            "def": "A read produced by pyrosequencing technology. [SO:ke]"
          },
          "SO:0001425": {
            "name": "ligation_based_read",
            "def": "A read produced by ligation based sequencing technologies. [SO:ke]"
          },
          "SO:0001426": {
            "name": "polymerase_synthesis_read",
            "def": "A read produced by the polymerase based sequence by synthesis method. [SO:ke]"
          },
          "SO:0001427": {
            "name": "cis_regulatory_frameshift_element",
            "def": "A structural region in an RNA molecule which promotes ribosomal frameshifting of cis coding sequence. [RFAM:jd]"
          },
          "SO:0001428": {
            "name": "expressed_sequence_assembly",
            "def": "A sequence assembly derived from expressed sequences. [SO:ke]"
          },
          "SO:0001429": {
            "name": "DNA_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with DNA. [SO:ke]"
          },
          "SO:0001431": {
            "name": "cryptic_gene",
            "def": "A gene that is not transcribed under normal conditions and is not critical to normal cellular functioning. [SO:ke]"
          },
          "SO:0001432": {
            "name": "sequence_variant_affecting_polyadenylation"
          },
          "SO:0001433": {
            "name": "three_prime_RACE_clone",
            "def": "A three prime RACE (Rapid Amplification of cDNA Ends) clone is a cDNA clone copied from the 3' end of an mRNA (using a poly-dT primer to capture the polyA tail and a gene-specific or randomly primed 5' primer), and spliced into a vector for propagation in a suitable host. [modENCODE:nlw]"
          },
          "SO:0001434": {
            "name": "cassette_pseudogene",
            "def": "A cassette pseudogene is a kind of gene in an inactive form which may recombine at a telomeric locus to form a functional copy. [SO:ke]"
          },
          "SO:0001435": {
            "name": "alanine"
          },
          "SO:0001436": {
            "name": "valine"
          },
          "SO:0001437": {
            "name": "leucine"
          },
          "SO:0001438": {
            "name": "isoleucine"
          },
          "SO:0001439": {
            "name": "proline"
          },
          "SO:0001440": {
            "name": "tryptophan"
          },
          "SO:0001441": {
            "name": "phenylalanine"
          },
          "SO:0001442": {
            "name": "methionine"
          },
          "SO:0001443": {
            "name": "glycine"
          },
          "SO:0001444": {
            "name": "serine"
          },
          "SO:0001445": {
            "name": "threonine"
          },
          "SO:0001446": {
            "name": "tyrosine"
          },
          "SO:0001447": {
            "name": "cysteine"
          },
          "SO:0001448": {
            "name": "glutamine"
          },
          "SO:0001449": {
            "name": "asparagine"
          },
          "SO:0001450": {
            "name": "lysine"
          },
          "SO:0001451": {
            "name": "arginine"
          },
          "SO:0001452": {
            "name": "histidine"
          },
          "SO:0001453": {
            "name": "aspartic_acid"
          },
          "SO:0001454": {
            "name": "glutamic_acid"
          },
          "SO:0001455": {
            "name": "selenocysteine"
          },
          "SO:0001456": {
            "name": "pyrrolysine"
          },
          "SO:0001457": {
            "name": "transcribed_cluster",
            "def": "A region defined by a set of transcribed sequences from the same gene or expressed pseudogene. [SO:ke]"
          },
          "SO:0001458": {
            "name": "unigene_cluster",
            "def": "A kind of transcribed_cluster defined by a set of transcribed sequences from the a unique gene. [SO:ke]"
          },
          "SO:0001459": {
            "name": "CRISPR",
            "def": "Clustered Palindromic Repeats interspersed with bacteriophage derived spacer sequences. [RFAM:jd]"
          },
          "SO:0001460": {
            "name": "insulator_binding_site",
            "def": "A binding site that, in an insulator region of a nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
          },
          "SO:0001461": {
            "name": "enhancer_binding_site",
            "def": "A binding site that, in the enhancer region of a nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
          },
          "SO:0001462": {
            "name": "contig_collection",
            "def": "A collection of contigs. [SO:ke]"
          },
          "SO:0001463": {
            "name": "lincRNA",
            "def": "A multiexonic non-coding RNA transcribed by RNA polymerase II. [PMID:19182780, SO:ke]"
          },
          "SO:0001464": {
            "name": "UST",
            "def": "An EST spanning part or all of the untranslated regions of a protein-coding transcript. [SO:nlw]"
          },
          "SO:0001465": {
            "name": "three_prime_UST",
            "def": "A UST located in the 3'UTR of a protein-coding transcript. [SO:nlw]"
          },
          "SO:0001466": {
            "name": "five_prime_UST",
            "def": "An UST located in the 5'UTR of a protein-coding transcript. [SO:nlw]"
          },
          "SO:0001467": {
            "name": "RST",
            "def": "A tag produced from a single sequencing read from a RACE product; typically a few hundred base pairs long. [SO:nlw]"
          },
          "SO:0001468": {
            "name": "three_prime_RST",
            "def": "A tag produced from a single sequencing read from a 3'-RACE product; typically a few hundred base pairs long. [SO:nlw]"
          },
          "SO:0001469": {
            "name": "five_prime_RST",
            "def": "A tag produced from a single sequencing read from a 5'-RACE product; typically a few hundred base pairs long. [SO:nlw]"
          },
          "SO:0001470": {
            "name": "UST_match",
            "def": "A match against an UST sequence. [SO:nlw]"
          },
          "SO:0001471": {
            "name": "RST_match",
            "def": "A match against an RST sequence. [SO:nlw]"
          },
          "SO:0001472": {
            "name": "primer_match",
            "def": "A nucleotide match to a primer sequence. [SO:nlw]"
          },
          "SO:0001473": {
            "name": "miRNA_antiguide",
            "def": "A region of the pri miRNA that base pairs with the guide to form the hairpin. [SO:ke]"
          },
          "SO:0001474": {
            "name": "trans_splice_junction",
            "def": "The boundary between the spliced leader and the first exon of the mRNA. [SO:ke]"
          },
          "SO:0001475": {
            "name": "outron",
            "def": "A region of a primary transcript, that is removed via trans splicing. [PMID:16401417, SO:ke]"
          },
          "SO:0001476": {
            "name": "natural_plasmid",
            "def": "A plasmid that occurs naturally. [SO:xp]"
          },
          "SO:0001477": {
            "name": "gene_trap_construct",
            "def": "A gene trap construct is a type of engineered plasmid which is designed to integrate into a genome and produce a fusion transcript between exons of the gene into which it inserts and a reporter element in the construct. Gene traps contain a splice acceptor, do not contain promoter elements for the reporter, and are mutagenic. Gene traps may be bicistronic with the second cassette containing a promoter driving an a selectable marker. [ZFIN:dh]"
          },
          "SO:0001478": {
            "name": "promoter_trap_construct",
            "def": "A promoter trap construct is a type of engineered plasmid which is designed to integrate into a genome and express a reporter when inserted in close proximity to a promoter element. Promoter traps typically do not contain promoter elements and are mutagenic. [ZFIN:dh]"
          },
          "SO:0001479": {
            "name": "enhancer_trap_construct",
            "def": "An enhancer trap construct is a type of engineered plasmid which is designed to integrate into a genome and express a reporter when the expression from a basic minimal promoter is enhanced by genomic enhancer elements. Enhancer traps contain promoter elements and are not usually mutagenic. [ZFIN:dh]"
          },
          "SO:0001480": {
            "name": "PAC_end",
            "def": "A region of sequence from the end of a PAC clone that may provide a highly specific marker. [ZFIN:mh]"
          },
          "SO:0001481": {
            "name": "RAPD",
            "def": "RAPD is a 'PCR product' where a sequence variant is identified through the use of PCR with random primers. [ZFIN:mh]"
          },
          "SO:0001482": {
            "name": "shadow_enhancer"
          },
          "SO:0001483": {
            "name": "SNV",
            "def": "SNVs are single nucleotide positions in genomic DNA at which different sequence alternatives exist. [SO:bm]"
          },
          "SO:0001484": {
            "name": "X_element_combinatorial_repeat",
            "def": "An X element combinatorial repeat is a repeat region located between the X element and the telomere or adjacent Y' element. [http://www.yeastgenome.org/help/glossary.html]"
          },
          "SO:0001485": {
            "name": "Y_prime_element",
            "def": "A Y' element is a repeat region (SO:0000657) located adjacent to telomeric repeats or X element combinatorial repeats, either as a single copy or tandem repeat of two to four copies. [http:http://www.yeastgenome.org/help/glossary.html]"
          },
          "SO:0001486": {
            "name": "standard_draft",
            "def": "The status of a whole genome sequence, where the data is minimally filtered or un-filtered, from any number of sequencing platforms, and is assembled into contigs. Genome sequence of this quality may harbour regions of poor quality and can be relatively incomplete. [DOI:10.1126]"
          },
          "SO:0001487": {
            "name": "high_quality_draft",
            "def": "The status of a whole genome sequence, where overall coverage represents at least 90 percent of the genome. [DOI:10.1126]"
          },
          "SO:0001488": {
            "name": "improved_high_quality_draft",
            "def": "The status of a whole genome sequence, where additional work has been performed, using either manual or automated methods, such as gap resolution. [DOI:10.1126]"
          },
          "SO:0001489": {
            "name": "annotation_directed_improved_draft",
            "def": "The status of a whole genome sequence,where annotation, and verification of coding regions has occurred. [DOI:10.1126]"
          },
          "SO:0001490": {
            "name": "noncontiguous_finished",
            "def": "The status of a whole genome sequence, where the assembly is high quality, closure approaches have been successful for most gaps, misassemblies and low quality regions. [DOI:10.1126]"
          },
          "SO:0001491": {
            "name": "finished_genome",
            "def": "The status of a whole genome sequence, with less than 1 error per 100,000 base pairs. [DOI:10.1126]"
          },
          "SO:0001492": {
            "name": "intronic_regulatory_region",
            "def": "A regulatory region that is part of an intron. [SO:ke]"
          },
          "SO:0001493": {
            "name": "centromere_DNA_Element_I",
            "def": "A centromere DNA Element I (CDEI) is a conserved region, part of the centromere, consisting of a consensus region composed of 8-11bp which enables binding by the centromere binding factor 1(Cbf1p). [PMID:11222754]"
          },
          "SO:0001494": {
            "name": "centromere_DNA_Element_II",
            "def": "A centromere DNA Element II (CDEII) is part a conserved region of the centromere, consisting of a consensus region that is AT-rich and ~ 75-100 bp in length. [PMID:11222754]"
          },
          "SO:0001495": {
            "name": "centromere_DNA_Element_III",
            "def": "A centromere DNA Element I (CDEI) is a conserved region, part of the centromere, consisting of a consensus region that consists of a 25-bp which enables binding by the centromere DNA binding factor 3 (CBF3) complex. [PMID:11222754]"
          },
          "SO:0001496": {
            "name": "telomeric_repeat",
            "def": "The telomeric repeat is a repeat region, part of the chromosome, which in yeast, is a G-rich terminal sequence of the form (TG(1-3))n or more precisely ((TG)(1-6)TG(2-3))n. [PMID:8720065]"
          },
          "SO:0001497": {
            "name": "X_element",
            "def": "The X element is a conserved region, of the telomere, of ~475 bp that contains an ARS sequence and in most cases an Abf1p binding site. [http://www.yeastgenome.org/help/glossary.html#xelemcoresequence, PMID:7785338, PMID:8005434]"
          },
          "SO:0001498": {
            "name": "YAC_end",
            "def": "A region of sequence from the end of a YAC clone that may provide a highly specific marker. [SO:ke]"
          },
          "SO:0001499": {
            "name": "whole_genome_sequence_status",
            "def": "The status of whole genome sequence. [DOI:10.1126]"
          },
          "SO:0001500": {
            "name": "heritable_phenotypic_marker",
            "def": "A biological_region characterized as a single heritable trait in a phenotype screen. The heritable phenotype may be mapped to a chromosome but generally has not been characterized to a specific gene locus. [JAX:hdene]"
          },
          "SO:0001501": {
            "name": "peptide_collection",
            "def": "A collection of peptide sequences. [BBOP:nlw]"
          },
          "SO:0001502": {
            "name": "high_identity_region",
            "def": "An experimental feature with high sequence identity to another sequence. [SO:ke]"
          },
          "SO:0001503": {
            "name": "processed_transcript",
            "def": "A transcript for which no open reading frame has been identified and for which no other function has been determined. [MGI:hdeen]"
          },
          "SO:0001504": {
            "name": "assortment_derived_variation",
            "def": "A chromosome variation derived from an event during meiosis. [SO:ke]"
          },
          "SO:0001505": {
            "name": "reference_genome",
            "def": "A collection of sequences (often chromosomes) taken as the standard for a given organism and genome assembly. [SO:ke]"
          },
          "SO:0001506": {
            "name": "variant_genome",
            "def": "A collection of sequences (often chromosomes) of an individual. [SO:ke]"
          },
          "SO:0001507": {
            "name": "variant_collection",
            "def": "A collection of one or more sequences of an individual. [SO:ke]"
          },
          "SO:0001508": {
            "name": "alteration_attribute"
          },
          "SO:0001509": {
            "name": "chromosomal_variation_attribute"
          },
          "SO:0001510": {
            "name": "intrachromosomal"
          },
          "SO:0001511": {
            "name": "interchromosomal"
          },
          "SO:0001512": {
            "name": "insertion_attribute",
            "def": "A quality of a chromosomal insertion,. [SO:ke]"
          },
          "SO:0001513": {
            "name": "tandem"
          },
          "SO:0001514": {
            "name": "direct",
            "def": "A quality of an insertion where the insert is not in a cytologically inverted orientation. [SO:ke]"
          },
          "SO:0001515": {
            "name": "inverted",
            "def": "A quality of an insertion where the insert is in a cytologically inverted orientation. [SO:ke]"
          },
          "SO:0001516": {
            "name": "free",
            "def": "The quality of a duplication where the new region exists independently of the original. [SO:ke]"
          },
          "SO:0001517": {
            "name": "inversion_attribute"
          },
          "SO:0001518": {
            "name": "pericentric"
          },
          "SO:0001519": {
            "name": "paracentric"
          },
          "SO:0001520": {
            "name": "translocaton_attribute"
          },
          "SO:0001521": {
            "name": "reciprocal"
          },
          "SO:0001522": {
            "name": "insertional"
          },
          "SO:0001523": {
            "name": "duplication_attribute"
          },
          "SO:0001524": {
            "name": "chromosomally_aberrant_genome"
          },
          "SO:0001525": {
            "name": "assembly_error_correction",
            "def": "A region of sequence where the final nucleotide assignment differs from the original assembly due to an improvement that replaces a mistake. [SO:ke]"
          },
          "SO:0001526": {
            "name": "base_call_error_correction",
            "def": "A region of sequence where the final nucleotide assignment is different from that given by the base caller due to an improvement that replaces a mistake. [SO:ke]"
          },
          "SO:0001527": {
            "name": "peptide_localization_signal",
            "def": "A region of peptide sequence used to target the polypeptide molecule to a specific organelle. [SO:ke]"
          },
          "SO:0001528": {
            "name": "nuclear_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the nucleus. [SO:ke]"
          },
          "SO:0001529": {
            "name": "endosomal_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the endosome. [SO:ke]"
          },
          "SO:0001530": {
            "name": "lysosomal_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the lysosome. [SO:ke]"
          },
          "SO:0001531": {
            "name": "nuclear_export_signal",
            "def": "A polypeptide region that targets a polypeptide to he cytoplasm. [SO:ke]"
          },
          "SO:0001532": {
            "name": "recombination_signal_sequence",
            "def": "A region recognized by a recombinase. [SO:ke]"
          },
          "SO:0001533": {
            "name": "cryptic_splice_site",
            "def": "A splice site that is in part of the transcript not normally spliced. They occur via mutation or transcriptional error. [SO:ke]"
          },
          "SO:0001534": {
            "name": "nuclear_rim_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the nuclear rim. [SO:ke]"
          },
          "SO:0001535": {
            "name": "p_element",
            "def": "A P_element is a DNA transposon responsible for hybrid dysgenesis. [SO:ke]"
          },
          "SO:0001536": {
            "name": "functional_variant",
            "def": "A sequence variant in which the function of a gene product is altered with respect to a reference. [SO:ke]"
          },
          "SO:0001537": {
            "name": "structural_variant",
            "def": "A sequence variant that changes one or more sequence features. [SO:ke]"
          },
          "SO:0001538": {
            "name": "transcript_function_variant",
            "def": "A sequence variant which alters the functioning of a transcript with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001539": {
            "name": "translational_product_function_variant",
            "def": "A sequence variant that affects the functioning of a translational product with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001540": {
            "name": "level_of_transcript_variant",
            "def": "A sequence variant which alters the level of a transcript. [SO:ke]"
          },
          "SO:0001541": {
            "name": "decreased_transcript_level_variant",
            "def": "A sequence variant that increases the level of mature, spliced and processed RNA with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001542": {
            "name": "increased_transcript_level_variant",
            "def": "A sequence variant that increases the level of mature, spliced and processed RNA with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001543": {
            "name": "transcript_processing_variant",
            "def": "A sequence variant that affects the post transcriptional processing of a transcript with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001544": {
            "name": "editing_variant",
            "def": "A transcript processing variant whereby the process of editing is disrupted with respect to the reference. [SO:ke]"
          },
          "SO:0001545": {
            "name": "polyadenylation_variant",
            "def": "A sequence variant that changes polyadenylation with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001546": {
            "name": "transcript_stability_variant",
            "def": "A variant that changes the stability of a transcript with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001547": {
            "name": "decreased_transcript_stability_variant",
            "def": "A sequence variant that decreases transcript stability with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001548": {
            "name": "increased_transcript_stability_variant",
            "def": "A sequence variant that increases transcript stability with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001549": {
            "name": "transcription_variant",
            "def": "A variant that changes alters the transcription of a transcript with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001550": {
            "name": "rate_of_transcription_variant",
            "def": "A sequence variant that changes the rate of transcription with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001551": {
            "name": "increased_transcription_rate_variant",
            "def": "A sequence variant that increases the rate of transcription with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001552": {
            "name": "decreased_transcription_rate_variant",
            "def": "A sequence variant that decreases the rate of transcription with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001553": {
            "name": "translational_product_level_variant",
            "def": "A functional variant that changes the translational product level with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001554": {
            "name": "polypeptide_function_variant",
            "def": "A sequence variant which changes polypeptide functioning with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001555": {
            "name": "decreased_translational_product_level",
            "def": "A sequence variant which decreases the translational product level with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001556": {
            "name": "increased_translational_product_level",
            "def": "A sequence variant which increases the translational product level with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001557": {
            "name": "polypeptide_gain_of_function_variant",
            "def": "A sequence variant which causes gain of polypeptide function with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001558": {
            "name": "polypeptide_localization_variant",
            "def": "A sequence variant which changes the localization of a polypeptide with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001559": {
            "name": "polypeptide_loss_of_function_variant",
            "def": "A sequence variant that causes the loss of a polypeptide function with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001560": {
            "name": "inactive_ligand_binding_site",
            "def": "A sequence variant that causes the inactivation of a ligand binding site with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001561": {
            "name": "polypeptide_partial_loss_of_function",
            "def": "A sequence variant that causes some but not all loss of polypeptide function with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001562": {
            "name": "polypeptide_post_translational_processing_variant",
            "def": "A sequence variant that causes a change in post translational processing of the peptide with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001563": {
            "name": "copy_number_change",
            "def": "A sequence variant where copies of a feature (CNV) are either increased or decreased. [SO:ke]"
          },
          "SO:0001564": {
            "name": "gene_variant",
            "def": "A sequence variant where the structure of the gene is changed. [SO:ke]"
          },
          "SO:0001565": {
            "name": "gene_fusion",
            "def": "A sequence variant whereby a two genes have become joined. [SO:ke]"
          },
          "SO:0001566": {
            "name": "regulatory_region_variant",
            "def": "A sequence variant located within a regulatory region. [SO:ke]"
          },
          "SO:0001567": {
            "name": "stop_retained_variant",
            "def": "A sequence variant where at least one base in the terminator codon is changed, but the terminator remains. [SO:ke]"
          },
          "SO:0001568": {
            "name": "splicing_variant",
            "def": "A sequence variant that changes the process of splicing. [SO:ke]"
          },
          "SO:0001569": {
            "name": "cryptic_splice_site_variant",
            "def": "A sequence variant causing a new (functional) splice site. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:0001570": {
            "name": "cryptic_splice_acceptor",
            "def": "A sequence variant whereby a new splice site is created due to the activation of a new acceptor. [SO:ke]"
          },
          "SO:0001571": {
            "name": "cryptic_splice_donor",
            "def": "A sequence variant whereby a new splice site is created due to the activation of a new donor. [SO:ke]"
          },
          "SO:0001572": {
            "name": "exon_loss_variant",
            "def": "A sequence variant whereby an exon is lost from the transcript. [SO:ke]"
          },
          "SO:0001573": {
            "name": "intron_gain_variant",
            "def": "A sequence variant whereby an intron is gained by the processed transcript; usually a result of an alteration of the donor or acceptor. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:0001574": {
            "name": "splice_acceptor_variant",
            "def": "A splice variant that changes the 2 base region at the 3' end of an intron. [SO:ke]"
          },
          "SO:0001575": {
            "name": "splice_donor_variant",
            "def": "A splice variant that changes the 2 base pair region at the 5' end of an intron. [SO:ke]"
          },
          "SO:0001576": {
            "name": "transcript_variant",
            "def": "A sequence variant that changes the structure of the transcript. [SO:ke]"
          },
          "SO:0001577": {
            "name": "complex_transcript_variant",
            "def": "A transcript variant with a complex INDEL- Insertion or deletion that spans an exon/intron border or a coding sequence/UTR border. [http://ensembl.org/info/docs/variation/index.html]"
          },
          "SO:0001578": {
            "name": "stop_lost",
            "def": "A sequence variant where at least one base of the terminator codon (stop) is changed, resulting in an elongated transcript. [SO:ke]"
          },
          "SO:0001579": {
            "name": "transcript_sequence_variant"
          },
          "SO:0001580": {
            "name": "coding_sequence_variant",
            "def": "A sequence variant that changes the coding sequence. [SO:ke]"
          },
          "SO:0001582": {
            "name": "initiator_codon_variant",
            "def": "A codon variant that changes at least one base of the first codon of a transcript. [SO:ke]"
          },
          "SO:0001583": {
            "name": "missense_variant",
            "def": "A sequence variant, that changes one or more bases, resulting in a different amino acid sequence but where the length is preserved. [EBI:fc, EBI:gr, SO:ke]"
          },
          "SO:0001585": {
            "name": "conservative_missense_variant",
            "def": "A sequence variant whereby at least one base of a codon is changed resulting in a codon that encodes for a different but similar amino acid. These variants may or may not be deleterious. [SO:ke]"
          },
          "SO:0001586": {
            "name": "non_conservative_missense_variant",
            "def": "A sequence variant whereby at least one base of a codon is changed resulting in a codon that encodes for an amino acid with different biochemical properties. [SO:ke]"
          },
          "SO:0001587": {
            "name": "stop_gained",
            "def": "A sequence variant whereby at least one base of a codon is changed, resulting in a premature stop codon, leading to a shortened transcript. [SO:ke]"
          },
          "SO:0001589": {
            "name": "frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, because the number of nucleotides inserted or deleted is not a multiple of three. [SO:ke]"
          },
          "SO:0001590": {
            "name": "terminator_codon_variant",
            "def": "A sequence variant whereby at least one of the bases in the terminator codon is changed. [SO:ke]"
          },
          "SO:0001591": {
            "name": "frame_restoring_variant",
            "def": "A sequence variant that reverts the sequence of a previous frameshift mutation back to the initial frame. [SO:ke]"
          },
          "SO:0001592": {
            "name": "minus_1_frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, by shifting one base ahead. [http://arjournals.annualreviews.org/doi/pdf/10.1146/annurev.ge.08.120174.001535]"
          },
          "SO:0001593": {
            "name": "minus_2_frameshift_variant"
          },
          "SO:0001594": {
            "name": "plus_1_frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, by shifting one base backward. [http://arjournals.annualreviews.org/doi/pdf/10.1146/annurev.ge.08.120174.001535]"
          },
          "SO:0001595": {
            "name": "plus_2_frameshift_variant"
          },
          "SO:0001596": {
            "name": "transcript_secondary_structure_variant",
            "def": "A sequence variant within a transcript that changes the secondary structure of the RNA product. [SO:ke]"
          },
          "SO:0001597": {
            "name": "compensatory_transcript_secondary_structure_variant",
            "def": "A secondary structure variant that compensate for the change made by a previous variant. [SO:ke]"
          },
          "SO:0001598": {
            "name": "translational_product_structure_variant",
            "def": "A sequence variant within the transcript that changes the structure of the translational product. [SO:ke]"
          },
          "SO:0001599": {
            "name": "3D_polypeptide_structure_variant",
            "def": "A sequence variant that changes the resulting polypeptide structure. [SO:ke]"
          },
          "SO:0001600": {
            "name": "complex_3D_structural_variant",
            "def": "A sequence variant that changes the resulting polypeptide structure. [SO:ke]"
          },
          "SO:0001601": {
            "name": "conformational_change_variant",
            "def": "A sequence variant in the CDS region that causes a conformational change in the resulting polypeptide sequence. [SO:ke]"
          },
          "SO:0001602": {
            "name": "complex_change_of_translational_product_variant"
          },
          "SO:0001603": {
            "name": "polypeptide_sequence_variant",
            "def": "A sequence variant with in the CDS that causes a change in the resulting polypeptide sequence. [SO:ke]"
          },
          "SO:0001604": {
            "name": "amino_acid_deletion",
            "def": "A sequence variant within a CDS resulting in the loss of an amino acid from the resulting polypeptide. [SO:ke]"
          },
          "SO:0001605": {
            "name": "amino_acid_insertion",
            "def": "A sequence variant within a CDS resulting in the gain of an amino acid to the resulting polypeptide. [SO:ke]"
          },
          "SO:0001606": {
            "name": "amino_acid_substitution",
            "def": "A sequence variant of a codon resulting in the substitution of one amino acid for another in the resulting polypeptide. [SO:ke]"
          },
          "SO:0001607": {
            "name": "conservative_amino_acid_substitution",
            "def": "A sequence variant of a codon causing the substitution of a similar amino acid for another in the resulting polypeptide. [SO:ke]"
          },
          "SO:0001608": {
            "name": "non_conservative_amino_acid_substitution",
            "def": "A sequence variant of a codon causing the substitution of a non conservative amino acid for another in the resulting polypeptide. [SO:ke]"
          },
          "SO:0001609": {
            "name": "elongated_polypeptide",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence. [SO:ke]"
          },
          "SO:0001610": {
            "name": "elongated_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
          },
          "SO:0001611": {
            "name": "elongated_polypeptide_N_terminal",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
          },
          "SO:0001612": {
            "name": "elongated_in_frame_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes in frame elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
          },
          "SO:0001613": {
            "name": "elongated_out_of_frame_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes out of frame elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
          },
          "SO:0001614": {
            "name": "elongated_in_frame_polypeptide_N_terminal_elongation",
            "def": "A sequence variant with in the CDS that causes in frame elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
          },
          "SO:0001615": {
            "name": "elongated_out_of_frame_polypeptide_N_terminal",
            "def": "A sequence variant with in the CDS that causes out of frame elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
          },
          "SO:0001616": {
            "name": "polypeptide_fusion",
            "def": "A sequence variant that causes a fusion of two polypeptide sequences. [SO:ke]"
          },
          "SO:0001617": {
            "name": "polypeptide_truncation",
            "def": "A sequence variant of the CD that causes a truncation of the resulting polypeptide. [SO:ke]"
          },
          "SO:0001618": {
            "name": "inactive_catalytic_site",
            "def": "A sequence variant that causes the inactivation of a catalytic site with respect to a reference sequence. [SO:ke]"
          },
          "SO:0001619": {
            "name": "non_coding_transcript_variant",
            "def": "A transcript variant of a non coding RNA gene. [SO:ke]"
          },
          "SO:0001620": {
            "name": "mature_miRNA_variant",
            "def": "A transcript variant located with the sequence of the mature miRNA. [SO:ke]"
          },
          "SO:0001621": {
            "name": "NMD_transcript_variant",
            "def": "A variant in a transcript that is the target of NMD. [SO:ke]"
          },
          "SO:0001622": {
            "name": "UTR_variant",
            "def": "A transcript variant that is located within the UTR. [SO:ke]"
          },
          "SO:0001623": {
            "name": "5_prime_UTR_variant",
            "def": "A UTR variant of the 5' UTR. [SO:ke]"
          },
          "SO:0001624": {
            "name": "3_prime_UTR_variant",
            "def": "A UTR variant of the 3' UTR. [SO:ke]"
          },
          "SO:0001626": {
            "name": "incomplete_terminal_codon_variant",
            "def": "A sequence variant where at least one base of the final codon of an incompletely annotated transcript is changed. [SO:ke]"
          },
          "SO:0001627": {
            "name": "intron_variant",
            "def": "A transcript variant occurring within an intron. [SO:ke]"
          },
          "SO:0001628": {
            "name": "intergenic_variant",
            "def": "A sequence variant located in the intergenic region, between genes. [SO:ke]"
          },
          "SO:0001629": {
            "name": "splice_site_variant",
            "def": "A sequence variant that changes the first two or last two bases of an intron, or the 5th base from the start of the intron in the orientation of the transcript. [http://ensembl.org/info/docs/variation/index.html]"
          },
          "SO:0001630": {
            "name": "splice_region_variant",
            "def": "A sequence variant in which a change has occurred within the region of the splice site, either within 1-3 bases of the exon or 3-8 bases of the intron. [http://ensembl.org/info/docs/variation/index.html]"
          },
          "SO:0001631": {
            "name": "upstream_gene_variant",
            "def": "A sequence variant located 5' of a gene. [SO:ke]"
          },
          "SO:0001632": {
            "name": "downstream_gene_variant",
            "def": "A sequence variant located 3' of a gene. [SO:ke]"
          },
          "SO:0001633": {
            "name": "5KB_downstream_variant",
            "def": "A sequence variant located within 5 KB of the end of a gene. [SO:ke]"
          },
          "SO:0001634": {
            "name": "500B_downstream_variant",
            "def": "A sequence variant located within a half KB of the end of a gene. [SO:ke]"
          },
          "SO:0001635": {
            "name": "5KB_upstream_variant",
            "def": "A sequence variant located within 5KB 5' of a gene. [SO:ke]"
          },
          "SO:0001636": {
            "name": "2KB_upstream_variant",
            "def": "A sequence variant located within 2KB 5' of a gene. [SO:ke]"
          },
          "SO:0001637": {
            "name": "rRNA_gene",
            "def": "A gene that encodes for ribosomal RNA. [SO:ke]"
          },
          "SO:0001638": {
            "name": "piRNA_gene",
            "def": "A gene that encodes for an piwi associated RNA. [SO:ke]"
          },
          "SO:0001639": {
            "name": "RNase_P_RNA_gene",
            "def": "A gene that encodes an RNase P RNA. [SO:ke]"
          },
          "SO:0001640": {
            "name": "RNase_MRP_RNA_gene",
            "def": "A gene that encodes a RNase_MRP_RNA. [SO:ke]"
          },
          "SO:0001641": {
            "name": "lincRNA_gene",
            "def": "A gene that encodes large intervening non-coding RNA. [SO:ke]"
          },
          "SO:0001642": {
            "name": "mathematically_defined_repeat",
            "def": "A mathematically defined repeat (MDR) is a experimental feature that is determined by querying overlapping oligomers of length k against a database of shotgun sequence data and identifying regions in the query sequence that exceed a statistically determined threshold of repetitiveness. [SO:jestill]"
          },
          "SO:0001643": {
            "name": "telomerase_RNA_gene",
            "def": "A telomerase RNA gene is a non coding RNA gene the RNA product of which is a component of telomerase. [SO:ke]"
          },
          "SO:0001644": {
            "name": "targeting_vector",
            "def": "An engineered vector that is able to take part in homologous recombination in a host with the intent of introducing site specific genomic modifications. [MGD:tm, PMID:10354467]"
          },
          "SO:0001645": {
            "name": "genetic_marker",
            "def": "A measurable sequence feature that varies within a population. [SO:db]"
          },
          "SO:0001646": {
            "name": "DArT_marker",
            "def": "A genetic marker, discovered using Diversity Arrays Technology (DArT) technology. [SO:ke]"
          },
          "SO:0001647": {
            "name": "kozak_sequence",
            "def": "A kind of ribosome entry site, specific to Eukaryotic organisms that overlaps part of both 5' UTR and CDS sequence. [SO:ke]"
          },
          "SO:0001648": {
            "name": "nested_transposon",
            "def": "A transposon that is disrupted by the insertion of another element. [SO:ke]"
          },
          "SO:0001649": {
            "name": "nested_repeat",
            "def": "A repeat that is disrupted by the insertion of another element. [SO:ke]"
          },
          "SO:0001650": {
            "name": "inframe_variant",
            "def": "A sequence variant which does not cause a disruption of the translational reading frame. [SO:ke]"
          },
          "SO:0001653": {
            "name": "retinoic_acid_responsive_element",
            "def": "A transcription factor binding site of variable direct repeats of the sequence PuGGTCA spaced by five nucleotides (DR5) found in the promoters of retinoic acid-responsive genes, to which retinoic acid receptors bind. [PMID:11327309, PMID:19917671]"
          },
          "SO:0001654": {
            "name": "nucleotide_to_protein_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
          },
          "SO:0001655": {
            "name": "nucleotide_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with nucleotide residues. [SO:cb]"
          },
          "SO:0001656": {
            "name": "metal_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with metal ions. [SO:cb]"
          },
          "SO:0001657": {
            "name": "ligand_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with a small molecule such as a drug, or hormone. [SO:ke]"
          },
          "SO:0001658": {
            "name": "nested_tandem_repeat",
            "def": "An NTR is a nested repeat of two distinct tandem motifs interspersed with each other. [SO:AF]"
          },
          "SO:0001659": {
            "name": "promoter_element"
          },
          "SO:0001660": {
            "name": "core_promoter_element"
          },
          "SO:0001661": {
            "name": "RNA_polymerase_II_TATA_box",
            "def": "A TATA box core promoter of a gene transcribed by RNA polymerase II. [PMID:16858867]"
          },
          "SO:0001662": {
            "name": "RNA_polymerase_III_TATA_box",
            "def": "A TATA box core promoter of a gene transcribed by RNA polymerase III. [SO:ke]"
          },
          "SO:0001663": {
            "name": "BREd_motif",
            "def": "A core TRNA polymerase II promoter element with consensus (G/A)T(T/G/A)(T/A)(G/T)(T/G)(T/G). [PMID:16858867]"
          },
          "SO:0001664": {
            "name": "DCE",
            "def": "A discontinuous core element of RNA polymerase II transcribed genes, situated downstream of the TSS. It is composed of three sub elements: SI, SII and SIII. [PMID:16858867]"
          },
          "SO:0001665": {
            "name": "DCE_SI",
            "def": "A sub element of the DCE core promoter element, with consensus sequence CTTC. [PMID:16858867, SO:ke]"
          },
          "SO:0001666": {
            "name": "DCE_SII",
            "def": "A sub element of the DCE core promoter element with consensus sequence CTGT. [PMID:16858867, SO:ke]"
          },
          "SO:0001667": {
            "name": "DCE_SIII",
            "def": "A sub element of the DCE core promoter element with consensus sequence AGC. [PMID:16858867, SO:ke]"
          },
          "SO:0001668": {
            "name": "proximal_promoter_element",
            "def": "DNA segment that ranges from about -250 to -40 relative to +1 of RNA transcription start site, where sequence specific DNA-binding transcription factors binds, such as Sp1, CTF (CCAAT-binding transcription factor), and CBF (CCAAT-box binding factor). [PMID:12515390, PMID:9679020, SO:ml]"
          },
          "SO:0001669": {
            "name": "RNApol_II_core_promoter",
            "def": "The minimal portion of the promoter required to properly initiate transcription in RNA polymerase II transcribed genes. [PMID:16858867]"
          },
          "SO:0001670": {
            "name": "distal_promoter_element"
          },
          "SO:0001671": {
            "name": "bacterial_RNApol_promoter_sigma_70"
          },
          "SO:0001672": {
            "name": "bacterial_RNApol_promoter_sigma54"
          },
          "SO:0001673": {
            "name": "minus_12_signal",
            "def": "A conserved region about 12-bp upstream of the start point of bacterial transcription units, involved with sigma factor 54. [PMID:18331472]"
          },
          "SO:0001674": {
            "name": "minus_24_signal",
            "def": "A conserved region about 12-bp upstream of the start point of bacterial transcription units, involved with sigma factor 54. [PMID:18331472]"
          },
          "SO:0001675": {
            "name": "A_box_type_1",
            "def": "An A box within an RNA polymerase III type 1 promoter. [SO:ke]"
          },
          "SO:0001676": {
            "name": "A_box_type_2",
            "def": "An A box within an RNA polymerase III type 2 promoter. [SO:ke]"
          },
          "SO:0001677": {
            "name": "intermediate_element",
            "def": "A core promoter region of RNA polymerase III type 1 promoters. [PMID:12381659]"
          },
          "SO:0001678": {
            "name": "regulatory_promoter_element",
            "def": "A promoter element that is not part of the core promoter, but provides the promoter with a specific regulatory region. [PMID:12381659]"
          },
          "SO:0001679": {
            "name": "transcription_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of transcription. [SO:ke]"
          },
          "SO:0001680": {
            "name": "translation_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of translation. [SO:ke]"
          },
          "SO:0001681": {
            "name": "recombination_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of recombination. [SO:ke]"
          },
          "SO:0001682": {
            "name": "replication_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of nucleotide replication. [SO:ke]"
          },
          "SO:0001683": {
            "name": "sequence_motif",
            "def": "A sequence motif is a nucleotide or amino-acid sequence pattern that may have biological significance. [http://en.wikipedia.org/wiki/Sequence_motif]"
          },
          "SO:0001684": {
            "name": "experimental_feature_attribute",
            "def": "An attribute of an experimentally derived feature. [SO:ke]"
          },
          "SO:0001685": {
            "name": "score",
            "def": "The score of an experimentally derived feature such as a p-value. [SO:ke]"
          },
          "SO:0001686": {
            "name": "quality_value",
            "def": "An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score. [SO:ke]"
          },
          "SO:0001687": {
            "name": "restriction_enzyme_recognition_site",
            "def": "The nucleotide region (usually a palindrome) that is recognized by a restriction enzyme. This may or may not be equal to the restriction enzyme binding site. [SO:ke]"
          },
          "SO:0001688": {
            "name": "restriction_enzyme_cleavage_junction",
            "def": "The boundary at which a restriction enzyme breaks the nucleotide sequence. [SO:ke]"
          },
          "SO:0001689": {
            "name": "five_prime_restriction_enzyme_junction",
            "def": "The restriction enzyme cleavage junction on the 5' strand of the nucleotide sequence. [SO:ke]"
          },
          "SO:0001690": {
            "name": "three_prime_restriction_enzyme_junction"
          },
          "SO:0001691": {
            "name": "blunt_end_restriction_enzyme_cleavage_site"
          },
          "SO:0001692": {
            "name": "sticky_end_restriction_enzyme_cleavage_site"
          },
          "SO:0001693": {
            "name": "blunt_end_restriction_enzyme_cleavage_junction",
            "def": "A restriction enzyme cleavage site where both strands are cut at the same position. [SO:ke]"
          },
          "SO:0001694": {
            "name": "single_strand_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme cleavage site whereby only one strand is cut. [SO:ke]"
          },
          "SO:0001695": {
            "name": "restriction_enzyme_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended. [SO:ke]"
          },
          "SO:0001696": {
            "name": "experimentally_defined_binding_region",
            "def": "A region that has been implicated in binding although the exact coordinates of binding may be unknown. [SO:ke]"
          },
          "SO:0001697": {
            "name": "ChIP_seq_region",
            "def": "A region of sequence identified by CHiP seq technology to contain a protein binding site. [SO:ke]"
          },
          "SO:0001698": {
            "name": "ASPE_primer",
            "def": "\\A primer containing an SNV at the 3' end for accurate genotyping. [http://www.ncbi.nlm.nih.gov/pubmed/11252801]"
          },
          "SO:0001699": {
            "name": "dCAPS_primer",
            "def": "A primer with one or more mismatches to the DNA template corresponding to a position within a restriction enzyme recognition site. [http://www.ncbi.nlm.nih.gov/pubmed/9628033]"
          },
          "SO:0001700": {
            "name": "histone_modification",
            "def": "Histone modification is a post translationally modified region whereby residues of the histone protein are modified by methylation, acetylation, phosphorylation, ubiquitination, sumoylation, citrullination, or ADP-ribosylation. [http:en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001701": {
            "name": "histone_methylation_site",
            "def": "A histone modification site where the modification is the methylation of the residue. [SO:ke]"
          },
          "SO:0001702": {
            "name": "histone_acetylation_site",
            "def": "A histone modification where the modification is the acylation of the residue. [SO:ke]"
          },
          "SO:0001703": {
            "name": "H3K9_acetylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is acylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001704": {
            "name": "H3K14_acetylation_site",
            "def": "A kind of histone modification site, whereby the 14th residue (a lysine), from the start of the H3 histone protein is acylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001705": {
            "name": "H3K4_monomethylation_site",
            "def": "A kind of histone modification, whereby the 4th residue (a lysine), from the start of the H3 protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001706": {
            "name": "H3K4_trimethylation",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001707": {
            "name": "H3K9_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001708": {
            "name": "H3K27_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001709": {
            "name": "H3K27_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001710": {
            "name": "H3K79_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is mono- methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001711": {
            "name": "H3K79_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is di-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001712": {
            "name": "H3K79_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001713": {
            "name": "H4K20_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H4histone protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001714": {
            "name": "H2BK5_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H2B protein is methylated. [http://en.wikipedia.org/wiki/Histone]"
          },
          "SO:0001715": {
            "name": "ISRE",
            "def": "An ISRE is a transcriptional cis regulatory region, containing the consensus region: YAGTTTC(A/T)YTTTYCC, responsible for increased transcription via interferon binding. [http://genesdev.cshlp.org/content/2/4/383.abstrac]"
          },
          "SO:0001716": {
            "name": "histone_ubiqitination_site",
            "def": "A histone modification site where ubiquitin may be added. [SO:ke]"
          },
          "SO:0001717": {
            "name": "H2B_ubiquitination_site",
            "def": "A histone modification site on H2B where ubiquitin may be added. [SO:ke]"
          },
          "SO:0001718": {
            "name": "H3K18_acetylation_site",
            "def": "A kind of histone modification site, whereby the 14th residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
          },
          "SO:0001719": {
            "name": "H3K23_acylation_site",
            "def": "A kind of histone modification, whereby the 23rd residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
          },
          "SO:0001720": {
            "name": "epigenetically_modified_region",
            "def": "A biological region implicated in inherited changes caused by mechanisms other than changes in the underlying DNA sequence. [http://en.wikipedia.org/wiki/Epigenetics, SO:ke]"
          },
          "SO:0001721": {
            "name": "H3K27_acylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
          },
          "SO:0001722": {
            "name": "H3K36_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [SO:ke]"
          },
          "SO:0001723": {
            "name": "H3K36_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is dimethylated. [SO:ke]"
          },
          "SO:0001724": {
            "name": "H3K36_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [SO:ke]"
          },
          "SO:0001725": {
            "name": "H3K4_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 histone protein is di-methylated. [SO:ke]"
          },
          "SO:0001726": {
            "name": "H3K27_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is di-methylated. [SO:ke]"
          },
          "SO:0001727": {
            "name": "H3K9_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [SO:ke]"
          },
          "SO:0001728": {
            "name": "H3K9_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein may be dimethylated. [SO:ke]"
          },
          "SO:0001729": {
            "name": "H4K16_acylation_site",
            "def": "A kind of histone modification site, whereby the 16th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:ke]"
          },
          "SO:0001730": {
            "name": "H4K5_acylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:ke]"
          },
          "SO:0001731": {
            "name": "H4K8_acylation_site",
            "def": "A kind of histone modification site, whereby the 8th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:KE]"
          },
          "SO:0001732": {
            "name": "H3K27_methylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
          },
          "SO:0001733": {
            "name": "H3K36_methylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
          },
          "SO:0001734": {
            "name": "H3K4_methylation_site",
            "def": "A kind of histone modification, whereby the 4th residue (a lysine), from the start of the H3 protein is methylated. [SO:ke]"
          },
          "SO:0001735": {
            "name": "H3K79_methylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
          },
          "SO:0001736": {
            "name": "H3K9_methylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
          },
          "SO:0001737": {
            "name": "histone_acylation_region",
            "def": "A histone modification, whereby the histone protein is acylated at multiple sites in a region. [SO:ke]"
          },
          "SO:0001738": {
            "name": "H4K_acylation_region",
            "def": "A region of the H4 histone whereby multiple lysines are acylated. [SO:ke]"
          },
          "SO:0001739": {
            "name": "gene_with_non_canonical_start_codon",
            "def": "A gene with a start codon other than AUG. [SO:xp]"
          },
          "SO:0001740": {
            "name": "gene_with_start_codon_CUG",
            "def": "A gene with a translational start codon of CUG. [SO:mc]"
          },
          "SO:0001741": {
            "name": "pseudogenic_gene_segment",
            "def": "A gene segment which when incorporated by somatic recombination in the final gene transcript results in a nonfunctional product. [SO:hd]"
          },
          "SO:0001742": {
            "name": "copy_number_gain",
            "def": "A sequence alteration whereby the copy number of a given regions is greater than the reference sequence. [SO:ke]"
          },
          "SO:0001743": {
            "name": "copy_number_loss",
            "def": "A sequence alteration whereby the copy number of a given region is less than the reference sequence. [SO:ke]"
          },
          "SO:0001744": {
            "name": "UPD",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from one parent and no copies of the same chromosome or region from the other parent. [SO:BM]"
          },
          "SO:0001745": {
            "name": "maternal_uniparental_disomy",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from the mother and no copies of the same chromosome or region from the father. [SO:bm]"
          },
          "SO:0001746": {
            "name": "paternal_uniparental_disomy",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from the father and no copies of the same chromosome or region from the mother. [SO:bm]"
          },
          "SO:0001747": {
            "name": "open_chromatin_region",
            "def": "A DNA sequence that in the normal state of the chromosome corresponds to an unfolded, un-complexed stretch of double-stranded DNA. [SO:cb]"
          },
          "SO:0001748": {
            "name": "SL3_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL3 RNA leader sequence to the 5' end of an mRNA. SL3 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001749": {
            "name": "SL4_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL4 RNA leader sequence to the 5' end of an mRNA. SL4 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001750": {
            "name": "SL5_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL5 RNA leader sequence to the 5' end of an mRNA. SL5 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001751": {
            "name": "SL6_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL6 RNA leader sequence to the 5' end of an mRNA. SL6 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001752": {
            "name": "SL7_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL7 RNA leader sequence to the 5' end of an mRNA. SL7 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001753": {
            "name": "SL8_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL8 RNA leader sequence to the 5' end of an mRNA. SL8 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001754": {
            "name": "SL9_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL9 RNA leader sequence to the 5' end of an mRNA. SL9 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001755": {
            "name": "SL10_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL10 RNA leader sequence to the 5' end of an mRNA. SL10 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001756": {
            "name": "SL11_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL11 RNA leader sequence to the 5' end of an mRNA. SL11 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001757": {
            "name": "SL12_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL12 RNA leader sequence to the 5' end of an mRNA. SL12 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
          },
          "SO:0001758": {
            "name": "duplicated_pseudogene",
            "def": "A pseudogene that arose via gene duplication. Generally duplicated pseudogenes have the same structure as the original gene, including intron-exon structure and some regulatory sequence. [http://en.wikipedia.org/wiki/Pseudogene]"
          },
          "SO:0001759": {
            "name": "unitary_pseudogene",
            "def": "A pseudogene, deactivated from original state by mutation, fixed in a population. [http://en.wikipedia.org/wiki/Pseudogene, SO:ke]"
          },
          "SO:0001760": {
            "name": "non_processed_pseudogene",
            "def": "A pseudogene that arose from a means other than retrotransposition. [SO:ke]"
          },
          "SO:0001761": {
            "name": "variant_quality",
            "def": "A dependent entity that inheres in a bearer, a sequence variant. [PMID:17597783, SO:ke]"
          },
          "SO:0001762": {
            "name": "variant_origin",
            "def": "A quality inhering in a variant by virtue of its origin. [PMID:17597783, SO:ke]"
          },
          "SO:0001763": {
            "name": "variant_frequency",
            "def": "A physical quality which inheres to the variant by virtue of the number instances of the variant within a population. [PMID:17597783, SO:ke]"
          },
          "SO:0001764": {
            "name": "unique_variant",
            "def": "A physical quality which inheres to the variant by virtue of the number instances of the variant within a population. [SO:ke]"
          },
          "SO:0001765": {
            "name": "rare_variant"
          },
          "SO:0001766": {
            "name": "polymorphic_variant"
          },
          "SO:0001767": {
            "name": "common_variant"
          },
          "SO:0001768": {
            "name": "fixed_variant"
          },
          "SO:0001769": {
            "name": "variant_phenotype",
            "def": "A quality inhering in a variant by virtue of its phenotype. [PMID:17597783, SO:ke]"
          },
          "SO:0001770": {
            "name": "benign_variant"
          },
          "SO:0001771": {
            "name": "disease_associated_variant"
          },
          "SO:0001772": {
            "name": "disease_causing_variant"
          },
          "SO:0001773": {
            "name": "lethal_variant"
          },
          "SO:0001774": {
            "name": "quantitative_variant"
          },
          "SO:0001775": {
            "name": "maternal_variant"
          },
          "SO:0001776": {
            "name": "paternal_variant"
          },
          "SO:0001777": {
            "name": "somatic_variant"
          },
          "SO:0001778": {
            "name": "germline_variant"
          },
          "SO:0001779": {
            "name": "pedigree_specific_variant"
          },
          "SO:0001780": {
            "name": "population_specific_variant"
          },
          "SO:0001781": {
            "name": "de_novo_variant"
          },
          "SO:0001782": {
            "name": "TF_binding_site_variant",
            "def": "A sequence variant located within a transcription factor binding site. [EBI:fc]"
          },
          "SO:0001784": {
            "name": "complex_structural_alteration",
            "def": "A structural sequence alteration or rearrangement encompassing one or more genome fragments, with 4 or more breakpoints. [FB:reference_manual, NCBI:th, SO:ke]"
          },
          "SO:0001785": {
            "name": "structural_alteration"
          },
          "SO:0001786": {
            "name": "loss_of_heterozygosity",
            "def": "A functional variant whereby the sequence alteration causes a loss of function of one allele of a gene. [SO:ke]"
          },
          "SO:0001787": {
            "name": "splice_donor_5th_base_variant",
            "def": "A sequence variant that causes a change at the 5th base pair after the start of the intron in the orientation of the transcript. [EBI:gr]"
          },
          "SO:0001788": {
            "name": "U_box",
            "def": "An U-box is a conserved T-rich region upstream of a retroviral polypurine tract that is involved in PPT primer creation during reverse transcription. [PMID:10556309, PMID:11577982, PMID:9649446]"
          },
          "SO:0001789": {
            "name": "mating_type_region",
            "def": "A specialized region in the genomes of some yeast and fungi, the genes of which regulate mating type. [SO:ke]"
          },
          "SO:0001790": {
            "name": "paired_end_fragment",
            "def": "An assembly region that has been sequenced from both ends resulting in a read_pair (mate_pair). [SO:ke]"
          },
          "SO:0001791": {
            "name": "exon_variant",
            "def": "A sequence variant that changes exon sequence. [SO:ke]"
          },
          "SO:0001792": {
            "name": "non_coding_transcript_exon_variant",
            "def": "A sequence variant that changes non-coding exon sequence in a non-coding transcript. [EBI:fc, SO:ke]"
          },
          "SO:0001793": {
            "name": "clone_end",
            "def": "A read from an end of the clone sequence. [SO:ke]"
          },
          "SO:0001794": {
            "name": "point_centromere",
            "def": "A point centromere is a relatively small centromere (about 125 bp DNA) in discrete sequence, found in some yeast including S. cerevisiae. [PMID:7502067, SO:vw]"
          },
          "SO:0001795": {
            "name": "regional_centromere",
            "def": "A regional centromere is a large modular centromere found in fission yeast and higher eukaryotes. It consist of a central core region flanked by inverted inner and outer repeat regions. [PMID:7502067, SO:vw]"
          },
          "SO:0001796": {
            "name": "regional_centromere_central_core",
            "def": "A conserved region within the central region of a modular centromere, where the kinetochore is formed. [SO:vw]"
          },
          "SO:0001797": {
            "name": "centromeric_repeat",
            "def": "A repeat region found within the modular centromere. [SO:ke]"
          },
          "SO:0001798": {
            "name": "regional_centromere_inner_repeat_region",
            "def": "The inner inverted repeat region of a modular centromere and part of the central core surrounding a non-conserved central region. This region is adjacent to the central core, on each chromosome arm. [SO:vw]"
          },
          "SO:0001799": {
            "name": "regional_centromere_outer_repeat_region",
            "def": "The heterochromatic outer repeat region of a modular centromere. These repeats exist in tandem arrays on both chromosome arms. [SO:vw]"
          },
          "SO:0001800": {
            "name": "tasiRNA",
            "def": "The sequence of a 21 nucleotide double stranded, polyadenylated non coding RNA, transcribed from the TAS gene. [PMID:16145017]"
          },
          "SO:0001801": {
            "name": "tasiRNA_primary_transcript",
            "def": "A primary transcript encoding a tasiRNA. [PMID:16145017]"
          },
          "SO:0001802": {
            "name": "increased_polyadenylation_variant",
            "def": "A transcript processing variant whereby polyadenylation of the encoded transcript is increased with respect to the reference. [SO:ke]"
          },
          "SO:0001803": {
            "name": "decreased_polyadenylation_variant",
            "def": "A transcript processing variant whereby polyadenylation of the encoded transcript is decreased with respect to the reference. [SO:ke]"
          },
          "SO:0001804": {
            "name": "DDB_box",
            "def": "A conserved polypeptide motif that mediates protein-protein interaction and defines adaptor proteins for DDB1/cullin 4 ubiquitin ligases. [PMID:18794354, PMID:19818632]"
          },
          "SO:0001805": {
            "name": "destruction_box",
            "def": "A conserved polypeptide motif that can be recognized by both Fizzy/Cdc20- and FZR/Cdh1-activated anaphase-promoting complex/cyclosome (APC/C) and targets a protein for ubiquitination and subsequent degradation by the APC/C. The consensus sequence is RXXLXXXXN. [PMID:12208841, PMID:1842691]"
          },
          "SO:0001806": {
            "name": "ER_retention_signal",
            "def": "A C-terminal tetrapeptide motif that mediates retention of a protein in (or retrieval to) the endoplasmic reticulum. In mammals the sequence is KDEL, and in fungi HDEL or DDEL. [doi:10.1093/jxb/50.331.157, PMID:2077689]"
          },
          "SO:0001807": {
            "name": "KEN_box",
            "def": "A conserved polypeptide motif that can be recognized by FZR/Cdh1-activated anaphase-promoting complex/cyclosome (APC/C) and targets a protein for ubiquitination and subsequent degradation by the APC/C. The consensus sequence is KENXXXN. [PMID:10733526, PMID:1220884, PMID:18426916]"
          },
          "SO:0001808": {
            "name": "mitochondrial_targeting_signal",
            "def": "A polypeptide region that targets a polypeptide to the mitochondrion. [PomBase:mah]"
          },
          "SO:0001809": {
            "name": "signal_anchor",
            "def": "A signal sequence that is not cleaved from the polypeptide. Anchors a Type II membrane protein to the membrane. [http://www.cbs.dtu.dk/services/SignalP/background/biobackground.php]"
          },
          "SO:0001810": {
            "name": "PIP_box",
            "def": "A polypeptide region that mediates binding to PCNA. The consensus sequence is QXX(hh)XX(aa), where (h) denotes residues with moderately hydrophobic side chains and (a) denotes residues with highly hydrophobic aromatic side chains. [PMID:9631646]"
          },
          "SO:0001811": {
            "name": "phosphorylation_site",
            "def": "A post-translationally modified region in which residues of the protein are modified by phosphorylation. [PomBase:mah]"
          },
          "SO:0001812": {
            "name": "transmembrane_helix",
            "def": "A region that traverses the lipid bilayer and adopts a helical secondary structure. [PomBase:mah]"
          },
          "SO:0001813": {
            "name": "vacuolar_sorting_signal",
            "def": "A polypeptide region that targets a polypeptide to the vacuole. [PomBase:mah]"
          },
          "SO:0001814": {
            "name": "coding_variant_quality"
          },
          "SO:0001815": {
            "name": "synonymous"
          },
          "SO:0001816": {
            "name": "non_synonymous"
          },
          "SO:0001817": {
            "name": "inframe",
            "def": "An attribute describing a sequence that contains a mutation involving the deletion or insertion of one or more bases, where this number is divisible by 3. [SO:ke]"
          },
          "SO:0001818": {
            "name": "protein_altering_variant",
            "def": "A sequence_variant which is predicted to change the protein encoded in the coding sequence. [EBI:gr]"
          },
          "SO:0001819": {
            "name": "synonymous_variant",
            "def": "A sequence variant where there is no resulting change to the encoded amino acid. [SO:ke]"
          },
          "SO:0001820": {
            "name": "inframe_indel",
            "def": "A coding sequence variant where the change does not alter the frame of the transcript. [SO:ke]"
          },
          "SO:0001821": {
            "name": "inframe_insertion",
            "def": "An inframe non synonymous variant that inserts bases into in the coding sequence. [EBI:gr]"
          },
          "SO:0001822": {
            "name": "inframe_deletion",
            "def": "An inframe non synonymous variant that deletes bases from the coding sequence. [EBI:gr]"
          },
          "SO:0001823": {
            "name": "conservative_inframe_insertion",
            "def": "An inframe increase in cds length that inserts one or more codons into the coding sequence between existing codons. [EBI:gr]"
          },
          "SO:0001824": {
            "name": "disruptive_inframe_insertion",
            "def": "An inframe increase in cds length that inserts one or more codons into the coding sequence within an existing codon. [EBI:gr]"
          },
          "SO:0001825": {
            "name": "conservative_inframe_deletion",
            "def": "An inframe decrease in cds length that deletes one or more entire codons from the coding sequence but does not change any remaining codons. [EBI:gr]"
          },
          "SO:0001826": {
            "name": "disruptive_inframe_deletion",
            "def": "An inframe decrease in cds length that deletes bases from the coding sequence starting within an existing codon. [EBI:gr]"
          },
          "SO:0001827": {
            "name": "mRNA_read",
            "def": "A sequencer read of an mRNA substrate. [SO:ke]"
          },
          "SO:0001828": {
            "name": "genomic_DNA_read",
            "def": "A sequencer read of a genomic DNA substrate. [SO:ke]"
          },
          "SO:0001829": {
            "name": "mRNA_contig",
            "def": "A contig composed of mRNA_reads. [SO:ke]"
          },
          "SO:0001830": {
            "name": "AFLP_fragment",
            "def": "A PCR product obtained by applying the AFLP technique, based on a restriction enzyme digestion of genomic DNA and an amplification of the resulting fragments. [GMOD:ea]"
          },
          "SO:0001831": {
            "name": "protein_hmm_match",
            "def": "A match to a protein HMM such as pfam. [SO:ke]"
          },
          "SO:0001832": {
            "name": "immunoglobulin_region",
            "def": "A region of immunoglobulin sequence, either constant or variable. [SO:ke]"
          },
          "SO:0001833": {
            "name": "V_region",
            "def": "The variable region of an immunoglobulin polypeptide sequence. [SO:ke]"
          },
          "SO:0001834": {
            "name": "C_region",
            "def": "The constant region of an immunoglobulin polypeptide sequence. [SO:ke]"
          },
          "SO:0001835": {
            "name": "N_region",
            "def": "Extra nucleotides inserted between rearranged immunoglobulin segments. [SO:ke]"
          },
          "SO:0001836": {
            "name": "S_region",
            "def": "The switch region of immunoglobulin heavy chains; it is involved in the rearrangement of heavy chain DNA leading to the expression of a different immunoglobulin classes from the same B-cell. [SO:ke]"
          },
          "SO:0001837": {
            "name": "mobile_element_insertion",
            "def": "A kind of insertion where the inserted sequence is a mobile element. [EBI:dvga]"
          },
          "SO:0001838": {
            "name": "novel_sequence_insertion",
            "def": "An insertion the sequence of which cannot be mapped to the reference genome. [NCBI:th]"
          },
          "SO:0001839": {
            "name": "CSL_response_element",
            "def": "A promoter element with consensus sequence GTGRGAA, bound by CSL (CBF1/RBP-JK/Suppressor of Hairless/LAG-1) transcription factors. [PMID:19101542]"
          },
          "SO:0001840": {
            "name": "GATA_box",
            "def": "A GATA transcription factor element containing the consensus sequence WGATAR (in which W indicates A/T and R indicates A/G). [PMID:8321208]"
          },
          "SO:0001841": {
            "name": "polymorphic_pseudogene",
            "def": "Pseudogene owing to a SNP/DIP but in other individuals/haplotypes/strains the gene is translated. [JAX:hd]"
          },
          "SO:0001842": {
            "name": "AP_1_binding_site",
            "def": "A promoter element with consensus sequence TGACTCA, bound by AP-1 and related transcription factors. [PMID:1899230, PMID:3034432, PMID:3125983]"
          },
          "SO:0001843": {
            "name": "CRE",
            "def": "A promoter element with consensus sequence TGACGTCA; bound by the ATF/CREB family of transcription factors. [PMID:11483355, PMID:11483993]"
          },
          "SO:0001844": {
            "name": "CuRE",
            "def": "A promoter element bound by copper ion-sensing transcription factors such as S. cerevisiae Mac1p or S. pombe Cuf1; the consensus sequence is HTHNNGCTGD (more specifically TTTGCKCR in budding yeast). [PMID:10593913, PMID:9188496, PMID:9211922]"
          },
          "SO:0001845": {
            "name": "DRE",
            "def": "A promoter element with consensus sequence CGWGGWNGMM, bound by transcription factors related to RecA and found in promoters of genes expressed following several types of DNA damage or inhibition of DNA synthesis. [PMID:11073995, PMID:8668127]"
          },
          "SO:0001846": {
            "name": "FLEX_element",
            "def": "A promoter element that has consensus sequence GTAAACAAACAAAM and contains a heptameric core GTAAACA, bound by transcription factors with a forkhead DNA-binding domain. [PMID:10747048, PMID:14871934]"
          },
          "SO:0001847": {
            "name": "forkhead_motif",
            "def": "A promoter element with consensus sequence TTTRTTTACA, bound by transcription factors with a forkhead DNA-binding domain. [PMID:15195092]"
          },
          "SO:0001848": {
            "name": "homol_D_box",
            "def": "A core promoter element that has the consensus sequence CAGTCACA (or its inverted form TGTGACTG), and plays the role of a TATA box in promoters that do not contain a canonical TATA sequence. [PMID:7501449, PMID:8458332]"
          },
          "SO:0001849": {
            "name": "homol_E_box",
            "def": "A core promoter element that has the consensus sequence ACCCTACCCT (or its inverted form AGGGTAGGGT), and is found near the homol D box in some promoters that use a homol D box instead of a canonical TATA sequence. [PMID:7501449]"
          },
          "SO:0001850": {
            "name": "HSE",
            "def": "A promoter element that consists of at least three copies of the pentanucleotide NGAAN, bound by the heat shock transcription factor HSF. [PMID:17347150, PMID:8689565]"
          },
          "SO:0001851": {
            "name": "iron_repressed_GATA_element",
            "def": "A GATA promoter element with consensus sequence WGATAA, found in promoters of genes repressed in the presence of iron. [PMID:11956219, PMID:17211681]"
          },
          "SO:0001852": {
            "name": "mating_type_M_box",
            "def": "A promoter element with consensus sequence ACAAT, found in promoters of mating type M-specific genes in fission yeast and bound by the transcription factor Mat1-Mc. [PMID:9233811]"
          },
          "SO:0001853": {
            "name": "androgen_response_element",
            "def": "A non-palindromic sequence found in the promoters of genes whose expression is regulated in response to androgen. [PMID:21796522]"
          },
          "SO:0001854": {
            "name": "smFISH_probe",
            "def": "A smFISH is a probe that binds RNA in a single molecule in situ hybridization experiment. [PMID:18806792]"
          },
          "SO:0001855": {
            "name": "MCB",
            "def": "A promoter element with consensus sequence ACGCGT, bound by the transcription factor complex MBF (MCB-binding factor) and found in promoters of genes expressed during the G1/S transition of the cell cycle. [PMID:16285853]"
          },
          "SO:0001856": {
            "name": "CCAAT_motif",
            "def": "A promoter element with consensus sequence CCAAT, bound by a protein complex that represses transcription in response to low iron levels. [PMID:16963626]"
          },
          "SO:0001857": {
            "name": "Ace2_UAS",
            "def": "A promoter element with consensus sequence CCAGCC, bound by the fungal transcription factor Ace2. [PMID:16678171]"
          },
          "SO:0001858": {
            "name": "TR_box",
            "def": "A promoter element with consensus sequence TTCTTTGTTY, bound an HMG-box transcription factor such as S. pombe Ste11, and found in promoters of genes up-regulated early in meiosis. [PMID:1657709]"
          },
          "SO:0001859": {
            "name": "STREP_motif",
            "def": "A promoter element with consensus sequence CCCCTC, bound by the PKA-responsive zinc finger transcription factor Rst2. [PMID:11739717]"
          },
          "SO:0001860": {
            "name": "rDNA_intergenic_spacer_element",
            "def": "A DNA motif that contains a core consensus sequence AGGTAAGGGTAATGCAC, is found in the intergenic regions of rDNA repeats, and is bound by an RNA polymerase I transcription termination factor (e.g. S. pombe Reb1). [PMID:9016645]"
          },
          "SO:0001861": {
            "name": "sterol_regulatory_element",
            "def": "A 10-bp promoter element bound by sterol regulatory element binding proteins (SREBPs), found in promoters of genes involved in sterol metabolism. Many variants of the sequence ATCACCCCAC function as SREs. [GO:mah, PMID:11111080, PMID:16537923]"
          },
          "SO:0001862": {
            "name": "GT_dinucleotide_repeat",
            "def": "A dinucleotide repeat region composed of GT repeating elements. [SO:ke]"
          },
          "SO:0001863": {
            "name": "GTT_trinucleotide_repeat",
            "def": "A trinucleotide repeat region composed of GTT repeating elements. [SO:ke]"
          },
          "SO:0001864": {
            "name": "Sap1_recognition_motif",
            "def": "A DNA motif to which the S. pombe Sap1 protein binds. The consensus sequence is 5'-TARGCAGNTNYAACGMG-3'; it is found at the mating type locus, where it is important for mating type switching, and at replication fork barriers in rDNA repeats. [PMID:16166653, PMID:7651412]"
          },
          "SO:0001865": {
            "name": "CDRE_motif",
            "def": "An RNA polymerase II promoter element found in the promoters of genes regulated by calcineurin. The consensus sequence is GNGGCKCA. [PMID:16928959]"
          },
          "SO:0001866": {
            "name": "BAC_read_contig",
            "def": "A contig of BAC reads. [GMOD:ea]"
          },
          "SO:0001867": {
            "name": "candidate_gene",
            "def": "A gene suspected of being involved in the expression of a trait. [GMOD:ea]"
          },
          "SO:0001868": {
            "name": "positional_candidate_gene",
            "def": "A candidate gene whose association with a trait is based on the gene's location on a chromosome. [GMOD:ea]"
          },
          "SO:0001869": {
            "name": "functional_candidate_gene",
            "def": "A candidate gene whose function has something in common biologically with the trait under investigation. [GMOD:ea]"
          },
          "SO:0001870": {
            "name": "enhancerRNA",
            "def": "A short ncRNA that is transcribed from an enhancer. May have a regulatory function. [doi:10.1038/465173a, SO:cjm]"
          },
          "SO:0001871": {
            "name": "PCB",
            "def": "A promoter element with consensus sequence GNAACR, bound by the transcription factor complex PBF (PCB-binding factor) and found in promoters of genes expressed during the M/G1 transition of the cell cycle. [GO:mah, PMID:12411492]"
          },
          "SO:0001872": {
            "name": "rearrangement_region",
            "def": "A region of a chromosome, where the chromosome has undergone a large structural rearrangement that altered the genome organization. There is no longer synteny to the reference genome. [NCBI:th, PMID:18564416]"
          },
          "SO:0001873": {
            "name": "interchromosomal_breakpoint",
            "def": "A rearrangement breakpoint between two different chromosomes. [NCBI:th]"
          },
          "SO:0001874": {
            "name": "intrachromosomal_breakpoint",
            "def": "A rearrangement breakpoint within the same chromosome. [NCBI:th]"
          },
          "SO:0001875": {
            "name": "unassigned_supercontig",
            "def": "A supercontig that is not been assigned to any ultracontig during a genome assembly project. [GMOD:ea]"
          },
          "SO:0001876": {
            "name": "partial_genomic_sequence_assembly",
            "def": "A partial DNA sequence assembly of a chromosome or full genome, which contains gaps that are filled with N's. [GMOD:ea]"
          },
          "SO:0001877": {
            "name": "lnc_RNA",
            "def": "A non-coding RNA over 200nucleotides in length. [HGNC:mw]"
          },
          "SO:0001878": {
            "name": "feature_variant",
            "def": "A sequence variant that falls entirely or partially within a genomic feature. [EBI:fc, SO:ke]"
          },
          "SO:0001879": {
            "name": "feature_ablation",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the deletion, is greater than the extent of the underlying genomic features. [SO:ke]"
          },
          "SO:0001880": {
            "name": "feature_amplification",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the structural change, an amplification of sequence, is greater than the extent of the underlying genomic features. [SO:ke]"
          },
          "SO:0001881": {
            "name": "feature_translocation",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the structural change, a translocation, is greater than the extent of the underlying genomic features. [SO:ke]"
          },
          "SO:0001882": {
            "name": "feature_fusion",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where a deletion fuses genomic features. [SO:ke]"
          },
          "SO:0001883": {
            "name": "transcript_translocation",
            "def": "A feature translocation where the region contains a transcript. [SO:ke]"
          },
          "SO:0001884": {
            "name": "regulatory_region_translocation",
            "def": "A feature translocation where the region contains a regulatory region. [SO:ke]"
          },
          "SO:0001885": {
            "name": "TFBS_translocation",
            "def": "A feature translocation where the region contains a transcription factor binding site. [SO:ke]"
          },
          "SO:0001886": {
            "name": "transcript_fusion",
            "def": "A feature fusion where the deletion brings together transcript regions. [SO:ke]"
          },
          "SO:0001887": {
            "name": "regulatory_region_fusion",
            "def": "A feature fusion where the deletion brings together regulatory regions. [SO:ke]"
          },
          "SO:0001888": {
            "name": "TFBS_fusion",
            "def": "A fusion where the deletion brings together transcription factor binding sites. [SO:ke]"
          },
          "SO:0001889": {
            "name": "transcript_amplification",
            "def": "A feature amplification of a region containing a transcript. [SO:ke]"
          },
          "SO:0001890": {
            "name": "transcript_regulatory_region_fusion",
            "def": "A feature fusion where the deletion brings together a regulatory region and a transcript region. [SO:ke]"
          },
          "SO:0001891": {
            "name": "regulatory_region_amplification",
            "def": "A feature amplification of a region containing a regulatory region. [SO:ke]"
          },
          "SO:0001892": {
            "name": "TFBS_amplification",
            "def": "A feature amplification of a region containing a transcription factor binding site. [SO:ke]"
          },
          "SO:0001893": {
            "name": "transcript_ablation",
            "def": "A feature ablation whereby the deleted region includes a transcript feature. [SO:ke]"
          },
          "SO:0001894": {
            "name": "regulatory_region_ablation",
            "def": "A feature ablation whereby the deleted region includes a regulatory region. [SO:ke]"
          },
          "SO:0001895": {
            "name": "TFBS_ablation",
            "def": "A feature ablation whereby the deleted region includes a transcription factor binding site. [SO:ke]"
          },
          "SO:0001896": {
            "name": "transposable_element_CDS",
            "def": "A CDS that is part of a transposable element. [SO:ke]"
          },
          "SO:0001897": {
            "name": "transposable_element_pseudogene",
            "def": "A pseudogene contained within a transposable element. [SO:ke]"
          },
          "SO:0001898": {
            "name": "dg_repeat",
            "def": "A repeat region which is part of the regional centromere outer repeat region. [PMID:16407326, SO:vw]"
          },
          "SO:0001899": {
            "name": "dh_repeat",
            "def": "A repeat region which is part of the regional centromere outer repeat region. [PMID:16407326, SO:vw]"
          },
          "SO:0001900": {
            "name": "M26_binding_site",
            "def": "A promoter element that contains a core sequence TGACGT, bound by a protein complex that regulates transcription of genes encoding PKA pathway components. [PMID:15448137]"
          },
          "SO:0001901": {
            "name": "AACCCT_box",
            "def": "A conserved 17-bp sequence (5'-ATCA(C/A)AACCCTAACCCT-3') commonly present upstream of the start site of histone transcription units functioning as a transcription factor binding site. [PMID:17452352, PMID:4092687]"
          },
          "SO:0001902": {
            "name": "splice_region",
            "def": "A region surrounding a cis_splice site, either within 1-3 bases of the exon or 3-8 bases of the intron. [SO:bm]"
          },
          "SO:0001903": {
            "name": "intronic_lncRNA",
            "def": "A lnc_RNA totally contained within an intron. [PMID:19071207, SO:ke]"
          },
          "SO:0001904": {
            "name": "antisense_lncRNA",
            "def": "Non-coding RNA transcribed from the opposite DNA strand compared with other transcripts and overlap in part with sense RNA. [PMID:19638999]"
          },
          "SO:0001905": {
            "name": "regional_centromere_outer_repeat_transcript",
            "def": "A transcript that is transcribed from the outer repeat region of a regional centromere. [PomBase:mah]"
          },
          "SO:0001906": {
            "name": "feature_truncation",
            "def": "A sequence variant that causes the reduction of a genomic feature, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0001907": {
            "name": "feature_elongation",
            "def": "A sequence variant that causes the extension of a genomic feature, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0001908": {
            "name": "internal_feature_elongation",
            "def": "A sequence variant that causes the extension of a genomic feature from within the feature rather than from the terminus of the feature, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0001909": {
            "name": "frameshift_elongation",
            "def": "A frameshift variant that causes the translational reading frame to be extended relative to the reference feature. [SO:ke]"
          },
          "SO:0001910": {
            "name": "frameshift_truncation",
            "def": "A frameshift variant that causes the translational reading frame to be shortened relative to the reference feature. [SO:ke]"
          },
          "SO:0001911": {
            "name": "copy_number_increase",
            "def": "A sequence variant where copies of a feature are increased relative to the reference. [SO:ke]"
          },
          "SO:0001912": {
            "name": "copy_number_decrease",
            "def": "A sequence variant where copies of a feature are decreased relative to the reference. [SO:ke]"
          },
          "SO:0001913": {
            "name": "bacterial_RNApol_promoter_sigma_ecf",
            "def": "A bacterial promoter with sigma ecf factor binding dependency. This is a type of bacterial promoters that requires a sigma ECF factor to bind to identified -10 and -35 sequence regions in order to mediate binding of the RNA polymerase to the promoter region as part of transcription initiation. [Invitrogen:kc]"
          },
          "SO:0001914": {
            "name": "rDNA_replication_fork_barrier",
            "def": "A DNA motif that is found in eukaryotic rDNA repeats, and is a site of replication fork pausing. [PMID:14645529]"
          },
          "SO:0001915": {
            "name": "transcription_start_cluster",
            "def": "A region defined by a cluster of experimentally determined transcription starting sites. [PMID:19624849, PMID:21372179, SO:andrewgibson]"
          },
          "SO:0001916": {
            "name": "CAGE_tag",
            "def": "A CAGE tag is a sequence tag hat corresponds to 5' ends of mRNA at cap sites, produced by cap analysis gene expression and used to identify transcriptional start sites. [SO:andrewgibson]"
          },
          "SO:0001917": {
            "name": "CAGE_cluster",
            "def": "A kind of transcription_initiation_cluster defined by the clustering of CAGE tags on a sequence region. [PMID:16645617, SO:andrewgibson]"
          },
          "SO:0001918": {
            "name": "5_methylcytosine",
            "def": "A cytosine methylated at the 5 carbon. [SO:rtapella]"
          },
          "SO:0001919": {
            "name": "4_methylcytosine",
            "def": "A cytosine methylated at the 4 nitrogen. [SO:rtapella]"
          },
          "SO:0001920": {
            "name": "N6_methyladenine",
            "def": "An adenine methylated at the 6 nitrogen. [SO:rtapella]"
          },
          "SO:0001921": {
            "name": "mitochondrial_contig",
            "def": "A contig of mitochondria derived sequences. [GMOD:ea]"
          },
          "SO:0001922": {
            "name": "mitochondrial_supercontig",
            "def": "A scaffold composed of mitochondrial contigs. [GMOD:ea]"
          },
          "SO:0001923": {
            "name": "TERRA",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts contain G rich telomeric RNA repeats and RNA tracts corresponding to adjacent subtelomeric sequences. They are 100-9000 bases long. [PMID:22139915]"
          },
          "SO:0001924": {
            "name": "ARRET",
            "def": "A non coding RNA transcript, complementary to subtelomeric tract of TERRA transcript but devoid of the repeats. [PMID:2139915]"
          },
          "SO:0001925": {
            "name": "ARIA",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts consist of C rich repeats. [PMID:22139915]"
          },
          "SO:0001926": {
            "name": "anti_ARRET",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts are antisense of ARRET transcripts. [PMID:22139915]"
          },
          "SO:0001927": {
            "name": "telomeric_transcript",
            "def": "A non-coding transcript derived from the transcript of the telomere. [PMID:22139915]"
          },
          "SO:0001928": {
            "name": "distal_duplication",
            "def": "A duplication of the distal region of a chromosome. [SO:bm]"
          },
          "SO:0001929": {
            "name": "mitochondrial_DNA_read",
            "def": "A sequencer read of a mitochondrial DNA sample. [GMOD:ea]"
          },
          "SO:0001930": {
            "name": "chloroplast_DNA_read",
            "def": "A sequencer read of a chloroplast DNA sample. [GMOD:ea]"
          },
          "SO:0001931": {
            "name": "consensus_gDNA",
            "def": "Genomic DNA sequence produced from some base calling or alignment algorithm which uses aligned or assembled multiple gDNA sequences as input. [GMOD:ea]"
          },
          "SO:0001932": {
            "name": "restriction_enzyme_five_prime_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended and the exposed single strand terminates at the 5' end. [SO:ke]"
          },
          "SO:0001933": {
            "name": "restriction_enzyme_three_prime_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended and the exposed single strand terminates at the 3' end. [SO:ke]"
          },
          "SO:0001934": {
            "name": "monomeric_repeat",
            "def": "A repeat_region containing repeat_units of 1 bp that is repeated multiple times in tandem. [SO:ke]"
          },
          "SO:0001935": {
            "name": "H3K20_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H3 protein is tri-methylated. [EBI:nj]"
          },
          "SO:0001936": {
            "name": "H3K36_acetylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is acylated. [EBI:nj]"
          },
          "SO:0001937": {
            "name": "H2BK12_acetylation_site",
            "def": "A kind of histone modification site, whereby the 12th residue (a lysine), from the start of the H2B protein is methylated. [EBI:nj]"
          },
          "SO:0001938": {
            "name": "H2AK5_acetylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H2A histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001939": {
            "name": "H4K12_acetylation_site",
            "def": "A kind of histone modification site, whereby the 12th residue (a lysine), from the start of the H4 histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001940": {
            "name": "H2BK120_acetylation_site",
            "def": "A kind of histone modification site, whereby the 120th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001941": {
            "name": "H4K91_acetylation_site",
            "def": "A kind of histone modification site, whereby the 91st residue (a lysine), from the start of the H4 histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001942": {
            "name": "H2BK20_acetylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001943": {
            "name": "H3K4ac_acetylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001944": {
            "name": "H2AK9_acetylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H2A histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001945": {
            "name": "H3K56_acetylation_site",
            "def": "A kind of histone modification site, whereby the 56th residue (a lysine), from the start of the H3 histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001946": {
            "name": "H2BK15_acetylation_site",
            "def": "A kind of histone modification site, whereby the 15th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
          },
          "SO:0001947": {
            "name": "H3R2_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 2nd residue (an arginine), from the start of the H3 protein is mono-methylated. [EBI:nj]"
          },
          "SO:0001948": {
            "name": "H3R2_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 2nd residue (an arginine), from the start of the H3 protein is di-methylated. [EBI:nj]"
          },
          "SO:0001949": {
            "name": "H4R3_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 3nd residue (an arginine), from the start of the H4 protein is di-methylated. [EBI:nj]"
          },
          "SO:0001950": {
            "name": "H4K4_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H4 protein is tri-methylated. [EBI:nj]"
          },
          "SO:0001951": {
            "name": "H3K23_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 23rd residue (a lysine), from the start of the H3 protein is di-methylated. [EBI:nj]"
          },
          "SO:0001952": {
            "name": "promoter_flanking_region",
            "def": "A region immediately adjacent to a promoter which may or may not contain transcription factor binding sites. [EBI:nj]"
          },
          "SO:0001953": {
            "name": "restriction_enzyme_assembly_scar",
            "def": "A region of DNA sequence formed from the ligation of two sticky ends where the palindrome is broken and no longer comprises the recognition site and thus cannot be re-cut by the restriction enzymes used to create the sticky ends. [SO:ke]"
          },
          "SO:0001954": {
            "name": "restriction_enzyme_region",
            "def": "A region related to restriction enzyme function. [SO:ke]"
          },
          "SO:0001955": {
            "name": "protein_stability_element",
            "def": "A polypeptide region that proves structure in a protein that affects the stability of the protein. [SO:ke]"
          },
          "SO:0001956": {
            "name": "protease_site",
            "def": "A polypeptide_region that  codes for a protease cleavage site. [SO:ke]"
          },
          "SO:0001957": {
            "name": "RNA_stability_element",
            "def": "RNA secondary structure that affects the stability of an RNA molecule. [SO:ke]"
          },
          "SO:0001958": {
            "name": "lariat_intron",
            "def": "A kind of intron whereby the excision is driven by lariat formation. [SO:ke]"
          },
          "SO:0001959": {
            "name": "TCT_motif",
            "def": "A cis-regulatory element, conserved sequence YYC+1TTTYY, and spans -2 to +6 relative to +1 TSS. It is present in most ribosomal protein genes in Drosophila and mammals but not in the yeast Saccharomyces cerevisiae. Resembles the initiator (TCAKTY in Drosophila) but functionally distinct from initiator. [PMID:20801935, SO:myl]"
          },
          "SO:0001960": {
            "name": "5_hydroxymethylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a hydroxymethyl group at the 5 carbon. [SO:ke]"
          },
          "SO:0001961": {
            "name": "5_formylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a formyl group at the 5 carbon. [SO:ke]"
          },
          "SO:0001962": {
            "name": "modified_adenine",
            "def": "A modified adenine DNA base feature. [SO:ke]"
          },
          "SO:0001963": {
            "name": "modified_cytosine",
            "def": "A modified cytosine DNA base feature. [SO:ke]"
          },
          "SO:0001964": {
            "name": "modified_guanine",
            "def": "A modified guanine DNA base feature. [SO:ke]"
          },
          "SO:0001965": {
            "name": "8_oxoguanine",
            "def": "A modified DNA guanine base,at the 8 carbon, often the product of DNA damage. [SO:ke]"
          },
          "SO:0001966": {
            "name": "5_carboxylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a carboxy group at the 5 carbon. [SO:ke]"
          },
          "SO:0001967": {
            "name": "8_oxoadenine",
            "def": "A modified DNA adenine base,at the 8 carbon, often the product of DNA damage. [SO:ke]"
          },
          "SO:0001968": {
            "name": "coding_transcript_variant",
            "def": "A transcript variant of a protein coding gene. [SO:ke]"
          },
          "SO:0001969": {
            "name": "coding_transcript_intron_variant",
            "def": "A transcript variant occurring within an intron of a coding transcript. [SO:ke]"
          },
          "SO:0001970": {
            "name": "non_coding_transcript_intron_variant",
            "def": "A transcript variant occurring within an intron of a non coding transcript. [SO:ke]"
          },
          "SO:0001971": {
            "name": "zinc_finger_binding_site"
          },
          "SO:0001972": {
            "name": "histone_4_acylation_site",
            "def": "A histone 4 modification where the modification is the acylation of the residue. [EBI:nj, SO:ke]"
          },
          "SO:0001973": {
            "name": "histone_3_acetylation_site",
            "def": "A histone 3 modification where the modification is the acylation of the residue. [EBI:nj, SO:ke]"
          },
          "SO:0001974": {
            "name": "CTCF_binding_site",
            "def": "A transcription factor binding site with consensus sequence CCGCGNGGNGGCAG, bound by CCCTF-binding factor. [EBI:nj]"
          },
          "SO:0001975": {
            "name": "five_prime_sticky_end_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme recognition site that, when cleaved, results in 5 prime overhangs. [SO:ke]"
          },
          "SO:0001976": {
            "name": "three_prime_sticky_end_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme recognition site that, when cleaved, results in 3 prime overhangs. [SO:ke]"
          },
          "SO:0001977": {
            "name": "ribonuclease_site",
            "def": "A region of a transcript encoding the cleavage site for a ribonuclease enzyme. [SO:ke]"
          },
          "SO:0001978": {
            "name": "signature",
            "def": "A region of  sequence where developer information is encoded. [SO:ke]"
          },
          "SO:0001979": {
            "name": "RNA_stability_element",
            "def": "A motif that affects the stability of RNA. [PMID:22495308, SO:ke]"
          },
          "SO:0001980": {
            "name": "G_box",
            "def": "A regulatory promoter element identified in mutation experiments, with consensus sequence: CACGTG. Present in promoters, intergenic regions, coding regions, and introns. They are involved in gene expression responses to light and interact with G-box binding factor and I-box binding factor 1a. [PMID:19249238, PMID:8571452, SO:ml]"
          },
          "SO:0001981": {
            "name": "L_box",
            "def": "An orientation dependent  regulatory promoter element, with consensus sequence of TTGCACAN4TTGCACA, found in plants. [PMID:17381552, PMID:2902624, SO:ml]"
          },
          "SO:0001982": {
            "name": "I-box",
            "def": "A plant regulatory promoter motif,  composed of a highly conserved hexamer GATAAG (I-box core). [PMID:2347304, PMID:2902624, SO:ml]"
          },
          "SO:0001983": {
            "name": "5_prime_UTR_premature_start_codon_variant",
            "def": "A 5' UTR variant where a premature start codon is introduced, moved or lost. [SANGER:am]"
          },
          "SO:0001984": {
            "name": "silent_mating_type_cassette_array",
            "def": "A gene cassette array that corresponds to a silenced version of a mating type region. [PomBase:mah]"
          },
          "SO:0001985": {
            "name": "Okazaki_fragment",
            "def": "Any of the DNA segments produced by discontinuous synthesis of the lagging strand during DNA replication. [ISBN:0805350152]"
          },
          "SO:0001986": {
            "name": "upstream_transcript_variant",
            "def": "A feature variant, where the alteration occurs upstream of the transcript TSS. [EBI:gr]"
          },
          "SO:0001987": {
            "name": "downstream_transcript_variant"
          },
          "SO:0001988": {
            "name": "5_prime_UTR_premature_start_codon_gain_variant",
            "def": "A 5' UTR variant where a premature start codon is gained. [Sanger:am]"
          },
          "SO:0001989": {
            "name": "5_prime_UTR_premature_start_codon_loss_variant",
            "def": "A 5' UTR variant where a premature start codon is lost. [SANGER:am]"
          },
          "SO:0001990": {
            "name": "five_prime_UTR_premature_start_codon_location_variant",
            "def": "A 5' UTR variant where a premature start codon is moved. [SANGER:am]"
          },
          "SO:0001991": {
            "name": "consensus_AFLP_fragment",
            "def": "A consensus AFLP fragment is an AFLP sequence produced from any alignment algorithm which uses assembled multiple AFLP sequences as input. [GMOD:ea]"
          },
          "SO:0001992": {
            "name": "nonsynonymous_variant",
            "def": "A non-synonymous variant is an inframe, protein altering variant, resulting in a codon change. [SO:ke]"
          },
          "SO:0001993": {
            "name": "extended_cis_splice_site",
            "def": "Intronic positions associated with cis-splicing. Contains the first and second positions immediately before the exon and the first, second and fifth positions immediately after. [SANGER:am]"
          },
          "SO:0001994": {
            "name": "intron_base_5",
            "def": "Fifth intronic position after the intron exon boundary, close to the 5' edge of the intron. [SANGER:am]"
          },
          "SO:0001995": {
            "name": "extended_intronic_splice_region_variant",
            "def": "A sequence variant occurring in the intron, within 10 bases of exon. [sanger:am]"
          },
          "SO:0001996": {
            "name": "extended_intronic_splice_region",
            "def": "Region of intronic sequence within 10 bases of an exon. [SANGER:am]"
          },
          "SO:0001997": {
            "name": "subtelomere",
            "def": "A heterochromatic region of the chromosome,  adjacent to the telomere (on the centromeric side) that contains repetitive DNA and sometimes genes and it is transcribed. [POMBE:al]"
          },
          "SO:0001998": {
            "name": "sgRNA",
            "def": "A small RNA oligo, typically about 20 bases, that guides the cas nuclease to a target DNA sequence in the CRISPR/cas mutagenesis method. [PMID:23934893]"
          },
          "SO:0001999": {
            "name": "mating_type_region_motif",
            "def": "DNA motif that is a component of a mating type region. [SO:ke]"
          },
          "SO:0002001": {
            "name": "Y_region",
            "def": "A segment of non-homology between a and alpha mating alleles, found at all three mating loci (HML, MAT, and HMR), has two forms (Ya and Yalpha). [SGD:jd]"
          },
          "SO:0002002": {
            "name": "Z1_region",
            "def": "A mating type region motif, one of two segments of homology found at all three mating loci (HML, MAT, and HMR). [SGD:jd]"
          },
          "SO:0002003": {
            "name": "Z2_region",
            "def": "A mating type region motif, the rightmost segment of homology in the HML and MAT mating loci (not present in HMR). [SGD:jd]"
          },
          "SO:0002004": {
            "name": "ARS_consensus_sequence",
            "def": "The ACS is an 11-bp sequence of the form 5'-WTTTAYRTTTW-3' which is at the core of every yeast ARS, and is necessary but not sufficient for recognition and binding by the origin recognition complex (ORC). Functional ARSs require an ACS, as well as other cis elements in the 5' (C domain) and 3' (B domain) flanking sequences of the ACS. [SGD:jd]"
          },
          "SO:0002005": {
            "name": "DSR_motif",
            "def": "The determinant of selective removal (DSR) motif consists of repeats of U(U/C)AAAC. The motif targets meiotic transcripts for removal during mitosis via the exosome. [PMID:22645662]"
          },
          "SO:0002006": {
            "name": "zinc_repressed_element",
            "def": "A promoter element that has the consensus sequence GNMGATC, and is found in promoters of genes repressed in the presence of zinc. [PMID:24003116, POMBE:mh]"
          },
          "SO:0002007": {
            "name": "MNV",
            "def": "An MNV is a multiple nucleotide variant (substitution) in which the inserted sequence is the same length as the replaced sequence. [NCBI:th]"
          },
          "SO:0002008": {
            "name": "rare_amino_acid_variant",
            "def": "A sequence variant whereby at least one base of a codon encoding a rare amino acid is changed, resulting in a different encoded amino acid. [SO:ke]"
          },
          "SO:0002009": {
            "name": "selenocysteine_loss",
            "def": "A sequence variant whereby at least one base of a codon encoding selenocysteine  is changed, resulting in a different encoded amino acid. [SO:ke]"
          },
          "SO:0002010": {
            "name": "pyrrolysine_loss",
            "def": "A sequence variant whereby at least one base of a codon encoding pyrrolysine is changed, resulting in a different encoded amino acid. [SO:ke]"
          },
          "SO:0002011": {
            "name": "intragenic_variant",
            "def": "A variant that occurs within a gene but falls outside of all transcript features. This occurs when alternate transcripts of a gene do not share overlapping  sequence. [SO:ke]"
          },
          "SO:0002012": {
            "name": "start_lost",
            "def": "A codon variant that changes at least one base of the canonical start codon. [SO:ke]"
          },
          "SO:0002013": {
            "name": "5_prime_UTR_truncation",
            "def": "A sequence variant that causes the reduction of a the 5'UTR  with regard to the reference sequence. [SO:ke]"
          },
          "SO:0002014": {
            "name": "5_prime_UTR_elongation",
            "def": "A sequence variant that causes the extension of 5' UTR, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0002015": {
            "name": "3_prime_UTR_truncation",
            "def": "A sequence variant that causes the reduction of a the 3' UTR  with regard to the reference sequence. [SO:ke]"
          },
          "SO:0002016": {
            "name": "3_prime_UTR_elongation",
            "def": "A sequence variant that causes the extension of 3' UTR, with regard to the reference sequence. [SO:ke]"
          },
          "SO:0002017": {
            "name": "conserved_intergenic_variant",
            "def": "A sequence variant located in a conserved intergenic region, between genes. [SO:ke]"
          },
          "SO:0002018": {
            "name": "conserved_intron_variant",
            "def": "A transcript variant occurring within a conserved region of an intron. [SO:ke]"
          },
          "SO:0002019": {
            "name": "start_retained_variant",
            "def": "A sequence variant where at least one base in the start codon is changed, but the start remains. [SO:ke]"
          },
          "SO:0002020": {
            "name": "boundary_element",
            "def": "Boundary elements are DNA motifs that prevent heterochromatin from spreading into neighboring euchromatic regions. [PMID:24013502]"
          },
          "SO:0002021": {
            "name": "mating_type_region_replication_fork_barrier",
            "def": "A DNA motif that is found in eukaryotic rDNA repeats, and is a site of replication fork pausing. [PMID:17614787]"
          },
          "SO:0002022": {
            "name": "priRNA",
            "def": "A small RNA molecule, 22-23 nt in size, that is the product of a longer RNA. The production of priRNAs is independent of dicer and involves binding of RNA by argonaute and trimming by triman. In fission yeast, priRNAs trigger the establishment of heterochromatin. PriRNAs are primarily generated from centromeric transcripts (dg and dh repeats), but may also be produced from degradation products of primary transcripts. [PMID:20178743, PMID:24095277, PomBase:al]"
          },
          "SO:0002023": {
            "name": "multiplexing_sequence_identifier",
            "def": "A nucleic tag which is used in a ligation step of library preparation process to allow pooling of samples while maintaining ability to identify individual source material and creation of a multiplexed library. [OBO:prs, PMID:22574170]"
          },
          "SO:0002024": {
            "name": "W_region",
            "def": "The leftmost segment of homology in the HML and MAT mating loci,  but not present in HMR. [SGD:jd]"
          },
          "SO:0002025": {
            "name": "cis_acting_homologous_chromosome_pairing_region",
            "def": "A genome region where chromosome pairing occurs preferentially during homologous chromosome pairing during early meiotic prophase of Meiosis I. [PMID:22582262, PMID:23117617, PMID:24173580, PomBase:vw]"
          },
          "SO:0002026": {
            "name": "intein_encoding_region",
            "def": "The nucleotide sequence which encodes the intein portion of the precursor gene. [PMID:8165123]"
          },
          "SO:0002027": {
            "name": "uORF",
            "def": "A short open reading frame that is found in the 5' untranslated region of an mRNA and plays a role in translational regulation. [PMID:12890013, PMID:16153175, POMBASE:mah]"
          },
          "SO:0002028": {
            "name": "sORF",
            "def": "An open reading frame that encodes a peptide of less than 100 amino acids. [PMID:23970561, PMID:24705786, POMBASE:mah]"
          },
          "SO:0002029": {
            "name": "tnaORF",
            "def": "A translated ORF encoded entirely within the antisense strand of a known protein coding gene. [POMBASE:vw]"
          },
          "SO:0002030": {
            "name": "X_region",
            "def": "One of two segments of homology found at all three mating loci (HML, MAT and HMR). [SGD:jd]"
          },
          "SO:0002031": {
            "name": "shRNA",
            "def": "A short hairpin RNA (shRNA) is an RNA transcript that makes a tight hairpin turn that can be used to silence target gene expression via RNA interference. [PMID:6699500, SO:ke]"
          },
          "SO:0002032": {
            "name": "moR",
            "def": "A non-coding transcript encoded by sequences adjacent to the ends of the 5' and 3' miR-encoding sequences that abut the loop in precursor miRNA. [SO:ke]"
          },
          "SO:0002033": {
            "name": "loR",
            "def": "A short, non coding transcript of loop-derived sequences encoded in precursor miRNA. [SO:ke]"
          },
          "SO:0002034": {
            "name": "miR_encoding_snoRNA_primary_transcript",
            "def": "A snoRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002035": {
            "name": "lncRNA_primary_transcript",
            "def": "A primary transcript encoding a  lncRNA. [SO:ke]"
          },
          "SO:0002036": {
            "name": "miR_encoding_lncRNA_primary_transcript",
            "def": "A lncRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002037": {
            "name": "miR_encoding_tRNA_primary_transcript",
            "def": "A tRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002038": {
            "name": "shRNA_primary_transcript",
            "def": "A primary transcript encoding an shRNA. [SO:ke]"
          },
          "SO:0002039": {
            "name": "miR_encoding_shRNA_primary_transcript",
            "def": "A shRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002040": {
            "name": "vaultRNA_primary_transcript",
            "def": "A primary transcript encoding a  vaultRNA. [SO:ke]"
          },
          "SO:0002041": {
            "name": "miR_encoding_vaultRNA_primary_transcript",
            "def": "A vaultRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002042": {
            "name": "Y_RNA_primary_transcript",
            "def": "A primary transcript encoding a  Y-RNA. [SO:ke]"
          },
          "SO:0002043": {
            "name": "miR_encoding_Y_RNA_primary_transcript",
            "def": "A Y-RNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
          },
          "SO:0002044": {
            "name": "TCS_element",
            "def": "A TCS element is a (yeast) transcription factor binding site, bound by the TEA DNA binding domain (DBD) of transcription factors. The consensus site is CATTCC or CATTCT. [PMID:1489142, PMID:20118212, SO:ke]"
          },
          "SO:0002045": {
            "name": "pheromone_response_element",
            "def": "A PRE is a (yeast) TFBS with consensus site [TGAAAC(A/G)]. [PMID:1489142, SO:ke]"
          },
          "SO:0002046": {
            "name": "FRE",
            "def": "A FRE is an enhancer element necessary and sufficient to confer filamentation associated expression in S. cerevisiae. [PMID:1489142, SO:ke]"
          },
          "SO:0002047": {
            "name": "transcription_pause_site",
            "def": "Transcription pause sites are regions of a gene where RNA polymerase may pause during transcription. The functional role of pausing may be to facilitate factor recruitment, RNA folding, and synchronization with translation. Consensus transcription pause site have been observed in E. coli. [PMID:24789973, SO:ke]"
          },
          "SO:0002048": {
            "name": "disabled_reading_frame",
            "def": "A reading frame that could encode a full-length protein but which contains obvious mid-sequence disablements (frameshifts or premature stop codons). [SGD:se]"
          },
          "SO:0002049": {
            "name": "H3K27_acetylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is acetylated. [SO:rs]"
          },
          "SO:0002050": {
            "name": "constitutive_promoter",
            "def": "A promoter that allows for continual transcription of gene. [SO:ke]"
          },
          "SO:0002051": {
            "name": "inducible_promoter",
            "def": "A promoter whereby activity is induced by the presence or absence of biotic or abiotic factors. [SO:ke]"
          },
          "SO:0002052": {
            "name": "dominant_negative_variant",
            "def": "A variant where the mutated gene product adversely affects the other (wild type) gene product. [SO:ke]"
          },
          "SO:0002053": {
            "name": "gain_of_function_variant",
            "def": "A sequence variant whereby new or enhanced function is conferred on the gene product. [SO:ke]"
          },
          "SO:0002054": {
            "name": "loss_of_function_variant",
            "def": "A sequence variant whereby the gene product has diminished or abolished function. [SO:ke]"
          },
          "SO:0002055": {
            "name": "null_mutation",
            "def": "A variant whereby the gene product is not functional or the gene product is not produced. [SO:ke]"
          },
          "SO:0002056": {
            "name": "intronic_splicing_silencer",
            "def": "An intronic  splicing regulatory element that functions to recruit trans acting splicing factors suppress the transcription of the gene or genes they control. [PMID:23241926, SO:ke]"
          },
          "SO:0002057": {
            "name": "intronic_splicing_enhancer"
          },
          "SO:0002058": {
            "name": "exonic_splicing_silencer",
            "def": "An exonic  splicing regulatory element that functions to recruit trans acting splicing factors suppress the transcription of the gene or genes they control. [PMID:23241926, SO:ke]"
          },
          "SO:0002059": {
            "name": "recombination_enhancer",
            "def": "A regulatory_region that promotes or induces the process of recombination. [PMID:8861911, SGD:se]"
          },
          "SO:0002060": {
            "name": "interchomosomal_translocation",
            "def": "A translocation where the regions involved are from different chromosomes. [NCBI:th]"
          },
          "SO:0002061": {
            "name": "intrachomosomal_translocation",
            "def": "A translocation where the regions involved are from the same chromosome. [NCBI:th]"
          },
          "SO:0002062": {
            "name": "complex_chromosomal_rearrangement",
            "def": "A contiguous cluster of translocations, usually the result of a single catastrophic event such as chromothripsis or chromoanasynthesis. [NCBI:th]"
          },
          "SO:0002063": {
            "name": "alu_insertion",
            "def": "An insertion of sequence from the Alu family of mobile elements. [NCBI:th]"
          },
          "SO:0002064": {
            "name": "LINE1_insertion",
            "def": "An insertion from the Line1 family of mobile elements. [NCBI:th]"
          },
          "SO:0002065": {
            "name": "SVA_insertion",
            "def": "An insertion of sequence from the SVA family of mobile elements. [NCBI:th]"
          },
          "SO:0005836": {
            "name": "regulatory_region",
            "def": "A region of sequence that is involved in the control of a biological process. [SO:ke]"
          },
          "SO:0005837": {
            "name": "U14_snoRNA_primary_transcript",
            "def": "The primary transcript of an evolutionarily conserved eukaryotic low molecular weight RNA capable of intermolecular hybridization with both homologous and heterologous 18S rRNA. [PMID:2251119]"
          },
          "SO:0005841": {
            "name": "methylation_guide_snoRNA",
            "def": "A snoRNA that specifies the site of 2'-O-ribose methylation in an RNA molecule by base pairing with a short sequence around the target residue. [GOC:mah, PMID:12457565]"
          },
          "SO:0005843": {
            "name": "rRNA_cleavage_RNA",
            "def": "An ncRNA that is part of a ribonucleoprotein that cleaves the primary pre-rRNA transcript in the process of producing mature rRNA molecules. [GOC:kgc]"
          },
          "SO:0005845": {
            "name": "exon_of_single_exon_gene",
            "def": "An exon that is the only exon in a gene. [RSC:cb]"
          },
          "SO:0005847": {
            "name": "cassette_array_member"
          },
          "SO:0005848": {
            "name": "gene_cassette_member"
          },
          "SO:0005849": {
            "name": "gene_subarray_member"
          },
          "SO:0005850": {
            "name": "primer_binding_site",
            "def": "Non-covalent primer binding site for initiation of replication, transcription, or reverse transcription. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
          },
          "SO:0005851": {
            "name": "gene_array",
            "def": "An array includes two or more genes, or two or more gene subarrays, contiguously arranged where the individual genes, or subarrays, are either identical in sequence, or essentially so. [SO:ma]"
          },
          "SO:0005852": {
            "name": "gene_subarray",
            "def": "A subarray is, by defintition, a member of a gene array (SO:0005851); the members of a subarray may differ substantially in sequence, but are closely related in function. [SO:ma]"
          },
          "SO:0005853": {
            "name": "gene_cassette",
            "def": "A gene that can be substituted for a related gene at a different site in the genome. [SGD:se]"
          },
          "SO:0005854": {
            "name": "gene_cassette_array",
            "def": "An array of non-functional genes whose members, when captured by recombination form functional genes. [SO:ma]"
          },
          "SO:0005855": {
            "name": "gene_group",
            "def": "A collection of related genes. [SO:ma]"
          },
          "SO:0005856": {
            "name": "selenocysteine_tRNA_primary_transcript",
            "def": "A primary transcript encoding seryl tRNA (SO:000269). [SO:ke]"
          },
          "SO:0005857": {
            "name": "selenocysteinyl_tRNA",
            "def": "A tRNA sequence that has a selenocysteine anticodon, and a 3' selenocysteine binding region. [SO:ke]"
          },
          "SO:0005858": {
            "name": "syntenic_region",
            "def": "A region in which two or more pairs of homologous markers occur on the same chromosome in two or more species. [http://www.informatics.jax.org/silverbook/glossary.shtml]"
          },
          "SO:0100001": {
            "name": "biochemical_region_of_peptide",
            "def": "A region of a peptide that is involved in a biochemical function. [EBIBS:GAR]"
          },
          "SO:0100002": {
            "name": "molecular_contact_region",
            "def": "A region that is involved a contact with another molecule. [EBIBS:GAR]"
          },
          "SO:0100003": {
            "name": "intrinsically_unstructured_polypeptide_region",
            "def": "A region of polypeptide chain with high conformational flexibility. [EBIBS:GAR]"
          },
          "SO:0100004": {
            "name": "catmat_left_handed_three",
            "def": "A motif of 3 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -75 bounds -100 to -50, res i+1: psi 140 bounds 110 to 170. An extra restriction of the length of the O to O distance would be useful, that it be less than 5 Angstrom. More precisely these two oxygens are the main chain carbonyl oxygen atoms of residues i-1 and i+1. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100005": {
            "name": "catmat_left_handed_four",
            "def": "A motif of 4 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i psi -10 bounds -50 to 30, res i+1: phi -90 bounds -120 to -60, res i+1: psi -10 bounds -50 to 30, res i+2: phi -75 bounds -100 to -50, res i+2: psi 140 bounds 110 to 170.  The extra restriction of the length of the O to O distance is similar, that it be less than 5 Angstrom. In this case these two Oxygen atoms are the main chain carbonyl oxygen atoms of residues i-1 and i+2. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100006": {
            "name": "catmat_right_handed_three",
            "def": "A motif of 3 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -75 bounds -100 to -50, res i+1: psi 140 bounds 110 to 170. An extra restriction of the length of the O to O distance would be useful, that it be less than 5 Angstrom. More precisely these two oxygens are the main chain carbonyl oxygen atoms of residues i-1 and i+1. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100007": {
            "name": "catmat_right_handed_four",
            "def": "A motif of 4 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -90 bounds -120 to -60, res i+1: psi -10 bounds -50 to 30, res i+2: phi -75 bounds -100 to -50, res i+2: psi 140 bounds 110 to 170. The extra restriction of the length of the O to O distance is similar, that it be less than 5 Angstrom. In this case these two Oxygen atoms are the main chain carbonyl oxygen atoms of residues i-1 and i+2. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100008": {
            "name": "alpha_beta_motif",
            "def": "A motif of five consecutive residues and two H-bonds in which: H-bond between CO of residue(i) and NH of residue(i+4), H-bond between CO of residue(i) and NH of residue(i+3),Phi angles of residues(i+1), (i+2) and (i+3) are negative. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
          },
          "SO:0100009": {
            "name": "lipoprotein_signal_peptide",
            "def": "A peptide that acts as a signal for both membrane translocation and lipid attachment in prokaryotes. [EBIBS:GAR]"
          },
          "SO:0100010": {
            "name": "no_output",
            "def": "An experimental region wherean analysis has been run and not produced any annotation. [EBIBS:GAR]"
          },
          "SO:0100011": {
            "name": "cleaved_peptide_region",
            "def": "The cleaved_peptide_region is the region of a peptide sequence that is cleaved during maturation. [EBIBS:GAR]"
          },
          "SO:0100012": {
            "name": "peptide_coil",
            "def": "Irregular, unstructured regions of a protein's backbone, as distinct from the regular region (namely alpha helix and beta strand - characterised by specific patterns of main-chain hydrogen bonds). [EBIBS:GAR]"
          },
          "SO:0100013": {
            "name": "hydrophobic_region_of_peptide",
            "def": "Hydrophobic regions are regions with a low affinity for water. [EBIBS:GAR]"
          },
          "SO:0100014": {
            "name": "n_terminal_region",
            "def": "The amino-terminal positively-charged region of a signal peptide (approx 1-5 aa). [EBIBS:GAR]"
          },
          "SO:0100015": {
            "name": "c_terminal_region",
            "def": "The more polar, carboxy-terminal region of the signal peptide (approx 3-7 aa). [EBIBS:GAR]"
          },
          "SO:0100016": {
            "name": "central_hydrophobic_region_of_signal_peptide",
            "def": "The central, hydrophobic region of the signal peptide (approx 7-15 aa). [EBIBS:GAR]"
          },
          "SO:0100017": {
            "name": "polypeptide_conserved_motif",
            "def": "A conserved motif is a short (up to 20 amino acids) region of biological interest that is conserved in different proteins. They may or may not have functional or structural significance within the proteins in which they are found. [EBIBS:GAR]"
          },
          "SO:0100018": {
            "name": "polypeptide_binding_motif",
            "def": "A polypeptide binding motif is a short (up to 20 amino acids) polypeptide region of biological interest that contains one or more amino acids experimentally shown to bind to a ligand. [EBIBS:GAR]"
          },
          "SO:0100019": {
            "name": "polypeptide_catalytic_motif",
            "def": "A polypeptide catalytic motif is a short (up to 20 amino acids) polypeptide region that contains one or more active site residues. [EBIBS:GAR]"
          },
          "SO:0100020": {
            "name": "polypeptide_DNA_contact",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with DNA. [EBIBS:GAR, SO:ke]"
          },
          "SO:0100021": {
            "name": "polypeptide_conserved_region",
            "def": "A subsection of sequence with biological interest that is conserved in different proteins. They may or may not have functional or structural significance within the proteins in which they are found. [EBIBS:GAR]"
          },
          "SO:1000002": {
            "name": "substitution",
            "def": "A sequence alteration where the length of the change in the variant is the same as that of the reference. [SO:ke]"
          },
          "SO:1000005": {
            "name": "complex_substitution",
            "def": "When no simple or well defined DNA mutation event describes the observed DNA change, the keyword \\complex\\ should be used. Usually there are multiple equally plausible explanations for the change. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000008": {
            "name": "point_mutation",
            "def": "A single nucleotide change which has occurred at the same position of a corresponding nucleotide in a reference sequence. [SO:immuno_workshop]"
          },
          "SO:1000009": {
            "name": "transition",
            "def": "Change of a pyrimidine nucleotide, C or T, into an other pyrimidine nucleotide, or change of a purine nucleotide, A or G, into an other purine nucleotide. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000010": {
            "name": "pyrimidine_transition",
            "def": "A substitution of a pyrimidine, C or T, for another pyrimidine. [SO:ke]"
          },
          "SO:1000011": {
            "name": "C_to_T_transition",
            "def": "A transition of a cytidine to a thymine. [SO:ke]"
          },
          "SO:1000012": {
            "name": "C_to_T_transition_at_pCpG_site",
            "def": "The transition of cytidine to thymine occurring at a pCpG site as a consequence of the spontaneous deamination of 5'-methylcytidine. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000013": {
            "name": "T_to_C_transition"
          },
          "SO:1000014": {
            "name": "purine_transition",
            "def": "A substitution of a purine, A or G, for another purine. [SO:ke]"
          },
          "SO:1000015": {
            "name": "A_to_G_transition",
            "def": "A transition of an adenine to a guanine. [SO:ke]"
          },
          "SO:1000016": {
            "name": "G_to_A_transition",
            "def": "A transition of a guanine to an adenine. [SO:ke]"
          },
          "SO:1000017": {
            "name": "transversion",
            "def": "Change of a pyrimidine nucleotide, C or T, into a purine nucleotide, A or G, or vice versa. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000018": {
            "name": "pyrimidine_to_purine_transversion",
            "def": "Change of a pyrimidine nucleotide, C or T, into a purine nucleotide, A or G. [SO:ke]"
          },
          "SO:1000019": {
            "name": "C_to_A_transversion",
            "def": "A transversion from cytidine to adenine. [SO:ke]"
          },
          "SO:1000020": {
            "name": "C_to_G_transversion"
          },
          "SO:1000021": {
            "name": "T_to_A_transversion",
            "def": "A transversion from T to A. [SO:ke]"
          },
          "SO:1000022": {
            "name": "T_to_G_transversion",
            "def": "A transversion from T to G. [SO:ke]"
          },
          "SO:1000023": {
            "name": "purine_to_pyrimidine_transversion",
            "def": "Change of a purine nucleotide, A or G , into a pyrimidine nucleotide C or T. [SO:ke]"
          },
          "SO:1000024": {
            "name": "A_to_C_transversion",
            "def": "A transversion from adenine to cytidine. [SO:ke]"
          },
          "SO:1000025": {
            "name": "A_to_T_transversion",
            "def": "A transversion from adenine to thymine. [SO:ke]"
          },
          "SO:1000026": {
            "name": "G_to_C_transversion",
            "def": "A transversion from guanine to cytidine. [SO:ke]"
          },
          "SO:1000027": {
            "name": "G_to_T_transversion",
            "def": "A transversion from guanine to thymine. [SO:ke]"
          },
          "SO:1000028": {
            "name": "intrachromosomal_mutation",
            "def": "A chromosomal structure variation within a single chromosome. [SO:ke]"
          },
          "SO:1000029": {
            "name": "chromosomal_deletion",
            "def": "An incomplete chromosome. [SO:ke]"
          },
          "SO:1000030": {
            "name": "chromosomal_inversion",
            "def": "An interchromosomal mutation where a region of the chromosome is inverted with respect to wild type. [SO:ke]"
          },
          "SO:1000031": {
            "name": "interchromosomal_mutation",
            "def": "A chromosomal structure variation whereby more than one chromosome is involved. [SO:ke]"
          },
          "SO:1000032": {
            "name": "indel",
            "def": "A sequence alteration which included an insertion and a deletion, affecting 2 or more bases. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html, http:http://www.hgvs.org/mutnomen/recs-DNA.html#indel]"
          },
          "SO:1000035": {
            "name": "duplication",
            "def": "An insertion which derives from, or is identical in sequence to, nucleotides present at a known location in the genome. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html, NCBI:th]"
          },
          "SO:1000036": {
            "name": "inversion",
            "def": "A continuous nucleotide sequence is inverted in the same position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000037": {
            "name": "chromosomal_duplication",
            "def": "An extra chromosome. [SO:ke]"
          },
          "SO:1000038": {
            "name": "intrachromosomal_duplication",
            "def": "A duplication that occurred within a chromosome. [SO:ke]"
          },
          "SO:1000039": {
            "name": "direct_tandem_duplication",
            "def": "A tandem duplication where the individual regions are in the same orientation. [SO:ke]"
          },
          "SO:1000040": {
            "name": "inverted_tandem_duplication",
            "def": "A tandem duplication where the individual regions are not in the same orientation. [SO:ke]"
          },
          "SO:1000041": {
            "name": "intrachromosomal_transposition",
            "def": "A chromosome structure variation whereby a transposition occurred within a chromosome. [SO:ke]"
          },
          "SO:1000042": {
            "name": "compound_chromosome",
            "def": "A chromosome structure variant where a monocentric element is caused by the fusion of two chromosome arms. [SO:ke]"
          },
          "SO:1000043": {
            "name": "Robertsonian_fusion",
            "def": "A non reciprocal translocation whereby the participating chromosomes break at their centromeres and the long arms fuse to form a single chromosome with a single centromere. [http://en.wikipedia.org/wiki/Robertsonian_translocation]"
          },
          "SO:1000044": {
            "name": "chromosomal_translocation",
            "def": "An interchromosomal mutation. Rearrangements that alter the pairing of telomeres are classified as translocations. [FB:reference_manual]"
          },
          "SO:1000045": {
            "name": "ring_chromosome",
            "def": "A ring chromosome is a chromosome whose arms have fused together to form a ring, often with the loss of the ends of the chromosome. [http://en.wikipedia.org/wiki/Ring_chromosome]"
          },
          "SO:1000046": {
            "name": "pericentric_inversion",
            "def": "A chromosomal inversion that includes the centromere. [FB:reference_manual]"
          },
          "SO:1000047": {
            "name": "paracentric_inversion",
            "def": "A chromosomal inversion that does not include the centromere. [FB:reference_manual]"
          },
          "SO:1000048": {
            "name": "reciprocal_chromosomal_translocation",
            "def": "A chromosomal translocation with two breaks; two chromosome segments have simply been exchanged. [FB:reference_manual]"
          },
          "SO:1000049": {
            "name": "sequence_variation_affecting_transcript",
            "def": "Any change in mature, spliced and processed, RNA that results from a change in the corresponding DNA sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000050": {
            "name": "sequence_variant_causing_no_change_in_transcript",
            "def": "No effect on the state of the RNA. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000054": {
            "name": "sequence_variation_affecting_coding_sequence",
            "def": "Any of the amino acid coding triplets of a gene are affected by the DNA mutation. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000055": {
            "name": "sequence_variant_causing_initiator_codon_change_in_transcript",
            "def": "The DNA mutation changes, usually destroys, the first coding triplet of a gene. Usually prevents translation although another initiator codon may be used. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000056": {
            "name": "sequence_variant_causing_amino_acid_coding_codon_change_in_transcript",
            "def": "The DNA mutation affects the amino acid coding sequence of a gene; this region includes both the initiator and terminator codons. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000057": {
            "name": "sequence_variant_causing_synonymous_codon_change_in_transcript",
            "def": "The changed codon has the same translation product as the original codon. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000058": {
            "name": "sequence_variant_causing_non_synonymous_codon_change_in_transcript",
            "def": "A DNA point mutation that causes a substitution of an amino acid by an other. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000059": {
            "name": "sequence_variant_causing_missense_codon_change_in_transcript",
            "def": "The nucleotide change in the codon leads to a new codon coding for a new amino acid. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000060": {
            "name": "sequence_variant_causing_conservative_missense_codon_change_in_transcript",
            "def": "The amino acid change following from the codon change does not change the gross properties (size, charge, hydrophobicity) of the amino acid at that position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000061": {
            "name": "sequence_variant_causing_nonconservative_missense_codon_change_in_transcript",
            "def": "The amino acid change following from the codon change changes the gross properties (size, charge, hydrophobicity) of the amino acid in that position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000062": {
            "name": "sequence_variant_causing_nonsense_codon_change_in_transcript",
            "def": "The nucleotide change in the codon triplet creates a terminator codon. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000063": {
            "name": "sequence_variant_causing_terminator_codon_change_in_transcript",
            "def": "The nucleotide change in the codon triplet changes the stop codon, causing an elongated transcript sequence. [SO:ke]"
          },
          "SO:1000064": {
            "name": "sequence_variation_affecting_reading_frame",
            "def": "An umbrella term for terms describing an effect of a sequence variation on the frame of translation. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000065": {
            "name": "frameshift_sequence_variation",
            "def": "A mutation causing a disruption of the translational reading frame, because the number of nucleotides inserted or deleted is not a multiple of three. [SO:ke]"
          },
          "SO:1000066": {
            "name": "sequence_variant_causing_plus_1_frameshift_mutation",
            "def": "A mutation causing a disruption of the translational reading frame, due to the insertion of a nucleotide. [SO:ke]"
          },
          "SO:1000067": {
            "name": "sequence_variant_causing_minus_1_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the deletion of a nucleotide. [SO:ke]"
          },
          "SO:1000068": {
            "name": "sequence_variant_causing_plus_2_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the insertion of two nucleotides. [SO:ke]"
          },
          "SO:1000069": {
            "name": "sequence_variant_causing_minus_2_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the deletion of two nucleotides. [SO:ke]"
          },
          "SO:1000070": {
            "name": "sequence_variant_affecting_transcript_processing",
            "def": "Sequence variant affects the way in which the primary transcriptional product is processed to form the mature transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000071": {
            "name": "sequence_variant_affecting_splicing",
            "def": "A sequence_variant_effect where the way in which the primary transcriptional product is processed to form the mature transcript, specifically by the removal (splicing) of intron sequences is changed. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000072": {
            "name": "sequence_variant_affecting_splice_donor",
            "def": "A sequence_variant_effect that changes the splice donor sequence. [SO:ke]"
          },
          "SO:1000073": {
            "name": "sequence_variant_affecting_splice_acceptor",
            "def": "A sequence_variant_effect that changes the splice acceptor sequence. [SO:ke]"
          },
          "SO:1000074": {
            "name": "sequence_variant_causing_cryptic_splice_activation",
            "def": "A sequence variant causing a new (functional) splice site. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000075": {
            "name": "sequence_variant_affecting_editing",
            "def": "Sequence variant affects the editing of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000076": {
            "name": "sequence_variant_affecting_transcription",
            "def": "Mutation affects the process of transcription, its initiation, progression or termination. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000078": {
            "name": "sequence_variant_decreasing_rate_of_transcription",
            "def": "A sequence variation that decreases the rate a which transcription of the sequence occurs. [SO:ke]"
          },
          "SO:1000079": {
            "name": "sequence_variation_affecting_transcript_sequence"
          },
          "SO:1000080": {
            "name": "sequence_variant_increasing_rate_of_transcription"
          },
          "SO:1000081": {
            "name": "sequence_variant_affecting_rate_of_transcription",
            "def": "A mutation that alters the rate a which transcription of the sequence occurs. [SO:ke]"
          },
          "SO:1000082": {
            "name": "sequence variant_affecting_transcript_stability",
            "def": "Sequence variant affects the stability of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000083": {
            "name": "sequence_variant_increasing_transcript_stability",
            "def": "Sequence variant increases the stability (half-life) of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000084": {
            "name": "sequence_variant_decreasing_transcript_stability",
            "def": "Sequence variant decreases the stability (half-life) of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000085": {
            "name": "sequence_variation_affecting_level_of_transcript",
            "def": "A sequence variation that causes a change in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
          },
          "SO:1000086": {
            "name": "sequence_variation_decreasing_level_of_transcript",
            "def": "A sequence variation that causes a decrease in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
          },
          "SO:1000087": {
            "name": "sequence_variation_increasing_level_of_transcript",
            "def": "A sequence_variation that causes an increase in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
          },
          "SO:1000088": {
            "name": "sequence_variant_affecting_translational_product",
            "def": "A sequence variant causing a change in primary translation product of a transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000089": {
            "name": "sequence_variant_causing_no_change_of_translational_product",
            "def": "The sequence variant at RNA level does not lead to any change in polypeptide. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000092": {
            "name": "sequence_variant_causing_complex_change_of_translational_product",
            "def": "Any sequence variant effect that is known at nucleotide level but cannot be explained by using other key terms. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000093": {
            "name": "sequence_variant_causing_amino_acid_substitution",
            "def": "The replacement of a single amino acid by another. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000094": {
            "name": "sequence_variant_causing_conservative_amino_acid_substitution"
          },
          "SO:1000095": {
            "name": "sequence_variant_causing_nonconservative_amino_acid_substitution"
          },
          "SO:1000096": {
            "name": "sequence_variant_causing_amino_acid_insertion",
            "def": "The insertion of one or more amino acids from the polypeptide, without affecting the surrounding sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000097": {
            "name": "sequence_variant_causing_amino_acid_deletion",
            "def": "The deletion of one or more amino acids from the polypeptide, without affecting the surrounding sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000098": {
            "name": "sequence_variant_causing_polypeptide_truncation",
            "def": "The translational product is truncated at its C-terminus, usually a result of a nonsense codon change in transcript (SO:1000062). [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000099": {
            "name": "sequence_variant_causing_polypeptide_elongation",
            "def": "The extension of the translational product at either (or both) the N-terminus and/or the C-terminus. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000100": {
            "name": "mutation_causing_polypeptide_N_terminal_elongation",
            "def": ". [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000101": {
            "name": "mutation_causing_polypeptide_C_terminal_elongation",
            "def": ". [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000102": {
            "name": "sequence_variant_affecting_level_of_translational_product"
          },
          "SO:1000103": {
            "name": "sequence_variant_decreasing_level_of_translation_product"
          },
          "SO:1000104": {
            "name": "sequence_variant_increasing_level_of_translation_product"
          },
          "SO:1000105": {
            "name": "sequence_variant_affecting_polypeptide_amino_acid_sequence"
          },
          "SO:1000106": {
            "name": "mutation_causing_inframe_polypeptide_N_terminal_elongation"
          },
          "SO:1000107": {
            "name": "mutation_causing_out_of_frame_polypeptide_N_terminal_elongation"
          },
          "SO:1000108": {
            "name": "mutaton_causing_inframe_polypeptide_C_terminal_elongation"
          },
          "SO:1000109": {
            "name": "mutation_causing_out_of_frame_polypeptide_C_terminal_elongation"
          },
          "SO:1000110": {
            "name": "frame_restoring_sequence_variant",
            "def": "A mutation that reverts the sequence of a previous frameshift mutation back to the initial frame. [SO:ke]"
          },
          "SO:1000111": {
            "name": "sequence_variant_affecting_3D_structure_of_polypeptide",
            "def": "A mutation that changes the amino acid sequence of the peptide in such a way that it changes the 3D structure of the molecule. [SO:ke]"
          },
          "SO:1000112": {
            "name": "sequence_variant_causing_no_3D_structural_change"
          },
          "SO:1000115": {
            "name": "sequence_variant_causing_complex_3D_structural_change"
          },
          "SO:1000116": {
            "name": "sequence_variant_causing_conformational_change"
          },
          "SO:1000117": {
            "name": "sequence_variant_affecting_polypeptide_function"
          },
          "SO:1000118": {
            "name": "sequence_variant_causing_loss_of_function_of_polypeptide"
          },
          "SO:1000119": {
            "name": "sequence_variant_causing_inactive_ligand_binding_site"
          },
          "SO:1000120": {
            "name": "sequence_variant_causing_inactive_catalytic_site"
          },
          "SO:1000121": {
            "name": "sequence_variant_causing_polypeptide_localization_change"
          },
          "SO:1000122": {
            "name": "sequence_variant_causing_polypeptide_post_translational_processing_change"
          },
          "SO:1000123": {
            "name": "polypeptide_post_translational_processing_affected"
          },
          "SO:1000124": {
            "name": "sequence_variant_causing_partial_loss_of_function_of_polypeptide"
          },
          "SO:1000125": {
            "name": "sequence_variant_causing_gain_of_function_of_polypeptide"
          },
          "SO:1000126": {
            "name": "sequence_variant_affecting_transcript_secondary_structure",
            "def": "A sequence variant that affects the secondary structure (folding) of the RNA transcript molecule. [SO:ke]"
          },
          "SO:1000127": {
            "name": "sequence_variant_causing_compensatory_transcript_secondary_structure_mutation"
          },
          "SO:1000132": {
            "name": "sequence_variant_effect",
            "def": "The effect of a change in nucleotide sequence. [SO:ke]"
          },
          "SO:1000134": {
            "name": "sequence_variant_causing_polypeptide_fusion"
          },
          "SO:1000136": {
            "name": "autosynaptic_chromosome",
            "def": "An autosynaptic chromosome is the aneuploid product of recombination between a pericentric inversion and a cytologically wild-type chromosome. [PMID:6804304]"
          },
          "SO:1000138": {
            "name": "homo_compound_chromosome",
            "def": "A compound chromosome whereby two copies of the same chromosomal arm attached to a common centromere. The chromosome is diploid for the arm involved. [SO:ke]"
          },
          "SO:1000140": {
            "name": "hetero_compound_chromosome",
            "def": "A compound chromosome whereby two arms from different chromosomes are connected through the centromere of one of them. [FB:reference_manual, SO:ke]"
          },
          "SO:1000141": {
            "name": "chromosome_fission",
            "def": "A chromosome that occurred by the division of a larger chromosome. [SO:ke]"
          },
          "SO:1000142": {
            "name": "dexstrosynaptic_chromosome",
            "def": "An autosynaptic chromosome carrying the two right (D = dextro) telomeres. [FB:manual]"
          },
          "SO:1000143": {
            "name": "laevosynaptic_chromosome",
            "def": "LS is an autosynaptic chromosome carrying the two left (L = levo) telomeres. [FB:manual]"
          },
          "SO:1000144": {
            "name": "free_duplication",
            "def": "A chromosome structure variation whereby the duplicated sequences are carried as a free centric element. [FB:reference_manual]"
          },
          "SO:1000145": {
            "name": "free_ring_duplication",
            "def": "A ring chromosome which is a copy of another chromosome. [SO:ke]"
          },
          "SO:1000147": {
            "name": "deficient_translocation",
            "def": "A chromosomal deletion whereby a translocation occurs in which one of the four broken ends loses a segment before re-joining. [FB:reference_manual]"
          },
          "SO:1000148": {
            "name": "inversion_cum_translocation",
            "def": "A chromosomal translocation whereby the first two breaks are in the same chromosome, and the region between them is rejoined in inverted order to the other side of the first break, such that both sides of break one are present on the same chromosome. The remaining free ends are joined as a translocation with those resulting from the third break. [FB:reference_manual]"
          },
          "SO:1000149": {
            "name": "bipartite_duplication",
            "def": "An interchromosomal mutation whereby the (large) region between the first two breaks listed is lost, and the two flanking segments (one of them centric) are joined as a translocation to the free ends resulting from the third break. [FB:reference_manual]"
          },
          "SO:1000150": {
            "name": "cyclic_translocation",
            "def": "A chromosomal translocation whereby three breaks occurred in three different chromosomes. The centric segment resulting from the first break listed is joined to the acentric segment resulting from the second, rather than the third. [FB:reference_manual]"
          },
          "SO:1000151": {
            "name": "bipartite_inversion",
            "def": "A chromosomal inversion caused by three breaks in the same chromosome; both central segments are inverted in place (i.e., they are not transposed). [FB:reference_manual]"
          },
          "SO:1000152": {
            "name": "uninverted_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
          },
          "SO:1000153": {
            "name": "inverted_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segments. [FB:reference_manual]"
          },
          "SO:1000154": {
            "name": "insertional_duplication",
            "def": "A chromosome duplication involving the insertion of a duplicated region (as opposed to a free duplication). [SO:ke]"
          },
          "SO:1000155": {
            "name": "interchromosomal_transposition",
            "def": "A chromosome structure variation whereby a transposition occurred between chromosomes. [SO:ke]"
          },
          "SO:1000156": {
            "name": "inverted_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segment. [FB:reference_manual]"
          },
          "SO:1000157": {
            "name": "uninverted_interchromosomal_transposition",
            "def": "An interchromosomal transition where the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
          },
          "SO:1000158": {
            "name": "inverted_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segments. [FB:reference_manual]"
          },
          "SO:1000159": {
            "name": "uninverted_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
          },
          "SO:1000160": {
            "name": "unoriented_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
          },
          "SO:1000161": {
            "name": "unoriented_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a copy of the segment between the first two breaks listed is inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
          },
          "SO:1000162": {
            "name": "unoriented_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
          },
          "SO:1000170": {
            "name": "uncharacterized_chromosomal_mutation"
          },
          "SO:1000171": {
            "name": "deficient_inversion",
            "def": "A chromosomal deletion whereby three breaks occur in the same chromosome; one central region is lost, and the other is inverted. [FB:reference_manual, SO:ke]"
          },
          "SO:1000173": {
            "name": "tandem_duplication",
            "def": "A duplication consisting of 2 identical adjacent regions. [SO:ke]"
          },
          "SO:1000175": {
            "name": "partially_characterized_chromosomal_mutation"
          },
          "SO:1000180": {
            "name": "sequence_variant_affecting_gene_structure",
            "def": "A sequence_variant_effect that changes the gene structure. [SO:ke]"
          },
          "SO:1000181": {
            "name": "sequence_variant_causing_gene_fusion",
            "def": "A sequence_variant_effect that changes the gene structure by causing a fusion to another gene. [SO:ke]"
          },
          "SO:1000182": {
            "name": "chromosome_number_variation",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number. [SO:ke]"
          },
          "SO:1000183": {
            "name": "chromosome_structure_variation"
          },
          "SO:1000184": {
            "name": "sequence_variant_causes_exon_loss",
            "def": "A sequence variant affecting splicing and causes an exon loss. [SO:ke]"
          },
          "SO:1000185": {
            "name": "sequence_variant_causes_intron_gain",
            "def": "A sequence variant effect, causing an intron to be gained by the processed transcript; usually a result of a donor acceptor mutation (SO:1000072). [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
          },
          "SO:1000186": {
            "name": "sequence_variant_causing_cryptic_splice_donor_activation"
          },
          "SO:1001186": {
            "name": "sequence_variant_causing_cryptic_splice_acceptor_activation"
          },
          "SO:1001187": {
            "name": "alternatively_spliced_transcript",
            "def": "A transcript that is alternatively spliced. [SO:xp]"
          },
          "SO:1001188": {
            "name": "encodes_1_polypeptide",
            "def": "A gene that is alternately spliced, but encodes only one polypeptide. [SO:ke]"
          },
          "SO:1001189": {
            "name": "encodes_greater_than_1_polypeptide",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide. [SO:ke]"
          },
          "SO:1001190": {
            "name": "encodes_different_polypeptides_different_stop",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different stop codons. [SO:ke]"
          },
          "SO:1001191": {
            "name": "encodes_overlapping_peptides_different_start",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different start codons. [SO:ke]"
          },
          "SO:1001192": {
            "name": "encodes_disjoint_polypeptides",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that do not have overlapping peptide sequences. [SO:ke]"
          },
          "SO:1001193": {
            "name": "encodes_overlapping_polypeptides_different_start_and_stop",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different start and stop codons. [SO:ke]"
          },
          "SO:1001194": {
            "name": "alternatively_spliced_gene_encoding_greater_than_1_polypeptide_coding_regions_overlapping"
          },
          "SO:1001195": {
            "name": "encodes_overlapping_peptides",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences. [SO:ke]"
          },
          "SO:1001196": {
            "name": "cryptogene",
            "def": "A maxicircle gene so extensively edited that it cannot be matched to its edited mRNA sequence. [SO:ma]"
          },
          "SO:1001197": {
            "name": "dicistronic_primary_transcript",
            "def": "A primary transcript that has the quality dicistronic. [SO:xp]"
          },
          "SO:1001217": {
            "name": "member_of_regulon"
          },
          "SO:1001244": {
            "name": "alternatively_spliced_transcript_encoding_greater_than_1_polypeptide_different_start_codon_different_stop_codon_coding_regions_non_overlapping"
          },
          "SO:1001246": {
            "name": "CDS_independently_known",
            "def": "A CDS with the evidence status of being independently known. [SO:xp]"
          },
          "SO:1001247": {
            "name": "orphan_CDS",
            "def": "A CDS whose predicted amino acid sequence is unsupported by any experimental evidence or by any match with any other known sequence. [SO:ma]"
          },
          "SO:1001249": {
            "name": "CDS_supported_by_domain_match_data",
            "def": "A CDS that is supported by domain similarity. [SO:xp]"
          },
          "SO:1001251": {
            "name": "CDS_supported_by_sequence_similarity_data",
            "def": "A CDS that is supported by sequence similarity data. [SO:xp]"
          },
          "SO:1001254": {
            "name": "CDS_predicted",
            "def": "A CDS that is predicted. [SO:ke]"
          },
          "SO:1001255": {
            "name": "status_of_coding_sequence"
          },
          "SO:1001259": {
            "name": "CDS_supported_by_EST_or_cDNA_data",
            "def": "A CDS that is supported by similarity to EST or cDNA data. [SO:xp]"
          },
          "SO:1001260": {
            "name": "internal_Shine_Dalgarno_sequence",
            "def": "A Shine-Dalgarno sequence that stimulates recoding through interactions with the anti-Shine-Dalgarno in the RNA of small ribosomal subunits of translating ribosomes. The signal is only operative in Bacteria. [PMID:12519954, SO:ke]"
          },
          "SO:1001261": {
            "name": "recoded_mRNA",
            "def": "The sequence of a mature mRNA transcript, modified before translation or during translation, usually by special cis-acting signals. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8811194&dopt=Abstract]"
          },
          "SO:1001262": {
            "name": "minus_1_translationally_frameshifted",
            "def": "An attribute describing a translational frameshift of -1. [SO:ke]"
          },
          "SO:1001263": {
            "name": "plus_1_translationally_frameshifted",
            "def": "An attribute describing a translational frameshift of +1. [SO:ke]"
          },
          "SO:1001264": {
            "name": "mRNA_recoded_by_translational_bypass",
            "def": "A recoded_mRNA where translation was suspended at a particular codon and resumed at a particular non-overlapping downstream codon. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8811194&dopt=Abstract]"
          },
          "SO:1001265": {
            "name": "mRNA_recoded_by_codon_redefinition",
            "def": "A recoded_mRNA that was modified by an alteration of codon meaning. [SO:ma]"
          },
          "SO:1001266": {
            "name": "stop_codon_redefinition_as_selenocysteine"
          },
          "SO:1001267": {
            "name": "stop_codon_readthrough"
          },
          "SO:1001268": {
            "name": "recoding_stimulatory_region",
            "def": "A site in an mRNA sequence that stimulates the recoding of a region in the same mRNA. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=12519954&dopt=Abstract]"
          },
          "SO:1001269": {
            "name": "four_bp_start_codon",
            "def": "A non-canonical start codon with 4 base pairs. [SO:ke]"
          },
          "SO:1001270": {
            "name": "stop_codon_redefinition_as_pyrrolysine"
          },
          "SO:1001271": {
            "name": "archaeal_intron",
            "def": "An intron characteristic of Archaeal tRNA and rRNA genes, where intron transcript generates a bulge-helix-bulge motif that is recognised by a splicing endoribonuclease. [PMID:9301331, SO:ma]"
          },
          "SO:1001272": {
            "name": "tRNA_intron",
            "def": "An intron found in tRNA that is spliced via endonucleolytic cleavage and ligation rather than transesterification. [SO:ke]"
          },
          "SO:1001273": {
            "name": "CTG_start_codon",
            "def": "A non-canonical start codon of sequence CTG. [SO:ke]"
          },
          "SO:1001274": {
            "name": "SECIS_element",
            "def": "The incorporation of selenocysteine into a protein sequence is directed by an in-frame UGA codon (usually a stop codon) within the coding region of the mRNA. Selenoprotein mRNAs contain a conserved secondary structure in the 3' UTR that is required for the distinction of UGA stop from UGA selenocysteine. The selenocysteine insertion sequence (SECIS) is around 60 nt in length and adopts a hairpin structure which is sufficiently well-defined and conserved to act as a computational screen for selenoprotein genes. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00031]"
          },
          "SO:1001275": {
            "name": "retron",
            "def": "Sequence coding for a short, single-stranded, DNA sequence via a retrotransposed RNA intermediate; characteristic of some microbial genomes. [SO:ma]"
          },
          "SO:1001277": {
            "name": "three_prime_recoding_site",
            "def": "The recoding stimulatory signal located downstream of the recoding site. [SO:ke]"
          },
          "SO:1001279": {
            "name": "three_prime_stem_loop_structure",
            "def": "A recoding stimulatory region, the stem-loop secondary structural element is downstream of the redefined region. [PMID:12519954, SO:ke]"
          },
          "SO:1001280": {
            "name": "five_prime_recoding_site",
            "def": "The recoding stimulatory signal located upstream of the recoding site. [SO:ke]"
          },
          "SO:1001281": {
            "name": "flanking_three_prime_quadruplet_recoding_signal",
            "def": "Four base pair sequence immediately downstream of the redefined region. The redefined region is a frameshift site. The quadruplet is 2 overlapping codons. [PMID:12519954, SO:ke]"
          },
          "SO:1001282": {
            "name": "UAG_stop_codon_signal",
            "def": "A stop codon signal for a UAG stop codon redefinition. [SO:ke]"
          },
          "SO:1001283": {
            "name": "UAA_stop_codon_signal",
            "def": "A stop codon signal for a UAA stop codon redefinition. [SO:ke]"
          },
          "SO:1001284": {
            "name": "regulon",
            "def": "A group of genes, whether linked as a cluster or not, that respond to a common regulatory signal. [ISBN:0198506732]"
          },
          "SO:1001285": {
            "name": "UGA_stop_codon_signal",
            "def": "A stop codon signal for a UGA stop codon redefinition. [SO:ke]"
          },
          "SO:1001286": {
            "name": "three_prime_repeat_recoding_signal",
            "def": "A recoding stimulatory signal, downstream sequence important for recoding that contains repetitive elements. [PMID:12519954, SO:ke]"
          },
          "SO:1001287": {
            "name": "distant_three_prime_recoding_signal",
            "def": "A recoding signal that is found many hundreds of nucleotides 3' of a redefined stop codon. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8709208&dopt=Abstract]"
          },
          "SO:1001288": {
            "name": "stop_codon_signal",
            "def": "A recoding stimulatory signal that is a stop codon and has effect on efficiency of recoding. [PMID:12519954, SO:ke]"
          },
          "SO:2000061": {
            "name": "databank_entry",
            "def": "The sequence referred to by an entry in a databank such as GenBank or SwissProt. [SO:ke]"
          },
          "SO:3000000": {
            "name": "gene_segment",
            "def": "A gene component region which acts as a recombinational unit of a gene whose functional form is generated through somatic recombination. [GOC:add]"
          }
        };
      })(sequenceOntology = exports.sequenceOntology || (exports.sequenceOntology = {}));
    }
  });

  // node_modules/bioterms/dist/index.js
  var require_dist6 = __commonJS({
    "node_modules/bioterms/dist/index.js"(exports) {
      "use strict";
      init_shim();
      Object.defineProperty(exports, "__esModule", { value: true });
      var Prefixes_1 = require_Prefixes3();
      exports.Prefixes = Prefixes_1.Prefixes;
      exports.prefixify = Prefixes_1.prefixify;
      var Types_1 = require_Types3();
      exports.Types = Types_1.Types;
      var Predicates_1 = require_Predicates3();
      exports.Predicates = Predicates_1.Predicates;
      var Specifiers_1 = require_Specifiers3();
      exports.Specifiers = Specifiers_1.Specifiers;
      var sequenceOntology_1 = require_sequenceOntology3();
      exports.sequenceOntology = sequenceOntology_1.sequenceOntology;
      exports.uriToName = sequenceOntology_1.uriToName;
    }
  });

  // node_modules/console-browserify/index.js
  var require_console_browserify = __commonJS({
    "node_modules/console-browserify/index.js"(exports, module) {
      init_shim();
      var util = require_util2();
      var assert27 = require_assert();
      function now() {
        return new Date().getTime();
      }
      var slice = Array.prototype.slice;
      var console2;
      var times = {};
      if (typeof _global !== "undefined" && _global.console) {
        console2 = _global.console;
      } else if (typeof window !== "undefined" && window.console) {
        console2 = window.console;
      } else {
        console2 = {};
      }
      var functions = [
        [log, "log"],
        [info, "info"],
        [warn, "warn"],
        [error, "error"],
        [time, "time"],
        [timeEnd, "timeEnd"],
        [trace2, "trace"],
        [dir, "dir"],
        [consoleAssert, "assert"]
      ];
      for (i = 0; i < functions.length; i++) {
        tuple = functions[i];
        f = tuple[0];
        name = tuple[1];
        if (!console2[name]) {
          console2[name] = f;
        }
      }
      var tuple;
      var f;
      var name;
      var i;
      module.exports = console2;
      function log() {
      }
      function info() {
        console2.log.apply(console2, arguments);
      }
      function warn() {
        console2.log.apply(console2, arguments);
      }
      function error() {
        console2.warn.apply(console2, arguments);
      }
      function time(label) {
        times[label] = now();
      }
      function timeEnd(label) {
        var time2 = times[label];
        if (!time2) {
          throw new Error("No such label: " + label);
        }
        delete times[label];
        var duration = now() - time2;
        console2.log(label + ": " + duration + "ms");
      }
      function trace2() {
        var err = new Error();
        err.name = "Trace";
        err.message = util.format.apply(null, arguments);
        console2.error(err.stack);
      }
      function dir(object) {
        console2.log(util.inspect(object) + "\n");
      }
      function consoleAssert(expression) {
        if (!expression) {
          var arr = slice.call(arguments, 1);
          assert27.ok(false, util.format.apply(null, arr));
        }
      }
    }
  });

  // node_modules/string-argv/index.js
  var require_string_argv = __commonJS({
    "node_modules/string-argv/index.js"(exports) {
      "use strict";
      init_shim();
      exports.__esModule = true;
      function parseArgsStringToArgv(value, env, file) {
        var myRegexp = /([^\s'"]([^\s'"]*(['"])([^\3]*?)\3)+[^\s'"]*)|[^\s'"]+|(['"])([^\5]*?)\5/gi;
        var myString = value;
        var myArray = [];
        if (env) {
          myArray.push(env);
        }
        if (file) {
          myArray.push(file);
        }
        var match;
        do {
          match = myRegexp.exec(myString);
          if (match !== null) {
            myArray.push(firstString(match[1], match[6], match[0]));
          }
        } while (match !== null);
        return myArray;
      }
      exports["default"] = parseArgsStringToArgv;
      exports.parseArgsStringToArgv = parseArgsStringToArgv;
      function firstString() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        for (var i = 0; i < args.length; i++) {
          var arg = args[i];
          if (typeof arg === "string") {
            return arg;
          }
        }
      }
    }
  });

  // node_modules/path-browserify/index.js
  var require_path_browserify = __commonJS({
    "node_modules/path-browserify/index.js"(exports, module) {
      "use strict";
      init_shim();
      function assertPath(path) {
        if (typeof path !== "string") {
          throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
        }
      }
      function normalizeStringPosix(path, allowAboveRoot) {
        var res = "";
        var lastSegmentLength = 0;
        var lastSlash = -1;
        var dots = 0;
        var code;
        for (var i = 0; i <= path.length; ++i) {
          if (i < path.length)
            code = path.charCodeAt(i);
          else if (code === 47)
            break;
          else
            code = 47;
          if (code === 47) {
            if (lastSlash === i - 1 || dots === 1) {
            } else if (lastSlash !== i - 1 && dots === 2) {
              if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                if (res.length > 2) {
                  var lastSlashIndex = res.lastIndexOf("/");
                  if (lastSlashIndex !== res.length - 1) {
                    if (lastSlashIndex === -1) {
                      res = "";
                      lastSegmentLength = 0;
                    } else {
                      res = res.slice(0, lastSlashIndex);
                      lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                    }
                    lastSlash = i;
                    dots = 0;
                    continue;
                  }
                } else if (res.length === 2 || res.length === 1) {
                  res = "";
                  lastSegmentLength = 0;
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              }
              if (allowAboveRoot) {
                if (res.length > 0)
                  res += "/..";
                else
                  res = "..";
                lastSegmentLength = 2;
              }
            } else {
              if (res.length > 0)
                res += "/" + path.slice(lastSlash + 1, i);
              else
                res = path.slice(lastSlash + 1, i);
              lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
          } else if (code === 46 && dots !== -1) {
            ++dots;
          } else {
            dots = -1;
          }
        }
        return res;
      }
      function _format(sep, pathObject) {
        var dir = pathObject.dir || pathObject.root;
        var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
        if (!dir) {
          return base;
        }
        if (dir === pathObject.root) {
          return dir + base;
        }
        return dir + sep + base;
      }
      var posix = {
        resolve: function resolve() {
          var resolvedPath = "";
          var resolvedAbsolute = false;
          var cwd;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path;
            if (i >= 0)
              path = arguments[i];
            else {
              if (cwd === void 0)
                cwd = import_process.default.cwd();
              path = cwd;
            }
            assertPath(path);
            if (path.length === 0) {
              continue;
            }
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charCodeAt(0) === 47;
          }
          resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
          if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
              return "/" + resolvedPath;
            else
              return "/";
          } else if (resolvedPath.length > 0) {
            return resolvedPath;
          } else {
            return ".";
          }
        },
        normalize: function normalize2(path) {
          assertPath(path);
          if (path.length === 0)
            return ".";
          var isAbsolute = path.charCodeAt(0) === 47;
          var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
          path = normalizeStringPosix(path, !isAbsolute);
          if (path.length === 0 && !isAbsolute)
            path = ".";
          if (path.length > 0 && trailingSeparator)
            path += "/";
          if (isAbsolute)
            return "/" + path;
          return path;
        },
        isAbsolute: function isAbsolute(path) {
          assertPath(path);
          return path.length > 0 && path.charCodeAt(0) === 47;
        },
        join: function join() {
          if (arguments.length === 0)
            return ".";
          var joined;
          for (var i = 0; i < arguments.length; ++i) {
            var arg = arguments[i];
            assertPath(arg);
            if (arg.length > 0) {
              if (joined === void 0)
                joined = arg;
              else
                joined += "/" + arg;
            }
          }
          if (joined === void 0)
            return ".";
          return posix.normalize(joined);
        },
        relative: function relative(from, to) {
          assertPath(from);
          assertPath(to);
          if (from === to)
            return "";
          from = posix.resolve(from);
          to = posix.resolve(to);
          if (from === to)
            return "";
          var fromStart = 1;
          for (; fromStart < from.length; ++fromStart) {
            if (from.charCodeAt(fromStart) !== 47)
              break;
          }
          var fromEnd = from.length;
          var fromLen = fromEnd - fromStart;
          var toStart = 1;
          for (; toStart < to.length; ++toStart) {
            if (to.charCodeAt(toStart) !== 47)
              break;
          }
          var toEnd = to.length;
          var toLen = toEnd - toStart;
          var length = fromLen < toLen ? fromLen : toLen;
          var lastCommonSep = -1;
          var i = 0;
          for (; i <= length; ++i) {
            if (i === length) {
              if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                  return to.slice(toStart + i + 1);
                } else if (i === 0) {
                  return to.slice(toStart + i);
                }
              } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                  lastCommonSep = i;
                } else if (i === 0) {
                  lastCommonSep = 0;
                }
              }
              break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
              break;
            else if (fromCode === 47)
              lastCommonSep = i;
          }
          var out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === 47) {
              if (out.length === 0)
                out += "..";
              else
                out += "/..";
            }
          }
          if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
          else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47)
              ++toStart;
            return to.slice(toStart);
          }
        },
        _makeLong: function _makeLong(path) {
          return path;
        },
        dirname: function dirname(path) {
          assertPath(path);
          if (path.length === 0)
            return ".";
          var code = path.charCodeAt(0);
          var hasRoot = code === 47;
          var end = -1;
          var matchedSlash = true;
          for (var i = path.length - 1; i >= 1; --i) {
            code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1)
            return hasRoot ? "/" : ".";
          if (hasRoot && end === 1)
            return "//";
          return path.slice(0, end);
        },
        basename: function basename(path, ext) {
          if (ext !== void 0 && typeof ext !== "string")
            throw new TypeError('"ext" argument must be a string');
          assertPath(path);
          var start = 0;
          var end = -1;
          var matchedSlash = true;
          var i;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
              return "";
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end)
              end = firstNonSlashEnd;
            else if (end === -1)
              end = path.length;
            return path.slice(start, end);
          } else {
            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1)
              return "";
            return path.slice(start, end);
          }
        },
        extname: function extname(path) {
          assertPath(path);
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var preDotState = 0;
          for (var i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path.slice(startDot, end);
        },
        format: function format(pathObject) {
          if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
          }
          return _format("/", pathObject);
        },
        parse: function parse(path) {
          assertPath(path);
          var ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path.length === 0)
            return ret;
          var code = path.charCodeAt(0);
          var isAbsolute = code === 47;
          var start;
          if (isAbsolute) {
            ret.root = "/";
            start = 1;
          } else {
            start = 0;
          }
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var i = path.length - 1;
          var preDotState = 0;
          for (; i >= start; --i) {
            code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute)
                ret.base = ret.name = path.slice(1, end);
              else
                ret.base = ret.name = path.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path.slice(1, startDot);
              ret.base = path.slice(1, end);
            } else {
              ret.name = path.slice(startPart, startDot);
              ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
          }
          if (startPart > 0)
            ret.dir = path.slice(0, startPart - 1);
          else if (isAbsolute)
            ret.dir = "/";
          return ret;
        },
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null
      };
      posix.posix = posix;
      module.exports = posix;
    }
  });

  // node_modules/fs.realpath/old.js
  var require_old = __commonJS({
    "node_modules/fs.realpath/old.js"(exports) {
      init_shim();
      var pathModule = require_path_browserify();
      var isWindows = import_process.default.platform === "win32";
      var fs14 = require_fs();
      var DEBUG = import_process.default.env.NODE_DEBUG && /fs/.test(import_process.default.env.NODE_DEBUG);
      function rethrow() {
        var callback;
        if (DEBUG) {
          var backtrace = new Error();
          callback = debugCallback;
        } else
          callback = missingCallback;
        return callback;
        function debugCallback(err) {
          if (err) {
            backtrace.message = err.message;
            err = backtrace;
            missingCallback(err);
          }
        }
        function missingCallback(err) {
          if (err) {
            if (import_process.default.throwDeprecation)
              throw err;
            else if (!import_process.default.noDeprecation) {
              var msg = "fs: missing callback " + (err.stack || err.message);
              if (import_process.default.traceDeprecation)
                console.trace(msg);
              else
                console.error(msg);
            }
          }
        }
      }
      function maybeCallback(cb) {
        return typeof cb === "function" ? cb : rethrow();
      }
      var normalize2 = pathModule.normalize;
      if (isWindows) {
        nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
      } else {
        nextPartRe = /(.*?)(?:[\/]+|$)/g;
      }
      var nextPartRe;
      if (isWindows) {
        splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
      } else {
        splitRootRe = /^[\/]*/;
      }
      var splitRootRe;
      exports.realpathSync = function realpathSync(p, cache) {
        p = pathModule.resolve(p);
        if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
          return cache[p];
        }
        var original = p, seenLinks = {}, knownHard = {};
        var pos;
        var current;
        var base;
        var previous;
        start();
        function start() {
          var m = splitRootRe.exec(p);
          pos = m[0].length;
          current = m[0];
          base = m[0];
          previous = "";
          if (isWindows && !knownHard[base]) {
            fs14.lstatSync(base);
            knownHard[base] = true;
          }
        }
        while (pos < p.length) {
          nextPartRe.lastIndex = pos;
          var result = nextPartRe.exec(p);
          previous = current;
          current += result[0];
          base = previous + result[1];
          pos = nextPartRe.lastIndex;
          if (knownHard[base] || cache && cache[base] === base) {
            continue;
          }
          var resolvedLink;
          if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
            resolvedLink = cache[base];
          } else {
            var stat = fs14.lstatSync(base);
            if (!stat.isSymbolicLink()) {
              knownHard[base] = true;
              if (cache)
                cache[base] = base;
              continue;
            }
            var linkTarget = null;
            if (!isWindows) {
              var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
              if (seenLinks.hasOwnProperty(id)) {
                linkTarget = seenLinks[id];
              }
            }
            if (linkTarget === null) {
              fs14.statSync(base);
              linkTarget = fs14.readlinkSync(base);
            }
            resolvedLink = pathModule.resolve(previous, linkTarget);
            if (cache)
              cache[base] = resolvedLink;
            if (!isWindows)
              seenLinks[id] = linkTarget;
          }
          p = pathModule.resolve(resolvedLink, p.slice(pos));
          start();
        }
        if (cache)
          cache[original] = p;
        return p;
      };
      exports.realpath = function realpath(p, cache, cb) {
        if (typeof cb !== "function") {
          cb = maybeCallback(cache);
          cache = null;
        }
        p = pathModule.resolve(p);
        if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
          return import_process.default.nextTick(cb.bind(null, null, cache[p]));
        }
        var original = p, seenLinks = {}, knownHard = {};
        var pos;
        var current;
        var base;
        var previous;
        start();
        function start() {
          var m = splitRootRe.exec(p);
          pos = m[0].length;
          current = m[0];
          base = m[0];
          previous = "";
          if (isWindows && !knownHard[base]) {
            fs14.lstat(base, function(err) {
              if (err)
                return cb(err);
              knownHard[base] = true;
              LOOP();
            });
          } else {
            import_process.default.nextTick(LOOP);
          }
        }
        function LOOP() {
          if (pos >= p.length) {
            if (cache)
              cache[original] = p;
            return cb(null, p);
          }
          nextPartRe.lastIndex = pos;
          var result = nextPartRe.exec(p);
          previous = current;
          current += result[0];
          base = previous + result[1];
          pos = nextPartRe.lastIndex;
          if (knownHard[base] || cache && cache[base] === base) {
            return import_process.default.nextTick(LOOP);
          }
          if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
            return gotResolvedLink(cache[base]);
          }
          return fs14.lstat(base, gotStat);
        }
        function gotStat(err, stat) {
          if (err)
            return cb(err);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            return import_process.default.nextTick(LOOP);
          }
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              return gotTarget(null, seenLinks[id], base);
            }
          }
          fs14.stat(base, function(err2) {
            if (err2)
              return cb(err2);
            fs14.readlink(base, function(err3, target) {
              if (!isWindows)
                seenLinks[id] = target;
              gotTarget(err3, target);
            });
          });
        }
        function gotTarget(err, target, base2) {
          if (err)
            return cb(err);
          var resolvedLink = pathModule.resolve(previous, target);
          if (cache)
            cache[base2] = resolvedLink;
          gotResolvedLink(resolvedLink);
        }
        function gotResolvedLink(resolvedLink) {
          p = pathModule.resolve(resolvedLink, p.slice(pos));
          start();
        }
      };
    }
  });

  // node_modules/fs.realpath/index.js
  var require_fs2 = __commonJS({
    "node_modules/fs.realpath/index.js"(exports, module) {
      init_shim();
      module.exports = realpath;
      realpath.realpath = realpath;
      realpath.sync = realpathSync;
      realpath.realpathSync = realpathSync;
      realpath.monkeypatch = monkeypatch;
      realpath.unmonkeypatch = unmonkeypatch;
      var fs14 = require_fs();
      var origRealpath = fs14.realpath;
      var origRealpathSync = fs14.realpathSync;
      var version = import_process.default.version;
      var ok = /^v[0-5]\./.test(version);
      var old = require_old();
      function newError(er) {
        return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
      }
      function realpath(p, cache, cb) {
        if (ok) {
          return origRealpath(p, cache, cb);
        }
        if (typeof cache === "function") {
          cb = cache;
          cache = null;
        }
        origRealpath(p, cache, function(er, result) {
          if (newError(er)) {
            old.realpath(p, cache, cb);
          } else {
            cb(er, result);
          }
        });
      }
      function realpathSync(p, cache) {
        if (ok) {
          return origRealpathSync(p, cache);
        }
        try {
          return origRealpathSync(p, cache);
        } catch (er) {
          if (newError(er)) {
            return old.realpathSync(p, cache);
          } else {
            throw er;
          }
        }
      }
      function monkeypatch() {
        fs14.realpath = realpath;
        fs14.realpathSync = realpathSync;
      }
      function unmonkeypatch() {
        fs14.realpath = origRealpath;
        fs14.realpathSync = origRealpathSync;
      }
    }
  });

  // node_modules/concat-map/index.js
  var require_concat_map = __commonJS({
    "node_modules/concat-map/index.js"(exports, module) {
      init_shim();
      module.exports = function(xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
          var x = fn(xs[i], i);
          if (isArray(x))
            res.push.apply(res, x);
          else
            res.push(x);
        }
        return res;
      };
      var isArray = Array.isArray || function(xs) {
        return Object.prototype.toString.call(xs) === "[object Array]";
      };
    }
  });

  // node_modules/balanced-match/index.js
  var require_balanced_match = __commonJS({
    "node_modules/balanced-match/index.js"(exports, module) {
      "use strict";
      init_shim();
      module.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp)
          a = maybeMatch(a, str);
        if (b instanceof RegExp)
          b = maybeMatch(b, str);
        var r = range(a, b, str);
        return r && {
          start: r[0],
          end: r[1],
          pre: str.slice(0, r[0]),
          body: str.slice(r[0] + a.length, r[1]),
          post: str.slice(r[1] + b.length)
        };
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left, right];
          }
        }
        return result;
      }
    }
  });

  // node_modules/brace-expansion/index.js
  var require_brace_expansion = __commonJS({
    "node_modules/brace-expansion/index.js"(exports, module) {
      init_shim();
      var concatMap = require_concat_map();
      var balanced = require_balanced_match();
      module.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function escapeBraces(str) {
        return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
      }
      function unescapeBraces(str) {
        return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
      }
      function parseCommaParts(str) {
        if (!str)
          return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m)
          return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      function expandTop(str) {
        if (!str)
          return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand(escapeBraces(str), true).map(unescapeBraces);
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m || /\$$/.test(m.pre))
          return [str];
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              var post = m.post.length ? expand(m.post, false) : [""];
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var pre = m.pre;
        var post = m.post.length ? expand(m.post, false) : [""];
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = concatMap(n, function(el) {
            return expand(el, false);
          });
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
        return expansions;
      }
    }
  });

  // node_modules/minimatch/minimatch.js
  var require_minimatch = __commonJS({
    "node_modules/minimatch/minimatch.js"(exports, module) {
      init_shim();
      module.exports = minimatch;
      minimatch.Minimatch = Minimatch;
      var path = function() {
        try {
          return require_path_browserify();
        } catch (e) {
        }
      }() || {
        sep: "/"
      };
      minimatch.sep = path.sep;
      var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
      var expand = require_brace_expansion();
      var plTypes = {
        "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
        "?": { open: "(?:", close: ")?" },
        "+": { open: "(?:", close: ")+" },
        "*": { open: "(?:", close: ")*" },
        "@": { open: "(?:", close: ")" }
      };
      var qmark = "[^/]";
      var star = qmark + "*?";
      var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
      var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
      var reSpecials = charSet("().*{}+?[]^$\\!");
      function charSet(s) {
        return s.split("").reduce(function(set, c) {
          set[c] = true;
          return set;
        }, {});
      }
      var slashSplit = /\/+/;
      minimatch.filter = filter;
      function filter(pattern, options) {
        options = options || {};
        return function(p, i, list) {
          return minimatch(p, pattern, options);
        };
      }
      function ext(a, b) {
        b = b || {};
        var t = {};
        Object.keys(a).forEach(function(k) {
          t[k] = a[k];
        });
        Object.keys(b).forEach(function(k) {
          t[k] = b[k];
        });
        return t;
      }
      minimatch.defaults = function(def) {
        if (!def || typeof def !== "object" || !Object.keys(def).length) {
          return minimatch;
        }
        var orig = minimatch;
        var m = function minimatch2(p, pattern, options) {
          return orig(p, pattern, ext(def, options));
        };
        m.Minimatch = function Minimatch2(pattern, options) {
          return new orig.Minimatch(pattern, ext(def, options));
        };
        m.Minimatch.defaults = function defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        };
        m.filter = function filter2(pattern, options) {
          return orig.filter(pattern, ext(def, options));
        };
        m.defaults = function defaults(options) {
          return orig.defaults(ext(def, options));
        };
        m.makeRe = function makeRe2(pattern, options) {
          return orig.makeRe(pattern, ext(def, options));
        };
        m.braceExpand = function braceExpand2(pattern, options) {
          return orig.braceExpand(pattern, ext(def, options));
        };
        m.match = function(list, pattern, options) {
          return orig.match(list, pattern, ext(def, options));
        };
        return m;
      };
      Minimatch.defaults = function(def) {
        return minimatch.defaults(def).Minimatch;
      };
      function minimatch(p, pattern, options) {
        assertValidPattern(pattern);
        if (!options)
          options = {};
        if (!options.nocomment && pattern.charAt(0) === "#") {
          return false;
        }
        return new Minimatch(pattern, options).match(p);
      }
      function Minimatch(pattern, options) {
        if (!(this instanceof Minimatch)) {
          return new Minimatch(pattern, options);
        }
        assertValidPattern(pattern);
        if (!options)
          options = {};
        pattern = pattern.trim();
        if (!options.allowWindowsEscape && path.sep !== "/") {
          pattern = pattern.split(path.sep).join("/");
        }
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      Minimatch.prototype.debug = function() {
      };
      Minimatch.prototype.make = make;
      function make() {
        var pattern = this.pattern;
        var options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        var set = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = function debug() {
            console.error.apply(console, arguments);
          };
        this.debug(this.pattern, set);
        set = this.globParts = set.map(function(s) {
          return s.split(slashSplit);
        });
        this.debug(this.pattern, set);
        set = set.map(function(s, si, set2) {
          return s.map(this.parse, this);
        }, this);
        this.debug(this.pattern, set);
        set = set.filter(function(s) {
          return s.indexOf(false) === -1;
        });
        this.debug(this.pattern, set);
        this.set = set;
      }
      Minimatch.prototype.parseNegate = parseNegate;
      function parseNegate() {
        var pattern = this.pattern;
        var negate = false;
        var options = this.options;
        var negateOffset = 0;
        if (options.nonegate)
          return;
        for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.substr(negateOffset);
        this.negate = negate;
      }
      minimatch.braceExpand = function(pattern, options) {
        return braceExpand(pattern, options);
      };
      Minimatch.prototype.braceExpand = braceExpand;
      function braceExpand(pattern, options) {
        if (!options) {
          if (this instanceof Minimatch) {
            options = this.options;
          } else {
            options = {};
          }
        }
        pattern = typeof pattern === "undefined" ? this.pattern : pattern;
        assertValidPattern(pattern);
        if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
          return [pattern];
        }
        return expand(pattern);
      }
      var MAX_PATTERN_LENGTH = 1024 * 64;
      var assertValidPattern = function(pattern) {
        if (typeof pattern !== "string") {
          throw new TypeError("invalid pattern");
        }
        if (pattern.length > MAX_PATTERN_LENGTH) {
          throw new TypeError("pattern is too long");
        }
      };
      Minimatch.prototype.parse = parse;
      var SUBPARSE = {};
      function parse(pattern, isSub) {
        assertValidPattern(pattern);
        var options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        var re = "";
        var hasMagic = !!options.nocase;
        var escaping = false;
        var patternListStack = [];
        var negativeLists = [];
        var stateChar;
        var inClass = false;
        var reClassStart = -1;
        var classStart = -1;
        var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        var self2 = this;
        function clearStateChar() {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            self2.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        }
        for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping && reSpecials[c]) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              self2.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              var pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length || escaping) {
                re += "\\|";
                escaping = false;
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                escaping = false;
                continue;
              }
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
              hasMagic = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (escaping) {
                escaping = false;
              } else if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
          }
        }
        if (inClass) {
          cs = pattern.substr(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          var tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        var addPatternStart = false;
        switch (re.charAt(0)) {
          case "[":
          case ".":
          case "(":
            addPatternStart = true;
        }
        for (var n = negativeLists.length - 1; n > -1; n--) {
          var nl = negativeLists[n];
          var nlBefore = re.slice(0, nl.reStart);
          var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
          var nlAfter = re.slice(nl.reEnd);
          nlLast += nlAfter;
          var openParensBefore = nlBefore.split("(").length - 1;
          var cleanAfter = nlAfter;
          for (i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          var dollar = "";
          if (nlAfter === "" && isSub !== SUBPARSE) {
            dollar = "$";
          }
          var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
          re = newRe;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        var flags = options.nocase ? "i" : "";
        try {
          var regExp = new RegExp("^" + re + "$", flags);
        } catch (er) {
          return new RegExp("$.");
        }
        regExp._glob = pattern;
        regExp._src = re;
        return regExp;
      }
      minimatch.makeRe = function(pattern, options) {
        return new Minimatch(pattern, options || {}).makeRe();
      };
      Minimatch.prototype.makeRe = makeRe;
      function makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        var set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        var options = this.options;
        var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        var flags = options.nocase ? "i" : "";
        var re = set.map(function(pattern) {
          return pattern.map(function(p) {
            return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
          }).join("\\/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      minimatch.match = function(list, pattern, options) {
        options = options || {};
        var mm = new Minimatch(pattern, options);
        list = list.filter(function(f) {
          return mm.match(f);
        });
        if (mm.options.nonull && !list.length) {
          list.push(pattern);
        }
        return list;
      };
      Minimatch.prototype.match = function match(f, partial) {
        if (typeof partial === "undefined")
          partial = this.partial;
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        var options = this.options;
        if (path.sep !== "/") {
          f = f.split(path.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        var set = this.set;
        this.debug(this.pattern, "set", set);
        var filename;
        var i;
        for (i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename)
            break;
        }
        for (i = 0; i < set.length; i++) {
          var pattern = set[i];
          var file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          var hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      };
      Minimatch.prototype.matchOne = function(file, pattern, partial) {
        var options = this.options;
        this.debug("matchOne", { "this": this, file, pattern });
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      };
      function globUnescape(s) {
        return s.replace(/\\(.)/g, "$1");
      }
      function regExpEscape(s) {
        return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }
    }
  });

  // node_modules/path-is-absolute/index.js
  var require_path_is_absolute = __commonJS({
    "node_modules/path-is-absolute/index.js"(exports, module) {
      "use strict";
      init_shim();
      function posix(path) {
        return path.charAt(0) === "/";
      }
      function win32(path) {
        var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
        var result = splitDeviceRe.exec(path);
        var device = result[1] || "";
        var isUnc = Boolean(device && device.charAt(1) !== ":");
        return Boolean(result[2] || isUnc);
      }
      module.exports = import_process.default.platform === "win32" ? win32 : posix;
      module.exports.posix = posix;
      module.exports.win32 = win32;
    }
  });

  // node_modules/glob/common.js
  var require_common = __commonJS({
    "node_modules/glob/common.js"(exports) {
      init_shim();
      exports.setopts = setopts;
      exports.ownProp = ownProp;
      exports.makeAbs = makeAbs;
      exports.finish = finish;
      exports.mark = mark;
      exports.isIgnored = isIgnored;
      exports.childrenIgnored = childrenIgnored;
      function ownProp(obj, field) {
        return Object.prototype.hasOwnProperty.call(obj, field);
      }
      var fs14 = require_fs();
      var path = require_path_browserify();
      var minimatch = require_minimatch();
      var isAbsolute = require_path_is_absolute();
      var Minimatch = minimatch.Minimatch;
      function alphasort(a, b) {
        return a.localeCompare(b, "en");
      }
      function setupIgnores(self2, options) {
        self2.ignore = options.ignore || [];
        if (!Array.isArray(self2.ignore))
          self2.ignore = [self2.ignore];
        if (self2.ignore.length) {
          self2.ignore = self2.ignore.map(ignoreMap);
        }
      }
      function ignoreMap(pattern) {
        var gmatcher = null;
        if (pattern.slice(-3) === "/**") {
          var gpattern = pattern.replace(/(\/\*\*)+$/, "");
          gmatcher = new Minimatch(gpattern, { dot: true });
        }
        return {
          matcher: new Minimatch(pattern, { dot: true }),
          gmatcher
        };
      }
      function setopts(self2, pattern, options) {
        if (!options)
          options = {};
        if (options.matchBase && pattern.indexOf("/") === -1) {
          if (options.noglobstar) {
            throw new Error("base matching requires globstar");
          }
          pattern = "**/" + pattern;
        }
        self2.silent = !!options.silent;
        self2.pattern = pattern;
        self2.strict = options.strict !== false;
        self2.realpath = !!options.realpath;
        self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
        self2.follow = !!options.follow;
        self2.dot = !!options.dot;
        self2.mark = !!options.mark;
        self2.nodir = !!options.nodir;
        if (self2.nodir)
          self2.mark = true;
        self2.sync = !!options.sync;
        self2.nounique = !!options.nounique;
        self2.nonull = !!options.nonull;
        self2.nosort = !!options.nosort;
        self2.nocase = !!options.nocase;
        self2.stat = !!options.stat;
        self2.noprocess = !!options.noprocess;
        self2.absolute = !!options.absolute;
        self2.fs = options.fs || fs14;
        self2.maxLength = options.maxLength || Infinity;
        self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
        self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
        self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
        setupIgnores(self2, options);
        self2.changedCwd = false;
        var cwd = import_process.default.cwd();
        if (!ownProp(options, "cwd"))
          self2.cwd = cwd;
        else {
          self2.cwd = path.resolve(options.cwd);
          self2.changedCwd = self2.cwd !== cwd;
        }
        self2.root = options.root || path.resolve(self2.cwd, "/");
        self2.root = path.resolve(self2.root);
        if (import_process.default.platform === "win32")
          self2.root = self2.root.replace(/\\/g, "/");
        self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
        if (import_process.default.platform === "win32")
          self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
        self2.nomount = !!options.nomount;
        options.nonegate = true;
        options.nocomment = true;
        options.allowWindowsEscape = false;
        self2.minimatch = new Minimatch(pattern, options);
        self2.options = self2.minimatch.options;
      }
      function finish(self2) {
        var nou = self2.nounique;
        var all = nou ? [] : /* @__PURE__ */ Object.create(null);
        for (var i = 0, l = self2.matches.length; i < l; i++) {
          var matches = self2.matches[i];
          if (!matches || Object.keys(matches).length === 0) {
            if (self2.nonull) {
              var literal = self2.minimatch.globSet[i];
              if (nou)
                all.push(literal);
              else
                all[literal] = true;
            }
          } else {
            var m = Object.keys(matches);
            if (nou)
              all.push.apply(all, m);
            else
              m.forEach(function(m2) {
                all[m2] = true;
              });
          }
        }
        if (!nou)
          all = Object.keys(all);
        if (!self2.nosort)
          all = all.sort(alphasort);
        if (self2.mark) {
          for (var i = 0; i < all.length; i++) {
            all[i] = self2._mark(all[i]);
          }
          if (self2.nodir) {
            all = all.filter(function(e) {
              var notDir = !/\/$/.test(e);
              var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
              if (notDir && c)
                notDir = c !== "DIR" && !Array.isArray(c);
              return notDir;
            });
          }
        }
        if (self2.ignore.length)
          all = all.filter(function(m2) {
            return !isIgnored(self2, m2);
          });
        self2.found = all;
      }
      function mark(self2, p) {
        var abs = makeAbs(self2, p);
        var c = self2.cache[abs];
        var m = p;
        if (c) {
          var isDir = c === "DIR" || Array.isArray(c);
          var slash = p.slice(-1) === "/";
          if (isDir && !slash)
            m += "/";
          else if (!isDir && slash)
            m = m.slice(0, -1);
          if (m !== p) {
            var mabs = makeAbs(self2, m);
            self2.statCache[mabs] = self2.statCache[abs];
            self2.cache[mabs] = self2.cache[abs];
          }
        }
        return m;
      }
      function makeAbs(self2, f) {
        var abs = f;
        if (f.charAt(0) === "/") {
          abs = path.join(self2.root, f);
        } else if (isAbsolute(f) || f === "") {
          abs = f;
        } else if (self2.changedCwd) {
          abs = path.resolve(self2.cwd, f);
        } else {
          abs = path.resolve(f);
        }
        if (import_process.default.platform === "win32")
          abs = abs.replace(/\\/g, "/");
        return abs;
      }
      function isIgnored(self2, path2) {
        if (!self2.ignore.length)
          return false;
        return self2.ignore.some(function(item) {
          return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
        });
      }
      function childrenIgnored(self2, path2) {
        if (!self2.ignore.length)
          return false;
        return self2.ignore.some(function(item) {
          return !!(item.gmatcher && item.gmatcher.match(path2));
        });
      }
    }
  });

  // node_modules/glob/sync.js
  var require_sync = __commonJS({
    "node_modules/glob/sync.js"(exports, module) {
      init_shim();
      module.exports = globSync;
      globSync.GlobSync = GlobSync;
      var rp = require_fs2();
      var minimatch = require_minimatch();
      var Minimatch = minimatch.Minimatch;
      var Glob = require_glob().Glob;
      var util = require_util2();
      var path = require_path_browserify();
      var assert27 = require_assert();
      var isAbsolute = require_path_is_absolute();
      var common = require_common();
      var setopts = common.setopts;
      var ownProp = common.ownProp;
      var childrenIgnored = common.childrenIgnored;
      var isIgnored = common.isIgnored;
      function globSync(pattern, options) {
        if (typeof options === "function" || arguments.length === 3)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        return new GlobSync(pattern, options).found;
      }
      function GlobSync(pattern, options) {
        if (!pattern)
          throw new Error("must provide pattern");
        if (typeof options === "function" || arguments.length === 3)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        if (!(this instanceof GlobSync))
          return new GlobSync(pattern, options);
        setopts(this, pattern, options);
        if (this.noprocess)
          return this;
        var n = this.minimatch.set.length;
        this.matches = new Array(n);
        for (var i = 0; i < n; i++) {
          this._process(this.minimatch.set[i], i, false);
        }
        this._finish();
      }
      GlobSync.prototype._finish = function() {
        assert27.ok(this instanceof GlobSync);
        if (this.realpath) {
          var self2 = this;
          this.matches.forEach(function(matchset, index) {
            var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
            for (var p in matchset) {
              try {
                p = self2._makeAbs(p);
                var real = rp.realpathSync(p, self2.realpathCache);
                set[real] = true;
              } catch (er) {
                if (er.syscall === "stat")
                  set[self2._makeAbs(p)] = true;
                else
                  throw er;
              }
            }
          });
        }
        common.finish(this);
      };
      GlobSync.prototype._process = function(pattern, index, inGlobStar) {
        assert27.ok(this instanceof GlobSync);
        var n = 0;
        while (typeof pattern[n] === "string") {
          n++;
        }
        var prefix;
        switch (n) {
          case pattern.length:
            this._processSimple(pattern.join("/"), index);
            return;
          case 0:
            prefix = null;
            break;
          default:
            prefix = pattern.slice(0, n).join("/");
            break;
        }
        var remain = pattern.slice(n);
        var read;
        if (prefix === null)
          read = ".";
        else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
          return typeof p === "string" ? p : "[*]";
        }).join("/"))) {
          if (!prefix || !isAbsolute(prefix))
            prefix = "/" + prefix;
          read = prefix;
        } else
          read = prefix;
        var abs = this._makeAbs(read);
        if (childrenIgnored(this, read))
          return;
        var isGlobStar = remain[0] === minimatch.GLOBSTAR;
        if (isGlobStar)
          this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
        else
          this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
      };
      GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
        var entries = this._readdir(abs, inGlobStar);
        if (!entries)
          return;
        var pn = remain[0];
        var negate = !!this.minimatch.negate;
        var rawGlob = pn._glob;
        var dotOk = this.dot || rawGlob.charAt(0) === ".";
        var matchedEntries = [];
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (e.charAt(0) !== "." || dotOk) {
            var m;
            if (negate && !prefix) {
              m = !e.match(pn);
            } else {
              m = e.match(pn);
            }
            if (m)
              matchedEntries.push(e);
          }
        }
        var len = matchedEntries.length;
        if (len === 0)
          return;
        if (remain.length === 1 && !this.mark && !this.stat) {
          if (!this.matches[index])
            this.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < len; i++) {
            var e = matchedEntries[i];
            if (prefix) {
              if (prefix.slice(-1) !== "/")
                e = prefix + "/" + e;
              else
                e = prefix + e;
            }
            if (e.charAt(0) === "/" && !this.nomount) {
              e = path.join(this.root, e);
            }
            this._emitMatch(index, e);
          }
          return;
        }
        remain.shift();
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          var newPattern;
          if (prefix)
            newPattern = [prefix, e];
          else
            newPattern = [e];
          this._process(newPattern.concat(remain), index, inGlobStar);
        }
      };
      GlobSync.prototype._emitMatch = function(index, e) {
        if (isIgnored(this, e))
          return;
        var abs = this._makeAbs(e);
        if (this.mark)
          e = this._mark(e);
        if (this.absolute) {
          e = abs;
        }
        if (this.matches[index][e])
          return;
        if (this.nodir) {
          var c = this.cache[abs];
          if (c === "DIR" || Array.isArray(c))
            return;
        }
        this.matches[index][e] = true;
        if (this.stat)
          this._stat(e);
      };
      GlobSync.prototype._readdirInGlobStar = function(abs) {
        if (this.follow)
          return this._readdir(abs, false);
        var entries;
        var lstat;
        var stat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er.code === "ENOENT") {
            return null;
          }
        }
        var isSym = lstat && lstat.isSymbolicLink();
        this.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory())
          this.cache[abs] = "FILE";
        else
          entries = this._readdir(abs, false);
        return entries;
      };
      GlobSync.prototype._readdir = function(abs, inGlobStar) {
        var entries;
        if (inGlobStar && !ownProp(this.symlinks, abs))
          return this._readdirInGlobStar(abs);
        if (ownProp(this.cache, abs)) {
          var c = this.cache[abs];
          if (!c || c === "FILE")
            return null;
          if (Array.isArray(c))
            return c;
        }
        try {
          return this._readdirEntries(abs, this.fs.readdirSync(abs));
        } catch (er) {
          this._readdirError(abs, er);
          return null;
        }
      };
      GlobSync.prototype._readdirEntries = function(abs, entries) {
        if (!this.mark && !this.stat) {
          for (var i = 0; i < entries.length; i++) {
            var e = entries[i];
            if (abs === "/")
              e = abs + e;
            else
              e = abs + "/" + e;
            this.cache[e] = true;
          }
        }
        this.cache[abs] = entries;
        return entries;
      };
      GlobSync.prototype._readdirError = function(f, er) {
        switch (er.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var abs = this._makeAbs(f);
            this.cache[abs] = "FILE";
            if (abs === this.cwdAbs) {
              var error = new Error(er.code + " invalid cwd " + this.cwd);
              error.path = this.cwd;
              error.code = er.code;
              throw error;
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(f)] = false;
            break;
          default:
            this.cache[this._makeAbs(f)] = false;
            if (this.strict)
              throw er;
            if (!this.silent)
              console.error("glob error", er);
            break;
        }
      };
      GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
        var entries = this._readdir(abs, inGlobStar);
        if (!entries)
          return;
        var remainWithoutGlobStar = remain.slice(1);
        var gspref = prefix ? [prefix] : [];
        var noGlobStar = gspref.concat(remainWithoutGlobStar);
        this._process(noGlobStar, index, false);
        var len = entries.length;
        var isSym = this.symlinks[abs];
        if (isSym && inGlobStar)
          return;
        for (var i = 0; i < len; i++) {
          var e = entries[i];
          if (e.charAt(0) === "." && !this.dot)
            continue;
          var instead = gspref.concat(entries[i], remainWithoutGlobStar);
          this._process(instead, index, true);
          var below = gspref.concat(entries[i], remain);
          this._process(below, index, true);
        }
      };
      GlobSync.prototype._processSimple = function(prefix, index) {
        var exists = this._stat(prefix);
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        if (!exists)
          return;
        if (prefix && isAbsolute(prefix) && !this.nomount) {
          var trail = /[\/\\]$/.test(prefix);
          if (prefix.charAt(0) === "/") {
            prefix = path.join(this.root, prefix);
          } else {
            prefix = path.resolve(this.root, prefix);
            if (trail)
              prefix += "/";
          }
        }
        if (import_process.default.platform === "win32")
          prefix = prefix.replace(/\\/g, "/");
        this._emitMatch(index, prefix);
      };
      GlobSync.prototype._stat = function(f) {
        var abs = this._makeAbs(f);
        var needDir = f.slice(-1) === "/";
        if (f.length > this.maxLength)
          return false;
        if (!this.stat && ownProp(this.cache, abs)) {
          var c = this.cache[abs];
          if (Array.isArray(c))
            c = "DIR";
          if (!needDir || c === "DIR")
            return c;
          if (needDir && c === "FILE")
            return false;
        }
        var exists;
        var stat = this.statCache[abs];
        if (!stat) {
          var lstat;
          try {
            lstat = this.fs.lstatSync(abs);
          } catch (er) {
            if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
              this.statCache[abs] = false;
              return false;
            }
          }
          if (lstat && lstat.isSymbolicLink()) {
            try {
              stat = this.fs.statSync(abs);
            } catch (er) {
              stat = lstat;
            }
          } else {
            stat = lstat;
          }
        }
        this.statCache[abs] = stat;
        var c = true;
        if (stat)
          c = stat.isDirectory() ? "DIR" : "FILE";
        this.cache[abs] = this.cache[abs] || c;
        if (needDir && c === "FILE")
          return false;
        return c;
      };
      GlobSync.prototype._mark = function(p) {
        return common.mark(this, p);
      };
      GlobSync.prototype._makeAbs = function(f) {
        return common.makeAbs(this, f);
      };
    }
  });

  // node_modules/wrappy/wrappy.js
  var require_wrappy = __commonJS({
    "node_modules/wrappy/wrappy.js"(exports, module) {
      init_shim();
      module.exports = wrappy;
      function wrappy(fn, cb) {
        if (fn && cb)
          return wrappy(fn)(cb);
        if (typeof fn !== "function")
          throw new TypeError("need wrapper function");
        Object.keys(fn).forEach(function(k) {
          wrapper[k] = fn[k];
        });
        return wrapper;
        function wrapper() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          var ret = fn.apply(this, args);
          var cb2 = args[args.length - 1];
          if (typeof ret === "function" && ret !== cb2) {
            Object.keys(cb2).forEach(function(k) {
              ret[k] = cb2[k];
            });
          }
          return ret;
        }
      }
    }
  });

  // node_modules/once/once.js
  var require_once2 = __commonJS({
    "node_modules/once/once.js"(exports, module) {
      init_shim();
      var wrappy = require_wrappy();
      module.exports = wrappy(once2);
      module.exports.strict = wrappy(onceStrict);
      once2.proto = once2(function() {
        Object.defineProperty(Function.prototype, "once", {
          value: function() {
            return once2(this);
          },
          configurable: true
        });
        Object.defineProperty(Function.prototype, "onceStrict", {
          value: function() {
            return onceStrict(this);
          },
          configurable: true
        });
      });
      function once2(fn) {
        var f = function() {
          if (f.called)
            return f.value;
          f.called = true;
          return f.value = fn.apply(this, arguments);
        };
        f.called = false;
        return f;
      }
      function onceStrict(fn) {
        var f = function() {
          if (f.called)
            throw new Error(f.onceError);
          f.called = true;
          return f.value = fn.apply(this, arguments);
        };
        var name = fn.name || "Function wrapped with `once`";
        f.onceError = name + " shouldn't be called more than once";
        f.called = false;
        return f;
      }
    }
  });

  // node_modules/inflight/inflight.js
  var require_inflight = __commonJS({
    "node_modules/inflight/inflight.js"(exports, module) {
      init_shim();
      var wrappy = require_wrappy();
      var reqs = /* @__PURE__ */ Object.create(null);
      var once2 = require_once2();
      module.exports = wrappy(inflight);
      function inflight(key, cb) {
        if (reqs[key]) {
          reqs[key].push(cb);
          return null;
        } else {
          reqs[key] = [cb];
          return makeres(key);
        }
      }
      function makeres(key) {
        return once2(function RES() {
          var cbs = reqs[key];
          var len = cbs.length;
          var args = slice(arguments);
          try {
            for (var i = 0; i < len; i++) {
              cbs[i].apply(null, args);
            }
          } finally {
            if (cbs.length > len) {
              cbs.splice(0, len);
              import_process.default.nextTick(function() {
                RES.apply(null, args);
              });
            } else {
              delete reqs[key];
            }
          }
        });
      }
      function slice(args) {
        var length = args.length;
        var array = [];
        for (var i = 0; i < length; i++)
          array[i] = args[i];
        return array;
      }
    }
  });

  // node_modules/glob/glob.js
  var require_glob = __commonJS({
    "node_modules/glob/glob.js"(exports, module) {
      init_shim();
      module.exports = glob2;
      var rp = require_fs2();
      var minimatch = require_minimatch();
      var Minimatch = minimatch.Minimatch;
      var inherits = require_inherits_browser();
      var EE = require_events().EventEmitter;
      var path = require_path_browserify();
      var assert27 = require_assert();
      var isAbsolute = require_path_is_absolute();
      var globSync = require_sync();
      var common = require_common();
      var setopts = common.setopts;
      var ownProp = common.ownProp;
      var inflight = require_inflight();
      var util = require_util2();
      var childrenIgnored = common.childrenIgnored;
      var isIgnored = common.isIgnored;
      var once2 = require_once2();
      function glob2(pattern, options, cb) {
        if (typeof options === "function")
          cb = options, options = {};
        if (!options)
          options = {};
        if (options.sync) {
          if (cb)
            throw new TypeError("callback provided to sync glob");
          return globSync(pattern, options);
        }
        return new Glob(pattern, options, cb);
      }
      glob2.sync = globSync;
      var GlobSync = glob2.GlobSync = globSync.GlobSync;
      glob2.glob = glob2;
      function extend(origin, add) {
        if (add === null || typeof add !== "object") {
          return origin;
        }
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      }
      glob2.hasMagic = function(pattern, options_) {
        var options = extend({}, options_);
        options.noprocess = true;
        var g = new Glob(pattern, options);
        var set = g.minimatch.set;
        if (!pattern)
          return false;
        if (set.length > 1)
          return true;
        for (var j = 0; j < set[0].length; j++) {
          if (typeof set[0][j] !== "string")
            return true;
        }
        return false;
      };
      glob2.Glob = Glob;
      inherits(Glob, EE);
      function Glob(pattern, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        if (options && options.sync) {
          if (cb)
            throw new TypeError("callback provided to sync glob");
          return new GlobSync(pattern, options);
        }
        if (!(this instanceof Glob))
          return new Glob(pattern, options, cb);
        setopts(this, pattern, options);
        this._didRealPath = false;
        var n = this.minimatch.set.length;
        this.matches = new Array(n);
        if (typeof cb === "function") {
          cb = once2(cb);
          this.on("error", cb);
          this.on("end", function(matches) {
            cb(null, matches);
          });
        }
        var self2 = this;
        this._processing = 0;
        this._emitQueue = [];
        this._processQueue = [];
        this.paused = false;
        if (this.noprocess)
          return this;
        if (n === 0)
          return done();
        var sync = true;
        for (var i = 0; i < n; i++) {
          this._process(this.minimatch.set[i], i, false, done);
        }
        sync = false;
        function done() {
          --self2._processing;
          if (self2._processing <= 0) {
            if (sync) {
              import_process.default.nextTick(function() {
                self2._finish();
              });
            } else {
              self2._finish();
            }
          }
        }
      }
      Glob.prototype._finish = function() {
        assert27(this instanceof Glob);
        if (this.aborted)
          return;
        if (this.realpath && !this._didRealpath)
          return this._realpath();
        common.finish(this);
        this.emit("end", this.found);
      };
      Glob.prototype._realpath = function() {
        if (this._didRealpath)
          return;
        this._didRealpath = true;
        var n = this.matches.length;
        if (n === 0)
          return this._finish();
        var self2 = this;
        for (var i = 0; i < this.matches.length; i++)
          this._realpathSet(i, next);
        function next() {
          if (--n === 0)
            self2._finish();
        }
      };
      Glob.prototype._realpathSet = function(index, cb) {
        var matchset = this.matches[index];
        if (!matchset)
          return cb();
        var found = Object.keys(matchset);
        var self2 = this;
        var n = found.length;
        if (n === 0)
          return cb();
        var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
        found.forEach(function(p, i) {
          p = self2._makeAbs(p);
          rp.realpath(p, self2.realpathCache, function(er, real) {
            if (!er)
              set[real] = true;
            else if (er.syscall === "stat")
              set[p] = true;
            else
              self2.emit("error", er);
            if (--n === 0) {
              self2.matches[index] = set;
              cb();
            }
          });
        });
      };
      Glob.prototype._mark = function(p) {
        return common.mark(this, p);
      };
      Glob.prototype._makeAbs = function(f) {
        return common.makeAbs(this, f);
      };
      Glob.prototype.abort = function() {
        this.aborted = true;
        this.emit("abort");
      };
      Glob.prototype.pause = function() {
        if (!this.paused) {
          this.paused = true;
          this.emit("pause");
        }
      };
      Glob.prototype.resume = function() {
        if (this.paused) {
          this.emit("resume");
          this.paused = false;
          if (this._emitQueue.length) {
            var eq = this._emitQueue.slice(0);
            this._emitQueue.length = 0;
            for (var i = 0; i < eq.length; i++) {
              var e = eq[i];
              this._emitMatch(e[0], e[1]);
            }
          }
          if (this._processQueue.length) {
            var pq = this._processQueue.slice(0);
            this._processQueue.length = 0;
            for (var i = 0; i < pq.length; i++) {
              var p = pq[i];
              this._processing--;
              this._process(p[0], p[1], p[2], p[3]);
            }
          }
        }
      };
      Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
        assert27(this instanceof Glob);
        assert27(typeof cb === "function");
        if (this.aborted)
          return;
        this._processing++;
        if (this.paused) {
          this._processQueue.push([pattern, index, inGlobStar, cb]);
          return;
        }
        var n = 0;
        while (typeof pattern[n] === "string") {
          n++;
        }
        var prefix;
        switch (n) {
          case pattern.length:
            this._processSimple(pattern.join("/"), index, cb);
            return;
          case 0:
            prefix = null;
            break;
          default:
            prefix = pattern.slice(0, n).join("/");
            break;
        }
        var remain = pattern.slice(n);
        var read;
        if (prefix === null)
          read = ".";
        else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
          return typeof p === "string" ? p : "[*]";
        }).join("/"))) {
          if (!prefix || !isAbsolute(prefix))
            prefix = "/" + prefix;
          read = prefix;
        } else
          read = prefix;
        var abs = this._makeAbs(read);
        if (childrenIgnored(this, read))
          return cb();
        var isGlobStar = remain[0] === minimatch.GLOBSTAR;
        if (isGlobStar)
          this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
        else
          this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
      };
      Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
        var self2 = this;
        this._readdir(abs, inGlobStar, function(er, entries) {
          return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
        });
      };
      Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
        if (!entries)
          return cb();
        var pn = remain[0];
        var negate = !!this.minimatch.negate;
        var rawGlob = pn._glob;
        var dotOk = this.dot || rawGlob.charAt(0) === ".";
        var matchedEntries = [];
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (e.charAt(0) !== "." || dotOk) {
            var m;
            if (negate && !prefix) {
              m = !e.match(pn);
            } else {
              m = e.match(pn);
            }
            if (m)
              matchedEntries.push(e);
          }
        }
        var len = matchedEntries.length;
        if (len === 0)
          return cb();
        if (remain.length === 1 && !this.mark && !this.stat) {
          if (!this.matches[index])
            this.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < len; i++) {
            var e = matchedEntries[i];
            if (prefix) {
              if (prefix !== "/")
                e = prefix + "/" + e;
              else
                e = prefix + e;
            }
            if (e.charAt(0) === "/" && !this.nomount) {
              e = path.join(this.root, e);
            }
            this._emitMatch(index, e);
          }
          return cb();
        }
        remain.shift();
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          var newPattern;
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          this._process([e].concat(remain), index, inGlobStar, cb);
        }
        cb();
      };
      Glob.prototype._emitMatch = function(index, e) {
        if (this.aborted)
          return;
        if (isIgnored(this, e))
          return;
        if (this.paused) {
          this._emitQueue.push([index, e]);
          return;
        }
        var abs = isAbsolute(e) ? e : this._makeAbs(e);
        if (this.mark)
          e = this._mark(e);
        if (this.absolute)
          e = abs;
        if (this.matches[index][e])
          return;
        if (this.nodir) {
          var c = this.cache[abs];
          if (c === "DIR" || Array.isArray(c))
            return;
        }
        this.matches[index][e] = true;
        var st = this.statCache[abs];
        if (st)
          this.emit("stat", e, st);
        this.emit("match", e);
      };
      Glob.prototype._readdirInGlobStar = function(abs, cb) {
        if (this.aborted)
          return;
        if (this.follow)
          return this._readdir(abs, false, cb);
        var lstatkey = "lstat\0" + abs;
        var self2 = this;
        var lstatcb = inflight(lstatkey, lstatcb_);
        if (lstatcb)
          self2.fs.lstat(abs, lstatcb);
        function lstatcb_(er, lstat) {
          if (er && er.code === "ENOENT")
            return cb();
          var isSym = lstat && lstat.isSymbolicLink();
          self2.symlinks[abs] = isSym;
          if (!isSym && lstat && !lstat.isDirectory()) {
            self2.cache[abs] = "FILE";
            cb();
          } else
            self2._readdir(abs, false, cb);
        }
      };
      Glob.prototype._readdir = function(abs, inGlobStar, cb) {
        if (this.aborted)
          return;
        cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
        if (!cb)
          return;
        if (inGlobStar && !ownProp(this.symlinks, abs))
          return this._readdirInGlobStar(abs, cb);
        if (ownProp(this.cache, abs)) {
          var c = this.cache[abs];
          if (!c || c === "FILE")
            return cb();
          if (Array.isArray(c))
            return cb(null, c);
        }
        var self2 = this;
        self2.fs.readdir(abs, readdirCb(this, abs, cb));
      };
      function readdirCb(self2, abs, cb) {
        return function(er, entries) {
          if (er)
            self2._readdirError(abs, er, cb);
          else
            self2._readdirEntries(abs, entries, cb);
        };
      }
      Glob.prototype._readdirEntries = function(abs, entries, cb) {
        if (this.aborted)
          return;
        if (!this.mark && !this.stat) {
          for (var i = 0; i < entries.length; i++) {
            var e = entries[i];
            if (abs === "/")
              e = abs + e;
            else
              e = abs + "/" + e;
            this.cache[e] = true;
          }
        }
        this.cache[abs] = entries;
        return cb(null, entries);
      };
      Glob.prototype._readdirError = function(f, er, cb) {
        if (this.aborted)
          return;
        switch (er.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var abs = this._makeAbs(f);
            this.cache[abs] = "FILE";
            if (abs === this.cwdAbs) {
              var error = new Error(er.code + " invalid cwd " + this.cwd);
              error.path = this.cwd;
              error.code = er.code;
              this.emit("error", error);
              this.abort();
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(f)] = false;
            break;
          default:
            this.cache[this._makeAbs(f)] = false;
            if (this.strict) {
              this.emit("error", er);
              this.abort();
            }
            if (!this.silent)
              console.error("glob error", er);
            break;
        }
        return cb();
      };
      Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
        var self2 = this;
        this._readdir(abs, inGlobStar, function(er, entries) {
          self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
        });
      };
      Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
        if (!entries)
          return cb();
        var remainWithoutGlobStar = remain.slice(1);
        var gspref = prefix ? [prefix] : [];
        var noGlobStar = gspref.concat(remainWithoutGlobStar);
        this._process(noGlobStar, index, false, cb);
        var isSym = this.symlinks[abs];
        var len = entries.length;
        if (isSym && inGlobStar)
          return cb();
        for (var i = 0; i < len; i++) {
          var e = entries[i];
          if (e.charAt(0) === "." && !this.dot)
            continue;
          var instead = gspref.concat(entries[i], remainWithoutGlobStar);
          this._process(instead, index, true, cb);
          var below = gspref.concat(entries[i], remain);
          this._process(below, index, true, cb);
        }
        cb();
      };
      Glob.prototype._processSimple = function(prefix, index, cb) {
        var self2 = this;
        this._stat(prefix, function(er, exists) {
          self2._processSimple2(prefix, index, er, exists, cb);
        });
      };
      Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        if (!exists)
          return cb();
        if (prefix && isAbsolute(prefix) && !this.nomount) {
          var trail = /[\/\\]$/.test(prefix);
          if (prefix.charAt(0) === "/") {
            prefix = path.join(this.root, prefix);
          } else {
            prefix = path.resolve(this.root, prefix);
            if (trail)
              prefix += "/";
          }
        }
        if (import_process.default.platform === "win32")
          prefix = prefix.replace(/\\/g, "/");
        this._emitMatch(index, prefix);
        cb();
      };
      Glob.prototype._stat = function(f, cb) {
        var abs = this._makeAbs(f);
        var needDir = f.slice(-1) === "/";
        if (f.length > this.maxLength)
          return cb();
        if (!this.stat && ownProp(this.cache, abs)) {
          var c = this.cache[abs];
          if (Array.isArray(c))
            c = "DIR";
          if (!needDir || c === "DIR")
            return cb(null, c);
          if (needDir && c === "FILE")
            return cb();
        }
        var exists;
        var stat = this.statCache[abs];
        if (stat !== void 0) {
          if (stat === false)
            return cb(null, stat);
          else {
            var type = stat.isDirectory() ? "DIR" : "FILE";
            if (needDir && type === "FILE")
              return cb();
            else
              return cb(null, type, stat);
          }
        }
        var self2 = this;
        var statcb = inflight("stat\0" + abs, lstatcb_);
        if (statcb)
          self2.fs.lstat(abs, statcb);
        function lstatcb_(er, lstat) {
          if (lstat && lstat.isSymbolicLink()) {
            return self2.fs.stat(abs, function(er2, stat2) {
              if (er2)
                self2._stat2(f, abs, null, lstat, cb);
              else
                self2._stat2(f, abs, er2, stat2, cb);
            });
          } else {
            self2._stat2(f, abs, er, lstat, cb);
          }
        }
      };
      Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return cb();
        }
        var needDir = f.slice(-1) === "/";
        this.statCache[abs] = stat;
        if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
          return cb(null, false, stat);
        var c = true;
        if (stat)
          c = stat.isDirectory() ? "DIR" : "FILE";
        this.cache[abs] = this.cache[abs] || c;
        if (needDir && c === "FILE")
          return cb();
        return cb(null, c, stat);
      };
    }
  });

  // node_modules/glob-promise/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/glob-promise/lib/index.js"(exports, module) {
      "use strict";
      init_shim();
      var glob2 = require_glob();
      var promise = function(pattern, options) {
        return new Promise((resolve, reject) => {
          glob2(pattern, options, (err, files) => err === null ? resolve(files) : reject(err));
        });
      };
      module.exports = promise;
      module.exports.glob = glob2;
      module.exports.Glob = glob2.Glob;
      module.exports.hasMagic = glob2.hasMagic;
      module.exports.promise = promise;
      module.exports.sync = glob2.sync;
    }
  });

  // node_modules/@octetstream/promisify/util.js
  var require_util4 = __commonJS({
    "node_modules/@octetstream/promisify/util.js"(exports, module) {
      init_shim();
      var keys = Object.keys;
      var toString = (val) => Object.prototype.toString.call(val);
      var getType = (val) => toString(val).slice(8, -1).toLowerCase();
      var isString2 = (val) => typeof val === "string" || getType(val) === "string";
      function isPlainObject(val) {
        if (getType(val) !== "object") {
          return false;
        }
        const pp = Object.getPrototypeOf(val);
        if (pp === null || pp === void 0) {
          return true;
        }
        const Ctor = pp.constructor && pp.constructor.toString();
        return Ctor === Object.toString();
      }
      function isArrayOf(arr, predicate, ctx = null) {
        for (const [key, val] of arr.entries()) {
          if (predicate.call(ctx, val, key, arr) === false) {
            return false;
          }
        }
        return true;
      }
      function map(obj, fn) {
        const res = {};
        for (const key of keys(obj)) {
          const val = obj[key];
          res[key] = fn(val, key, obj);
        }
        return res;
      }
      module.exports = { isArrayOf, getType, isString: isString2, isPlainObject, map };
    }
  });

  // node_modules/@octetstream/promisify/promisify.js
  var require_promisify = __commonJS({
    "node_modules/@octetstream/promisify/promisify.js"(exports, module) {
      init_shim();
      var { isString: isString2, getType, isPlainObject, isArrayOf, map } = require_util4();
      var isArray = Array.isArray;
      var filter = (name) => !/.+(Sync|Stream|Promise)$/.test(name);
      function promisify(target, ctx = null) {
        if (typeof target !== "function") {
          throw TypeError(`Expected target function. Received ${getType(target)}`);
        }
        return function(...args) {
          ctx || (ctx = this);
          return new Promise((resolve, reject) => {
            const fulfill = (err, res) => err ? reject(err) : resolve(res);
            target.call(ctx, ...args, fulfill);
          });
        };
      }
      function all(targets, ctx) {
        if (!isPlainObject(targets)) {
          throw new TypeError(`Expected a plain object as targets. Received ${getType(targets)}`);
        }
        return map(targets, (fn, name) => filter(name) ? promisify(fn, ctx) : fn);
      }
      function some(targets, list, ctx) {
        if (!isPlainObject(targets)) {
          throw new TypeError(`Expected a plain object as targets. Received ${getType(targets)}`);
        }
        if (!isArray(list)) {
          throw new TypeError(`Expected list as an array. Received ${getType(list)}`);
        }
        if (!isArrayOf(list, isString2)) {
          throw new TypeError("Each element in the list should be a string.");
        }
        return map(targets, (fn, name) => filter(name) && list.includes(name) ? promisify(fn, ctx) : fn);
      }
      function except(targets, list, ctx) {
        if (!isPlainObject(targets)) {
          throw new TypeError(`Expected a plain object as targets. Received ${getType(targets)}`);
        }
        if (!isArray(list)) {
          throw new TypeError(`Expected list as an array. Received ${getType(list)}`);
        }
        if (!isArrayOf(list, isString2)) {
          throw new TypeError("Each element in the list should be a string.");
        }
        return map(targets, (fn, name) => filter(name) && !list.includes(name) ? promisify(fn, ctx) : fn);
      }
      module.exports = promisify;
      module.exports.default = promisify;
      module.exports.all = all;
      module.exports.some = some;
      module.exports.except = except;
    }
  });

  // node_modules/promise-fs/main.js
  var require_main = __commonJS({
    "node_modules/promise-fs/main.js"(exports, module) {
      init_shim();
      var fs14 = require_fs();
      var promisify = require_promisify();
      var isFunction = (value) => typeof value === "function";
      var names = [
        "access",
        "readFile",
        "writeFile",
        "copyFile",
        "close",
        "open",
        "read",
        "write",
        "rename",
        "rmdir",
        "mkdir",
        "readdir",
        "stat",
        "lstat",
        "fstat",
        "appendFile",
        "realpath",
        "link",
        "unlink",
        "readlink",
        "chmod",
        "fchmod",
        "chown",
        "fchown",
        "lchown",
        "fsync",
        "utimes",
        "futimes",
        "ftruncate"
      ];
      var pfs = promisify.some(fs14, names.filter((name) => isFunction(fs14[name])));
      module.exports = pfs;
      module.exports.default = pfs;
    }
  });

  // node_modules/shell-quote/index.js
  var require_shell_quote = __commonJS({
    "node_modules/shell-quote/index.js"(exports) {
      init_shim();
      exports.quote = function(xs) {
        return xs.map(function(s) {
          if (s && typeof s === "object") {
            return s.op.replace(/(.)/g, "\\$1");
          } else if (/["\s]/.test(s) && !/'/.test(s)) {
            return "'" + s.replace(/(['\\])/g, "\\$1") + "'";
          } else if (/["'\s]/.test(s)) {
            return '"' + s.replace(/(["\\$`!])/g, "\\$1") + '"';
          } else {
            return String(s).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@\[\\\]^`{|}])/g, "$1\\$2");
          }
        }).join(" ");
      };
      var CONTROL = "(?:" + [
        "\\|\\|",
        "\\&\\&",
        ";;",
        "\\|\\&",
        "\\<\\(",
        ">>",
        ">\\&",
        "[&;()|<>]"
      ].join("|") + ")";
      var META = "|&;()<> \\t";
      var BAREWORD = `(\\\\['"` + META + `]|[^\\s'"` + META + "])+";
      var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
      var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
      var TOKEN = "";
      for (i = 0; i < 4; i++) {
        TOKEN += (Math.pow(16, 8) * Math.random()).toString(16);
      }
      var i;
      exports.parse = function(s, env, opts) {
        var mapped = parse(s, env, opts);
        if (typeof env !== "function")
          return mapped;
        return mapped.reduce(function(acc, s2) {
          if (typeof s2 === "object")
            return acc.concat(s2);
          var xs = s2.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
          if (xs.length === 1)
            return acc.concat(xs[0]);
          return acc.concat(xs.filter(Boolean).map(function(x) {
            if (RegExp("^" + TOKEN).test(x)) {
              return JSON.parse(x.split(TOKEN)[1]);
            } else
              return x;
          }));
        }, []);
      };
      function parse(s, env, opts) {
        var chunker = new RegExp([
          "(" + CONTROL + ")",
          "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")*"
        ].join("|"), "g");
        var match = s.match(chunker).filter(Boolean);
        var commented = false;
        if (!match)
          return [];
        if (!env)
          env = {};
        if (!opts)
          opts = {};
        return match.map(function(s2, j) {
          if (commented) {
            return;
          }
          if (RegExp("^" + CONTROL + "$").test(s2)) {
            return { op: s2 };
          }
          var SQ = "'";
          var DQ = '"';
          var DS = "$";
          var BS = opts.escape || "\\";
          var quote = false;
          var esc = false;
          var out = "";
          var isGlob = false;
          for (var i2 = 0, len = s2.length; i2 < len; i2++) {
            var c = s2.charAt(i2);
            isGlob = isGlob || !quote && (c === "*" || c === "?");
            if (esc) {
              out += c;
              esc = false;
            } else if (quote) {
              if (c === quote) {
                quote = false;
              } else if (quote == SQ) {
                out += c;
              } else {
                if (c === BS) {
                  i2 += 1;
                  c = s2.charAt(i2);
                  if (c === DQ || c === BS || c === DS) {
                    out += c;
                  } else {
                    out += BS + c;
                  }
                } else if (c === DS) {
                  out += parseEnvVar();
                } else {
                  out += c;
                }
              }
            } else if (c === DQ || c === SQ) {
              quote = c;
            } else if (RegExp("^" + CONTROL + "$").test(c)) {
              return { op: s2 };
            } else if (RegExp("^#$").test(c)) {
              commented = true;
              if (out.length) {
                return [out, { comment: s2.slice(i2 + 1) + match.slice(j + 1).join(" ") }];
              }
              return [{ comment: s2.slice(i2 + 1) + match.slice(j + 1).join(" ") }];
            } else if (c === BS) {
              esc = true;
            } else if (c === DS) {
              out += parseEnvVar();
            } else
              out += c;
          }
          if (isGlob)
            return { op: "glob", pattern: out };
          return out;
          function parseEnvVar() {
            i2 += 1;
            var varend, varname;
            if (s2.charAt(i2) === "{") {
              i2 += 1;
              if (s2.charAt(i2) === "}") {
                throw new Error("Bad substitution: " + s2.substr(i2 - 2, 3));
              }
              varend = s2.indexOf("}", i2);
              if (varend < 0) {
                throw new Error("Bad substitution: " + s2.substr(i2));
              }
              varname = s2.substr(i2, varend - i2);
              i2 = varend;
            } else if (/[*@#?$!_\-]/.test(s2.charAt(i2))) {
              varname = s2.charAt(i2);
              i2 += 1;
            } else {
              varend = s2.substr(i2).match(/[^\w\d_]/);
              if (!varend) {
                varname = s2.substr(i2);
                i2 = s2.length;
              } else {
                varname = s2.substr(i2, varend.index);
                i2 += varend.index - 1;
              }
            }
            return getVar(null, "", varname);
          }
        }).reduce(function(prev, arg) {
          if (arg === void 0) {
            return prev;
          }
          return prev.concat(arg);
        }, []);
        function getVar(_, pre, key) {
          var r = typeof env === "function" ? env(key) : env[key];
          if (r === void 0 && key != "")
            r = "";
          else if (r === void 0)
            r = "$";
          if (typeof r === "object") {
            return pre + TOKEN + JSON.stringify(r) + TOKEN;
          } else
            return pre + r;
        }
      }
    }
  });

  // src/browser.ts
  init_shim();

  // src/sboltools.ts
  init_shim();
  var import_sboljs23 = __toESM(require_dist5());

  // src/output/print.ts
  init_shim();

  // src/output/tostring.ts
  init_shim();

  // src/output/OutputNodeTree.ts
  init_shim();

  // src/output/OutputNode.ts
  init_shim();
  var OutputNode = class {
    constructor(children) {
      this.children = children || [];
    }
  };

  // src/output/OutputNodeTree.ts
  var OutputNodeTree = class extends OutputNode {
    constructor(text5, attribs, children) {
      super(children);
      this.text = text5;
      this.attribs = attribs;
      this.children = children;
    }
  };

  // src/output/OutputNodeText.ts
  init_shim();
  var OutputNodeText = class extends OutputNode {
    constructor(text5, style) {
      super();
      this.text = text5;
      this.style = style || "";
    }
  };

  // src/output/OutputNodeSpacer.ts
  init_shim();
  var OutputNodeSpacer = class extends OutputNode {
    constructor() {
      super();
    }
  };

  // src/output/OutputNodeHeader.ts
  init_shim();
  var OutputNodeHeader = class extends OutputNode {
    constructor(title, style) {
      super();
      this.title = title;
      this.style = style || "white bold underline";
    }
  };

  // src/applyStyles.ts
  init_shim();
  var chalk = require_source();
  function applyStyles(str, style) {
    if (style === "")
      return str;
    let fns = style.split(" ");
    let fn = chalk[fns[0]];
    if (!fn) {
      throw new Error("unknown style: " + fns[0]);
    }
    for (let s of fns.slice(1)) {
      if (s === "caps") {
        str = str.toUpperCase();
        continue;
      }
      fn = fn[s];
      if (!fn) {
        throw new Error("unknown style: " + s);
      }
    }
    return fn(str);
  }

  // src/output/OutputNodeGroup.ts
  init_shim();
  var OutputNodeGroup = class extends OutputNode {
    constructor(children) {
      super(children);
    }
  };

  // src/output/OutputNodeIndent.ts
  init_shim();
  var OutputNodeIndent = class extends OutputNode {
    constructor(children) {
      super(children);
    }
  };

  // src/output/OutputNodeTabulated.ts
  init_shim();
  var OutputNodeTabulated = class extends OutputNode {
    constructor(rows) {
      super();
      this.rows = rows;
    }
  };

  // src/output/OutputNodeJSONTree.ts
  init_shim();
  var OutputNodeJSONTree = class extends OutputNode {
    constructor(obj) {
      super();
      this.obj = obj;
    }
  };

  // src/output/OutputNodeMultiline.ts
  init_shim();
  var OutputNodeMultiline = class extends OutputNode {
    constructor(text5, style) {
      super();
      this.text = text5;
      this.style = style || "";
    }
  };

  // src/output/tostring.ts
  var colorizeJSON = require_lib3();
  var INDENT_SIZE = 4;
  function tostring(indent22, node19) {
    let lastWasSpace = false;
    let out = [];
    printNode(node19, indent22);
    out.push("");
    return out.join("\n");
    function printNode(node20, depth) {
      if (node20 instanceof OutputNodeGroup) {
        printGroupNode(node20, depth);
        return;
      } else if (node20 instanceof OutputNodeTree) {
        printTreeNode(node20, depth, depth);
        return;
      } else if (node20 instanceof OutputNodeText) {
        printTextNode(node20, depth);
        return;
      } else if (node20 instanceof OutputNodeMultiline) {
        printMultilineNode(node20, depth);
        return;
      } else if (node20 instanceof OutputNodeSpacer) {
        printSpacerNode(node20, depth);
        return;
      } else if (node20 instanceof OutputNodeHeader) {
        printHeaderNode(node20, depth);
        return;
      } else if (node20 instanceof OutputNodeIndent) {
        printIndentNode(node20, depth);
        return;
      } else if (node20 instanceof OutputNodeTabulated) {
        printTabulatedNode(node20, depth);
        return;
      } else if (node20 instanceof OutputNodeJSONTree) {
        printJSONTreeNode(node20, depth);
        return;
      } else {
        throw new Error("unknown node type >>" + JSON.stringify(node20) + "<<");
      }
    }
    function printGroupNode(node20, depth) {
      for (let child of node20.children) {
        printNode(child, depth);
      }
    }
    function printTextNode(node20, depth) {
      lastWasSpace = false;
      let indentstr = " ".repeat(depth * INDENT_SIZE);
      out.push(indentstr + applyStyles(node20.text, node20.style));
      for (let child of node20.children) {
        printNode(child, depth + 1);
      }
    }
    function printMultilineNode(node20, depth) {
      lastWasSpace = false;
      let indentstr = " ".repeat(depth * INDENT_SIZE);
      for (let line of node20.text.split("\n")) {
        out.push(indentstr + applyStyles(line, node20.style));
      }
    }
    function printTreeNode(node20, rootDepth, depth) {
      lastWasSpace = false;
      let indentstr = " ".repeat(depth * INDENT_SIZE);
      let branch = depth > rootDepth ? "\u2517 " : "";
      out.push(indentstr + branch + node20.text);
      for (let child of node20.children) {
        if (!(child instanceof OutputNodeTree)) {
          throw new Error("tree child not tree node");
        }
        printTreeNode(child, rootDepth, depth + 1);
      }
    }
    function printSpacerNode(node20, depth) {
      if (lastWasSpace)
        return;
      lastWasSpace = true;
      let indentstr = " ".repeat(depth * INDENT_SIZE);
      out.push(indentstr);
    }
    function printHeaderNode(node20, depth) {
      lastWasSpace = false;
      let indentstr = " ".repeat(depth * INDENT_SIZE);
      out.push(indentstr + applyStyles(node20.title, node20.style));
      for (let child of node20.children) {
        printNode(child, depth + 1);
      }
    }
    function printIndentNode(node20, depth) {
      for (let child of node20.children) {
        printNode(child, depth + 1);
      }
    }
    function printTabulatedNode(node20, depth) {
      let indentstr = " ".repeat(depth * INDENT_SIZE);
      let cols = 0;
      for (let row of node20.rows) {
        cols = Math.max(cols, row.length);
      }
      let widths = [];
      for (let i = 0; i < cols; ++i) {
        widths.push(0);
      }
      for (let row of node20.rows) {
        for (let i = 0; i < cols; ++i) {
          widths[i] = Math.max(widths[i], row[i].length);
        }
      }
      for (let i = 0; i < cols; ++i) {
        widths[i] = widths[i] + 7;
      }
      for (let row of node20.rows) {
        let outRow = "";
        for (let c = 0; c < row.length; ++c) {
          let outCol = row[c];
          while (outCol.length < widths[c]) {
            outCol += " ";
          }
          outRow += outCol;
        }
        out.push(indentstr + outRow);
      }
    }
    function printJSONTreeNode(node20, depth) {
      let indentstr = " ".repeat(depth * INDENT_SIZE);
      let replace = (k, v) => v === void 0 ? null : v;
      let json = colorizeJSON(JSON.stringify(node20.obj, replace, 2));
      for (let line of json.split("\n")) {
        out.push(indentstr + line);
      }
    }
  }

  // src/output/print.ts
  var chalk2 = require_source();
  var traceOn = false;
  var captureOutput = false;
  var captured = [];
  function print(node19, prefix) {
    if (captureOutput) {
      captured.push({ type: "print", node: node19 });
      return;
    }
    if (prefix) {
      let out = tostring(0, node19);
      out = out.trim().split("\n").map((line) => prefix + line).join("\n");
      out = out + "\n";
      printStderr(out + "\n");
    } else {
      printStderr(tostring(0, node19));
    }
  }
  function trace(node19) {
    if (!traceOn)
      return;
    if (captureOutput) {
      captured.push({ type: "trace", node: node19 });
      return;
    }
    let out = tostring(0, node19);
    out = out.trim().split("\n").map((line) => "[trace] " + line).join("\n");
    out = chalk2.dim(out) + "\n";
    printStderr(chalk2.dim(out));
  }
  function enableTrace() {
    traceOn = true;
  }
  function beginCaptureOutput() {
    captureOutput = true;
    captured = [];
  }
  function endCaptureOutput() {
    captureOutput = false;
    return captured;
  }
  function printStderr(out) {
    if (typeof window !== "undefined") {
      if (window["sboltools"]) {
        window["sboltools"].print(out);
      }
    } else {
      import_process.default.stderr.write(out);
    }
  }

  // src/actions/index.ts
  init_shim();

  // src/actions/import.ts
  init_shim();

  // src/output/output.ts
  init_shim();
  function header(title, style) {
    return new OutputNodeHeader(title, style);
  }
  function spacer() {
    return new OutputNodeSpacer();
  }
  function text(text5, style) {
    return new OutputNodeText(text5, style);
  }
  function multiline(text5, style) {
    return new OutputNodeMultiline(text5, style);
  }
  function group(children) {
    return new OutputNodeGroup(children);
  }
  function indent(children) {
    return new OutputNodeIndent(children);
  }
  function conditional(cond, children) {
    return new OutputNodeGroup(cond ? children : []);
  }
  function tabulated(rows) {
    return new OutputNodeTabulated(rows);
  }
  function jsonTree(obj) {
    return new OutputNodeJSONTree(obj);
  }

  // src/actions/ActionResult.ts
  init_shim();
  var ActionResult = class {
    constructor(output, outcome) {
      this.output = output;
      this.outcome = outcome;
      if (outcome === void 0) {
        this.outcome = 2 /* Continue */;
      }
    }
  };
  function actionResult(output) {
    return new ActionResult(output, 2 /* Continue */);
  }
  function actionResultAbort(output) {
    return new ActionResult(output, 0 /* Abort */);
  }

  // src/actions/import.ts
  var import_assert = __toESM(require_assert());

  // src/actions/opt/OptURL.ts
  init_shim();

  // src/actions/opt/Opt.ts
  init_shim();
  var Opt = class {
    constructor(actDef, optDef, argv) {
      this.actDef = actDef;
      this.optDef = optDef;
      this.argv = argv;
    }
  };

  // src/actions/opt/OptURL.ts
  var import_node_fetch = __toESM(require_browser5());
  var fs2 = __toESM(require_fs());
  var OptURL = class extends Opt {
    constructor(actDef, optDef, argv) {
      super(actDef, optDef, argv);
    }
    getURL() {
      return this.argv.getString(this.optDef.name, "");
    }
    downloadToString() {
      return __async(this, null, function* () {
        let url = this.getURL();
        if (!url) {
          trace(text("downloadToString: no URL, returning empty string"));
          return "";
        }
        trace(text("Downloading " + url + "..."));
        if (url.indexOf("http://") === 0 || url.indexOf("https://") === 0) {
          let res = yield (0, import_node_fetch.default)(url);
          return yield res.text();
        } else if (url.indexOf("file:///") === 0) {
          let res = yield loadFile(url.split("file:///")[1]);
          return res + "";
        } else {
          let res = yield loadFile(url);
          return res + "";
        }
      });
    }
  };
  function loadFile(filename) {
    return new Promise((resolve, reject) => {
      fs2.readFile(filename, (err, file) => {
        if (err)
          reject(err);
        else
          resolve(file);
      });
    });
  }

  // src/actions/opt/OptString.ts
  init_shim();
  var OptString = class extends Opt {
    constructor(actDef, optDef, argv) {
      super(actDef, optDef, argv);
    }
    getString(g) {
      return this.argv.getString(this.optDef.name, "");
    }
  };

  // src/actions/helpers/import-to-graph.ts
  init_shim();
  var import_rdfoo = __toESM(require_dist());
  var import_sboljs = __toESM(require_dist5());
  function importToGraph(g, src, format) {
    return __async(this, null, function* () {
      let ft = (0, import_rdfoo.identifyFiletype)(src, "");
      if (!format) {
        if (ft === import_rdfoo.Filetype.RDFXML || ft === import_rdfoo.Filetype.NTriples) {
          yield g.loadString(src);
          return new ActionResult();
        } else {
          throw new ActionResult(text("Please specify a conversion target --as for GenBank/FASTA files"), 0 /* Abort */);
        }
      }
      let tempg = new import_rdfoo.Graph();
      if (ft === import_rdfoo.Filetype.RDFXML || ft === import_rdfoo.Filetype.NTriples) {
        yield tempg.loadString(src);
      } else {
        yield new import_sboljs.SBOL2GraphView(tempg).loadString(src);
      }
      switch (format) {
        case "sbol1":
          yield import_sboljs.SBOLConverter.convert3to2(tempg);
          yield import_sboljs.SBOLConverter.convert2to1(tempg);
          break;
        case "sbol2":
          yield import_sboljs.SBOLConverter.convert3to2(tempg);
          yield import_sboljs.SBOLConverter.convert1to2(tempg);
          break;
        case "sbol3":
        default:
          yield import_sboljs.SBOLConverter.convert1to2(tempg);
          yield import_sboljs.SBOLConverter.convert2to3(tempg);
          break;
      }
      g.addAll(tempg);
    });
  }

  // src/actions/import.ts
  var createSequenceAction = {
    name: "import",
    description: "Import RDF, FASTA, or GenBank into the current graph",
    category: "graph",
    positionalOpts: [
      {
        name: "source",
        type: OptURL,
        optional: true
      }
    ],
    namedOpts: [
      {
        name: "as",
        type: OptString
      }
    ],
    run: _import,
    help: `
The source may be either the filename or URL of a serialized RDF resource, such as an SBOL1, 2, or 3 file; or the filename or URL of a FASTA or GenBank file.

The --as parameter specifies the RDF conversion target sbol1/sbol/sbol3.  For example,

    import foo.fasta --as sbol1

would result in a graph containing foo.fasta converted to SBOL1 RDF. Without an --as parameter, the SBOL will be imported as-is.  The --as parameter
for FASTA/GenBank imports defaults to SBOL3.
`
  };
  var import_default = createSequenceAction;
  function _import(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      let [source] = positionalOpts;
      let [_as] = namedOpts;
      (0, import_assert.strict)(source instanceof OptURL);
      (0, import_assert.strict)(!_as || _as instanceof OptString);
      trace(text("Import: positional opts " + JSON.stringify(positionalOpts)));
      let format = _as ? _as.getString(g) : void 0;
      let src = yield source.downloadToString();
      yield importToGraph(g, src, format);
      return new ActionResult();
    });
  }

  // src/actions/convert.ts
  init_shim();
  var import_rdfoo3 = __toESM(require_dist());
  var import_sboljs3 = __toESM(require_dist5());

  // src/actions/opt/OptSBOLVersion.ts
  init_shim();

  // src/util/get-sbol-version-from-graph.ts
  init_shim();
  var import_rdfoo2 = __toESM(require_dist());
  var import_bioterms = __toESM(require_dist6());
  function getSBOLVersionFromGraph(g) {
    let version = "Empty" /* Empty */;
    for (let s of g.subjects) {
      for (let t of g.match(import_rdfoo2.node.createUriNode(s), import_bioterms.Predicates.a, null)) {
        let uri = import_rdfoo2.triple.objectUri(t);
        if (!uri)
          continue;
        if (uri.indexOf(import_bioterms.Prefixes.sbol1) === 0) {
          if (version !== "Empty" /* Empty */) {
            if (version !== "SBOL1" /* SBOL1 */) {
              return "Mixed" /* Mixed */;
            }
          } else {
            version = "SBOL1" /* SBOL1 */;
          }
        } else if (uri.indexOf(import_bioterms.Prefixes.sbol2) === 0) {
          if (version !== "Empty" /* Empty */) {
            if (version !== "SBOL2" /* SBOL2 */) {
              return "Mixed" /* Mixed */;
            }
          } else {
            version = "SBOL2" /* SBOL2 */;
          }
        } else if (uri.indexOf(import_bioterms.Prefixes.sbol3) === 0) {
          if (version !== "Empty" /* Empty */) {
            if (version !== "SBOL3" /* SBOL3 */) {
              return "Mixed" /* Mixed */;
            }
          } else {
            version = "SBOL3" /* SBOL3 */;
          }
        }
      }
    }
    return version;
  }

  // src/actions/opt/helper/get-consensus-sbol-version.ts
  init_shim();
  var import_sboljs2 = __toESM(require_dist5());
  var import_bioterms2 = __toESM(require_dist6());
  function getConsensusSBOLVersion(g) {
    let version = 4 /* Empty */;
    for (let s of g.subjects) {
      for (let t of g.match(import_sboljs2.node.createUriNode(s), import_bioterms2.Predicates.a, null)) {
        let uri = import_sboljs2.triple.objectUri(t);
        if (!uri)
          continue;
        if (uri.indexOf(import_bioterms2.Prefixes.sbol1) === 0) {
          if (version !== 4 /* Empty */) {
            if (version !== 0 /* SBOL1 */) {
              return 3 /* Mixed */;
            }
          } else {
            version = 0 /* SBOL1 */;
          }
        } else if (uri.indexOf(import_bioterms2.Prefixes.sbol2) === 0) {
          if (version !== 4 /* Empty */) {
            if (version !== 1 /* SBOL2 */) {
              return 3 /* Mixed */;
            }
          } else {
            version = 1 /* SBOL2 */;
          }
        } else if (uri.indexOf(import_bioterms2.Prefixes.sbol3) === 0) {
          if (version !== 4 /* Empty */) {
            if (version !== 2 /* SBOL3 */) {
              return 3 /* Mixed */;
            }
          } else {
            version = 2 /* SBOL3 */;
          }
        }
      }
    }
    return version;
  }

  // src/actions/opt/OptSBOLVersion.ts
  var OptSBOLVersion = class extends Opt {
    constructor(actDef, optDef, argv) {
      super(actDef, optDef, argv);
    }
    getSBOLVersion(g) {
      let paramPrefix = this.optDef.name !== "" ? this.optDef.name + "-" : "";
      let sbolversion = this.argv.getString(paramPrefix + "sbol-version", "");
      let infer = this.optDef.refinements.infer !== false;
      if (sbolversion === "1") {
        return "SBOL1" /* SBOL1 */;
      } else if (sbolversion === "2") {
        return "SBOL2" /* SBOL2 */;
      } else if (sbolversion === "3") {
        return "SBOL3" /* SBOL3 */;
      } else {
        if (!infer) {
          throw actionResultAbort(text(`Please specify --${paramPrefix}sbol-version 1/2/3`));
        }
        let consensus = getConsensusSBOLVersion(g);
        if (consensus === 0 /* SBOL1 */)
          return "SBOL1" /* SBOL1 */;
        else if (consensus === 1 /* SBOL2 */)
          return "SBOL2" /* SBOL2 */;
        else if (consensus === 2 /* SBOL3 */)
          return "SBOL3" /* SBOL3 */;
        else {
          throw actionResultAbort(text(`Could not infer input SBOL version from current graph (does it contain mixed SBOL versions?); please specify  --${paramPrefix}sbol-version 1/2/3`));
        }
      }
    }
  };

  // src/actions/convert.ts
  var import_assert2 = __toESM(require_assert());

  // src/actions/opt/OptFlag.ts
  init_shim();
  var OptFlag = class extends Opt {
    constructor(actDef, optDef, argv) {
      super(actDef, optDef, argv);
    }
    isSet() {
      return this.argv.getFlag(this.optDef.name);
    }
  };

  // src/actions/convert.ts
  var import_node_fetch2 = __toESM(require_browser5());
  var convertAction = {
    name: "convert",
    category: "local-conversion",
    namedOpts: [
      {
        name: "target",
        type: OptSBOLVersion,
        refinements: {
          infer: false
        }
      },
      {
        name: "online",
        type: OptFlag,
        optional: true
      }
    ],
    positionalOpts: [],
    run: convert
  };
  var convert_default = convertAction;
  function convert(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      let [target, online] = namedOpts;
      (0, import_assert2.strict)(target instanceof OptSBOLVersion);
      (0, import_assert2.strict)(online instanceof OptFlag);
      let sbolVersion2 = target.getSBOLVersion(g);
      if (online.isSet()) {
        return convertVC(g, sbolVersion2);
      } else {
        return convertOffline(g, sbolVersion2);
      }
    });
  }
  function convertOffline(g, sbolVersion2) {
    return __async(this, null, function* () {
      if (sbolVersion2 === "SBOL1" /* SBOL1 */) {
        trace(text("Offline converting 3->2 and 2->1"));
        yield import_sboljs3.SBOLConverter.convert3to2(g);
        yield import_sboljs3.SBOLConverter.convert2to1(g);
      } else if (sbolVersion2 === "SBOL2" /* SBOL2 */) {
        trace(text("Offline converting 1->2 and 3->2"));
        yield import_sboljs3.SBOLConverter.convert1to2(g);
        yield import_sboljs3.SBOLConverter.convert3to2(g);
      } else if (sbolVersion2 === "SBOL3" /* SBOL3 */) {
        trace(text("Offline converting 1->2 and 2->3"));
        yield import_sboljs3.SBOLConverter.convert1to2(g);
        yield import_sboljs3.SBOLConverter.convert2to3(g);
      } else {
        return new ActionResult(text("convert: target must be one of sbol1, sbol2, sbol3"), 0 /* Abort */);
      }
      return actionResult();
    });
  }
  function convertVC(g, sbolVersion2) {
    return __async(this, null, function* () {
      let sourceVersion = getSBOLVersionFromGraph(g);
      let xml = "";
      if (sourceVersion === "SBOL1" /* SBOL1 */) {
        xml = new import_sboljs3.SBOL1GraphView(g).serializeXML();
      } else if (sourceVersion === "SBOL2" /* SBOL2 */) {
        xml = new import_sboljs3.SBOL2GraphView(g).serializeXML();
      } else if (sourceVersion === "SBOL3" /* SBOL3 */) {
        throw new ActionResult(text("convert: cannot convert from SBOL3 using the online validator/converter"), 0 /* Abort */);
      } else if (sourceVersion === "Mixed" /* Mixed */) {
        throw new ActionResult(text("convert: graph has mixed SBOL versions so cannot use online validator/converter"), 0 /* Abort */);
      } else if (sourceVersion === "Empty" /* Empty */) {
        xml = new import_sboljs3.SBOL2GraphView(g).serializeXML();
      } else {
        throw new ActionResult(text("convert: unknown source SBOLVersion " + sourceVersion));
      }
      let target = "";
      if (sbolVersion2 === "SBOL1" /* SBOL1 */) {
        target = "sbol1";
      } else if (sbolVersion2 === "SBOL2" /* SBOL2 */) {
        target = "sbol2";
      } else if (sbolVersion2 === "SBOL3" /* SBOL3 */) {
        throw new ActionResult(text("convert: cannot convert to SBOL3 using the online validator/converter"), 0 /* Abort */);
      } else {
        throw new ActionResult(text("convert: unknown SBOLVersion " + sbolVersion2));
      }
      trace(text(`convert: target language sent to validator/converter is ${target.toUpperCase()}`));
      let body = {
        options: {
          language: target.toUpperCase(),
          test_equality: false,
          check_uri_compliance: false,
          check_completeness: false,
          check_best_practices: false,
          fail_on_first_error: false,
          provide_detailed_stack_trace: false,
          subset_uri: "",
          uri_prefix: "",
          version: "",
          insert_type: false,
          main_file_name: "main file",
          diff_file_name: "comparison file"
        },
        main_file: xml,
        return_file: true
      };
      let r = yield (0, import_node_fetch2.default)("https://validator.sbolstandard.org/validate/", {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(body)
      });
      try {
        var response = yield r.json();
      } catch (e) {
        return actionResult(text("The online validator/converter failed: " + e));
      }
      let { valid, check_equality, equality, errors, output_file, result } = response;
      let output = [];
      if (!valid) {
        throw actionResult(group([
          spacer(),
          text("The online validator/converter said the SBOL sent by sboltools was invalid"),
          text("This should not happen, and is likely indicative of a bug in sboltools"),
          spacer()
        ]));
      }
      errors = errors.filter((e) => e.trim() != "");
      if (!valid) {
        if (errors.length > 0) {
          output.push(spacer());
          output.push(group(errors.map((e) => text("Online validator error: " + e))));
          output.push(spacer());
        }
      }
      if (result) {
        if (sourceVersion === "SBOL1" /* SBOL1 */) {
          for (let topLevel of new import_sboljs3.SBOL1GraphView(g).topLevels) {
            topLevel.destroy();
          }
        } else if (sourceVersion === "SBOL2" /* SBOL2 */) {
          for (let topLevel of new import_sboljs3.SBOL2GraphView(g).topLevels) {
            topLevel.destroy();
          }
        }
        g.addAll(yield import_rdfoo3.Graph.loadString(result, "http://dummyprefix/", "application/rdf+xml"));
      }
      return actionResult(group(output));
    });
  }

  // src/actions/object-cd/create-sequence.ts
  init_shim();
  var import_rdfoo7 = __toESM(require_dist());
  var import_assert6 = __toESM(require_assert());
  var import_sboljs8 = __toESM(require_dist5());

  // src/actions/opt/OptIdentity.ts
  init_shim();

  // src/identity/Identity.ts
  init_shim();

  // src/identity/IdentityFactorySBOL1.ts
  init_shim();
  var import_rdfoo4 = __toESM(require_dist());

  // src/identity/IdentityFactory.ts
  init_shim();
  var IdentityFactory = class {
  };

  // src/util/join-uri-fragments.ts
  init_shim();
  function joinURIFragments(t) {
    let s = "";
    for (let token of t) {
      if (token === void 0)
        continue;
      if (s.length > 0 && token[0] !== "/" && s[s.length - 1] !== "/")
        s += "/";
      s += token;
    }
    return s;
  }

  // src/identity/IdentityFactorySBOL1.ts
  var import_sboljs4 = __toESM(require_dist5());
  var import_bioterms3 = __toESM(require_dist6());
  var import_assert4 = __toESM(require_assert());

  // src/identity/helpers/errors.ts
  init_shim();
  function identityErrorUnguessableNamespace(namespaces) {
    if (namespaces.length > 0) {
      return actionResultAbort(text(`No namespace was specified, and cannot default to a single existing namespace as there are ${namespaces.length} different namespaces in use in the knowledge graph: ${namespaces.join(", ")}`));
    } else {
      return actionResultAbort(text(`No namespace was specified, and cannot default to a single existing namespace as the knowledge graph appears to be empty`));
    }
  }
  function identityErrorEmptyChain() {
    return actionResultAbort(text(`Empty identity chain`));
  }

  // src/identity/helpers/validation.ts
  init_shim();
  function validateDisplayId(displayId) {
    if (displayId.length === 0) {
      throw actionResultAbort(text(`Empty displayId`));
    }
    if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(displayId)) {
      throw actionResultAbort(text(`displayId '${displayId}': must start with a letter or underscore and be composed of only alphanumeric and underscore characters`));
    }
  }
  function validateNamespace(namespace3, debug) {
    if (namespace3.length === 0) {
      trace(group([
        text("Namespace validation debug output:"),
        spacer(),
        indent([
          jsonTree(debug)
        ])
      ]));
      throw actionResultAbort(group([
        text(`Empty namespace`)
      ]));
    }
    if (namespace3[namespace3.length - 1] !== "/" && namespace3[namespace3.length - 1] !== "#") {
      throw actionResultAbort(text(`Namespace ${namespace3} does not look valid: should end in / or #`));
    }
  }
  function validateNamespaceIsPrefix(ns, uri) {
    if (uri.indexOf(ns) !== 0) {
      throw actionResultAbort(text(`Specified namespace ${ns} is not a prefix of identity URI ${uri}`));
    }
  }

  // src/identity/helpers/Chain.ts
  init_shim();
  var import_assert3 = __toESM(require_assert());
  var Chain = class {
    static isChain(chain) {
      return chain.indexOf("://") === -1;
    }
    static isEmpty(chain) {
      return Chain.tokens(chain).length === 0;
    }
    static context(chain) {
      return Chain.tokens(chain).slice(0, -1).join(".");
    }
    static displayId(chain) {
      return Chain.tokens(chain).pop();
    }
    static tokens(chain) {
      (0, import_assert3.strict)(Chain.isChain(chain));
      return chain.split(".");
    }
  };

  // src/identity/IdentityFactorySBOL1.ts
  var IdentityFactorySBOL1 = class extends IdentityFactory {
    from_namespace_and_identity(existence, g, namespace3, identity, version) {
      if (version) {
        throw sbol1VersionError();
      }
      if (Chain.isChain(identity)) {
        if (Chain.isEmpty(identity)) {
          throw identityErrorEmptyChain();
        }
        if (Chain.tokens(identity).length === 1) {
          return this.toplevel_from_namespace_displayId(existence, g, namespace3, Chain.displayId(identity), void 0);
        } else {
          return this.child_from_namespace_context_displayId(existence, g, namespace3, Chain.context(identity), Chain.displayId(identity), void 0);
        }
      } else {
        validateNamespaceIsPrefix(namespace3, identity);
        let displayId = identity.slice(namespace3.length);
        return new Identity("SBOL1" /* SBOL1 */, namespace3, displayId, void 0, void 0, identity);
      }
    }
    from_identity(existence, g, identity, version) {
      trace(text(`SBOL1 from_identity: identity ${identity}, version ${version}`));
      if (version) {
        throw sbol1VersionError();
      }
      if (Chain.isChain(identity)) {
        let prefixes = extractPrefixesFromGraphSBOL1(g);
        if (prefixes.length !== 1) {
          throw identityErrorUnguessableNamespace(prefixes);
        }
        return this.from_namespace_and_identity(existence, g, prefixes[0], identity, void 0);
      } else {
        let namespace3 = inventUriPrefixSBOL1(identity);
        return this.from_namespace_and_identity(existence, g, namespace3, identity, void 0);
      }
    }
    toplevel_from_displayId(existence, g, displayId, version) {
      trace(text(`SBOL1 toplevel_from_displayId: displayId ${displayId}, version ${version}`));
      if (version) {
        throw sbol1VersionError();
      }
      let prefixes = extractPrefixesFromGraphSBOL1(g);
      if (prefixes.length !== 1) {
        throw identityErrorUnguessableNamespace(prefixes);
      }
      return this.toplevel_from_namespace_displayId(existence, g, prefixes[0], displayId, void 0);
    }
    toplevel_from_namespace_displayId(existence, g, namespace3, displayId, version) {
      trace(text(`SBOL1 toplevel_from_namespace_displayId: namespace ${namespace3}, displayId ${displayId}, version ${version}`));
      if (version) {
        throw sbol1VersionError();
      }
      return new Identity("SBOL1" /* SBOL1 */, namespace3, displayId, void 0, "", joinURIFragments([namespace3, displayId]));
    }
    child_from_namespace_context_displayId(existence, g, namespace3, contextIdentity, displayId, version) {
      trace(text(`SBOL1 child_from_namespace_context_displayId: existence ${existence}, namespace ${namespace3}, contextIdentity ${contextIdentity}, displayId ${displayId}, version ${version}`));
      if (version !== void 0) {
        throw sbol1VersionError();
      }
      let context = this.from_namespace_and_identity("MustExist" /* MustExist */, g, namespace3, contextIdentity, void 0);
      (0, import_assert4.strict)(context.namespace === namespace3);
      let parent = (0, import_sboljs4.sbol1)(g).subjectToFacade(import_rdfoo4.node.createUriNode(context.uri));
      let children = [];
      if (parent instanceof import_sboljs4.S1DnaComponent) {
        children = children.concat(parent.annotations);
        children = children.concat(parent.subComponents);
      }
      let match = children.filter((child) => child.getStringProperty(import_bioterms3.Predicates.SBOL1.displayId) === displayId)[0];
      if (match) {
        if (existence === "MustNotExist" /* MustNotExist */) {
          throw actionResultAbort(text(`Child with displayId ${displayId} already exists in context ${contextIdentity}`));
        }
        return this.from_namespace_and_identity(existence, g, namespace3, match.subject.value, version);
      } else {
        if (existence === "MustExist" /* MustExist */) {
          throw actionResultAbort(text(`No child found with displayId ${displayId} in context ${contextIdentity}`));
        }
        let childUri = joinURIFragments([parent.subject.value, displayId]);
        return new Identity("SBOL1" /* SBOL1 */, context.namespace, displayId, version, context.uri, childUri);
      }
    }
    child_from_context_displayId(existence, g, contextIdentity, displayId, version) {
      if (version !== void 0) {
        throw sbol1VersionError();
      }
      let context = this.from_identity("MustExist" /* MustExist */, g, contextIdentity, void 0);
      let parent = (0, import_sboljs4.sbol1)(g).subjectToFacade(import_rdfoo4.node.createUriNode(context.uri));
      if (!parent) {
        throw actionResultAbort(text(`Context object with identity ${contextIdentity} not found`));
      }
      let children = [];
      if (parent instanceof import_sboljs4.S1DnaComponent) {
        children = children.concat(parent.annotations);
        children = children.concat(parent.subComponents);
      }
      let match = children.filter((child) => child.getStringProperty(import_bioterms3.Predicates.SBOL1.displayId) === displayId)[0];
      return this.from_namespace_and_identity(existence, g, context.namespace, match.subject.value, version);
    }
  };
  function sbol1VersionError() {
    return actionResultAbort(text(`Version is only supported in SBOL2`));
  }
  function extractPrefixesFromGraphSBOL1(g) {
    let v = new import_sboljs4.SBOL1GraphView(g);
    let topLevels = v.topLevels;
    let prefixes = /* @__PURE__ */ new Set();
    for (let t of topLevels) {
      let prefix = inventUriPrefixSBOL1(t.subject.value);
      if (prefix)
        prefixes.add(prefix);
    }
    let arr = Array.from(prefixes);
    arr.sort((a, b) => a.length - b.length);
    return arr;
  }
  function inventUriPrefixSBOL1(uri) {
    let slash = uri.lastIndexOf("/");
    let hash = uri.lastIndexOf("#");
    if (slash !== -1) {
      return uri.slice(0, slash + 1);
    }
    if (hash !== -1) {
      return uri.slice(0, hash + 1);
    }
    return "";
  }

  // src/identity/IdentityFactorySBOL2.ts
  init_shim();
  var import_rdfoo5 = __toESM(require_dist());
  var import_sboljs6 = __toESM(require_dist5());
  var import_bioterms5 = __toESM(require_dist6());
  var import_console = __toESM(require_console_browserify());

  // src/util/sbol2-compliant-concat.ts
  init_shim();
  var import_sboljs5 = __toESM(require_dist5());
  var assert5 = require_assert();
  function sbol2CompliantConcat(g, uri, childDisplayId) {
    assert5(uri);
    let gv = new import_sboljs5.SBOL2GraphView(g);
    let identified = new import_sboljs5.S2Identified(gv, import_sboljs5.node.createUriNode(uri));
    let pId = identified.persistentIdentity;
    let version = identified.version;
    if (pId) {
      return joinURIFragments([pId, childDisplayId, version]);
    }
    return joinURIFragments([uri, childDisplayId]);
  }

  // src/util/is-toplevel-type.ts
  init_shim();
  var import_bioterms4 = __toESM(require_dist6());
  function isTopLevelType(type) {
    return [
      import_bioterms4.Types.SBOL1.DnaComponent,
      import_bioterms4.Types.SBOL1.Collection,
      import_bioterms4.Types.SBOL2.ComponentDefinition,
      import_bioterms4.Types.SBOL2.ModuleDefinition,
      import_bioterms4.Types.SBOL2.Sequence,
      import_bioterms4.Types.SBOL3.Component,
      import_bioterms4.Types.SBOL3.Sequence
    ].indexOf(type) !== -1;
  }

  // src/identity/IdentityFactorySBOL2.ts
  var IdentityFactorySBOL2 = class extends IdentityFactory {
    from_namespace_and_identity(existence, g, namespace3, identity, version) {
      trace(text(`SBOL2 from_namespace_and_identity: existence ${existence}, namespace ${namespace3}, identity ${identity}, version ${version}`));
      if (Chain.isChain(identity)) {
        if (Chain.isEmpty(identity)) {
          throw identityErrorEmptyChain();
        }
        if (Chain.tokens(identity).length === 1) {
          return this.toplevel_from_namespace_displayId(existence, g, namespace3, Chain.displayId(identity), version);
        } else {
          return this.child_from_namespace_context_displayId(existence, g, namespace3, Chain.context(identity), Chain.displayId(identity), version);
        }
      } else {
        validateNamespaceIsPrefix(namespace3, identity);
        var displayId = void 0;
        let existing = (0, import_sboljs6.sbol2)(g).uriToIdentified(import_rdfoo5.node.createUriNode(identity));
        if (existing) {
          if (existence === "MustNotExist" /* MustNotExist */) {
            throw actionResultAbort(text(`An object with identity ${identity} in namespace ${namespace3} already exists`));
          }
          if (version !== void 0 && existing.version !== version) {
            throw actionResultAbort(text(`Supplied version ${version} does not match the version ${existing.version} of existing object ${identity}`));
          }
          if (existing.displayId !== void 0) {
            displayId = existing.displayId;
          }
        } else {
          if (existence === "MustExist" /* MustExist */) {
            throw actionResultAbort(text(`An object with identity ${identity} in namespace ${namespace3} was not found`));
          }
        }
        if (displayId === void 0) {
          let afterNamespace = identity.slice(namespace3.length);
          let tokens = afterNamespace.split(/[\/#]/g);
          if (version !== void 0 && tokens[tokens.length - 1] === version) {
            tokens.pop();
          }
          displayId = tokens[tokens.length - 1];
        }
        if (displayId === void 0) {
          throw actionResultAbort(text(`Could not determine displayId for identity ${identity}`));
        }
        return new Identity("SBOL2" /* SBOL2 */, namespace3, displayId, version, void 0, identity);
      }
    }
    from_identity(existence, g, identity, version) {
      trace(text(`SBOL2 from_identity: existence ${existence}, identity ${identity}, version ${version}`));
      if (Chain.isChain(identity)) {
        let prefixes = extractPrefixesFromGraphSBOL2(g);
        if (prefixes.length !== 1) {
          throw identityErrorUnguessableNamespace(prefixes);
        }
        return this.from_namespace_and_identity(existence, g, prefixes[0], identity, version);
      } else {
        var namespace3 = void 0;
        let existing = (0, import_sboljs6.sbol2)(g).uriToIdentified(import_rdfoo5.node.createUriNode(identity));
        if (existing && (version === void 0 || existing.version === version)) {
          if (existence === "MustNotExist" /* MustNotExist */) {
            throw actionResultAbort(text(`An object with identity ${identity} already exists`));
          }
          namespace3 = existing.uriPrefix;
        } else {
          if (existence === "MustExist" /* MustExist */) {
            throw actionResultAbort(text(`An object with identity ${identity} was not found`));
          }
        }
        if (namespace3 === void 0) {
          let persistentIdentity = identity;
          if (version !== void 0) {
            if (identity.endsWith("/" + version) || identity.endsWith("#" + version)) {
              persistentIdentity = identity.slice(0, identity.length - version.length - 1);
            }
          }
          let slash = persistentIdentity.lastIndexOf("/");
          let hash = persistentIdentity.lastIndexOf("#");
          if (slash === -1 && hash === -1) {
            throw actionResultAbort(text(`Could not invent namespace for identity ${identity}`));
          }
          namespace3 = persistentIdentity.slice(0, Math.min(slash, hash) - 1);
        }
        if (namespace3 === void 0) {
          throw actionResultAbort(text(`Could not determine namespace for identity ${identity}`));
        }
        return this.from_namespace_and_identity(existence, g, namespace3, identity, version);
      }
    }
    toplevel_from_namespace_displayId(existence, g, namespace3, displayId, version) {
      trace(text(`SBOL2 toplevel_from_namespace_displayId: existence ${existence} namespace ${namespace3}, displayId ${displayId}, version ${version}`));
      let matches = g.match(null, import_bioterms5.Predicates.SBOL2.displayId, import_rdfoo5.node.createStringNode(displayId)).map(import_rdfoo5.triple.subjectUri).filter((uri2) => uri2 && uri2.indexOf(namespace3) === 0);
      if (version !== void 0) {
        matches = matches.filter((uri2) => g.hasMatch(import_rdfoo5.node.createUriNode(uri2), import_bioterms5.Predicates.SBOL2.version, import_rdfoo5.node.createStringNode(version)));
      }
      matches = matches.filter((uri2) => {
        let type = import_rdfoo5.triple.objectUri(g.matchOne(import_rdfoo5.node.createUriNode(uri2), import_bioterms5.Predicates.a, null));
        return isTopLevelType(type);
      });
      if (matches.length > 0) {
        if (existence === "MustNotExist" /* MustNotExist */) {
          throw actionResultAbort(text(`An object with displayId ${displayId} in namespace ${namespace3} already exists`));
        }
        if (matches.length > 1) {
          throw actionResultAbort(text(`More than one object with displayId ${displayId} in namespace ${namespace3} found; reference is ambiguous`));
        }
        let uri2 = matches[0];
        (0, import_console.assert)(typeof uri2 === "string");
        return new Identity("SBOL2" /* SBOL2 */, namespace3, displayId, version, void 0, uri2);
      }
      if (existence === "MustExist" /* MustExist */) {
        throw actionResultAbort(text(`No object with displayId ${displayId} with version ${version} in namespace ${namespace3} found`));
      }
      let uri = joinURIFragments(version ? [namespace3, displayId, version] : [namespace3, displayId]);
      return new Identity("SBOL2" /* SBOL2 */, namespace3, displayId, version, void 0, uri);
    }
    toplevel_from_displayId(existence, g, displayId, version) {
      trace(text(`SBOL2 toplevel_from_displayId: displayId ${displayId}`));
      let matches = g.match(null, import_bioterms5.Predicates.SBOL2.displayId, import_rdfoo5.node.createStringNode(displayId)).map(import_rdfoo5.triple.subjectUri);
      if (version !== void 0) {
        matches = matches.filter((uri) => g.hasMatch(import_rdfoo5.node.createUriNode(uri), import_bioterms5.Predicates.SBOL2.version, import_rdfoo5.node.createStringNode(version)));
      }
      if (matches.length > 0) {
        if (existence === "MustNotExist" /* MustNotExist */) {
          throw actionResultAbort(text(`An object with displayId ${displayId} already exists, and no namespace was specified`));
        }
        let uri = matches[0];
        (0, import_console.assert)(typeof uri === "string");
        return this.from_identity("MustExist" /* MustExist */, g, uri, version);
      }
      if (existence === "MustExist" /* MustExist */) {
        throw actionResultAbort(text(`No object with displayId ${displayId} with version ${version} found`));
      }
      let prefixes = extractPrefixesFromGraphSBOL2(g);
      if (prefixes.length !== 1) {
        throw identityErrorUnguessableNamespace(prefixes);
      }
      return this.toplevel_from_namespace_displayId(existence, g, prefixes[0], displayId, version);
    }
    child_from_namespace_context_displayId(existence, g, namespace3, contextIdentity, displayId, version) {
      trace(text(`SBOL2 child_from_namespace_context_displayId: existence ${existence}, namespace ${namespace3}, context ${contextIdentity}, displayId ${displayId}`));
      let context = this.from_namespace_and_identity("MustExist" /* MustExist */, g, namespace3, contextIdentity, void 0);
      (0, import_console.assert)(context.namespace === namespace3);
      let parent = (0, import_sboljs6.sbol2)(g).subjectToFacade(import_rdfoo5.node.createUriNode(context.uri));
      if (!parent) {
        throw actionResultAbort(text(`Context object with identity ${contextIdentity} not found`));
      }
      (0, import_console.assert)(parent instanceof import_sboljs6.S2Identified);
      let children = [];
      if (parent instanceof import_sboljs6.S2ComponentDefinition || parent instanceof import_sboljs6.S2ModuleDefinition || parent instanceof import_sboljs6.S2ComponentInstance || parent instanceof import_sboljs6.S2SequenceAnnotation) {
        children = children.concat(parent.containedObjects);
      }
      let matches = children.filter((child) => displayIdMatches(child, displayId));
      if (version !== void 0) {
        matches = matches.filter((match) => match.version === version);
      }
      if (matches.length === 0) {
        if (existence === "MustExist" /* MustExist */) {
          throw actionResultAbort(text(`No object with displayId ${displayId} and version ${version} found in context ${JSON.stringify(context)}`));
        }
        let childUri = sbol2CompliantConcat(g, parent.subject.value, displayId);
        return new Identity("SBOL2" /* SBOL2 */, context.namespace, displayId, version, parent.subject.value, childUri);
      } else {
        (0, import_console.assert)(matches.length === 1);
        if (existence === "MustNotExist" /* MustNotExist */) {
          throw actionResultAbort(text(`Object with displayId ${displayId} and version ${version} already exists in context ${context}`));
        }
        let match = matches[0];
        return new Identity("SBOL2" /* SBOL2 */, context.namespace, displayId, version, context.uri, match.subject.value);
      }
    }
    child_from_context_displayId(existence, g, contextIdentity, displayId, version) {
      trace(text(`SBOL2 child_from_context_displayId: context ${contextIdentity}, displayId ${displayId}`));
      let context = this.from_identity("MustExist" /* MustExist */, g, contextIdentity, void 0);
      let parent = (0, import_sboljs6.sbol2)(g).subjectToFacade(import_rdfoo5.node.createUriNode(context.uri));
      if (!parent) {
        throw actionResultAbort(text(`Context object with identity ${contextIdentity} not found`));
      }
      (0, import_console.assert)(parent instanceof import_sboljs6.S2Identified);
      let children = [];
      if (parent instanceof import_sboljs6.S2ComponentDefinition || parent instanceof import_sboljs6.S2ModuleDefinition || parent instanceof import_sboljs6.S2ComponentInstance || parent instanceof import_sboljs6.S2SequenceAnnotation) {
        children = children.concat(parent.containedObjects);
      }
      let matches = children.filter((child) => displayIdMatches(child, displayId));
      if (version !== void 0) {
        matches = matches.filter((match) => match.version === version);
      }
      if (matches.length === 0) {
        if (existence === "MustExist" /* MustExist */) {
          throw actionResultAbort(text(`No object with displayId ${displayId} and version ${version} found in context ${JSON.stringify(context)}`));
        }
        let childUri = sbol2CompliantConcat(g, parent.subject.value, displayId);
        return new Identity("SBOL2" /* SBOL2 */, context.namespace, displayId, version, parent.subject.value, childUri);
      } else {
        (0, import_console.assert)(matches.length === 1);
        if (existence === "MustNotExist" /* MustNotExist */) {
          throw actionResultAbort(text(`Object with displayId ${displayId} and version ${version} already exists in context ${context}`));
        }
        let match = matches[0];
        return new Identity("SBOL2" /* SBOL2 */, context.namespace, displayId, version, context.uri, match.subject.value);
      }
    }
  };
  function extractPrefixesFromGraphSBOL2(g) {
    let v = new import_sboljs6.SBOL2GraphView(g);
    let prefixes = /* @__PURE__ */ new Set();
    for (let t of v.topLevels) {
      let prefix = t.uriPrefix;
      if (prefix)
        prefixes.add(prefix);
    }
    let arr = Array.from(prefixes);
    arr.sort((a, b) => a.length - b.length);
    return arr;
  }
  function displayIdMatches(obj, displayId) {
    if (obj.displayId === displayId)
      return true;
    let instanceOf = obj.getUriProperty(import_bioterms5.Predicates.SBOL2.definition);
    if (instanceOf) {
      let parentObj = obj.view.subjectToFacade(import_rdfoo5.node.createUriNode(instanceOf));
      if (parentObj && parentObj.getStringProperty(import_bioterms5.Predicates.SBOL2.displayId) === displayId) {
        return true;
      }
    }
    return false;
  }

  // src/identity/IdentityFactorySBOL3.ts
  init_shim();
  var import_rdfoo6 = __toESM(require_dist());
  var import_sboljs7 = __toESM(require_dist5());
  var import_bioterms6 = __toESM(require_dist6());
  var import_assert5 = __toESM(require_assert());

  // src/util/get-last-uri-fragment.ts
  init_shim();
  function getLastURIFragment(uri) {
    let slash = uri.lastIndexOf("/");
    let hash = uri.lastIndexOf("#");
    let eq = uri.lastIndexOf("=");
    if (slash !== -1) {
      return uri.slice(slash + 1);
    }
    if (hash !== -1) {
      return uri.slice(hash + 1);
    }
    if (eq !== -1) {
      return uri.slice(eq + 1);
    }
    throw new Error("could not extract last uri fragment");
  }

  // src/identity/IdentityFactorySBOL3.ts
  var IdentityFactorySBOL3 = class extends IdentityFactory {
    from_namespace_and_identity(existence, g, namespace3, identity, version) {
      if (version) {
        throw sbol3VersionError();
      }
      if (Chain.isChain(identity)) {
        if (Chain.isEmpty(identity)) {
          throw identityErrorEmptyChain();
        }
        if (Chain.tokens(identity).length === 1) {
          return this.toplevel_from_namespace_displayId(existence, g, namespace3, Chain.displayId(identity), void 0);
        } else {
          return this.child_from_namespace_context_displayId(existence, g, namespace3, Chain.context(identity), Chain.displayId(identity), void 0);
        }
      } else {
        validateNamespaceIsPrefix(namespace3, identity);
        let displayId = getLastURIFragment(identity);
        return new Identity("SBOL3" /* SBOL3 */, namespace3, displayId, void 0, void 0, identity);
      }
    }
    from_identity(existence, g, identity, version) {
      if (version) {
        throw sbol3VersionError();
      }
      trace(text(`SBOL3 from_identity: identity ${identity}`));
      if (Chain.isChain(identity)) {
        let prefixes = extractPrefixesFromGraphSBOL3(g);
        if (prefixes.length !== 1) {
          throw identityErrorUnguessableNamespace(prefixes);
        }
        return this.from_namespace_and_identity(existence, g, prefixes[0], identity, void 0);
      } else {
        let namespace3 = inventUriPrefixSBOL3(identity);
        return this.from_namespace_and_identity(existence, g, namespace3, identity, void 0);
      }
    }
    toplevel_from_displayId(existence, g, displayId, version) {
      if (version) {
        throw sbol3VersionError();
      }
      trace(text(`SBOL3 toplevel_from_displayId: displayId ${displayId}`));
      let prefixes = extractPrefixesFromGraphSBOL3(g);
      if (prefixes.length !== 1) {
        throw identityErrorUnguessableNamespace(prefixes);
      }
      return this.toplevel_from_namespace_displayId(existence, g, prefixes[0], displayId, void 0);
    }
    toplevel_from_namespace_displayId(existence, g, namespace3, displayId, version) {
      if (version) {
        throw sbol3VersionError();
      }
      trace(text(`SBOL3 toplevel_from_namespace_displayId: namespace ${namespace3}, displayId ${displayId}`));
      return new Identity("SBOL3" /* SBOL3 */, namespace3, displayId, void 0, "", joinURIFragments([namespace3, displayId]));
    }
    child_from_namespace_context_displayId(existence, g, namespace3, contextIdentity, displayId, version) {
      if (version !== void 0) {
        throw sbol3VersionError();
      }
      let context = this.from_namespace_and_identity("MustExist" /* MustExist */, g, namespace3, contextIdentity, void 0);
      (0, import_assert5.strict)(context.namespace === namespace3);
      let parent = (0, import_sboljs7.sbol3)(g).subjectToFacade(import_rdfoo6.node.createUriNode(context.uri));
      (0, import_assert5.strict)(parent instanceof import_sboljs7.S3Identified);
      let children = parent.ownedObjects;
      let matches = children.filter((child) => displayIdMatches2(child, displayId));
      if (matches.length === 0) {
        if (existence === "MustExist" /* MustExist */) {
          throw actionResultAbort(text(`No object with displayId ${displayId} in context ${JSON.stringify(context)}`));
        }
        let childUri = joinURIFragments([parent.subject.value, displayId]);
        return new Identity("SBOL3" /* SBOL3 */, context.namespace, displayId, version, parent.subject.value, childUri);
      } else {
        (0, import_assert5.strict)(matches.length === 1);
        if (existence === "MustNotExist" /* MustNotExist */) {
          throw actionResultAbort(text(`Object with displayId ${displayId} already exists in context ${JSON.stringify(context)}`));
        }
        let match = matches[0];
        return new Identity("SBOL3" /* SBOL3 */, context.namespace, displayId, version, context.uri, match.subject.value);
      }
    }
    child_from_context_displayId(existence, g, contextIdentity, displayId, version) {
      if (version !== void 0) {
        throw sbol3VersionError();
      }
      let context = this.from_identity("MustExist" /* MustExist */, g, contextIdentity, void 0);
      let parent = (0, import_sboljs7.sbol3)(g).subjectToFacade(import_rdfoo6.node.createUriNode(context.uri));
      if (!parent) {
        throw actionResultAbort(text(`Context object with identity ${contextIdentity} not found`));
      }
      (0, import_assert5.strict)(parent instanceof import_sboljs7.S3Identified);
      let matches = parent.ownedObjects.filter((child) => displayIdMatches2(child, displayId));
      if (matches.length === 0) {
        if (existence === "MustExist" /* MustExist */) {
          throw actionResultAbort(text(`No object with displayId ${displayId} and version ${version} found in context ${JSON.stringify(context)}`));
        }
        let childUri = parent.subject.value + "/" + displayId;
        return new Identity("SBOL3" /* SBOL3 */, context.namespace, displayId, version, parent.subject.value, childUri);
      } else {
        (0, import_assert5.strict)(matches.length === 1);
        if (existence === "MustNotExist" /* MustNotExist */) {
          throw actionResultAbort(text(`Object with displayId ${displayId} and version ${version} already exists in context ${context}`));
        }
        let match = matches[0];
        return new Identity("SBOL3" /* SBOL3 */, context.namespace, displayId, version, context.uri, match.subject.value);
      }
    }
  };
  function sbol3VersionError() {
    return actionResultAbort(text(`Version is only supported in SBOL2`));
  }
  function extractPrefixesFromGraphSBOL3(g) {
    let v = new import_sboljs7.SBOL3GraphView(g);
    let prefixes = /* @__PURE__ */ new Set();
    for (let t of v.topLevels) {
      let prefix = t.uriPrefix;
      if (prefix)
        prefixes.add(prefix);
    }
    let arr = Array.from(prefixes);
    arr.sort((a, b) => a.length - b.length);
    return arr;
  }
  function inventUriPrefixSBOL3(uri) {
    let slash = uri.lastIndexOf("/");
    let hash = uri.lastIndexOf("#");
    if (slash !== -1) {
      return uri.slice(0, slash + 1);
    }
    if (hash !== -1) {
      return uri.slice(0, hash + 1);
    }
    return "";
  }
  function displayIdMatches2(obj, displayId) {
    if (obj.displayId === displayId)
      return true;
    let instanceOf = obj.getProperty(import_bioterms6.Predicates.SBOL3.instanceOf);
    if (instanceOf) {
      let parentObj = obj.view.subjectToFacade(instanceOf);
      if (parentObj && parentObj.getStringProperty(import_bioterms6.Predicates.SBOL3.displayId) === displayId) {
        return true;
      }
    }
    return false;
  }

  // src/identity/Identity.ts
  var Identity = class {
    constructor(sbolVersion2, namespace3, displayId, version, parentURI, uri) {
      this.sbolVersion = sbolVersion2;
      this.namespace = namespace3;
      this.displayId = displayId;
      this.version = version;
      this.parentURI = parentURI;
      this.uri = uri;
      validateNamespace(namespace3, { sbolVersion: sbolVersion2, displayId, version, parentURI, uri });
      validateNamespaceIsPrefix(namespace3, uri);
      validateDisplayId(displayId);
    }
    static from_identity(existence, sbolVersion2, g, identity, version) {
      trace(text(`Identity.from_identity: Constructing identity (existence = ${existence}) from identity ${identity}, version ${version}`));
      return factory2(sbolVersion2).from_identity(existence, g, identity, version);
    }
    static from_namespace_and_identity(existence, sbolVersion2, g, namespace3, identity, version) {
      trace(text(`Identity.from_namespace_and_identity: Constructing identity (existence = ${existence}) from namespace ${namespace3}, identity ${identity}, version ${version}`));
      return factory2(sbolVersion2).from_namespace_and_identity(existence, g, namespace3, identity, version);
    }
    static child_from_namespace_context_displayId(existence, sbolVersion2, g, namespace3, context, displayId, version) {
      trace(text(`Identity.child_from_namespace_context_identity: Constructing identity (existence = ${existence}) from namespace ${namespace3}, context ${context}, displayId ${displayId}, version ${version}`));
      return factory2(sbolVersion2).child_from_namespace_context_displayId(existence, g, namespace3, context, displayId, version);
    }
    static toplevel_from_namespace_displayId(existence, sbolVersion2, g, namespace3, displayId, version) {
      trace(text(`Identity.toplevel_from_namespace_displayId: Constructing identity (existence = ${existence}) from namespace ${namespace3}, displayId ${displayId}`));
      return factory2(sbolVersion2).toplevel_from_namespace_displayId(existence, g, namespace3, displayId, version);
    }
    static child_from_context_displayId(existence, sbolVersion2, g, context, displayId, version) {
      trace(text(`Identity.child_from_namespace_displayId: Constructing identity (existence = ${existence}) from context ${context}, displayId ${displayId}, version ${version}`));
      return factory2(sbolVersion2).child_from_context_displayId(existence, g, context, displayId, version);
    }
    static toplevel_from_displayId(existence, sbolVersion2, g, displayId, version) {
      trace(text(`Identity.toplevel_from_displayId: Constructing identity (existence = ${existence}) from displayId ${displayId}, version ${version}`));
      return factory2(sbolVersion2).toplevel_from_displayId(existence, g, displayId, version);
    }
  };
  function factory2(sbolVersion2) {
    switch (sbolVersion2) {
      case "SBOL1" /* SBOL1 */:
        return new IdentityFactorySBOL1();
      case "SBOL2" /* SBOL2 */:
        return new IdentityFactorySBOL2();
      case "SBOL3" /* SBOL3 */:
        return new IdentityFactorySBOL3();
      default:
        throw actionResultAbort(text(`Unknown SBOL version`));
    }
  }

  // src/actions/opt/OptIdentity.ts
  var OptIdentity = class extends Opt {
    constructor(actDef, optDef, argv) {
      super(actDef, optDef, argv);
    }
    getIdentity(ctx, existence, relatedIdentity) {
      var _a;
      let g = ctx.getCurrentGraph();
      let currentNamespace = ctx.currentNamespace;
      let defaultVersion = ctx.sbolVersion;
      trace(text("default sbol version: " + defaultVersion));
      let paramPrefix = this.optDef.name !== "" ? this.optDef.name + "-" : "";
      let namespace3 = this.argv.getString(paramPrefix + "namespace", "");
      let displayId = this.argv.getString(paramPrefix + "displayId", "");
      let version = this.argv.getStringOrUndefined(paramPrefix + "version");
      let context = this.argv.getString(paramPrefix + "context", "");
      let identity = this.argv.getString(this.optDef.name, "") || this.argv.getString(paramPrefix + "identity", "");
      let sbolversion = this.argv.getString(paramPrefix + "sbol-version", "");
      let identityOpt = this.argv.getString(this.optDef.name, "");
      if (identityOpt) {
        identity = identityOpt;
      }
      trace(text(`get identity: relatedIdentity ${relatedIdentity}`));
      if (relatedIdentity) {
        if (!namespace3) {
          trace(text(`No namespace was specified, so using namespace of related identity ${relatedIdentity.namespace}`));
          namespace3 = relatedIdentity.namespace;
        }
      }
      if (!namespace3 && !displayId && version === void 0 && !context && !identity && !sbolversion) {
        if (this.optDef.optional === true) {
          return;
        }
      }
      if (currentNamespace && !namespace3) {
        namespace3 = currentNamespace;
      }
      let sbolVersion2 = "Empty" /* Empty */;
      let inferSBOLVersion = ((_a = this.optDef.refinements) == null ? void 0 : _a.inferSBOLVersion) !== false;
      if (sbolversion === "1") {
        sbolVersion2 = "SBOL1" /* SBOL1 */;
      } else if (sbolversion === "2") {
        sbolVersion2 = "SBOL2" /* SBOL2 */;
      } else if (sbolversion === "3") {
        sbolVersion2 = "SBOL3" /* SBOL3 */;
      } else {
        if (!inferSBOLVersion) {
          if (defaultVersion !== "Empty" /* Empty */) {
            sbolVersion2 = defaultVersion;
          } else {
            throw actionResultAbort(text(`Please specify --${paramPrefix}sbol-version 1/2/3`));
          }
        } else {
          if (relatedIdentity) {
            sbolVersion2 = relatedIdentity.sbolVersion;
          } else {
            if (defaultVersion !== "Empty" /* Empty */) {
              sbolVersion2 = defaultVersion;
            } else {
              let consensus = getConsensusSBOLVersion(g);
              if (consensus === 0 /* SBOL1 */)
                sbolVersion2 = "SBOL1" /* SBOL1 */;
              else if (consensus === 1 /* SBOL2 */)
                sbolVersion2 = "SBOL2" /* SBOL2 */;
              else if (consensus === 2 /* SBOL3 */)
                sbolVersion2 = "SBOL3" /* SBOL3 */;
              else {
                throw actionResultAbort(text(`Could not infer input SBOL version from current graph (is it empty, or does it contain mixed SBOL versions?); please specify --${paramPrefix}sbol-version 1/2/3 or set a global default SBOL version using the sbol-version action`));
              }
            }
          }
        }
      }
      let allOptions = { namespace: namespace3, displayId, context, identity };
      trace(text("allOptions: " + JSON.stringify(allOptions)));
      let anyCombinations = [
        {
          namespace: namespace3,
          identity,
          getIdentity: () => Identity.from_namespace_and_identity(existence, sbolVersion2, g, namespace3, identity, version)
        },
        {
          identity,
          getIdentity: () => Identity.from_identity(existence, sbolVersion2, g, identity, version)
        }
      ];
      let tlCombinations = [
        {
          namespace: namespace3,
          displayId,
          getIdentity: () => Identity.toplevel_from_namespace_displayId(existence, sbolVersion2, g, namespace3, displayId, version)
        },
        {
          displayId,
          getIdentity: () => Identity.toplevel_from_displayId(existence, sbolVersion2, g, displayId, version)
        }
      ];
      let childCombinations = [
        {
          namespace: namespace3,
          context,
          displayId,
          getIdentity: () => Identity.child_from_namespace_context_displayId(existence, sbolVersion2, g, namespace3, context, displayId, version)
        },
        {
          context,
          displayId,
          getIdentity: () => Identity.child_from_context_displayId(existence, sbolVersion2, g, context, displayId, version)
        }
      ];
      let allCombinations = anyCombinations.concat(tlCombinations).concat(childCombinations);
      var combo;
      eachCombo:
        for (combo of allCombinations) {
          if (Object.values(combo).filter((v) => v === "").length > 0) {
            continue;
          }
          for (let k of Object.keys(allOptions)) {
            if (Object.keys(combo).indexOf(k) !== -1) {
              continue;
            }
            if (allOptions[k] !== "") {
              continue eachCombo;
            }
          }
          trace(text("identity combination: " + JSON.stringify(combo) + " " + combo.getIdentity));
          return combo.getIdentity();
        }
      throw badCombo(this.actDef.name, paramPrefix);
    }
  };
  function badCombo(action9, paramPrefix) {
    let paramName = paramPrefix.slice(0, -1);
    let opts = [
      [`--${paramPrefix}identity`, `Identifies a top-level, or a child if --${paramPrefix}identity is an identity chain and provides context`],
      [`--${paramPrefix}namespace, --${paramPrefix}displayId`, `Identifies a top-level`],
      [`--${paramPrefix}namespace, --${paramPrefix}identity`, `Identifies a top-level, or a child if --${paramPrefix}identity is an identity chain and provides context`],
      [`--${paramPrefix}displayId`, `Identifies a top-level`],
      [`--${paramPrefix}namespace, --${paramPrefix}context, --${paramPrefix}displayId`, `Identifies a child object`],
      [`--${paramPrefix}context, --${paramPrefix}displayId`, `Identifies a child object`]
    ];
    if (paramName) {
      opts.unshift([`--${paramName}`, `Identifies a top-level, or a child if --${paramName} is an identity chain and provides context`]);
    }
    return actionResultAbort(group([
      text(`${action9}: Please specify a valid combination of identity parameters${paramPrefix ? " for --" + paramName : ""}.  The following combinations are supported:`),
      spacer(),
      tabulated(opts)
    ]));
  }

  // src/actions/object-cd/create-sequence.ts
  var import_bioterms7 = __toESM(require_dist6());

  // src/actions/opt/OptTerm.ts
  init_shim();

  // src/vocab.ts
  init_shim();

  // src/TwoWayMapping.ts
  init_shim();
  var TwoWayMapping = class {
    constructor(obj) {
      this.aToBMap = /* @__PURE__ */ new Map();
      this.bToAMap = /* @__PURE__ */ new Map();
      for (let a of Object.keys(obj)) {
        this.aToBMap.set(a, obj[a]);
        this.bToAMap.set(obj[a], a);
      }
    }
    aToB(a) {
      return this.aToBMap.get(a);
    }
    bToA(b) {
      return this.bToAMap.get(b);
    }
  };

  // src/vocab.ts
  function termShorthandToUri(type, name) {
    if (name.indexOf("://") !== -1) {
      return name;
    }
    if (type === "Role" /* Role */) {
      var uri = roleVocab.aToB(name.toLowerCase());
    } else if (type === "InteractionType" /* InteractionType */) {
      var uri = interactionTypeVocab.aToB(name.toLowerCase());
    } else if (type == "ParticipationRole" /* ParticipationRole */) {
      var uri = participationRoleVocab.aToB(name.toLowerCase());
    } else if (type == "RestrictionSBOL2" /* RestrictionSBOL2 */) {
      var uri = restrictionVocabSBOL2.aToB(name.toLowerCase());
    } else if (type == "RestrictionSBOL3" /* RestrictionSBOL3 */) {
      var uri = restrictionVocabSBOL3.aToB(name.toLowerCase());
    } else if (type == "SequenceEncodingSBOL2" /* SequenceEncodingSBOL2 */) {
      var uri = sequenceEncodingVocabSBOL2.aToB(name.toLowerCase());
    } else if (type == "SequenceEncodingSBOL3" /* SequenceEncodingSBOL3 */) {
      var uri = sequenceEncodingVocabSBOL3.aToB(name.toLowerCase());
    } else if (type == "ComponentTypeSBOL2" /* ComponentTypeSBOL2 */) {
      var uri = componentTypeVocabSBOL2.aToB(name.toLowerCase());
    } else if (type == "ComponentTypeSBOL3" /* ComponentTypeSBOL3 */) {
      var uri = componentTypeVocabSBOL3.aToB(name.toLowerCase());
    }
    if (uri === void 0) {
      throw new ActionResult(text("Unknown term: " + name + " for term type " + type));
    }
    return uri;
  }
  function termUriToShorthand(type, uri) {
    if (type === "Role" /* Role */) {
      var short = roleVocab.bToA(uri.toLowerCase());
    } else if (type === "InteractionType" /* InteractionType */) {
      var short = interactionTypeVocab.bToA(uri.toLowerCase());
    } else if (type == "ParticipationRole" /* ParticipationRole */) {
      var short = participationRoleVocab.bToA(uri.toLowerCase());
    } else if (type == "RestrictionSBOL2" /* RestrictionSBOL2 */) {
      var short = restrictionVocabSBOL2.bToA(uri.toLowerCase());
    } else if (type == "RestrictionSBOL3" /* RestrictionSBOL3 */) {
      var short = restrictionVocabSBOL3.bToA(uri.toLowerCase());
    } else if (type == "SequenceEncodingSBOL2" /* SequenceEncodingSBOL2 */) {
      var short = sequenceEncodingVocabSBOL2.bToA(uri.toLowerCase());
    } else if (type == "SequenceEncodingSBOL3" /* SequenceEncodingSBOL3 */) {
      var short = sequenceEncodingVocabSBOL3.bToA(uri.toLowerCase());
    } else if (type == "ComponentTypeSBOL2" /* ComponentTypeSBOL2 */) {
      var short = componentTypeVocabSBOL2.bToA(uri.toLowerCase());
    } else if (type == "ComponentTypeSBOL3" /* ComponentTypeSBOL3 */) {
      var short = componentTypeVocabSBOL3.bToA(uri.toLowerCase());
    }
    if (short === void 0) {
      return uri;
    }
    return short;
  }
  var roleVocab = new TwoWayMapping({
    "dna": "https://identifiers.org/SBO:0000251",
    "rna": "https://identifiers.org/SBO:0000250",
    "protein": "https://identifiers.org/SBO:0000252",
    "simplechemical": "https://identifiers.org/SBO:0000247",
    "chemical": "https://identifiers.org/SBO:0000247",
    "complex": "https://identifiers.org/SBO:0000253",
    "noncovalentcomplex": "https://identifiers.org/SBO:0000253",
    "functionalentity": "https://identifiers.org/SBO:0000241",
    "functional": "https://identifiers.org/SBO:0000241",
    "linear": "http://identifiers.org/so/SO:0000987",
    "circular": "http://identifiers.org/so/SO:0000988",
    "singlestranded": "http://identifiers.org/so/SO:0000984",
    "doublestranded": "http://identifiers.org/so/SO:0000985",
    "promoter": "http://identifiers.org/so/SO:0000167",
    "rbs": "http://identifiers.org/so/SO:0000139",
    "cds": "http://identifiers.org/so/SO:0000316",
    "terminator": "http://identifiers.org/so/SO:0000141",
    "gene": "http://identifiers.org/so/SO:0000704",
    "operator": "http://identifiers.org/so/SO:0000057",
    "engineeredgene": "http://identifiers.org/so/SO:0000280",
    "mrna": "http://identifiers.org/so/SO:0000234",
    "effector": "http://identifiers.org/chebi/CHEBI:35224",
    "transcriptionfactor": "http://identifiers.org/go/GO:0003700"
  });
  var interactionTypeVocab = new TwoWayMapping({
    "inhibition": "http://identifiers.org/biomodels.sbo/SBO:0000169",
    "stimulation": "http://identifiers.org/biomodels.sbo/SBO:0000170",
    "biochemicalreaction": "http://identifiers.org/biomodels.sbo/SBO:0000176",
    "noncovalentbinding": "http://identifiers.org/biomodels.sbo/SBO:0000177",
    "degradation": "http://identifiers.org/biomodels.sbo/SBO:0000179",
    "geneticproduction": "http://identifiers.org/biomodels.sbo/SBO:0000589",
    "control": "http://identifiers.org/biomodels.sbo/SBO:0000168"
  });
  var participationRoleVocab = new TwoWayMapping({
    "inhibitor": "http://identifiers.org/biomodels.sbo/SBO:0000020",
    "inhibited": "http://identifiers.org/biomodels.sbo/SBO:0000642",
    "stimulator": "http://identifiers.org/biomodels.sbo/SBO:0000459",
    "stimulated": "http://identifiers.org/biomodels.sbo/SBO:0000643",
    "reactant": "http://identifiers.org/biomodels.sbo/SBO:0000010",
    "product": "http://identifiers.org/biomodels.sbo/SBO:0000011",
    "promoter": "http://identifiers.org/biomodels.sbo/SBO:0000598",
    "modifier": "http://identifiers.org/biomodels.sbo/SBO:0000019",
    "modified": "http://identifiers.org/biomodels.sbo/SBO:0000644",
    "template": "http://identifiers.org/biomodels.sbo/SBO:0000645"
  });
  var restrictionVocabSBOL2 = new TwoWayMapping({
    "precedes": "http://sbols.org/v2#precedes"
  });
  var restrictionVocabSBOL3 = new TwoWayMapping({
    "precedes": "http://sbols.org/v3#precedes"
  });
  var sequenceEncodingVocabSBOL2 = new TwoWayMapping({
    "nucleicacid": "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html",
    "dna": "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html",
    "rna": "http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html",
    "protein": "http://www.chem.qmul.ac.uk/iupac/AminoAcid/",
    "smiles": "http://www.opensmiles.org/opensmiles.html"
  });
  var sequenceEncodingVocabSBOL3 = new TwoWayMapping({
    "nucleicacid": "http://sbols.org/v3#iupacNucleicAcid",
    "dna": "http://sbols.org/v3#iupacNucleicAcid",
    "rna": "http://sbols.org/v3#iupacNucleicAcid",
    "aminoacid": "http://sbols.org/v3#iupacAminoAcid",
    "protein": "http://sbols.org/v3#iupacAminoAcid",
    "smiles": "http://www.opensmiles.org/opensmiles.html",
    "chemical": "http://www.opensmiles.org/opensmiles.html"
  });
  var componentTypeVocabSBOL2 = new TwoWayMapping({
    "dna": "http://www.biopax.org/release/biopax-level3.owl#Dna",
    "dnamolecule": "http://www.biopax.org/release/biopax-level3.owl#Dna",
    "dnaregion": "http://www.biopax.org/release/biopax-level3.owl#DnaRegion",
    "rna": "http://www.biopax.org/release/biopax-level3.owl#Rna",
    "rnamolecule": "http://www.biopax.org/release/biopax-level3.owl#Rna",
    "rnaregion": "http://www.biopax.org/release/biopax-level3.owl#RnaRegion",
    "protein": "http://www.biopax.org/release/biopax-level3.owl#Protein",
    "smallmolecule": "http://www.biopax.org/release/biopax-level3.owl#SmallMolecule",
    "complex": "http://www.biopax.org/release/biopax-level3.owl#Complex"
  });
  var componentTypeVocabSBOL3 = new TwoWayMapping({
    "dna": "https://identifiers.org/SBO:0000251",
    "dnamolecule": "https://identifiers.org/SBO:0000251",
    "dnaregion": "https://identifiers.org/SBO:0000251",
    "rna": "https://identifiers.org/SBO:0000250",
    "protein": "https://identifiers.org/SBO:0000252",
    "chemical": "https://identifiers.org/SBO:0000247",
    "simplechemical": "https://identifiers.org/SBO:0000247",
    "noncovalentcomplex": "https://identifiers.org/SBO:0000253",
    "complex": "https://identifiers.org/SBO:0000253",
    "functionalentity": "https://identifiers.org/SBO:0000241",
    "module": "https://identifiers.org/SBO:0000241"
  });

  // src/actions/opt/OptTerm.ts
  var OptTerm = class extends Opt {
    constructor(actDef, optDef, argv) {
      super(actDef, optDef, argv);
    }
    getTerm(type) {
      let name = this.argv.getString(this.optDef.name, "");
      if (!name) {
        return void 0;
      }
      return termShorthandToUri(type, name);
    }
  };

  // src/actions/object-cd/create-sequence.ts
  var createSequenceAction2 = {
    name: "sequence",
    description: "Creates a sequence",
    category: "object-cd",
    namedOpts: [
      {
        name: "",
        type: OptIdentity
      },
      {
        name: "for-component",
        type: OptIdentity
      },
      {
        name: "source",
        type: OptURL
      },
      {
        name: "encoding",
        type: OptTerm
      }
    ],
    positionalOpts: [
      {
        name: "",
        type: OptIdentity,
        optional: true
      }
    ],
    run: createSequence,
    help: `
If the sequence identity is not specified, a default identity will be created from the component identity with \`_seq\` appended to its displayId.

If the encoding is not specified, it will be inferred from the component in the case that \`--for-component\` is specified (e.g. a DNA component will result in a nucleic acid sequence being created).

If such inference is not possible (e.g. no component is specified, or the specified component is of a type other than DNA, RNA, or Protein), an error will be thrown.
`
  };
  var create_sequence_default = createSequenceAction2;
  function createSequence(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      let [optNamedIdentity, optForComponentIdentity, optSource, optEncoding] = namedOpts;
      (0, import_assert6.strict)(optNamedIdentity instanceof OptIdentity);
      (0, import_assert6.strict)(optSource instanceof OptURL);
      (0, import_assert6.strict)(optForComponentIdentity instanceof OptIdentity);
      (0, import_assert6.strict)(optEncoding instanceof OptTerm);
      let [optPositionalIdentity] = positionalOpts;
      (0, import_assert6.strict)(!optPositionalIdentity || optPositionalIdentity instanceof OptIdentity);
      let identity = (optPositionalIdentity || optNamedIdentity).getIdentity(ctx, "MustNotExist" /* MustNotExist */);
      (0, import_assert6.strict)(identity !== void 0);
      let forComponentIdentity = optForComponentIdentity.getIdentity(ctx, "MustExist" /* MustExist */);
      let source = yield optSource.downloadToString();
      let sourceG = new import_rdfoo7.Graph();
      yield importToGraph(sourceG, source, "sbol3");
      let sourceGV = new import_sboljs8.SBOL3GraphView(sourceG);
      if (sourceGV.sequences.length !== 1) {
        throw new ActionResult(text("Source did not evaluate to exactly one sequence"));
      }
      let elements = sourceGV.sequences[0].elements;
      (0, import_assert6.strict)(elements);
      switch (identity.sbolVersion) {
        case "SBOL1" /* SBOL1 */:
          return createSequenceSBOL1(g, identity, forComponentIdentity, encoding2, elements);
        case "SBOL2" /* SBOL2 */:
          var encoding2 = optEncoding.getTerm("SequenceEncodingSBOL2" /* SequenceEncodingSBOL2 */);
          return createSequenceSBOL2(g, identity, forComponentIdentity, encoding2, elements);
        case "SBOL3" /* SBOL3 */:
          var encoding2 = optEncoding.getTerm("SequenceEncodingSBOL3" /* SequenceEncodingSBOL3 */);
          (0, import_assert6.strict)(encoding2);
          return createSequenceSBOL3(g, identity, forComponentIdentity, encoding2, elements);
        default:
          throw new ActionResult(text("Unsupported SBOL version for create-component"), 0 /* Abort */);
      }
    });
  }
  function createSequenceSBOL1(g, identity, forComponentIdentity, encoding2, elements) {
    let gv = new import_sboljs8.SBOL1GraphView(g);
    if (!identity.parentURI) {
      throw new ActionResult(text("DnaSequence must have a parent in SBOL1, as unlike Sequence in SBOL2/3, it is not designated as top-level"), 0 /* Abort */);
    }
    g.insertProperties(import_rdfoo7.node.createUriNode(identity.uri), {
      [import_bioterms7.Predicates.a]: import_rdfoo7.node.createUriNode(import_bioterms7.Types.SBOL1.DnaSequence),
      [import_bioterms7.Predicates.SBOL1.nucleotides]: import_rdfoo7.node.createStringNode(elements)
    });
    g.insertProperties(import_rdfoo7.node.createUriNode(identity.parentURI), {
      [import_bioterms7.Predicates.SBOL1.dnaSequence]: import_rdfoo7.node.createUriNode(identity.uri)
    });
    return new ActionResult();
  }
  function createSequenceSBOL2(g, identity, forComponentIdentity, encoding2, elements) {
    let gv = new import_sboljs8.SBOL2GraphView(g);
    if (identity.parentURI) {
      throw new ActionResult(text("Sequence cannot have a parent in SBOL2/3, as unlike DnaSequence in SBOL1, it is not designated as top-level. Consider using the --for-component option instead to attach the sequence to a component upon creation."), 0 /* Abort */);
    }
    if (!encoding2) {
      if (forComponentIdentity !== void 0) {
        let component = gv.subjectToFacade(import_rdfoo7.node.createUriNode(forComponentIdentity.uri));
        (0, import_assert6.strict)(component instanceof import_sboljs8.S2ComponentDefinition);
        trace(text("Attempting to infer seq encoding from component with types " + component.types.join(", ")));
        trace(text(import_bioterms7.Specifiers.SBOL2.Type.DNA));
        trace(text(import_bioterms7.Specifiers.SBOL2.SequenceEncoding.NucleicAcid));
        encoding2 = typesToEncoding(component.types);
      }
    }
    if (!encoding2) {
      throw new ActionResult(text("Cannot infer sequence encoding from component type; please specify an encoding"), 0 /* Abort */);
    }
    g.insertProperties(import_rdfoo7.node.createUriNode(identity.uri), {
      [import_bioterms7.Predicates.a]: import_rdfoo7.node.createUriNode(import_bioterms7.Types.SBOL2.Sequence),
      [import_bioterms7.Predicates.SBOL2.displayId]: import_rdfoo7.node.createStringNode(identity.displayId),
      [import_bioterms7.Predicates.SBOL2.encoding]: import_rdfoo7.node.createUriNode(encoding2),
      [import_bioterms7.Predicates.SBOL2.elements]: import_rdfoo7.node.createStringNode(elements)
    });
    if (identity.version) {
      g.insertProperties(import_rdfoo7.node.createUriNode(identity.uri), {
        [import_bioterms7.Predicates.SBOL2.version]: import_rdfoo7.node.createStringNode(identity.version)
      });
    }
    if (forComponentIdentity !== void 0) {
      g.insertProperties(import_rdfoo7.node.createUriNode(forComponentIdentity.uri), {
        [import_bioterms7.Predicates.SBOL2.sequence]: import_rdfoo7.node.createUriNode(identity.uri)
      });
    }
    return new ActionResult();
  }
  function createSequenceSBOL3(g, identity, forComponentIdentity, encoding2, elements) {
    return new ActionResult();
  }
  function typesToEncoding(types) {
    if (types.indexOf("http://www.biopax.org/release/biopax-level3.owl#Dna") !== -1) {
      return import_bioterms7.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    } else if (types.indexOf("http://www.biopax.org/release/biopax-level3.owl#DnaRegion") !== -1) {
      return import_bioterms7.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    } else if (types.indexOf("http://www.biopax.org/release/biopax-level3.owl#Rna") !== -1) {
      return import_bioterms7.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    } else if (types.indexOf("http://www.biopax.org/release/biopax-level3.owl#RnaRegion") !== -1) {
      return import_bioterms7.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    } else if (types.indexOf("http://www.biopax.org/release/biopax-level3.owl#Protein") !== -1) {
      return import_bioterms7.Specifiers.SBOL2.SequenceEncoding.AminoAcid;
    } else if (types.indexOf("http://www.biopax.org/release/biopax-level3.owl#Protein") !== -1) {
      return import_bioterms7.Specifiers.SBOL2.SequenceEncoding.AminoAcid;
    } else if (types.indexOf("https://identifiers.org/SBO:0000251") !== -1) {
      return import_bioterms7.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    } else if (types.indexOf("https://identifiers.org/SBO:0000251") !== -1) {
      return import_bioterms7.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    } else if (types.indexOf("https://identifiers.org/SBO:0000252") !== -1) {
      return import_bioterms7.Specifiers.SBOL2.SequenceEncoding.AminoAcid;
    }
    (0, import_assert6.strict)(false);
  }

  // src/actions/components.ts
  init_shim();
  var import_sboljs9 = __toESM(require_dist5());

  // src/sbol1/dnaComponentTree.ts
  init_shim();
  function dnaComponentTree(gv) {
    let roots = gv.rootDnaComponents;
    return group(roots.map(dnaComponentToNode));
    function dnaComponentToNode(c) {
      return new OutputNodeTree(c.name || c.displayId || c.subject.value, { "foo": "bar" }, c.subComponents.map(dnaComponentToNode).concat([c.dnaSequence].filter((seq) => seq !== void 0).map(dnaSequenceToNode)));
    }
    function dnaSequenceToNode(c) {
      return new OutputNodeTree(c.name || c.subject.value, { "foo": "bar" }, []);
    }
  }

  // src/sbol3/componentTree.ts
  init_shim();
  function componentTree(gv) {
    let roots = gv.components;
    return group(roots.map(componentToNode));
    function componentToNode(c) {
      return new OutputNodeTree(c.displayName || "c?", { "foo": "bar" }, c.subComponents.map(subComponentToNode));
    }
    function subComponentToNode(c) {
      return new OutputNodeTree(c.displayName || "sc?", { "foo": "bar" }, []);
    }
  }

  // src/sbol2/cdTree.ts
  init_shim();
  function cdTree(gv) {
    let roots = gv.structurallyRootComponentDefinitions;
    return group(roots.map(cdToNode));
    function cdToNode(cd) {
      return new OutputNodeTree(cd.displayName || "???", { "foo": "bar" }, cd.components.map(cToNode));
    }
    function cToNode(m) {
      if (roots.filter((r) => r.subject.value === m.subject.value).length > 0) {
        return new OutputNodeTree(" -> " + m.definition.displayName, {}, []);
      } else {
        return cdToNode(m.definition);
      }
    }
  }

  // src/actions/components.ts
  var componentsAction = {
    name: "components",
    category: "other",
    namedOpts: [],
    positionalOpts: [],
    run: components
  };
  var components_default = componentsAction;
  function components(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      let output = [];
      let g1 = new import_sboljs9.SBOL1GraphView(g);
      if (g1.dnaComponents.length > 0) {
        output.push(group([
          header("SBOL1 DnaComponents"),
          spacer(),
          dnaComponentTree(g1),
          spacer()
        ]));
      }
      let g2 = new import_sboljs9.SBOL2GraphView(g);
      if (g2.componentDefinitions.length > 0) {
        output.push(group([
          header("SBOL2 ComponentDefinitions"),
          spacer(),
          cdTree(g2),
          spacer()
        ]));
      }
      if (g2.moduleDefinitions.length > 0) {
        output.push(group([
          header("SBOL2 ModuleDefinitions"),
          spacer(),
          cdTree(g2),
          spacer()
        ]));
      }
      let g3 = new import_sboljs9.SBOL3GraphView(g);
      if (g3.components.length > 0) {
        output.push(group([
          header("SBOL3 Components"),
          spacer(),
          componentTree(new import_sboljs9.SBOL3GraphView(g)),
          spacer()
        ]));
      }
      return new ActionResult(group(output));
    });
  }

  // src/actions/validate.ts
  init_shim();
  var import_sboljs10 = __toESM(require_dist5());
  var fetch4 = require_browser5();
  var assert9 = require_assert();
  var vcValidateAction = {
    name: "validate",
    category: "vc",
    namedOpts: [],
    positionalOpts: [],
    run: vcValidate
  };
  var validate_default = vcValidateAction;
  function vcValidate(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      let sourceVersion = getSBOLVersionFromGraph(g);
      let xml = "";
      if (sourceVersion === "SBOL1" /* SBOL1 */) {
        xml = new import_sboljs10.SBOL1GraphView(g).serializeXML();
      } else if (sourceVersion === "SBOL2" /* SBOL2 */) {
        xml = new import_sboljs10.SBOL2GraphView(g).serializeXML();
      } else if (sourceVersion === "SBOL3" /* SBOL3 */) {
        throw new ActionResult(text("convert: cannot convert from SBOL3 using the online validator/converter"), 0 /* Abort */);
      } else if (sourceVersion === "Mixed" /* Mixed */) {
        throw new ActionResult(text("convert: graph has mixed SBOL versions so cannot use online validator/converter"), 0 /* Abort */);
      } else if (sourceVersion === "Empty" /* Empty */) {
        xml = new import_sboljs10.SBOL2GraphView(g).serializeXML();
      } else {
        throw new ActionResult(text("convert: unknown source SBOLVersion " + sourceVersion));
      }
      let body = {
        options: {
          test_equality: false,
          check_uri_compliance: false,
          check_completeness: false,
          check_best_practices: false,
          fail_on_first_error: false,
          provide_detailed_stack_trace: false,
          subset_uri: "",
          uri_prefix: "",
          version: "",
          insert_type: false,
          main_file_name: "main file",
          diff_file_name: "comparison file"
        },
        main_file: xml,
        return_file: true
      };
      let r = yield fetch4("https://validator.sbolstandard.org/validate/", {
        method: "POST",
        headers: {
          "content-type": "application/json"
        },
        body: JSON.stringify(body)
      });
      try {
        var response = yield r.json();
      } catch (e) {
        return actionResult(text("The online validator/converter failed: " + e));
      }
      let { valid, check_equality, equality, errors, output_file, result } = response;
      let output = [];
      errors = errors.filter((e) => e.trim() != "");
      if (!valid) {
        if (errors.length > 0) {
          output.push(spacer());
          output.push(group(errors.map((e) => text("Online validator error: " + e))));
          output.push(spacer());
        }
      }
      if (valid) {
        output.push(text("validate: the validator/converter said: valid!"));
      } else {
        output.push(spacer(), text("The online validator/converter said the SBOL sent by sboltools was invalid"), text("This should not happen, and is likely indicative of a bug in sboltools"), spacer());
        throw new ActionResult(group(output), 0 /* Abort */);
      }
      if (result) {
        output.push(text("validate: have result"));
      } else {
        output.push(text("validate: do not have result"));
      }
      return actionResult(group(output));
    });
  }

  // src/actions/object-cd/create-constraint.ts
  init_shim();
  var import_rdfoo8 = __toESM(require_dist());
  var import_assert7 = __toESM(require_assert());
  var import_sboljs11 = __toESM(require_dist5());
  var import_bioterms8 = __toESM(require_dist6());
  var createConstraintAction = {
    name: "constraint",
    description: "Creates a constraint",
    category: "object-cd",
    namedOpts: [
      {
        name: "",
        type: OptIdentity
      },
      {
        name: "subject",
        type: OptIdentity,
        optional: false
      },
      {
        name: "restriction",
        type: OptTerm,
        optional: false
      },
      {
        name: "object",
        type: OptIdentity,
        optional: false
      }
    ],
    positionalOpts: [
      {
        name: "",
        type: OptIdentity,
        optional: true
      }
    ],
    run: createConstraint
  };
  var create_constraint_default = createConstraintAction;
  function createConstraint(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      trace(text("createConstraint"));
      let [optNamedIdentity, optSubject, optRestriction, optObject] = namedOpts;
      (0, import_assert7.strict)(optNamedIdentity instanceof OptIdentity);
      (0, import_assert7.strict)(optSubject instanceof OptIdentity);
      (0, import_assert7.strict)(optRestriction instanceof OptTerm);
      (0, import_assert7.strict)(optObject instanceof OptIdentity);
      let [optPositionalIdentity] = positionalOpts;
      (0, import_assert7.strict)(!optPositionalIdentity || optPositionalIdentity instanceof OptIdentity);
      let identity = (optPositionalIdentity || optNamedIdentity).getIdentity(ctx, "MustNotExist" /* MustNotExist */);
      (0, import_assert7.strict)(identity !== void 0);
      let subjectIdentity = optSubject.getIdentity(ctx, "MustExist" /* MustExist */);
      if (!subjectIdentity) {
        throw new ActionResult(text("Constraint subject does not exist"));
      }
      if (subjectIdentity.parentURI !== identity.parentURI) {
        throw new ActionResult(text("Constraint subject must have the same parent as the constraint"));
      }
      let objectIdentity = optSubject.getIdentity(ctx, "MustExist" /* MustExist */);
      if (!objectIdentity) {
        throw new ActionResult(text("Constraint object does not exist"));
      }
      if (objectIdentity.parentURI !== identity.parentURI) {
        throw new ActionResult(text("Constraint object must have the same parent as the constraint"));
      }
      switch (identity.sbolVersion) {
        case "SBOL2" /* SBOL2 */:
          return createConstraintSBOL2(g, identity, subjectIdentity, optRestriction, objectIdentity);
        case "SBOL3" /* SBOL3 */:
          return createConstraintSBOL3(g, identity, subjectIdentity, optRestriction, objectIdentity);
        default:
          throw new ActionResult(text("Unsupported SBOL version for create-component"));
      }
      return new ActionResult();
    });
  }
  function createConstraintSBOL2(g, identity, subject, optRestriction, object) {
    let restriction = optRestriction.getTerm("RestrictionSBOL2" /* RestrictionSBOL2 */);
    (0, import_assert7.strict)(restriction);
    let gv = new import_sboljs11.SBOL2GraphView(g);
    g.insertProperties(import_rdfoo8.node.createUriNode(identity.uri), {
      [import_bioterms8.Predicates.a]: import_rdfoo8.node.createUriNode(import_bioterms8.Types.SBOL2.SequenceConstraint),
      [import_bioterms8.Predicates.SBOL2.displayId]: import_rdfoo8.node.createStringNode(identity.displayId),
      [import_bioterms8.Predicates.SBOL2.restriction]: import_rdfoo8.node.createUriNode(restriction)
    });
    if (identity.version !== void 0) {
      g.insertProperties(import_rdfoo8.node.createUriNode(identity.uri), {
        [import_bioterms8.Predicates.SBOL2.version]: import_rdfoo8.node.createStringNode(identity.version)
      });
    }
    (0, import_assert7.strict)(identity.parentURI);
    g.insertProperties(import_rdfoo8.node.createUriNode(identity.parentURI), {
      [import_bioterms8.Predicates.SBOL2.sequenceConstraint]: import_rdfoo8.node.createUriNode(identity.uri)
    });
    return new ActionResult();
  }
  function createConstraintSBOL3(g, identity, subject, optRestriction, object) {
    let restriction = optRestriction.getTerm("RestrictionSBOL3" /* RestrictionSBOL3 */);
    (0, import_assert7.strict)(restriction);
    let gv = new import_sboljs11.SBOL3GraphView(g);
    let namespace3 = identity.namespace;
    (0, import_assert7.strict)(namespace3);
    g.insertProperties(import_rdfoo8.node.createUriNode(identity.uri), {
      [import_bioterms8.Predicates.a]: import_rdfoo8.node.createUriNode(import_bioterms8.Types.SBOL3.Constraint),
      [import_bioterms8.Predicates.SBOL3.displayId]: import_rdfoo8.node.createStringNode(identity.displayId),
      [import_bioterms8.Prefixes.sbol3 + "namespace"]: import_rdfoo8.node.createUriNode(identity.namespace)
    });
    (0, import_assert7.strict)(identity.parentURI);
    g.insertProperties(import_rdfoo8.node.createUriNode(identity.parentURI), {
      [import_bioterms8.Predicates.SBOL3.hasConstraint]: import_rdfoo8.node.createUriNode(identity.uri)
    });
    return new ActionResult();
  }

  // src/actions/object-cd/create-component.ts
  init_shim();
  var import_rdfoo9 = __toESM(require_dist());
  var import_assert8 = __toESM(require_assert());
  var import_sboljs12 = __toESM(require_dist5());
  var import_bioterms9 = __toESM(require_dist6());
  var createComponentAction = {
    name: "component",
    description: "Creates a component",
    category: "object-cd",
    namedOpts: [
      {
        name: "",
        type: OptIdentity
      },
      {
        name: "type",
        type: OptTerm
      },
      {
        name: "role",
        type: OptTerm
      }
    ],
    positionalOpts: [
      {
        name: "",
        type: OptIdentity,
        optional: true
      }
    ],
    run: createComponent
  };
  var create_component_default = createComponentAction;
  function createComponent(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      trace(text("createComponent"));
      let [optNamedIdentity, optType, optRole] = namedOpts;
      (0, import_assert8.strict)(optType instanceof OptTerm);
      (0, import_assert8.strict)(optRole instanceof OptTerm);
      (0, import_assert8.strict)(optNamedIdentity instanceof Opt);
      let [optPositionalIdentity] = positionalOpts;
      (0, import_assert8.strict)(!optPositionalIdentity || optPositionalIdentity instanceof OptIdentity);
      let identity = (optPositionalIdentity || optNamedIdentity).getIdentity(ctx, "MustNotExist" /* MustNotExist */);
      (0, import_assert8.strict)(identity !== void 0);
      trace(text("Create component: identity: " + JSON.stringify(identity)));
      let parentURI = "";
      if (identity.parentURI) {
        parentURI = identity.parentURI;
        identity = Identity.toplevel_from_namespace_displayId("MustNotExist" /* MustNotExist */, identity.sbolVersion, g, identity.namespace, identity.displayId, identity.version);
      }
      trace(text("Create component: component identity: " + JSON.stringify(identity) + ", parent identity: " + parentURI));
      switch (identity.sbolVersion) {
        case "SBOL1" /* SBOL1 */:
          return createComponentSBOL1(g, identity, optType, optRole, parentURI);
        case "SBOL2" /* SBOL2 */:
          return createComponentSBOL2(g, identity, optType, optRole, parentURI);
        case "SBOL3" /* SBOL3 */:
          return createComponentSBOL3(g, identity, optType, optRole, parentURI);
        default:
          throw new ActionResult(text("Unsupported SBOL version for create-component"));
      }
      return new ActionResult();
    });
  }
  function createComponentSBOL1(g, identity, optType, optRole, parentURI) {
    let gv = new import_sboljs12.SBOL1GraphView(g);
    g.insertProperties(import_rdfoo9.node.createUriNode(identity.uri), {
      [import_bioterms9.Predicates.a]: import_rdfoo9.node.createUriNode(import_bioterms9.Types.SBOL1.DnaComponent),
      [import_bioterms9.Predicates.SBOL1.displayId]: import_rdfoo9.node.createStringNode(identity.displayId)
    });
    if (parentURI) {
      if (!g.hasMatch(import_rdfoo9.node.createUriNode(parentURI), import_bioterms9.Predicates.a, import_rdfoo9.node.createUriNode(import_bioterms9.Types.SBOL1.DnaComponent))) {
        throw new ActionResult(text(`Parent DnaComponent with URI ${parentURI} not found`), 0 /* Abort */);
      }
      let annoURI = g.generateURI(parentURI + "_anno$n$");
      g.insertProperties(import_rdfoo9.node.createUriNode(parentURI), {
        [import_bioterms9.Predicates.SBOL1.annotation]: import_rdfoo9.node.createUriNode(annoURI)
      });
      g.insertProperties(import_rdfoo9.node.createUriNode(annoURI), {
        [import_bioterms9.Predicates.a]: import_rdfoo9.node.createUriNode(import_bioterms9.Types.SBOL1.SequenceAnnotation),
        [import_bioterms9.Predicates.SBOL1.subComponent]: import_rdfoo9.node.createUriNode(identity.uri)
      });
    }
    return new ActionResult();
  }
  function createComponentSBOL2(g, identity, optType, optRole, parentURI) {
    let type = optType.getTerm("Role" /* Role */);
    if (!type) {
      throw new ActionResult(text(`--type parameter is required for component create action`), 0 /* Abort */);
    }
    let gv = new import_sboljs12.SBOL2GraphView(g);
    g.insertProperties(import_rdfoo9.node.createUriNode(identity.uri), {
      [import_bioterms9.Predicates.a]: import_rdfoo9.node.createUriNode(import_bioterms9.Types.SBOL2.ComponentDefinition),
      [import_bioterms9.Predicates.SBOL2.type]: import_rdfoo9.node.createUriNode(type),
      [import_bioterms9.Predicates.SBOL2.displayId]: import_rdfoo9.node.createStringNode(identity.displayId)
    });
    if (identity.version !== void 0) {
      g.insertProperties(import_rdfoo9.node.createUriNode(identity.uri), {
        [import_bioterms9.Predicates.SBOL2.version]: import_rdfoo9.node.createStringNode(identity.version)
      });
    }
    if (parentURI) {
      if (!g.hasMatch(import_rdfoo9.node.createUriNode(parentURI), import_bioterms9.Predicates.a, import_rdfoo9.node.createUriNode(import_bioterms9.Types.SBOL2.ComponentDefinition))) {
        throw new ActionResult(text(`Parent ComponentDefinition with URI ${identity.parentURI} not found`), 0 /* Abort */);
      }
      let scURI = g.generateURI(sbol2CompliantConcat(g, parentURI, identity.displayId));
      g.insertProperties(import_rdfoo9.node.createUriNode(parentURI), {
        [import_bioterms9.Predicates.SBOL2.component]: import_rdfoo9.node.createUriNode(scURI)
      });
      g.insertProperties(import_rdfoo9.node.createUriNode(scURI), {
        [import_bioterms9.Predicates.a]: import_rdfoo9.node.createUriNode(import_bioterms9.Types.SBOL2.Component),
        [import_bioterms9.Predicates.SBOL2.definition]: import_rdfoo9.node.createUriNode(identity.uri),
        [import_bioterms9.Predicates.SBOL2.displayId]: import_rdfoo9.node.createStringNode(identity.displayId)
      });
    }
    return new ActionResult();
  }
  function createComponentSBOL3(g, identity, optType, optRole, parentURI) {
    let type = optType.getTerm("Role" /* Role */);
    if (!type) {
      throw new ActionResult(text(`--type parameter is required for component create action. For example, component --type DNA.`), 0 /* Abort */);
    }
    let gv = new import_sboljs12.SBOL3GraphView(g);
    g.insertProperties(import_rdfoo9.node.createUriNode(identity.uri), {
      [import_bioterms9.Predicates.a]: import_rdfoo9.node.createUriNode(import_bioterms9.Types.SBOL3.Component),
      [import_bioterms9.Predicates.SBOL3.type]: import_rdfoo9.node.createUriNode(type),
      [import_bioterms9.Predicates.SBOL3.displayId]: import_rdfoo9.node.createStringNode(identity.displayId),
      [import_bioterms9.Predicates.SBOL3.hasNamespace]: import_rdfoo9.node.createUriNode(identity.namespace)
    });
    if (parentURI) {
      if (!g.hasMatch(import_rdfoo9.node.createUriNode(parentURI), import_bioterms9.Predicates.a, import_rdfoo9.node.createUriNode(import_bioterms9.Types.SBOL3.Component))) {
        throw new ActionResult(text(`Parent Component with URI ${identity.parentURI} not found`), 0 /* Abort */);
      }
      let scURI = g.generateURI(joinURIFragments([parentURI, "subcomponent$n$"]));
      let scDisplayId = scURI.split("/").pop() || identity.displayId;
      g.insertProperties(import_rdfoo9.node.createUriNode(parentURI), {
        [import_bioterms9.Predicates.SBOL3.hasFeature]: import_rdfoo9.node.createUriNode(scURI)
      });
      g.insertProperties(import_rdfoo9.node.createUriNode(scURI), {
        [import_bioterms9.Predicates.a]: import_rdfoo9.node.createUriNode(import_bioterms9.Types.SBOL3.SubComponent),
        [import_bioterms9.Predicates.SBOL3.instanceOf]: import_rdfoo9.node.createUriNode(identity.uri),
        [import_bioterms9.Predicates.SBOL3.displayId]: import_rdfoo9.node.createStringNode(scDisplayId)
      });
    }
    return new ActionResult();
  }

  // src/actions/object-cd/create-module.ts
  init_shim();
  var import_rdfoo10 = __toESM(require_dist());
  var import_assert9 = __toESM(require_assert());
  var import_sboljs13 = __toESM(require_dist5());
  var import_bioterms10 = __toESM(require_dist6());
  var createModuleAction = {
    name: "module",
    description: "Creates a module (SBOL2 only)",
    category: "object-cd",
    namedOpts: [
      {
        name: "",
        type: OptIdentity
      }
    ],
    positionalOpts: [
      {
        name: "",
        type: OptIdentity,
        optional: true
      }
    ],
    run: createModule
  };
  var create_module_default = createModuleAction;
  function createModule(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      trace(text("createModule"));
      let [optNamedIdentity] = namedOpts;
      (0, import_assert9.strict)(optNamedIdentity instanceof Opt);
      let [optPositionalIdentity] = positionalOpts;
      (0, import_assert9.strict)(!optPositionalIdentity || optPositionalIdentity instanceof OptIdentity);
      let identity = (optPositionalIdentity || optNamedIdentity).getIdentity(ctx, "MustNotExist" /* MustNotExist */);
      (0, import_assert9.strict)(identity !== void 0);
      let parentURI = "";
      if (identity.parentURI) {
        parentURI = identity.parentURI;
        identity = Identity.toplevel_from_namespace_displayId("MustNotExist" /* MustNotExist */, identity.sbolVersion, g, identity.namespace, identity.displayId, identity.version);
      }
      switch (identity.sbolVersion) {
        case "SBOL2" /* SBOL2 */:
          return createModuleSBOL2(g, identity, parentURI);
        default:
          throw new ActionResult(text("Unsupported SBOL version for create-module"));
      }
      return new ActionResult();
    });
  }
  function createModuleSBOL2(g, identity, parentURI) {
    let gv = new import_sboljs13.SBOL2GraphView(g);
    g.insertProperties(import_rdfoo10.node.createUriNode(identity.uri), {
      [import_bioterms10.Predicates.a]: import_rdfoo10.node.createUriNode(import_bioterms10.Types.SBOL2.ModuleDefinition),
      [import_bioterms10.Predicates.SBOL2.displayId]: import_rdfoo10.node.createStringNode(identity.displayId)
    });
    if (identity.version !== void 0) {
      g.insertProperties(import_rdfoo10.node.createUriNode(identity.uri), {
        [import_bioterms10.Predicates.SBOL2.version]: import_rdfoo10.node.createStringNode(identity.version)
      });
    }
    if (parentURI) {
      if (!g.hasMatch(import_rdfoo10.node.createUriNode(parentURI), import_bioterms10.Predicates.a, import_rdfoo10.node.createUriNode(import_bioterms10.Types.SBOL2.ModuleDefinition))) {
        throw new ActionResult(text(`Parent ModuleDefinition with URI ${parentURI} not found`), 0 /* Abort */);
      }
      let scURI = g.generateURI(sbol2CompliantConcat(g, parentURI, "subModule$n$"));
      g.insertProperties(import_rdfoo10.node.createUriNode(parentURI), {
        [import_bioterms10.Predicates.SBOL2.module]: import_rdfoo10.node.createUriNode(scURI)
      });
      g.insertProperties(import_rdfoo10.node.createUriNode(scURI), {
        [import_bioterms10.Predicates.a]: import_rdfoo10.node.createUriNode(import_bioterms10.Types.SBOL2.Module),
        [import_bioterms10.Predicates.SBOL2.definition]: import_rdfoo10.node.createUriNode(identity.uri),
        [import_bioterms10.Predicates.SBOL2.displayId]: import_rdfoo10.node.createStringNode(identity.displayId)
      });
    }
    return new ActionResult();
  }

  // src/actions/object-cd/create-interaction.ts
  init_shim();
  var import_rdfoo11 = __toESM(require_dist());
  var import_assert10 = __toESM(require_assert());
  var import_sboljs14 = __toESM(require_dist5());
  var import_bioterms11 = __toESM(require_dist6());
  var createInteractionAction = {
    name: "interaction",
    description: "Creates an interaction",
    category: "object-cd",
    namedOpts: [
      {
        name: "",
        type: OptIdentity
      },
      {
        name: "type",
        type: OptTerm,
        optional: false
      }
    ],
    positionalOpts: [
      {
        name: "",
        type: OptIdentity,
        optional: true
      }
    ],
    run: createInteraction
  };
  var create_interaction_default = createInteractionAction;
  function createInteraction(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      trace(text("createInteraction"));
      let [optNamedIdentity, optType] = namedOpts;
      (0, import_assert10.strict)(optNamedIdentity instanceof Opt);
      (0, import_assert10.strict)(optType instanceof OptTerm);
      let [optPositionalIdentity] = positionalOpts;
      (0, import_assert10.strict)(!optPositionalIdentity || optPositionalIdentity instanceof OptIdentity);
      let identity = (optPositionalIdentity || optNamedIdentity).getIdentity(ctx, "MustNotExist" /* MustNotExist */);
      (0, import_assert10.strict)(identity !== void 0);
      let parentURI = "";
      if (identity.parentURI) {
        parentURI = identity.parentURI;
        identity = Identity.toplevel_from_namespace_displayId("MustNotExist" /* MustNotExist */, identity.sbolVersion, g, identity.namespace, identity.displayId, identity.version);
      }
      if (!parentURI) {
        throw new ActionResult(text("Interaction must have a parent"));
      }
      let _type = optType.getTerm("InteractionType" /* InteractionType */);
      (0, import_assert10.strict)(_type);
      switch (identity.sbolVersion) {
        case "SBOL2" /* SBOL2 */:
          return createInteractionSBOL2(g, identity, parentURI, _type);
        case "SBOL3" /* SBOL3 */:
          return createInteractionSBOL3(g, identity, parentURI, _type);
        default:
          throw new ActionResult(text("Unsupported SBOL version for create-component"));
      }
      return new ActionResult();
    });
  }
  function createInteractionSBOL2(g, identity, parentURI, _type) {
    let gv = new import_sboljs14.SBOL2GraphView(g);
    g.insertProperties(import_rdfoo11.node.createUriNode(identity.uri), {
      [import_bioterms11.Predicates.a]: import_rdfoo11.node.createUriNode(import_bioterms11.Types.SBOL2.Interaction),
      [import_bioterms11.Predicates.SBOL2.displayId]: import_rdfoo11.node.createStringNode(identity.displayId),
      [import_bioterms11.Predicates.SBOL2.type]: import_rdfoo11.node.createUriNode(_type)
    });
    if (identity.version !== void 0) {
      g.insertProperties(import_rdfoo11.node.createUriNode(identity.uri), {
        [import_bioterms11.Predicates.SBOL2.version]: import_rdfoo11.node.createStringNode(identity.version)
      });
    }
    g.insertProperties(import_rdfoo11.node.createUriNode(parentURI), {
      [import_bioterms11.Predicates.SBOL2.interaction]: import_rdfoo11.node.createUriNode(identity.uri)
    });
    return new ActionResult();
  }
  function createInteractionSBOL3(g, identity, parentURI, _type) {
    let gv = new import_sboljs14.SBOL3GraphView(g);
    let namespace3 = identity.namespace;
    (0, import_assert10.strict)(namespace3);
    g.insertProperties(import_rdfoo11.node.createUriNode(identity.uri), {
      [import_bioterms11.Predicates.a]: import_rdfoo11.node.createUriNode(import_bioterms11.Types.SBOL3.Interaction),
      [import_bioterms11.Predicates.SBOL3.displayId]: import_rdfoo11.node.createStringNode(identity.displayId)
    });
    g.insertProperties(import_rdfoo11.node.createUriNode(parentURI), {
      [import_bioterms11.Predicates.SBOL3.hasInteraction]: import_rdfoo11.node.createUriNode(identity.uri)
    });
    return new ActionResult();
  }

  // src/actions/object-cd/create-participation.ts
  init_shim();
  var import_rdfoo12 = __toESM(require_dist());
  var import_assert11 = __toESM(require_assert());
  var import_sboljs15 = __toESM(require_dist5());
  var import_bioterms12 = __toESM(require_dist6());
  var createParticipationAction = {
    name: "participation",
    description: "Creates a participation",
    category: "object-cd",
    namedOpts: [
      {
        name: "",
        type: OptIdentity
      },
      {
        name: "participant",
        type: OptIdentity,
        optional: true
      },
      {
        name: "role",
        type: OptTerm,
        optional: false
      }
    ],
    positionalOpts: [
      {
        name: "",
        type: OptIdentity,
        optional: true
      }
    ],
    run: createParticipation
  };
  var create_participation_default = createParticipationAction;
  function createParticipation(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      trace(text("createParticipation"));
      let [optNamedIdentity, optParticipant, optRole] = namedOpts;
      (0, import_assert11.strict)(optNamedIdentity instanceof Opt);
      (0, import_assert11.strict)(optParticipant instanceof OptIdentity);
      (0, import_assert11.strict)(optRole instanceof OptTerm);
      let [optPositionalIdentity] = positionalOpts;
      (0, import_assert11.strict)(!optPositionalIdentity || optPositionalIdentity instanceof OptIdentity);
      let identity = (optPositionalIdentity || optNamedIdentity).getIdentity(ctx, "MustNotExist" /* MustNotExist */);
      (0, import_assert11.strict)(identity !== void 0);
      if (!identity.parentURI) {
        throw new ActionResult(text("Participation must have a parent"));
      }
      let participantIdentity = optParticipant.getIdentity(ctx, "MustExist" /* MustExist */);
      (0, import_assert11.strict)(participantIdentity);
      let role = optRole.getTerm("ParticipationRole" /* ParticipationRole */);
      (0, import_assert11.strict)(role);
      switch (identity.sbolVersion) {
        case "SBOL2" /* SBOL2 */:
          return createParticipationSBOL2(g, identity, participantIdentity, role);
        case "SBOL3" /* SBOL3 */:
          return createParticipationSBOL3(g, identity, participantIdentity, role);
        default:
          throw new ActionResult(text("Unsupported SBOL version for create-component"));
      }
      return new ActionResult();
    });
  }
  function createParticipationSBOL2(g, identity, participantIdentity, role) {
    let gv = new import_sboljs15.SBOL2GraphView(g);
    g.insertProperties(import_rdfoo12.node.createUriNode(identity.uri), {
      [import_bioterms12.Predicates.a]: import_rdfoo12.node.createUriNode(import_bioterms12.Types.SBOL2.Participation),
      [import_bioterms12.Predicates.SBOL2.displayId]: import_rdfoo12.node.createStringNode(identity.displayId),
      [import_bioterms12.Predicates.SBOL2.role]: import_rdfoo12.node.createUriNode(role)
    });
    if (identity.version !== void 0) {
      g.insertProperties(import_rdfoo12.node.createUriNode(identity.uri), {
        [import_bioterms12.Predicates.SBOL2.version]: import_rdfoo12.node.createStringNode(identity.version)
      });
    }
    g.insertProperties(import_rdfoo12.node.createUriNode(identity.parentURI), {
      [import_bioterms12.Predicates.SBOL2.participation]: import_rdfoo12.node.createUriNode(identity.uri)
    });
    if (participantIdentity) {
      g.insertProperties(import_rdfoo12.node.createUriNode(identity.uri), {
        [import_bioterms12.Predicates.SBOL2.participant]: import_rdfoo12.node.createUriNode(participantIdentity.uri)
      });
    }
    return new ActionResult();
  }
  function createParticipationSBOL3(g, identity, participantIdentity, role) {
    let gv = new import_sboljs15.SBOL3GraphView(g);
    let namespace3 = identity.namespace;
    (0, import_assert11.strict)(namespace3);
    g.insertProperties(import_rdfoo12.node.createUriNode(identity.uri), {
      [import_bioterms12.Predicates.a]: import_rdfoo12.node.createUriNode(import_bioterms12.Types.SBOL3.Participation),
      [import_bioterms12.Predicates.SBOL3.displayId]: import_rdfoo12.node.createStringNode(identity.displayId),
      [import_bioterms12.Predicates.SBOL3.role]: import_rdfoo12.node.createUriNode(role)
    });
    g.insertProperties(import_rdfoo12.node.createUriNode(identity.parentURI), {
      [import_bioterms12.Predicates.SBOL3.hasParticipation]: import_rdfoo12.node.createUriNode(identity.uri)
    });
    if (participantIdentity) {
      g.insertProperties(import_rdfoo12.node.createUriNode(identity.uri), {
        [import_bioterms12.Predicates.SBOL3.participant]: import_rdfoo12.node.createUriNode(participantIdentity.uri)
      });
    }
    return new ActionResult();
  }

  // src/actions/render.ts
  init_shim();
  var fetch5 = require_browser5();
  var fs3 = require_fs();
  var renderAction = {
    name: "synbiocad-render",
    category: "other",
    namedOpts: [],
    positionalOpts: [],
    run: render
  };
  var render_default = renderAction;
  function render(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      return new ActionResult(group([]));
    });
  }

  // src/actions/annotate-range.ts
  init_shim();
  var import_assert12 = __toESM(require_assert());

  // src/actions/opt/Opt1BasedInt.ts
  init_shim();
  var Opt1BasedInt = class extends Opt {
    constructor(actDef, optDef, argv) {
      super(actDef, optDef, argv);
    }
    getInt(g) {
      let s = this.argv.getString(this.optDef.name, "");
      let n = parseInt(s);
      if (n < 1) {
        throw new Error("1 based int must be >= 1");
      }
      return n;
    }
  };

  // src/actions/annotate-range.ts
  var annotateRangeAction = {
    name: "annotate-range",
    description: "Annotates a range in a sequence",
    category: "seq-anno",
    namedOpts: [
      {
        name: "",
        type: OptIdentity
      },
      {
        name: "in-component",
        type: OptIdentity
      },
      {
        name: "start",
        type: Opt1BasedInt
      },
      {
        name: "end",
        type: Opt1BasedInt
      },
      {
        name: "role",
        type: Opt1BasedInt
      }
    ],
    positionalOpts: [],
    run: annotateRange,
    help: `
`
  };
  var annotate_range_default = annotateRangeAction;
  function annotateRange(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let [optIdentity, optInComponentIdentity, optSource, optEncoding] = namedOpts;
      let g = ctx.getCurrentGraph();
      (0, import_assert12.strict)(optIdentity instanceof OptIdentity);
      (0, import_assert12.strict)(optInComponentIdentity instanceof OptIdentity);
      (0, import_assert12.strict)(optSource instanceof OptURL);
      (0, import_assert12.strict)(optEncoding instanceof OptString);
      let identity = optIdentity.getIdentity(ctx, "MustExist" /* MustExist */);
      (0, import_assert12.strict)(identity !== void 0);
      if (identity.sbolVersion === "SBOL1" /* SBOL1 */) {
        throw new ActionResult(text("SBOL1 does not support sequence annotations without subcomponents.  Instead, create and assign a subcomponent using the create-component and add-subcomponent actions."), 0 /* Abort */);
      }
      return new ActionResult();
    });
  }

  // src/actions/add-subcomponent.ts
  init_shim();
  var addSubcomponentAction = {
    name: "create-component",
    description: "Creates a component",
    category: "object-cd",
    namedOpts: [
      {
        name: "",
        type: OptIdentity
      },
      {
        name: "within-component",
        type: OptIdentity,
        optional: true
      }
    ],
    positionalOpts: [],
    run: addSubcomponent
  };
  var add_subcomponent_default = addSubcomponentAction;
  function addSubcomponent(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      return actionResult(text(""));
    });
  }

  // src/actions/object-cd/create-participant.ts
  init_shim();
  var import_rdfoo13 = __toESM(require_dist());
  var import_assert13 = __toESM(require_assert());
  var import_sboljs16 = __toESM(require_dist5());
  var import_bioterms13 = __toESM(require_dist6());
  var createParticipantAction = {
    name: "participant",
    description: "Shorthand for creating a participation with a participant",
    category: "object-cd",
    namedOpts: [
      {
        name: "",
        type: OptIdentity
      },
      {
        name: "within-interaction",
        type: OptIdentity,
        optional: true
      },
      {
        name: "role",
        type: OptTerm,
        optional: false
      }
    ],
    positionalOpts: [],
    run: createParticipant
  };
  var create_participant_default = createParticipantAction;
  function createParticipant(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      trace(text("createParticipant"));
      let [optIdentity, optWithinInteractionIdentity, optRole] = namedOpts;
      (0, import_assert13.strict)(optIdentity instanceof OptIdentity);
      (0, import_assert13.strict)(optWithinInteractionIdentity instanceof OptIdentity);
      (0, import_assert13.strict)(optRole instanceof OptTerm);
      let withinInteractionIdentity = optWithinInteractionIdentity.getIdentity(ctx, "MayExist" /* MayExist */);
      let identity = optIdentity.getIdentity(ctx, "MustExist" /* MustExist */, withinInteractionIdentity);
      (0, import_assert13.strict)(identity !== void 0);
      if (!withinInteractionIdentity) {
        if (identity.parentURI) {
          withinInteractionIdentity = Identity.from_namespace_and_identity("MustExist" /* MustExist */, identity.sbolVersion, g, identity.namespace, identity.parentURI, identity.version);
        }
      }
      (0, import_assert13.strict)(withinInteractionIdentity !== void 0);
      if (!withinInteractionIdentity) {
        throw new ActionResult(text("Participation must be contained by an interaction"));
      }
      let role = optRole.getTerm(TermType.ParticipationRole);
      (0, import_assert13.strict)(role);
      switch (identity.sbolVersion) {
        case "SBOL2" /* SBOL2 */:
          return createParticipantSBOL2(g, identity, withinInteractionIdentity, role);
        case "SBOL3" /* SBOL3 */:
          return createParticipantSBOL3(g, identity, withinInteractionIdentity, role);
        default:
          throw new ActionResult(text("Unsupported SBOL version for participant action"));
      }
      return new ActionResult();
    });
  }
  function createParticipantSBOL2(g, participantIdentity, withinInteractionIdentity, role) {
    let gv = new import_sboljs16.SBOL2GraphView(g);
    let participationURI = g.generateURI(joinURIFragments([withinInteractionIdentity.uri, "participation$n$"]));
    let participationDisplayId = participationURI.split("/").pop();
    g.insertProperties(import_rdfoo13.node.createUriNode(participationURI), {
      [import_bioterms13.Predicates.a]: import_rdfoo13.node.createUriNode(import_bioterms13.Types.SBOL2.Participation),
      [import_bioterms13.Predicates.SBOL2.displayId]: import_rdfoo13.node.createStringNode(participationDisplayId),
      [import_bioterms13.Predicates.SBOL2.role]: import_rdfoo13.node.createUriNode(role),
      [import_bioterms13.Predicates.SBOL2.participant]: import_rdfoo13.node.createUriNode(participantIdentity.uri)
    });
    g.insertProperties(import_rdfoo13.node.createUriNode(withinInteractionIdentity.uri), {
      [import_bioterms13.Predicates.SBOL2.participation]: import_rdfoo13.node.createUriNode(participationURI)
    });
    return new ActionResult();
  }
  function createParticipantSBOL3(g, participantIdentity, withinInteractionIdentity, role) {
    let gv = new import_sboljs16.SBOL3GraphView(g);
    let participationURI = g.generateURI(joinURIFragments([withinInteractionIdentity.uri, "participation$n$"]));
    let participationDisplayId = participationURI.split("/").pop();
    g.insertProperties(import_rdfoo13.node.createUriNode(participationURI), {
      [import_bioterms13.Predicates.a]: import_rdfoo13.node.createUriNode(import_bioterms13.Types.SBOL3.Participation),
      [import_bioterms13.Predicates.SBOL3.displayId]: import_rdfoo13.node.createStringNode(participationDisplayId),
      [import_bioterms13.Predicates.SBOL3.role]: import_rdfoo13.node.createUriNode(role),
      [import_bioterms13.Predicates.SBOL3.participant]: import_rdfoo13.node.createUriNode(participantIdentity.uri)
    });
    g.insertProperties(import_rdfoo13.node.createUriNode(withinInteractionIdentity.uri), {
      [import_bioterms13.Predicates.SBOL3.hasParticipation]: import_rdfoo13.node.createUriNode(participationURI)
    });
    return new ActionResult();
  }

  // src/actions/dump-graph.ts
  init_shim();
  var import_sboljs17 = __toESM(require_dist5());
  var fs4 = require_fs();
  var action = {
    name: "graph-dump",
    category: "graphops",
    namedOpts: [
      {
        name: "title",
        type: OptString,
        optional: true
      }
    ],
    positionalOpts: [],
    run: dumpGraph
  };
  var dump_graph_default = action;
  function dumpGraph(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      let [titleOpt] = namedOpts;
      let title = "Graph dump";
      if (titleOpt) {
        title += ": " + titleOpt.getString(g);
      }
      return actionResult(group([
        spacer(),
        header(title),
        spacer(),
        indent([
          text(new import_sboljs17.SBOL3GraphView(g).serializeXML())
        ])
      ]));
    });
  }

  // src/actions/show-graphs.ts
  init_shim();
  var fs5 = require_fs();
  var action2 = {
    name: "show-graphs",
    category: "graphops",
    namedOpts: [],
    positionalOpts: [],
    run: showGraphs
  };
  var show_graphs_default = action2;
  function showGraphs(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let g = ctx.getCurrentGraph();
      let title = "Graphs (" + ctx.graphs.size + ")";
      return actionResult(group([
        spacer(),
        header(title),
        spacer(),
        indent([
          tabulated(Array.from(ctx.graphs.keys()).map((k) => {
            return [k, ctx.graphs.get(k).toArray().length.toString()];
          }))
        ])
      ]));
    });
  }

  // src/actions/graph.ts
  init_shim();
  var fs6 = require_fs();
  var assert17 = require_assert();
  var action3 = {
    name: "graph",
    category: "graphops",
    namedOpts: [],
    positionalOpts: [
      {
        name: "graph_name",
        type: OptString,
        optional: true
      }
    ],
    run: graph
  };
  var graph_default = action3;
  function graph(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      if (positionalOpts.length !== 1) {
        throw new ActionResult(text("graph action needs exactly one parameter: the name of the graph to switch to"));
      }
      let graphNameOpt = positionalOpts[0];
      assert17(graphNameOpt instanceof OptString);
      let graphName = graphNameOpt.getString(ctx.getCurrentGraph());
      ctx.setCurrentGraph(graphName);
      return actionResult();
    });
  }

  // src/actions/compare.ts
  init_shim();

  // src/actions/opt/OptGraph.ts
  init_shim();
  var OptGraphName = class extends Opt {
    constructor(actDef, optDef, argv) {
      super(actDef, optDef, argv);
    }
    getGraph(ctx) {
      let s = this.argv.getString(this.optDef.name, "");
      let g = ctx.getGraph(s);
      return g;
    }
  };

  // src/actions/compare.ts
  var import_assert14 = __toESM(require_assert());
  var import_bioterms14 = __toESM(require_dist6());
  var import_rdfoo14 = __toESM(require_dist());

  // src/actions/opt/OptTriplePattern.ts
  init_shim();
  var OptTriplePattern = class extends Opt {
    constructor(actDef, optDef, argv) {
      super(actDef, optDef, argv);
    }
    getPattern() {
      let pattern = this.argv.getString(this.optDef.name, "");
      if (!pattern)
        return void 0;
      let spo = pattern.split(/\s+/);
      return {
        s: new RegExp(spo[0]),
        p: new RegExp(spo[1]),
        o: new RegExp(spo[2])
      };
    }
  };

  // src/actions/compare.ts
  var fs7 = require_fs();
  var action4 = {
    name: "compare",
    category: "graphops",
    namedOpts: [
      {
        name: "to",
        type: OptGraphName,
        optional: false
      },
      {
        name: "ignore",
        type: OptTriplePattern,
        optional: true
      }
    ],
    positionalOpts: [],
    run: graphCompare
  };
  var compare_default = action4;
  function graphCompare(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let [to, ignore] = namedOpts;
      (0, import_assert14.strict)(to instanceof OptGraphName);
      (0, import_assert14.strict)(ignore instanceof OptTriplePattern);
      let ignorePattern = ignore.getPattern();
      let fromGraph = ctx.getCurrentGraph();
      let toGraph = to.getGraph(ctx);
      let fromGraphName = Array.from(ctx.graphs.entries()).filter((e) => e[1] === fromGraph)[0][0];
      let toGraphName = Array.from(ctx.graphs.entries()).filter((e) => e[1] === toGraph)[0][0];
      trace(text("fromGraph (" + fromGraphName + ") has size " + fromGraph.toArray().length));
      trace(text("toGraph (" + toGraphName + ") has size " + toGraph.toArray().length));
      (0, import_assert14.strict)(toGraph);
      let equal = true;
      let inFromOnly = [];
      let inToOnly = [];
      let subjects = /* @__PURE__ */ new Set();
      for (let triple6 of fromGraph.toArray()) {
        if (ignorePattern) {
          if (ignorePattern.s.test(triple6.subject.value) && ignorePattern.p.test(triple6.predicate.value) && ignorePattern.o.test(triple6.object.value)) {
            continue;
          }
        }
        if (!toGraph.hasMatch(triple6.subject, triple6.predicate, triple6.object)) {
          equal = false;
          inFromOnly.push([
            triple6.subject.value,
            triple6.predicate.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" ? "a" : triple6.predicate.value,
            triple6.object.value
          ]);
          subjects.add(triple6.subject.value);
          subjects.add(triple6.object.value);
        }
      }
      for (let triple6 of toGraph.toArray()) {
        if (ignorePattern) {
          if (ignorePattern.s.test(triple6.subject.value) && ignorePattern.p.test(triple6.predicate.value) && ignorePattern.o.test(triple6.object.value)) {
            continue;
          }
        }
        if (!fromGraph.hasMatch(triple6.subject, triple6.predicate, triple6.object)) {
          equal = false;
          inToOnly.push([
            triple6.subject.value,
            triple6.predicate.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" ? "a" : triple6.predicate.value,
            triple6.object.value
          ]);
          subjects.add(triple6.subject.value);
          subjects.add(triple6.object.value);
        }
      }
      let typesInFrom = [];
      let typesInTo = [];
      for (let subject of subjects) {
        let type = import_rdfoo14.triple.objectUri(fromGraph.match(import_rdfoo14.node.createUriNode(subject), import_bioterms14.Predicates.a, null)[0]);
        if (type)
          typesInFrom.push([subject, "a", type]);
      }
      for (let subject of subjects) {
        let type = import_rdfoo14.triple.objectUri(toGraph.match(import_rdfoo14.node.createUriNode(subject), import_bioterms14.Predicates.a, null)[0]);
        if (type)
          typesInTo.push([subject, "a", type]);
      }
      let out = [];
      if (equal) {
        out.push(text("compare: Graphs were equal"));
        return actionResult(group(out));
      } else {
        out.push(text("compare: Graphs were not equal"));
        out.push(spacer());
        if (inFromOnly.length > 0) {
          out.push(spacer());
          out.push(text("In current graph (" + fromGraphName + ") but not comparison graph (" + toGraphName + "):"));
          out.push(indent([
            tabulated(inFromOnly)
          ]));
        }
        if (inToOnly.length > 0) {
          out.push(spacer());
          out.push(text("In comparison graph (" + toGraphName + ") but not current graph (" + fromGraphName + "):"));
          out.push(indent([
            tabulated(inToOnly)
          ]));
        }
        return actionResultAbort(group(out));
      }
    });
  }

  // src/actions/merge.ts
  init_shim();
  var import_assert15 = __toESM(require_assert());
  var fs8 = require_fs();
  var action5 = {
    name: "merge",
    category: "graphops",
    namedOpts: [
      {
        name: "from",
        type: OptGraphName,
        optional: false
      }
    ],
    positionalOpts: [],
    run: graphMerge
  };
  var merge_default = action5;
  function graphMerge(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let [from] = namedOpts;
      (0, import_assert15.strict)(from instanceof OptGraphName);
      let toGraph = ctx.getCurrentGraph();
      let fromGraph = from.getGraph(ctx);
      (0, import_assert15.strict)(fromGraph);
      toGraph.addAll(fromGraph);
      return actionResult();
    });
  }

  // src/actions/insert.ts
  init_shim();
  var import_rdfoo15 = __toESM(require_dist());
  var fs9 = require_fs();
  var action6 = {
    name: "insert",
    category: "graphops",
    namedOpts: [
      {
        name: "subject",
        type: OptString,
        optional: false
      },
      {
        name: "predicate",
        type: OptString,
        optional: false
      },
      {
        name: "object",
        type: OptString,
        optional: false
      }
    ],
    positionalOpts: [],
    run: graphInsert
  };
  var insert_default = action6;
  function graphInsert(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let [subject, predicate, object] = namedOpts;
      let g = ctx.getCurrentGraph();
      g.insertProperties(import_rdfoo15.node.createUriNode(subject.getString(g)), {
        [predicate.getString(g)]: import_rdfoo15.node.createStringNode(object.getString(g))
      });
      return actionResult();
    });
  }

  // src/actions/namespace.ts
  init_shim();
  var fs10 = require_fs();
  var assert20 = require_assert();
  var action7 = {
    name: "namespace",
    category: "graphops",
    namedOpts: [],
    positionalOpts: [
      {
        name: "",
        type: OptString,
        optional: false
      }
    ],
    run: namespace2,
    help: `
Sets the default namespace for actions which accept an identity parameter. This namespace can be overridden per-action with --identity.
`
  };
  var namespace_default2 = action7;
  function namespace2(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      if (positionalOpts.length !== 1) {
        throw new ActionResult(text("namespace action needs exactly one parameter: the URI of a namespace to set as current"));
      }
      let nsOpt = positionalOpts[0];
      assert20(nsOpt instanceof OptString);
      let ns = nsOpt.getString(ctx.getCurrentGraph());
      ctx.currentNamespace = ns;
      return actionResult();
    });
  }

  // src/actions/sbol-version.ts
  init_shim();
  var fs11 = require_fs();
  var assert21 = require_assert();
  var action8 = {
    name: "sbol-version",
    category: "graphops",
    namedOpts: [],
    positionalOpts: [
      {
        name: "",
        type: OptString,
        optional: false
      }
    ],
    run: sbolVersion,
    help: `
Sets the default SBOL version 1/2/3 for actions which create SBOL objects. This namespace can be overridden per-action with --sbol-version.
`
  };
  var sbol_version_default = action8;
  function sbolVersion(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      if (positionalOpts.length !== 1) {
        throw new ActionResult(text("sbol-version action needs exactly one parameter: an SBOL version 1/2/3"));
      }
      let versionOpt = positionalOpts[0];
      assert21(versionOpt instanceof OptString);
      let version = versionOpt.getString(ctx.getCurrentGraph());
      if (version === "1") {
        ctx.sbolVersion = "SBOL1" /* SBOL1 */;
      } else if (version === "2") {
        ctx.sbolVersion = "SBOL2" /* SBOL2 */;
      } else if (version === "3") {
        ctx.sbolVersion = "SBOL3" /* SBOL3 */;
      } else {
        throw new ActionResult(text("unknown SBOL version: " + version));
      }
      return actionResult();
    });
  }

  // src/actions/run-tests.ts
  init_shim();

  // test/run-tests.ts
  init_shim();

  // test/graph-ops/index.ts
  init_shim();

  // test/graph-ops/multigraph.ts
  init_shim();
  var import_rdfoo16 = __toESM(require_dist());
  var import_assert16 = __toESM(require_assert());
  var tests = [
    {
      id: "graphops-switch-graph-1",
      name: "Switch from one graph to another (test 1)",
      command: `
            --trace
            --output sbol

            graph a
                insert --subject "http://s" --predicate "http://p" --object "o"

            graph b
                insert --subject "http://s" --predicate "http://p" --object "o2"

            graph a
        `,
      validate: (r) => __async(void 0, null, function* () {
        if (r === void 0) {
          throw new Error("no output");
        }
        let g = yield import_rdfoo16.Graph.loadString(r);
        (0, import_assert16.strict)(g.hasMatch(import_rdfoo16.node.createUriNode("http://s"), "http://p", import_rdfoo16.node.createStringNode("o")));
        (0, import_assert16.strict)(!g.hasMatch(import_rdfoo16.node.createUriNode("http://s"), "http://p", import_rdfoo16.node.createStringNode("o2")));
        (0, import_assert16.strict)(g.toArray().length === 1);
      })
    },
    {
      id: "graphops-switch-graph-2",
      name: "Switch from one graph to another (test 2)",
      command: `
            --trace
            --output sbol

            graph a
                insert --subject "http://s" --predicate "http://p" --object "o"

            graph b
                insert --subject "http://s" --predicate "http://p" --object "o2"
        `,
      validate: (r) => __async(void 0, null, function* () {
        if (r === void 0) {
          throw new Error("no output");
        }
        let g = yield import_rdfoo16.Graph.loadString(r);
        (0, import_assert16.strict)(g.hasMatch(import_rdfoo16.node.createUriNode("http://s"), "http://p", import_rdfoo16.node.createStringNode("o2")));
        (0, import_assert16.strict)(!g.hasMatch(import_rdfoo16.node.createUriNode("http://s"), "http://p", import_rdfoo16.node.createStringNode("o")));
        (0, import_assert16.strict)(g.toArray().length === 1);
      })
    }
  ];
  var multigraph_default = tests;

  // test/graph-ops/merge.ts
  init_shim();
  var import_rdfoo17 = __toESM(require_dist());
  var import_assert17 = __toESM(require_assert());
  var tests2 = [
    {
      id: "graphops-merge",
      name: "Merge one graph into another",
      command: `
            --trace
            --output sbol

            graph a
                insert --subject "http://s" --predicate "http://p" --object "o"

            graph b
                merge --from a
        `,
      validate: (r) => __async(void 0, null, function* () {
        if (r === void 0) {
          throw new Error("no output");
        }
        let g = yield import_rdfoo17.Graph.loadString(r);
        (0, import_assert17.strict)(g.hasMatch(import_rdfoo17.node.createUriNode("http://s"), "http://p", import_rdfoo17.node.createStringNode("o")));
        (0, import_assert17.strict)(!g.hasMatch(import_rdfoo17.node.createUriNode("http://s"), "http://p", import_rdfoo17.node.createStringNode("o2")));
        (0, import_assert17.strict)(g.toArray().length === 1);
      })
    }
  ];
  var merge_default2 = tests2;

  // test/graph-ops/dump.ts
  init_shim();
  var tests3 = [
    {
      id: "graphops-dump",
      name: "Dump the graph",
      command: `
            --trace

            graph a
                insert --subject "http://s" --predicate "http://p" --object "o"
                graph-dump

        `,
      validate: (r) => __async(void 0, null, function* () {
      })
    },
    {
      id: "graphops-dump-with-title",
      name: "Dump the graph with a title",
      command: `
            --trace

            graph a
                insert --subject "http://s" --predicate "http://p" --object "o"
                graph-dump --title "Test title"

        `,
      validate: (r) => __async(void 0, null, function* () {
      })
    }
  ];
  var dump_default = tests3;

  // test/graph-ops/index.ts
  var graph_ops_default = [
    ...dump_default,
    ...merge_default2,
    ...multigraph_default
  ];

  // test/sbol1/index.ts
  init_shim();

  // test/sbol1/create-component.ts
  init_shim();
  var import_rdfoo18 = __toESM(require_dist());
  var import_sboljs18 = __toESM(require_dist5());
  var import_assert18 = __toESM(require_assert());
  var tests4 = [
    {
      id: "sbol1-create-component-001",
      name: "Create SBOL1 component",
      command: `
            --trace
            --output sbol
            sbol-version 1
            namespace "http://example.com/"
            component lac_inverter
        `,
      validate: (r) => __async(void 0, null, function* () {
        if (r === void 0) {
          throw new Error("no output");
        }
        let g = yield import_rdfoo18.Graph.loadString(r);
        let gv = new import_sboljs18.SBOL1GraphView(g);
        let matches = gv.dnaComponents.filter((c) => {
          return c.subject.value === "http://example.com/lac_inverter" && c.displayId === "lac_inverter";
        });
        (0, import_assert18.strict)(matches.length === 1);
      })
    },
    {
      id: "sbol1-create-component-002",
      name: "Create SBOL1 component with a subcomponent",
      command: `
            --trace
            --output sbol
            sbol-version 1
            namespace "http://example.com/"
            component lac_inverter
            graph-dump
            component lac_inverter.pLac
        `,
      validate: (r) => __async(void 0, null, function* () {
        if (r === void 0) {
          throw new Error("no output");
        }
        let g = yield import_rdfoo18.Graph.loadString(r);
        let gv = new import_sboljs18.SBOL1GraphView(g);
        let matches = gv.dnaComponents.filter((c2) => {
          return c2.subject.value === "http://example.com/lac_inverter" && c2.displayId === "lac_inverter";
        });
        if (matches.length !== 1) {
          throw new Error("matching component not found: " + matches.length);
        }
        let c = matches[0];
        (0, import_assert18.strict)(c.subComponents.length === 1);
        (0, import_assert18.strict)(c.subComponents[0].displayId === "pLac");
      })
    }
  ];
  var create_component_default2 = tests4;

  // test/sbol1/index.ts
  var sbol1_default = [
    ...create_component_default2
  ];

  // test/sbol2/index.ts
  init_shim();

  // test/sbol2/crispr.ts
  init_shim();
  var import_rdfoo19 = __toESM(require_dist());
  var import_sboljs19 = __toESM(require_dist5());
  var import_assert19 = __toESM(require_assert());
  var tests5 = [
    {
      id: "sbol2-crispr-001",
      name: "CRISPR example",
      command: `
            --trace
            --output sbol
            namespace "http://example.com/"
            sbol-version 2
            component cas9_generic --type Protein
            component gRNA_generic --type RNA --role SO:0001998
            component cas9_gRNA_complex --type Complex
            component target_gene --type DNA --role Promoter
            component target --type Protein
            module CRISPR_Template
                interaction CRISPR_Template.cas9_complex_formation --type NonCovalentBinding
                    participation CRISPR_Template.cas9_complex_formation.cas9_generic --participant cas9_generic --role Reactant
                    participation CRISPR_Template.cas9_complex_formation.gRNA_generic --participant gRNA_generic --role Reactant
                    participation CRISPR_Template.cas9_complex_formation.cas9_gRNA_complex --participant cas9_gRNA_complex --role Product
                interaction CRISPR_Template.target_production --type GeneticProduction
                    participation CRISPR_Template.target_production.participant_target_gene --participant target_gene --role Promoter
                    participation CRISPR_Template.target_production.participant_target --participant target --role Product
                interaction CRISPR_Template.target_gene_inhibition --type Inhibition
                    participation CRISPR_Template.target_gene_inhibition.participant_cas9_gRNA_complex --participant cas9_gRNA_complex --role Inhibitor
                    participation CRISPR_Template.target_gene_inhibition.participant_target_gene --participant target_gene --role Promoter
            component EYFP_gene --type DNA 
            component EYFP_gene.CRP_b --type DNA --role Promoter
            sequence CRP_b_seq --for-component CRP_b --source ./test/data/CRP_b.fasta
            component EYFP_gene.EYFP_cds --type DNA --role CDS
            graph-dump
            constraint EYFP_gene.EYFP_gene_constraint --subject EYFP_gene.CRP_b --restriction Precedes --object EYFP_gene.EYFP_cds
        `,
      validate: (r) => __async(void 0, null, function* () {
        if (r === void 0) {
          throw new Error("no output");
        }
        let g = yield import_rdfoo19.Graph.loadString(r);
        let gv = new import_sboljs19.SBOL2GraphView(g);
        checkCrisprExample(g, gv);
      })
    }
  ];
  var crispr_default = tests5;
  function checkCrisprExample(g, gv) {
    var _a, _b, _c;
    (0, import_assert19.strict)(gv.componentDefinitions.filter((c) => c.displayId === "cas9_generic").length === 1);
    (0, import_assert19.strict)(gv.componentDefinitions.filter((c) => c.displayId === "gRNA_generic").length === 1);
    (0, import_assert19.strict)(gv.componentDefinitions.filter((c) => c.displayId === "cas9_gRNA_complex").length === 1);
    (0, import_assert19.strict)(gv.componentDefinitions.filter((c) => c.displayId === "target_gene").length === 1);
    (0, import_assert19.strict)(gv.componentDefinitions.filter((c) => c.displayId === "target").length === 1);
    (0, import_assert19.strict)(gv.moduleDefinitions.filter((c) => c.displayId === "CRISPR_Template").length === 1);
    let CRISPR_Template = gv.moduleDefinitions.filter((c) => c.displayId === "CRISPR_Template")[0];
    let cas9_complex_formation = CRISPR_Template.interactions.filter((i) => i.displayId === "cas9_complex_formation")[0];
    (0, import_assert19.strict)(cas9_complex_formation);
    (0, import_assert19.strict)(cas9_complex_formation.types.length === 1);
    (0, import_assert19.strict)(cas9_complex_formation.hasType("http://identifiers.org/biomodels.sbo/SBO:0000177"));
    (0, import_assert19.strict)(cas9_complex_formation.participations.length === 3);
    (0, import_assert19.strict)(cas9_complex_formation.participations.filter((p) => p.displayId === "cas9_generic").length === 1);
    (0, import_assert19.strict)(cas9_complex_formation.participations.filter((p) => p.displayId === "cas9_generic")[0].hasRole("http://identifiers.org/biomodels.sbo/SBO:0000010"));
    (0, import_assert19.strict)(((_a = cas9_complex_formation.participations.filter((p) => p.displayId === "cas9_generic")[0].participant) == null ? void 0 : _a.displayId) === "cas9_generic");
    (0, import_assert19.strict)(cas9_complex_formation.participations.filter((p) => p.displayId === "gRNA_generic").length === 1);
    (0, import_assert19.strict)(cas9_complex_formation.participations.filter((p) => p.displayId === "gRNA_generic")[0].hasRole("http://identifiers.org/biomodels.sbo/SBO:0000010"));
    (0, import_assert19.strict)(((_b = cas9_complex_formation.participations.filter((p) => p.displayId === "gRNA_generic")[0].participant) == null ? void 0 : _b.displayId) === "gRNA_generic");
    (0, import_assert19.strict)(cas9_complex_formation.participations.filter((p) => p.displayId === "cas9_gRNA_complex").length === 1);
    (0, import_assert19.strict)(cas9_complex_formation.participations.filter((p) => p.displayId === "cas9_gRNA_complex")[0].hasRole("http://identifiers.org/biomodels.sbo/SBO:0000011"));
    (0, import_assert19.strict)(((_c = cas9_complex_formation.participations.filter((p) => p.displayId === "cas9_gRNA_complex")[0].participant) == null ? void 0 : _c.displayId) === "cas9_gRNA_complex");
    let CRP_b_seq = gv.sequences.filter((seq) => seq.displayId === "CRP_b_seq")[0];
    (0, import_assert19.strict)(CRP_b_seq);
    (0, import_assert19.strict)(CRP_b_seq.elements);
    (0, import_assert19.strict)(gv.componentDefinitions.filter((c) => c.displayId === "CRP_b").length === 1);
    (0, import_assert19.strict)(gv.componentDefinitions.filter((c) => c.displayId === "CRP_b")[0].sequences.length === 1);
    (0, import_assert19.strict)(gv.componentDefinitions.filter((c) => c.displayId === "CRP_b")[0].sequences[0].displayId === "CRP_b_seq");
  }

  // test/sbol2/index.ts
  var sbol2_default = [
    ...crispr_default
  ];

  // test/sbol3/index.ts
  init_shim();

  // test/sbol3/sbol2-to-sbol3.ts
  init_shim();
  var import_rdfoo20 = __toESM(require_dist());
  var import_sboljs20 = __toESM(require_dist5());
  var tests6 = [
    {
      id: "sbol3-2to3conversion-001",
      name: "Convert SBOL2 to SBOL3",
      glob: [
        "tests-extra/SBOL2/m2.xml"
      ],
      globExclude: [
        "SBOLTestSuite/SBOL2/BBa_I0462.xml"
      ],
      command: (filename) => `
            --trace
            --output sbol

            graph orig
                import ${filename}

            graph converted
                merge --from orig
                graph-dump --title "Original SBOL2"
                convert --target-sbol-version 3
                graph-dump --title "SBOL2 -> SBOL3"
            
            graph roundtripped
                merge --from converted
                convert --target-sbol-version 2
                graph-dump --title "SBOL2 -> SBOL3 -> SBOL2"
                compare --to orig --ignore ".* .*backport.* .*"
	
	    show-graphs
        `,
      validate: (r) => __async(void 0, null, function* () {
        if (r === void 0) {
          throw new Error("no output");
        }
        let g = yield import_rdfoo20.Graph.loadString(r);
        let gv = new import_sboljs20.SBOL2GraphView(g);
      })
    }
  ];
  var sbol2_to_sbol3_default = tests6;

  // test/sbol3/index.ts
  var sbol3_default = [
    ...sbol2_to_sbol3_default
  ];

  // test/run-tests.ts
  var import_string_argv = __toESM(require_string_argv());
  var chalk3 = require_source();
  var glob = require_lib4();
  var tests7 = [
    ...graph_ops_default,
    ...sbol1_default,
    ...sbol2_default,
    ...sbol3_default
  ];
  function runTests() {
    return __async(this, null, function* () {
      let passes = [];
      let fails = [];
      var n = 0;
      for (let test of tests7) {
        ++n;
        let pass = true;
        if (test.glob) {
          let files = [];
          for (let g of test.glob) {
            files = files.concat(yield glob(g));
          }
          if (test.globExclude !== void 0) {
            files = files.filter((f) => {
              var _a;
              return ((_a = test.globExclude) == null ? void 0 : _a.indexOf(f)) === -1;
            });
          }
          print(text("Glob " + test.glob));
          print(text(files.length + " file(s)"));
          for (let file of files) {
            let c = test.command(file);
            print(text(`===== TEST [${n}/${tests7.length}]: ` + test.id + ": " + test.name + " " + file, "white bold"));
            print(text("      command: " + c, "white bold"));
            yield run(test, test.id + "#" + file.split("/").pop(), c);
          }
        } else {
          print(text(`===== TEST [${n}/${tests7.length}]: ` + test.id + ": " + test.name, "white bold"));
          print(text("      command: " + test.command, "white bold"));
          yield run(test, test.id, test.command);
        }
      }
      print(group([
        text(`===== PASSING:`, "white bold"),
        spacer(),
        indent(passes.map((t) => text(t, "green"))),
        spacer(),
        text(`===== FAILING:`, "white bold"),
        spacer(),
        indent(fails.map((t) => text(t, "red"))),
        spacer()
      ]));
      print(text(`===== SUMMARY: ${passes.length} test(s) passed, ${fails.length} test(s) failed`, "white bold"));
      if (fails.length > 0) {
        import_process.default.exitCode = 1;
      }
      function run(test, id, command) {
        return __async(this, null, function* () {
          let pass = true;
          beginCaptureOutput();
          try {
            var output = yield sboltools(["node", "just.a.unit.test"].concat((0, import_string_argv.default)(command)));
          } catch (e) {
            print(indent([spacer(), text("--- " + test.id + " failed at execution stage: " + e, "red bold"), indent([multiline(e.stack, "red bold")])]));
            pass = false;
          }
          let captured2 = endCaptureOutput();
          print(indent(captured2.map((node19) => {
            if (node19.type === "trace") {
              let t = tostring(0, node19.node);
              t = t.trim().split("\n").map((line) => "[trace] " + line).join("\n");
              t = chalk3.dim(t);
              return multiline(t);
            } else {
              let t = tostring(0, node19.node);
              return multiline(t);
            }
          })));
          if (output) {
            let lines = output.trim().split("\n").map((line) => text(line));
            print(indent(lines));
          }
          try {
            yield test.validate(output);
          } catch (e) {
            print(indent([spacer(), text("--- " + id + " failed at validation stage: " + e.stack, "red bold")]));
            pass = false;
          }
          if (pass) {
            print(spacer());
            print(text(`\u2705 Passed [${n}/${tests7.length}]: ` + id, "green bold"));
            print(spacer());
            passes.push(id);
          } else {
            print(spacer());
            print(text(`\u274C Failed [${n}/${tests7.length}]: ` + id, "red bold"));
            print(spacer());
            fails.push(id);
          }
          return pass;
        });
      }
    });
  }

  // src/actions/run-tests.ts
  var runTestsAction = {
    name: "run-tests",
    description: "Run tests of sboltools",
    category: "other",
    namedOpts: [],
    positionalOpts: [],
    run: doRunTests
  };
  var run_tests_default = runTestsAction;
  function doRunTests(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      yield runTests();
      return actionResult(text(""));
    });
  }

  // src/actions/object-cd/dna.ts
  init_shim();

  // src/actions/helpers/remap-opts.ts
  init_shim();
  var import_console2 = __toESM(require_console_browserify());

  // src/parse-argv.ts
  init_shim();
  var ArgvArgs = class {
    constructor(globalOpts, actions) {
      this.globalOpts = globalOpts;
      this.actions = actions;
    }
  };
  var ArgvAction = class {
    constructor(name, namedOpts, positionalOpts) {
      this.name = name;
      this.namedOpts = namedOpts;
      this.positionalOpts = positionalOpts;
    }
  };
  var ArgvNamedOption = class {
    constructor(name, value) {
      this.name = name;
      this.value = value;
    }
  };
  var ArgvOptionSet = class {
    constructor(opts) {
      this.opts = opts;
    }
    getStringOrUndefined(opt) {
      var _a;
      let value = (_a = this.opts.filter((o) => o.name === opt)[0]) == null ? void 0 : _a.value;
      return value;
    }
    getString(opt, def) {
      var _a;
      let value = (_a = this.opts.filter((o) => o.name === opt)[0]) == null ? void 0 : _a.value;
      return value === void 0 ? def : value;
    }
    getFlag(opt) {
      let value = this.opts.filter((o) => o.name === opt)[0];
      return value !== void 0;
    }
  };
  function parseArgv(argv) {
    let args = argv.slice(2);
    let globalOpts = [];
    let actions = [];
    while (args.length > 0) {
      let { type, name } = parseToken(args[0]);
      if (type === 0 /* Option */) {
        args.shift();
        let option = { name };
        if (args[0]) {
          if (parseToken(args[0]).type === 2 /* Other */) {
            option.value = args.shift();
          }
        }
        globalOpts.push(option);
        continue;
      } else {
        break;
      }
    }
    while (args.length > 0) {
      actions.push(parseAction());
    }
    return new ArgvArgs(new ArgvOptionSet(globalOpts), actions);
    function parseAction() {
      let name = args.shift();
      let def = actions_default.filter((a) => a.name === name)[0];
      let namedOpts = [];
      let positionalOpts = [];
      while (args.length > 0) {
        let { name: name2, type } = parseToken(args[0]);
        if (type === 1 /* Action */) {
          break;
        }
        if (type === 0 /* Option */) {
          let option = { name: name2 };
          args.shift();
          if (parseToken(args[0]).type !== 1 /* Action */) {
            option.value = args.shift();
          }
          namedOpts.push(option);
          continue;
        }
        positionalOpts.push(args[0]);
        args.shift();
      }
      return new ArgvAction(name, new ArgvOptionSet(namedOpts), positionalOpts);
    }
  }
  function isAction(str) {
    return actions_default.filter((a) => a.name === str).length > 0;
  }
  function parseToken(str) {
    if (/^-[^-]/g.test(str)) {
      return { type: 0 /* Option */, name: str.slice(1) };
    } else if (/^--[^-]/g.test(str)) {
      return { type: 0 /* Option */, name: str.slice(2) };
    } else if (isAction(str)) {
      return { type: 1 /* Action */ };
    } else {
      return { type: 2 /* Other */ };
    }
  }

  // src/actions/helpers/remap-opts.ts
  function remapOpts(thisActDef, actDefToMapTo, opts, newOptsToAdd) {
    let newOpts = actDefToMapTo.namedOpts.map((newOptDef) => {
      for (let n = 0; n < thisActDef.namedOpts.length; ++n) {
        let curOptDef = thisActDef.namedOpts[n];
        if (curOptDef.name == newOptDef.name) {
          return new newOptDef.type(actDefToMapTo, newOptDef, opts[n].argv);
        } else {
          let newVal = newOptsToAdd[newOptDef.name];
          (0, import_console2.assert)(newVal);
          let fakeArgv = new ArgvOptionSet([new ArgvNamedOption(newOptDef.name, newVal)]);
          let newOpt = new newOptDef.type(actDefToMapTo, newOptDef, fakeArgv);
          return newOpt;
        }
      }
      throw new Error("??");
    });
    return newOpts;
  }

  // src/actions/object-cd/dna.ts
  var dnaAction2 = {
    name: "dna",
    description: "Alias for `component --type DNA`; creates a DNA component",
    category: "object-cd",
    namedOpts: [
      {
        name: "",
        type: OptIdentity
      },
      {
        name: "role",
        type: OptTerm
      }
    ],
    positionalOpts: [],
    run: dna
  };
  var dna_default = dnaAction2;
  function dna(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let newOpts = remapOpts(dnaAction2, create_component_default, namedOpts, {
        type: "DNA"
      });
      return create_component_default.run(ctx, newOpts, positionalOpts);
    });
  }

  // src/actions/object-cd/protein.ts
  init_shim();
  var proteinAction = {
    name: "protein",
    description: "Alias for `component --type Protein`; creates a Protein component",
    category: "object-cd",
    namedOpts: [
      {
        name: "",
        type: OptIdentity
      },
      {
        name: "role",
        type: OptTerm
      }
    ],
    positionalOpts: [],
    run: protein
  };
  var protein_default = proteinAction;
  function protein(ctx, namedOpts, positionalOpts) {
    return __async(this, null, function* () {
      let newOpts = remapOpts(dnaAction, create_component_default, namedOpts, {
        type: "Protein"
      });
      return create_component_default.run(ctx, newOpts, positionalOpts);
    });
  }

  // src/actions/index.ts
  var actions_default = [
    import_default,
    convert_default,
    components_default,
    validate_default,
    create_component_default,
    dna_default,
    protein_default,
    create_constraint_default,
    create_module_default,
    create_interaction_default,
    create_participation_default,
    create_sequence_default,
    render_default,
    annotate_range_default,
    add_subcomponent_default,
    create_participant_default,
    dump_graph_default,
    show_graphs_default,
    graph_default,
    compare_default,
    merge_default,
    insert_default,
    namespace_default2,
    sbol_version_default,
    run_tests_default
  ];

  // src/help.ts
  init_shim();
  var help_default = `
\u2728 *sboltools 0.1.0                                   SBOL 1.1.0   2.3.0   3.0.0*
      -> using sboljs 1.0.0
      -> questions/comments please contact James McLaughlin <james@mclgh.net>

**Usage**

    sbol [--output <format>]
            [action1] [action1args]
            [action2] [action2args]
            ...

This tool allows the manipulation of files describing biological systems using
the Synthetic Biology Open Language (SBOL) and other related standards such as
FASTA and GenBank.

Available actions:

%actions%

For help with a specific action, try:

    sbol <action> --help

For comprehensive documentation, check out http://sboltools.github.io
`.trim();

  // src/help_json.ts
  init_shim();

  // src/actions/ActionDef.ts
  init_shim();
  function def2usage(def) {
    let out = "";
    let indent22 = 0;
    addLine(def.name);
    let doneOpts = /* @__PURE__ */ new Set();
    for (let forOpt of def.namedOpts.filter((opt) => opt.name.indexOf("for") === 0 || opt.name.indexOf("within") === 0)) {
      doneOpts.add(forOpt);
      addLine(descNamedOpt(forOpt));
    }
    for (let opt of def.namedOpts.filter((opt2) => !opt2.optional)) {
      if (!doneOpts.has(opt)) {
        doneOpts.add(opt);
        addLine(descNamedOpt(opt));
      }
    }
    for (let opt of def.namedOpts) {
      if (!doneOpts.has(opt)) {
        doneOpts.add(opt);
        addLine(descNamedOpt(opt));
      }
    }
    for (let opt of def.positionalOpts) {
      addLine(descPositionalOpt(opt));
    }
    return out;
    function addLine(line) {
      out += " ".repeat(indent22) + line + "\n";
      indent22 += 4;
    }
    function descNamedOpt(opt) {
      return [
        opt.optional === true ? "[" : "",
        opt.name.length > 0 ? "--" + opt.name : opt.name,
        " " + argType(opt),
        opt.optional === true ? "]" : ""
      ].join("");
    }
    function descPositionalOpt(opt) {
      return [
        opt.optional === true ? "[" : "<",
        opt.name,
        opt.optional === true ? "]" : ">"
      ].join("");
    }
    function argType(opt) {
      switch (opt.type.name) {
        case "OptIdentity":
          return "<identity>";
        case "OptSBOLVersion":
          return "<sbol-version>";
        case "OptString":
          return "<string>";
        case "OptURL":
          return "<url>";
        case "OptVcParameters":
          return "<vc-params>";
        default:
          return "<arg>";
      }
    }
  }

  // src/help_json.ts
  function jsonHelp() {
    return JSON.stringify(actions_default.sort((a, b) => a.name.localeCompare(b.name)).map((action9) => {
      return {
        name: action9.name,
        description: action9.description,
        category: action9.category,
        help: action9.help,
        usage: def2usage(action9),
        options: action9.namedOpts.map((opt) => {
          return {
            name: opt.name,
            type: opt.type.name,
            optional: opt.optional
          };
        }).concat(action9.positionalOpts.map((opt) => {
          return {
            name: opt.name,
            type: opt.type.name,
            optional: opt.optional
          };
        }))
      };
    }), null, 2);
  }

  // src/summarize.ts
  init_shim();
  var import_sboljs21 = __toESM(require_dist5());

  // src/sbol2/mdTree.ts
  init_shim();
  function mdTree(gv) {
    let roots = gv.rootModuleDefinitions;
    return group(roots.map(mdToNode));
    function mdToNode(md) {
      return new OutputNodeTree("ModuleDefinition " + md.displayName, { "foo": "bar" }, md.modules.map(mToNode).concat(md.functionalComponents.map(fcToNode)));
    }
    function mToNode(m) {
      if (roots.filter((r) => r.subject.value === m.subject.value).length > 0) {
        return {
          text: "ModuleDefinition --[definition]--> " + m.definition.displayName,
          attribs: {},
          children: []
        };
      } else {
        return mdToNode(m.definition);
      }
    }
    function fcToNode(fc) {
      let node19 = new OutputNodeTree(fc.definition.displayName || "??fc", {}, []);
      return node19;
    }
  }

  // src/summarize.ts
  var import_rdfoo_prov = __toESM(require_dist4());
  var fs12 = require_main();
  function summarize(g) {
    return __async(this, null, function* () {
      let out = [];
      out.push(group([
        spacer(),
        header("Summary", "bold underline caps"),
        spacer(),
        indent([
          summariseSBOL1(g),
          summariseSBOL2(g),
          summariseSBOL3(g),
          summariseProv(g)
        ]),
        spacer(),
        conditional(new import_sboljs21.SBOL1GraphView(g).topLevels.length > 0, [
          header("SBOL 1.x Overview", "bold underline caps"),
          spacer(),
          indent([
            indent([
              header("DnaComponent(s)"),
              spacer(),
              indent([
                dnaComponentTree(new import_sboljs21.SBOL1GraphView(g))
              ])
            ])
          ])
        ]),
        conditional(new import_sboljs21.SBOL2GraphView(g).topLevels.length > 0, [
          header("SBOL 2.x Overview", "bold underline caps"),
          spacer(),
          indent([
            indent([
              header("ModuleDefinition(s)"),
              spacer(),
              indent([
                mdTree(new import_sboljs21.SBOL2GraphView(g))
              ]),
              spacer(),
              header("ComponentDefinition(s)"),
              spacer(),
              indent([
                cdTree(new import_sboljs21.SBOL2GraphView(g))
              ])
            ])
          ])
        ]),
        conditional(new import_sboljs21.SBOL3GraphView(g).topLevels.length > 0, [
          header("SBOL 3.x Overview", "bold underline caps"),
          spacer(),
          indent([
            indent([
              header("Component(s)"),
              spacer(),
              indent([
                componentTree(new import_sboljs21.SBOL3GraphView(g))
              ])
            ])
          ])
        ])
      ]));
      print(group(out));
    });
  }
  function summariseSBOL1(g) {
    let v = new import_sboljs21.SBOL1GraphView(g);
    let any = v.topLevels.length > 0;
    if (!any) {
      return group([
        text("No SBOL 1.x to output"),
        spacer()
      ]);
    }
    return group([
      header("SBOL 1.x", "bold underline white"),
      spacer(),
      indent([
        arraySummary(v.dnaComponents, "DnaComponent"),
        arraySummary(v.dnaSequences, "DnaSequence")
      ]),
      spacer()
    ]);
  }
  function summariseSBOL2(g) {
    let v = new import_sboljs21.SBOL2GraphView(g);
    let any = v.topLevels.length > 0;
    if (!any) {
      return group([
        text("No SBOL 2.x to output"),
        spacer()
      ]);
    }
    return group([
      text("SBOL 2.x:"),
      spacer(),
      indent([
        arraySummary(v.moduleDefinitions, "ModuleDefinition"),
        arraySummary(v.componentDefinitions, "ComponentDefinition")
      ]),
      spacer()
    ]);
  }
  function summariseSBOL3(g) {
    let v = new import_sboljs21.SBOL3GraphView(g);
    let any = v.topLevels.length > 0;
    if (!any) {
      return group([
        text("No SBOL 3.x to output"),
        spacer()
      ]);
    }
    return group([
      text("SBOL 3.x:"),
      spacer(),
      indent([
        arraySummary(v.components, "Component")
      ]),
      spacer()
    ]);
  }
  function summariseProv(g) {
    let v = new import_rdfoo_prov.ProvView(g);
    return group([]);
  }
  function arraySummary(arr, name) {
    let style = arr.length > 0 ? "white" : "gray";
    return text(`${arr.length} ${name}(s)`, style);
  }

  // src/Context.ts
  init_shim();
  var import_rdfoo21 = __toESM(require_dist());
  var Context = class {
    constructor() {
      this.graphs = /* @__PURE__ */ new Map();
      this.currentGraph = new import_rdfoo21.Graph();
      this.graphs.set("default", this.currentGraph);
      this.currentNamespace = "";
      this.sbolVersion = "Empty" /* Empty */;
    }
    getCurrentGraph() {
      return this.currentGraph;
    }
    setCurrentGraph(name) {
      let g = this.graphs.get(name.toLowerCase());
      if (!g) {
        g = new import_rdfoo21.Graph();
        this.graphs.set(name.toLowerCase(), g);
      }
      this.currentGraph = g;
    }
    getGraph(name) {
      let g = this.graphs.get(name.toLowerCase());
      return g;
    }
  };

  // src/graphToSboltoolsCmd.ts
  init_shim();
  var import_sboljs22 = __toESM(require_dist5());
  var fs13 = require_main();
  function graphToSboltoolsCmd(g) {
    let out = [];
    out.push(indent([
      text("sbol-version 3")
    ]));
    let curNamespace = "";
    for (let rootC of (0, import_sboljs22.sbol3)(g).rootComponents) {
      if (curNamespace !== rootC.namespace) {
        out.push(indent([
          text("namespace " + rootC.namespace)
        ]));
        curNamespace = rootC.namespace;
      }
      let componentSection = [];
      for (let type of rootC.types) {
        componentSection.push(text("--type " + termUriToShorthand("ComponentTypeSBOL3" /* ComponentTypeSBOL3 */, type)));
      }
      let idchain = rootC.displayId;
      out.push(indent([
        text("component " + idchain),
        indent(componentSection)
      ]));
    }
    let lines = tostring(0, group([
      text("sbol --trace"),
      indent(out)
    ])).trim().split("\n");
    let cmd = "";
    for (let n = 0; n < lines.length; ++n) {
      if (n < lines.length - 1) {
        cmd += lines[n] + " \\\n";
      } else {
        cmd += lines[n] + "\n";
      }
    }
    return cmd;
  }

  // src/sboltools.ts
  var chalk4 = require_source();
  var sqparse = require_shell_quote().parse;
  function sboltools(args) {
    return __async(this, null, function* () {
      if (typeof args === "string") {
        args = sqparse(args);
      }
      let argv = parseArgv(args);
      if (argv.actions.length === 0 || (argv.globalOpts.getFlag("help") || argv.globalOpts.getFlag("h"))) {
        if (argv.globalOpts.getFlag("json")) {
          help_json();
        } else {
          help();
        }
        return;
      }
      if (argv.globalOpts.getFlag("trace")) {
        enableTrace();
        trace(text("sboltools trace output is enabled"));
      }
      let output = argv.globalOpts.getString("output", "summary");
      let ctx = new Context();
      let aborted = false;
      for (let action9 of argv.actions) {
        let help2 = function() {
          print(group([
            text(def2usage(actDef).trim()),
            spacer(),
            actDef.description ? text(actDef.description) : spacer(),
            spacer(),
            actDef.help ? text(actDef.help) : spacer()
          ]));
          aborted = true;
        };
        let actDef = actions_default.filter((a) => a.name === action9.name)[0];
        if (actDef === void 0) {
          print(text("Unknown action: " + action9.name));
          aborted = true;
          break;
        }
        if (action9.namedOpts.getFlag("help") || action9.namedOpts.getFlag("h")) {
          help2();
          break;
        }
        let namedOpts = actDef.namedOpts.map((optDef) => new optDef.type(actDef, optDef, action9.namedOpts));
        let positionalOpts = actDef.positionalOpts.map((optDef, i) => {
          if (action9.positionalOpts[i]) {
            return new optDef.type(actDef, optDef, new ArgvOptionSet([
              new ArgvNamedOption(optDef.name, action9.positionalOpts[i])
            ]));
          } else {
            return void 0;
          }
        });
        let err = false;
        try {
          trace(text(`Begin action: ${actDef.name}`));
          var actionResult2 = yield actDef.run(ctx, namedOpts, positionalOpts);
        } catch (e) {
          if (e instanceof ActionResult) {
            actionResult2 = e;
            err = true;
          } else {
            throw e;
          }
        }
        if (err) {
          if (actionResult2.output !== void 0) {
            print(actionResult2.output, chalk4.red.bold(action9.name + ": "));
          }
        } else {
          if (actionResult2.output !== void 0) {
            print(actionResult2.output, chalk4.bold(action9.name + ": "));
          }
        }
        if (actionResult2.outcome === 0 /* Abort */) {
          aborted = true;
          break;
        }
        if (actionResult2.outcome === 1 /* ShowHelp */) {
          help2();
          break;
        }
      }
      if (aborted) {
        import_process.default.exitCode = 1;
      } else {
        switch (output) {
          case "summary":
            summarize(ctx.getCurrentGraph());
            break;
          case "sbol":
            let detectedVersion = getSBOLVersionFromGraph(ctx.getCurrentGraph());
            switch (detectedVersion) {
              case "SBOL1" /* SBOL1 */:
                return new import_sboljs23.SBOL1GraphView(ctx.getCurrentGraph()).serializeXML();
              case "SBOL2" /* SBOL2 */:
                return new import_sboljs23.SBOL2GraphView(ctx.getCurrentGraph()).serializeXML();
              case "SBOL3" /* SBOL3 */:
                return new import_sboljs23.SBOL3GraphView(ctx.getCurrentGraph()).serializeXML();
              case "Mixed" /* Mixed */:
              default:
                return new import_sboljs23.SBOL3GraphView(ctx.getCurrentGraph()).serializeXML();
            }
          case "sbol1":
            return new import_sboljs23.SBOL1GraphView(ctx.getCurrentGraph()).serializeXML();
          case "sbol2":
            return new import_sboljs23.SBOL2GraphView(ctx.getCurrentGraph()).serializeXML();
          case "sbol3":
            return new import_sboljs23.SBOL3GraphView(ctx.getCurrentGraph()).serializeXML();
          case "fasta":
            print(text(chalk4.red("FASTA output not yet supported")));
            break;
          case "genbank":
            print(text(chalk4.red("GenBank output not yet supported")));
            break;
          case "sboltools":
            return graphToSboltoolsCmd(ctx.getCurrentGraph());
          case "none":
            break;
          default:
            print(text(chalk4.red("Unknown output type: " + output)));
            import_process.default.exitCode = 2;
            break;
        }
      }
    });
  }
  function help() {
    print(text(help_default.replace(/\*\*(.*)\*\*/g, (w, str) => chalk4.white.underline.bold(str.toUpperCase())).replace(/\*(.*)\*/g, (w, str) => chalk4.white.bold(str)).replace("%actions%", actions_default.map((a) => "    " + a.name).join("\n"))));
  }
  function help_json() {
    console.log(jsonHelp());
  }

  // src/browser.ts
  window["sboltools"] = sboltools;
})();
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
//# sourceMappingURL=sbol_browser.js.map
